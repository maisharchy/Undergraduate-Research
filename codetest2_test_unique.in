returnBuffer . append ( minParam ) ; 
returnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; 
returnBuffer . append ( FieldMetaData . Decimal . MAX ) ; 
returnBuffer . append ( maxParam ) ; 
returnBuffer . append ( FieldMetaData . Decimal . STEP_FACTOR ) ; 
returnBuffer . append ( stepFactorParam ) ; 
String prefix = ( prefixParam == null ) ? "" : prefixParam ; 
returnBuffer . append ( FieldMetaData . Decimal . PREFIX ) ; 
returnBuffer . append ( prefix ) ; 
return returnBuffer . toString ( ) ; 
} public User createUser ( User userParam ) 
if ( userParam != null && this . serviceTicket != null ) 
userParam . setServiceTicket ( this . serviceTicket ) ; 
return new User ( this . putJson ( 
userParam , WS . Path . User . Version1 . userCreate ( ) ) ) ; 
} public User updateUser ( User userParam ) 
return new User ( this . postJson ( 
userParam , WS . Path . User . Version1 . userUpdate ( ) ) ) ; 
} public User activateUser ( User userParam ) 
userParam , 
WS . Path . User . Version1 . userActivate ( ) ) ) ; 
} public User deActivateUser ( User userParam ) 
WS . Path . User . Version1 . userDeActivate ( ) ) ) ; 
} public User incrementInvalidLoginForUser ( User userParam ) 
WS . Path . User . Version1 . incrementInvalidLogin ( ) ) ) ; 
} public User changePasswordForLoggedInUser ( 
String existingPasswordParam , 
String newPasswordParam , 
String confirmNewPasswordParam ) { 
User toChangePasswordFor = new User ( ) ; 
toChangePasswordFor . setServiceTicket ( this . serviceTicket ) ; 
String existingPassword = 
existingPasswordParam == null ? UtilGlobal . EMPTY : existingPasswordParam ; 
String newPassword = 
newPasswordParam == null ? UtilGlobal . EMPTY : newPasswordParam ; 
String confirmNewPassword = 
confirmNewPasswordParam == null ? UtilGlobal . EMPTY : confirmNewPasswordParam ; 
JSONObject passwordClear = new JSONObject ( ) ; 
passwordClear . put ( "existing" , existingPassword ) ; 
passwordClear . put ( "new" , newPassword ) ; 
passwordClear . put ( "confirm_new" , confirmNewPassword ) ; 
toChangePasswordFor . setPasswordClear ( passwordClear . toString ( ) ) ; 
toChangePasswordFor , 
WS . Path . User . Version1 . changePassword ( ) ) ) ; 
} public User deleteUser ( 
User userToDeleteParam , 
boolean forcefullyDeleteParam ) 
if ( userToDeleteParam != null && this . serviceTicket != null ) 
userToDeleteParam . setServiceTicket ( this . serviceTicket ) ; 
return new User ( this . postJson ( userToDeleteParam , 
WS . Path . User . Version1 . userDelete ( forcefullyDeleteParam ) ) ) ; 
} public User getLoggedInUserInformation ( ) 
User userToGetInfoFor = new User ( ) ; 
if ( this . serviceTicket != null ) 
userToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; 
userToGetInfoFor , 
WS . Path . User . Version1 . userInformation ( ) ) ) ; 
catch ( JSONException jsonExcept ) { 
throw new FluidClientException ( jsonExcept . getMessage ( ) , 
FluidClientException . ErrorCode . JSON_PARSING ) ; 
} public User getUserWhereUsername ( String usernameParam ) 
userToGetInfoFor . setUsername ( usernameParam ) ; 
userToGetInfoFor , WS . Path . User . Version1 . getByUsername ( ) ) ) ; 
} public User getUserWhereEmail ( String emailAddressParam ) 
if ( emailAddressParam != null ) 
List < String > emailAdd = new ArrayList ( ) ; 
emailAdd . add ( emailAddressParam ) ; 
userToGetInfoFor . setEmailAddresses ( emailAdd ) ; 
userToGetInfoFor , WS . Path . User . Version1 . getByEmail ( ) ) ) ; 
} public User getUserById ( Long userIdParam ) 
userToGetInfoFor . setId ( userIdParam ) ; 
userToGetInfoFor , WS . Path . User . Version1 . getById ( ) ) ) ; 
} public UserListing getAllUsers ( ) 
UserListing userToGetInfoFor = new UserListing ( ) ; 
return new UserListing ( this . postJson ( 
WS . Path . User . Version1 . getAllUsers ( ) ) ) ; 
} public UserListing getAllUsersByJobView ( JobView jobViewParam ) { 
if ( this . serviceTicket != null && jobViewParam != null ) { 
jobViewParam . setServiceTicket ( this . serviceTicket ) ; 
jobViewParam , 
WS . Path . User . Version1 . getAllUsersByJobView ( ) ) ) ; 
} catch ( JSONException jsonExcept ) { 
} public UserListing getAllUsersByRole ( Role roleParam ) { 
if ( this . serviceTicket != null && roleParam != null ) { 
roleParam . setServiceTicket ( this . serviceTicket ) ; 
roleParam , WS . Path . User . Version1 . getAllUsersByRole ( ) ) ) ; 
} public UserListing getAllUsersWhereLoggedInSince ( Date loggedInSinceParam ) { 
User userToPost = new User ( ) ; 
userToPost . setLoggedInDateTime ( loggedInSinceParam ) ; 
userToPost . setServiceTicket ( this . serviceTicket ) ; 
userToPost , WS . Path . User . Version1 . getAllUsersWhereLoggedInSince ( ) ) ) ; 
} public UserFieldListing getAllUserFieldValuesByUser ( User userParam ) 
if ( userParam == null ) 
return new UserFieldListing ( this . postJson ( 
WS . Path . User . Version1 . getUserFieldValuesByUser ( ) ) ) ; 
} public byte [ ] getGravatarForEmail ( 
String emailAddressParam , 
int sizeParam ) 
JSONObject gravatarJSONObj = 
this . getJson ( 
WS . Path . User . Version1 . getGravatarByEmail ( 
emailAddressParam , sizeParam ) ) ; 
String base64Text = gravatarJSONObj . optString ( JSON_TAG_DATA , "" ) ; 
if ( base64Text == null || base64Text . isEmpty ( ) ) 
return UtilGlobal . decodeBase64 ( base64Text ) ; 
jsonExcept , FluidClientException . ErrorCode . JSON_PARSING ) ; 
catch ( UnsupportedEncodingException unsEncExcept ) { 
throw new FluidClientException ( unsEncExcept . getMessage ( ) , 
unsEncExcept , FluidClientException . ErrorCode . IO_ERROR ) ; 
} public byte [ ] getGravatarForUser ( User userParam , int sizeParam ) 
JSONObject gravatarJSONObj = this . postJson ( 
WS . Path . User . Version1 . getGravatarByUser ( sizeParam ) ) ; 
} @ XmlTransient 
public boolean doesUserHaveAccessToRole ( Role roleParam ) 
if ( roleParam == null ) 
return this . doesUserHaveAccessToRole ( roleParam . getName ( ) ) ; 
public boolean doesUserHaveAccessToRole ( String roleNameParam ) 
if ( roleNameParam == null || roleNameParam . trim ( ) . isEmpty ( ) ) 
if ( this . getRoles ( ) == null || this . getRoles ( ) . isEmpty ( ) ) 
String roleNameParamLower = roleNameParam . trim ( ) . toLowerCase ( ) ; 
for ( Role roleAtIndex : this . getRoles ( ) ) 
if ( roleAtIndex . getName ( ) == null || 
roleAtIndex . getName ( ) . trim ( ) . isEmpty ( ) ) 
String iterRoleNameLower = roleAtIndex . getName ( ) . trim ( ) . toLowerCase ( ) ; 
if ( roleNameParamLower . equals ( iterRoleNameLower ) ) 
@ XmlTransient 
returnVal . put ( JSONMapping . ACTIVE , this . isActive ( ) ) ; 
returnVal . put ( JSONMapping . INVALID_LOGIN_COUNT , 
this . getInvalidLoginCount ( ) ) ; 
if ( this . getUsername ( ) != null ) 
returnVal . put ( JSONMapping . USERNAME , this . getUsername ( ) ) ; 
if ( this . getPasswordSha256 ( ) != null ) 
returnVal . put ( JSONMapping . PASSWORD_SHA_256 , this . getPasswordSha256 ( ) ) ; 
if ( this . getPasswordClear ( ) != null ) 
returnVal . put ( JSONMapping . PASSWORD_CLEAR , this . getPasswordClear ( ) ) ; 
returnVal . put ( User . JSONMapping . DATE_CREATED , 
this . getDateAsLongFromJson ( this . getDateCreated ( ) ) ) ; 
returnVal . put ( User . JSONMapping . DATE_LAST_UPDATED , 
this . getDateAsLongFromJson ( this . getDateLastUpdated ( ) ) ) ; 
if ( this . getPasswordChangedAt ( ) != null ) 
returnVal . put ( JSONMapping . PASSWORD_CHANGED_AT , 
this . getDateAsLongFromJson ( this . getPasswordChangedAt ( ) ) ) ; 
if ( this . getLoggedInDateTime ( ) != null ) 
returnVal . put ( JSONMapping . LOGGED_IN_DATE_TIME , 
this . getDateAsLongFromJson ( this . getLoggedInDateTime ( ) ) ) ; 
if ( this . getSalt ( ) != null ) 
returnVal . put ( JSONMapping . SALT , this . getSalt ( ) ) ; 
if ( this . getTimezone ( ) != null ) 
returnVal . put ( JSONMapping . TIMEZONE , 
this . getTimezone ( ) . doubleValue ( ) ) ; 
if ( this . getDateFormat ( ) != null ) 
returnVal . put ( JSONMapping . DATE_FORMAT , this . getDateFormat ( ) ) ; 
if ( this . getTimeFormat ( ) != null ) 
returnVal . put ( JSONMapping . TIME_FORMAT , this . getTimeFormat ( ) ) ; 
if ( this . getLocale ( ) != null ) { 
returnVal . put ( JSONMapping . LOCALE , this . getLocale ( ) ) ; 
returnVal . put ( JSONMapping . EMAIL_USER_NOTIFICATION , this . isEmailUserNotification ( ) ) ; 
if ( this . getRoles ( ) != null && ! this . getRoles ( ) . isEmpty ( ) ) 
JSONArray rolesArr = new JSONArray ( ) ; 
for ( Role toAdd : this . getRoles ( ) ) 
rolesArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ROLES , rolesArr ) ; 
if ( this . getEmailAddresses ( ) != null && 
! this . getEmailAddresses ( ) . isEmpty ( ) ) 
JSONArray emailArr = new JSONArray ( ) ; 
for ( String toAdd : this . getEmailAddresses ( ) ) 
emailArr . put ( toAdd ) ; 
returnVal . put ( JSONMapping . EMAIL_ADDRESSES , emailArr ) ; 
JSONArray userFieldsArr = new JSONArray ( ) ; 
for ( Field toAdd : this . getUserFields ( ) ) 
userFieldsArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . USER_FIELDS , userFieldsArr ) ; 
public Field getField ( String fieldNameParam ) { 
if ( fieldNameParam == null || fieldNameParam . trim ( ) . isEmpty ( ) ) { 
if ( this . userFields == null || this . userFields . isEmpty ( ) ) { 
String fieldNameParamLower = fieldNameParam . trim ( ) . toLowerCase ( ) ; 
for ( Field field : this . userFields ) { 
String fieldName = field . getFieldName ( ) ; 
if ( fieldName == null || fieldName . trim ( ) . isEmpty ( ) ) { 
String fieldNameLower = fieldName . trim ( ) . toLowerCase ( ) ; 
if ( fieldNameParamLower . equals ( fieldNameLower ) ) { 
public MultiChoice getFieldValueAsMultiChoice ( String fieldNameParam ) { 
Field fieldReturn = this . getField ( fieldNameParam ) ; 
return ( fieldReturn == null ) ? null : fieldReturn . getFieldValueAsMultiChoice ( ) ; 
if ( this . getJobView ( ) != null ) 
returnVal . put ( JSONMapping . JOB_VIEW , 
this . getJobView ( ) . toJsonObject ( ) ) ; 
if ( this . getRole ( ) != null ) 
returnVal . put ( JSONMapping . ROLE , 
this . getRole ( ) . toJsonObject ( ) ) ; 
public String getFieldValueAsString ( ) { 
Object returnObj = this . getFieldValue ( ) ; 
return ( returnObj == null ) ? null : returnObj . toString ( ) ; 
public Double getFieldValueAsDouble ( ) { 
Object obj = this . getFieldValue ( ) ; 
if ( obj instanceof Double ) { 
return ( Double ) obj ; 
if ( obj instanceof Number ) { 
return ( ( Number ) obj ) . doubleValue ( ) ; 
public Long getFieldValueAsLong ( ) { 
if ( obj instanceof Long ) { 
return ( Long ) obj ; 
return ( ( Number ) obj ) . longValue ( ) ; 
public Integer getFieldValueAsInteger ( ) { 
if ( obj instanceof Integer ) { 
return ( Integer ) obj ; 
return ( ( Number ) obj ) . intValue ( ) ; 
public Number getFieldValueAsNumber ( ) { 
return ( Number ) obj ; 
public Boolean getFieldValueAsBoolean ( ) { 
if ( obj instanceof Boolean ) { 
return ( Boolean ) obj ; 
public Date getFieldValueAsDate ( ) { 
if ( obj instanceof Date ) { 
return ( Date ) obj ; 
else if ( obj instanceof Long ) { 
Long longValue = ( Long ) obj ; 
if ( longValue . longValue ( ) > 0 ) { 
return new Date ( longValue . longValue ( ) ) ; 
public MultiChoice getFieldValueAsMultiChoice ( ) { 
if ( obj instanceof MultiChoice ) { 
return ( MultiChoice ) obj ; 
public TableField getFieldValueAsTableField ( ) { 
if ( obj instanceof TableField ) { 
return ( TableField ) obj ; 
} public void setFieldValue ( Object fieldValueParam ) { 
this . fieldValue = fieldValueParam ; 
if ( this . getFieldType ( ) == null && fieldValueParam != null ) 
if ( fieldValueParam instanceof Date ) 
this . setTypeAsEnum ( Type . DateTime ) ; 
else if ( fieldValueParam instanceof Number ) 
this . setTypeAsEnum ( Type . Decimal ) ; 
else if ( fieldValueParam instanceof MultiChoice ) 
this . setTypeAsEnum ( Type . MultipleChoice ) ; 
else if ( fieldValueParam instanceof TableField ) 
this . setTypeAsEnum ( Type . Table ) ; 
else if ( fieldValueParam instanceof String ) 
this . setTypeAsEnum ( Type . Text ) ; 
else if ( fieldValueParam instanceof Boolean ) 
this . setTypeAsEnum ( Type . TrueFalse ) ; 
public void setTypeAsEnum ( Type typeParam ) { 
if ( typeParam == null ) 
this . fieldType = null ; 
this . fieldType = typeParam . name ( ) ; 
public Type getTypeAsEnum ( ) 
if ( this . getFieldType ( ) == null || this . getFieldType ( ) . trim ( ) . isEmpty ( ) ) 
return Type . valueOf ( this . getFieldType ( ) ) ; 
if ( this . getFieldName ( ) != null ) 
returnVal . put ( JSONMapping . FIELD_NAME , this . getFieldName ( ) ) ; 
if ( this . getFieldDescription ( ) != null ) 
returnVal . put ( JSONMapping . FIELD_DESCRIPTION , this . getFieldDescription ( ) ) ; 
if ( this . getFieldValue ( ) != null ) 
if ( this . getFieldValue ( ) instanceof String ) 
returnVal . put ( JSONMapping . FIELD_VALUE , this . getFieldValue ( ) ) ; 
else if ( this . getFieldValue ( ) instanceof Number ) 
returnVal . put ( JSONMapping . FIELD_VALUE , 
( ( Number ) this . getFieldValue ( ) ) . doubleValue ( ) ) ; 
else if ( this . getFieldValue ( ) instanceof Boolean ) 
( Boolean ) this . getFieldValue ( ) ) ; 
else if ( this . getFieldValue ( ) instanceof Date ) 
this . getDateAsLongFromJson ( ( Date ) this . getFieldValue ( ) ) ) ; 
else if ( this . getFieldValue ( ) instanceof MultiChoice ) 
( ( MultiChoice ) this . getFieldValue ( ) ) . toJsonObject ( ) ) ; 
else if ( this . getFieldValue ( ) instanceof TableField ) 
( ( TableField ) this . getFieldValue ( ) ) . toJsonObject ( ) ) ; 
if ( this . getFieldType ( ) != null ) 
returnVal . put ( JSONMapping . FIELD_TYPE , this . getFieldType ( ) ) ; 
if ( this . getTypeMetaData ( ) != null ) 
returnVal . put ( JSONMapping . TYPE_META_DATA , this . getTypeMetaData ( ) ) ; 
public JSONObject toJsonMappingForElasticSearch ( ) throws JSONException { 
String fieldNameUpperCamel = this . getFieldNameAsUpperCamel ( ) ; 
if ( fieldNameUpperCamel == null ) 
String elasticType = this . getElasticSearchFieldType ( ) ; 
if ( elasticType == null ) 
returnVal . put ( JSONMapping . Elastic . MAPPING_ONLY_TYPE , elasticType ) ; 
public JSONObject toJsonForElasticSearch ( ) throws JSONException { 
if ( ! this . doesFieldQualifyForElasticSearchInsert ( ) ) 
String fieldIdAsString = this . getFieldNameAsUpperCamel ( ) ; 
Object fieldValue = this . getFieldValue ( ) ; 
if ( fieldValue instanceof TableField ) 
TableField tableField = ( TableField ) this . getFieldValue ( ) ; 
if ( tableField . getTableRecords ( ) != null && 
! tableField . getTableRecords ( ) . isEmpty ( ) ) 
JSONArray array = new JSONArray ( ) ; 
for ( Form record : tableField . getTableRecords ( ) ) 
if ( record . getId ( ) == null ) 
array . put ( record . getId ( ) ) ; 
returnVal . put ( fieldIdAsString , array ) ; 
else if ( fieldValue instanceof MultiChoice ) 
MultiChoice multiChoice = ( MultiChoice ) this . getFieldValue ( ) ; 
if ( multiChoice . getSelectedMultiChoices ( ) != null && 
! multiChoice . getSelectedMultiChoices ( ) . isEmpty ( ) ) 
for ( String selectedChoice : multiChoice . getSelectedMultiChoices ( ) ) 
Long selectedChoiceAsLong = null ; 
if ( ! selectedChoice . isEmpty ( ) && 
Character . isDigit ( selectedChoice . charAt ( 0 ) ) ) 
selectedChoiceAsLong = Long . parseLong ( selectedChoice ) ; 
catch ( NumberFormatException nfe ) 
selectedChoiceAsLong = null ; 
if ( selectedChoiceAsLong == null ) 
array . put ( selectedChoice ) ; 
array . put ( selectedChoiceAsLong . longValue ( ) ) ; 
else if ( ( fieldValue instanceof Number || fieldValue instanceof Boolean ) || 
fieldValue instanceof String ) 
if ( ( fieldValue instanceof String ) && LATITUDE_AND_LONGITUDE . equals ( this . getTypeMetaData ( ) ) ) { 
String formFieldValueStr = fieldValue . toString ( ) ; 
UtilGlobal utilGlobal = new UtilGlobal ( ) ; 
String latitude = utilGlobal . getLatitudeFromFluidText ( formFieldValueStr ) ; 
String longitude = utilGlobal . getLongitudeFromFluidText ( formFieldValueStr ) ; 
fieldValue = ( latitude . concat ( UtilGlobal . COMMA ) . concat ( longitude ) ) ; 
returnVal . put ( fieldIdAsString , fieldValue ) ; 
else if ( fieldValue instanceof Date ) 
returnVal . put ( fieldIdAsString , ( ( Date ) fieldValue ) . getTime ( ) ) ; 
throw new FluidElasticSearchException ( 
public Field populateFromElasticSearchJson ( 
JSONObject jsonObjectParam 
) throws JSONException { 
if ( this . getFieldNameAsUpperCamel ( ) == null ) { 
if ( jsonObjectParam . isNull ( fieldIdAsString ) ) { 
Field . Type type ; 
if ( ( type = this . getTypeAsEnum ( ) ) == null ) { 
Object formFieldValue = jsonObjectParam . get ( fieldIdAsString ) ; 
Field fieldToAdd = null ; 
case DateTime : 
if ( formFieldValue instanceof Long ) { 
fieldToAdd = new Field ( 
this . getId ( ) , 
this . getFieldName ( ) , 
new Date ( ( ( Long ) formFieldValue ) . longValue ( ) ) , 
type ) ; 
case Decimal : 
if ( formFieldValue instanceof Number ) { 
( ( Number ) formFieldValue ) . doubleValue ( ) , 
case MultipleChoice : 
if ( formFieldValue instanceof JSONArray ) { 
JSONArray casted = ( JSONArray ) formFieldValue ; 
List < String > selectedChoices = new ArrayList ( ) ; 
for ( int index = 0 ; index < casted . length ( ) ; index ++ ) { 
selectedChoices . add ( casted . get ( index ) . toString ( ) ) ; 
if ( selectedChoices . isEmpty ( ) ) { 
MultiChoice multiChoiceToSet = new MultiChoice ( selectedChoices ) ; 
multiChoiceToSet , 
case Table : 
List < Form > tableRecords = new ArrayList ( ) ; 
Object obAtIndex = casted . get ( index ) ; 
if ( obAtIndex instanceof Number ) { 
tableRecords . add ( new Form ( ( ( Number ) obAtIndex ) . longValue ( ) ) ) ; 
else if ( formFieldValue instanceof Number ) { 
tableRecords . add ( new Form ( ( ( Number ) formFieldValue ) . longValue ( ) ) ) ; 
if ( tableRecords . isEmpty ( ) ) { 
new TableField ( tableRecords ) , 
case Text : 
case ParagraphText : 
if ( formFieldValue instanceof String ) { 
if ( LATITUDE_AND_LONGITUDE . equals ( this . getTypeMetaData ( ) ) ) { 
String formFieldValueStr = formFieldValue . toString ( ) ; 
double latitude = utilGlobal . getLatitudeFromElasticSearchText ( formFieldValueStr ) ; 
double longitude = utilGlobal . getLongitudeFromElasticSearchText ( formFieldValueStr ) ; 
String newFieldVal = 
( latitude + UtilGlobal . PIPE + longitude + UtilGlobal . PIPE ) ; 
newFieldVal , 
formFieldValue . toString ( ) , 
case TrueFalse : 
if ( formFieldValue instanceof Boolean ) { 
formFieldValue , 
return fieldToAdd ; 
public void populateFromElasticSearchJson ( 
JSONObject jsonObjectParam , List < Field > formFieldsParam ) throws JSONException { 
public String getElasticSearchFieldType ( ) 
Type fieldType = this . getTypeAsEnum ( ) ; 
if ( fieldType == null ) 
switch ( fieldType ) 
return ElasticSearchType . TEXT ; 
String metaData = this . getTypeMetaData ( ) ; 
if ( metaData == null || metaData . isEmpty ( ) ) 
if ( LATITUDE_AND_LONGITUDE . equals ( metaData ) ) 
return ElasticSearchType . GEO_POINT ; 
return ElasticSearchType . BOOLEAN ; 
return ElasticSearchType . DATE ; 
return ElasticSearchType . DOUBLE ; 
return ElasticSearchType . KEYWORD ; 
} private boolean doesFieldQualifyForElasticSearchInsert ( ) 
Field . Type fieldType ; 
if ( ( ( this . getFieldValue ( ) ) == null ) || 
( ( fieldType = this . getTypeAsEnum ( ) ) == null ) ) 
if ( this . getFieldName ( ) == null || 
this . getFieldName ( ) . trim ( ) . isEmpty ( ) ) 
switch ( fieldType ) { 
case TextEncrypted : 
if ( this . getClientId ( ) != null ) 
returnVal . put ( JSONMapping . CLIENT_ID , this . getClientId ( ) ) ; 
if ( this . getClientSecret ( ) != null ) 
returnVal . put ( JSONMapping . CLIENT_SECRET , this . getClientSecret ( ) ) ; 
if ( this . getCode ( ) != null ) 
returnVal . put ( JSONMapping . CODE , this . getCode ( ) ) ; 
if ( this . getGrantType ( ) != null ) 
returnVal . put ( JSONMapping . GRANT_TYPE , this . getGrantType ( ) ) ; 
if ( this . getRedirectUri ( ) != null ) 
returnVal . put ( JSONMapping . REDIRECT_URI , this . getRedirectUri ( ) ) ; 
} public void setStepProperty ( 
String nameParam , String valueParam ) 
if ( this . getStepProperties ( ) == null ) 
this . setStepProperties ( new ArrayList ( ) ) ; 
if ( nameParam == null || nameParam . trim ( ) . isEmpty ( ) ) 
if ( valueParam . trim ( ) . isEmpty ( ) ) 
String paramLower = nameParam . toLowerCase ( ) ; 
for ( StepProperty existingProp : this . getStepProperties ( ) ) 
if ( existingProp . getName ( ) . toLowerCase ( ) . equals ( paramLower ) ) 
existingProp . setValue ( valueParam ) ; 
this . getStepProperties ( ) . add ( new StepProperty ( nameParam , valueParam ) ) ; 
} public String getStepProperty ( String nameParam ) 
if ( this . getStepProperties ( ) == null || this . getStepProperties ( ) . isEmpty ( ) ) 
for ( StepProperty stepProperty : this . getStepProperties ( ) ) 
if ( stepProperty . getName ( ) . toLowerCase ( ) . equals ( paramLower ) ) 
return stepProperty . getValue ( ) ; 
returnVal . put ( JSONMapping . DATE_CREATED , 
returnVal . put ( JSONMapping . DATE_LAST_UPDATED , 
if ( this . getFlow ( ) != null ) 
returnVal . put ( JSONMapping . FLOW , 
this . getFlow ( ) . toJsonObject ( ) ) ; 
if ( this . getFlowStepType ( ) != null ) 
returnVal . put ( JSONMapping . FLOW_STEP_TYPE , this . getFlowStepType ( ) ) ; 
if ( this . getFlowStepParentId ( ) != null ) 
returnVal . put ( 
JSONMapping . FLOW_STEP_PARENT_ID , this . getFlowStepParentId ( ) ) ; 
if ( this . getEntryRules ( ) != null && ! this . getEntryRules ( ) . isEmpty ( ) ) 
for ( FlowStepRule rule : this . getEntryRules ( ) ) 
returnVal . put ( JSONMapping . ENTRY_RULES , jsonArray ) ; 
if ( this . getExitRules ( ) != null && ! this . getExitRules ( ) . isEmpty ( ) ) 
for ( FlowStepRule rule : this . getExitRules ( ) ) 
returnVal . put ( JSONMapping . EXIT_RULES , jsonArray ) ; 
if ( this . getViewRules ( ) != null && ! this . getViewRules ( ) . isEmpty ( ) ) 
for ( FlowStepRule rule : this . getViewRules ( ) ) 
returnVal . put ( JSONMapping . VIEW_RULES , jsonArray ) ; 
if ( this . getStepProperties ( ) != null && ! this . getStepProperties ( ) . isEmpty ( ) ) 
jsonArray . put ( stepProperty . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . STEP_PROPERTIES , jsonArray ) ; 
if ( this . getUsername ( ) != null ) { 
if ( this . getLifetime ( ) != null ) { 
returnVal . put ( JSONMapping . LIFETIME , this . getLifetime ( ) ) ; 
} public FlowStep createFlowStep ( FlowStep flowStepParam ) 
if ( flowStepParam != null && this . serviceTicket != null ) 
flowStepParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStep ( this . putJson ( 
flowStepParam , WS . Path . FlowStep . Version1 . flowStepCreate ( ) ) ) ; 
} public FlowStep updateFlowStep ( FlowStep flowStepParam ) 
return new FlowStep ( this . postJson ( 
flowStepParam , WS . Path . FlowStep . Version1 . flowStepUpdate ( ) ) ) ; 
} public FlowStep getFlowStepById ( 
Long flowStepIdParam , String flowStepTypeParam ) 
FlowStep flowStep = new FlowStep ( flowStepIdParam ) ; 
flowStep . setFlowStepType ( flowStepTypeParam ) ; 
flowStep . setServiceTicket ( this . serviceTicket ) ; 
flowStep , WS . Path . FlowStep . Version1 . getById ( ) ) ) ; 
} public FlowStep getFlowStepByStep ( FlowStep flowStepParam ) 
if ( this . serviceTicket != null && flowStepParam != null ) 
flowStepParam , WS . Path . FlowStep . Version1 . getByStep ( ) ) ) ; 
} public JobViewListing getJobViewsByStepName ( 
String flowStepNameParam , Flow flowParam ) 
FlowStep step = new FlowStep ( ) ; 
step . setName ( flowStepNameParam ) ; 
step . setFlow ( flowParam ) ; 
return this . getJobViewsByStep ( step ) ; 
} public JobView getStandardJobViewBy ( 
String flowNameParam , 
String flowStepNameParam , 
String flowViewNameParam ) 
if ( flowNameParam == null || 
flowNameParam . trim ( ) . isEmpty ( ) ) 
throw new FluidClientException ( 
FluidClientException . ErrorCode . FIELD_VALIDATE ) ; 
if ( flowStepNameParam == null || 
flowStepNameParam . trim ( ) . isEmpty ( ) ) 
if ( flowViewNameParam == null || 
flowViewNameParam . trim ( ) . isEmpty ( ) ) 
JobViewListing jobViewListing = this . getJobViewsByStepName ( 
flowStepNameParam , new Flow ( flowNameParam ) ) ; 
JobView returnVal = null ; 
if ( jobViewListing . getListingCount ( ) . intValue ( ) > 1 ) 
for ( JobView jobView : jobViewListing . getListing ( ) ) 
if ( ViewType . STANDARD . equals ( jobView . getViewType ( ) ) && 
jobView . getViewName ( ) . equalsIgnoreCase ( flowViewNameParam ) ) 
returnVal = jobView ; 
if ( returnVal == null ) 
flowViewNameParam + "'." , 
FluidClientException . ErrorCode . NO_RESULT ) ; 
} public JobViewListing getJobViewsByStep ( FlowStep flowStepParam ) 
return new JobViewListing ( this . postJson ( 
flowStepParam , WS . Path . FlowStep . Version1 . getAllViewsByStep ( ) ) ) ; 
} public JobViewListing getJobViewsByLoggedInUser ( ) 
FlowStep flowStep = new FlowStep ( ) ; 
flowStep , WS . Path . FlowStep . Version1 . getAllViewsByLoggedInUser ( ) ) ) ; 
} public JobViewListing getJobViewsByUser ( User userParam ) 
if ( this . serviceTicket != null && userParam != null ) 
userParam , WS . Path . FlowStep . Version1 . getAllViewsByUser ( ) ) ) ; 
} public JobViewListing getJobViewsByFlow ( Flow flowParam ) 
if ( this . serviceTicket != null && flowParam != null ) 
flowParam . setServiceTicket ( this . serviceTicket ) ; 
flowParam , WS . Path . FlowStep . Version1 . getAllViewsByFlow ( ) ) ) ; 
} public FlowStepListing getStepsByFlow ( Flow flowParam ) 
return new FlowStepListing ( this . postJson ( 
flowParam , WS . Path . FlowStep . Version1 . getAllStepsByFlow ( ) ) ) ; 
} public FlowStep deleteFlowStep ( FlowStep flowStepParam ) 
flowStepParam , WS . Path . FlowStep . Version1 . flowStepDelete ( ) ) ) ; 
} public FlowStep forceDeleteFlowStep ( FlowStep flowStepParam ) 
flowStepParam , WS . Path . FlowStep . Version1 . flowStepDelete ( true ) ) ) ; 
} public final List < ElasticTypeAndId > searchAndConvertHitsToIdsOnly ( 
QueryBuilder qbParam , 
String indexParam , 
int offsetParam , 
int limitParam , 
Long ... formTypesParam ) { 
SearchHits searchHits = this . searchWithHits ( 
qbParam , 
indexParam , 
offsetParam , 
limitParam , 
formTypesParam ) ; 
List < ElasticTypeAndId > returnVal = null ; 
long totalHits ; 
if ( searchHits != null && ( totalHits = searchHits . getTotalHits ( ) ) > 0 ) { 
returnVal = new ArrayList ( ) ; 
if ( ( searchHits . getHits ( ) . length != totalHits ) && 
( searchHits . getHits ( ) . length != limitParam ) ) 
searchHits . getHits ( ) . length + "'." ) ; 
long iterationMax = totalHits ; 
if ( limitParam > 0 && totalHits > limitParam ) { 
iterationMax = limitParam ; 
for ( int index = 0 ; index < iterationMax ; index ++ ) { 
SearchHit searchHit = searchHits . getAt ( index ) ; 
String idAsString ; 
if ( ( idAsString = searchHit . getId ( ) ) == null ) { 
returnVal . add ( new ElasticTypeAndId ( 
this . toLongSafe ( idAsString ) , 
searchHit . getType ( ) ) ) ; 
} public final SearchHits searchWithHits ( 
boolean withNoFieldsParam , 
Long ... formTypesParam 
SearchRequestBuilder searchRequestBuilder = this . client . prepareSearch ( 
indexParam ) 
. setSearchType ( SearchType . DFS_QUERY_THEN_FETCH ) 
. setQuery ( qbParam ) 
. setFrom ( 0 ) 
. setExplain ( false ) ; 
if ( withNoFieldsParam ) { 
searchRequestBuilder = searchRequestBuilder . storedFields ( NO_FIELDS_MAPPER ) ; 
if ( limitParam > 0 ) 
searchRequestBuilder = searchRequestBuilder . setSize ( limitParam ) ; 
if ( offsetParam > - 1 ) { 
searchRequestBuilder = searchRequestBuilder . setFrom ( offsetParam ) ; 
if ( formTypesParam == null ) 
formTypesParam = new Long [ ] { } ; 
if ( formTypesParam != null && formTypesParam . length > 0 ) 
String [ ] formTypesAsString = new String [ formTypesParam . length ] ; 
for ( int index = 0 ; index < formTypesParam . length ; index ++ ) 
Long formTypeId = formTypesParam [ index ] ; 
if ( formTypeId == null ) 
formTypesAsString [ index ] = formTypeId . toString ( ) ; 
searchRequestBuilder = searchRequestBuilder . setTypes ( formTypesAsString ) ; 
SearchResponse searchResponse = searchRequestBuilder . execute ( ) . actionGet ( ) ; 
if ( searchResponse == null ) { 
return searchResponse . getHits ( ) ; 
} public final boolean searchContainHits ( 
withNoFieldsParam , 
return ( searchHits != null && searchHits . getTotalHits ( ) > 0 ) ; 
} public final List < Form > getFormsByIds ( 
List < Long > formIdsParam , 
boolean includeFieldDataParam , 
int limitParam 
if ( formIdsParam == null || formIdsParam . isEmpty ( ) ) { 
if ( indexParam == null || indexParam . trim ( ) . isEmpty ( ) ) { 
StringBuffer byIdQuery = new StringBuffer ( ) ; 
for ( Long formId : formIdsParam ) { 
byIdQuery . append ( ABaseFluidJSONObject . JSONMapping . ID ) ; 
byIdQuery . append ( ":\"" ) ; 
byIdQuery . append ( formId ) ; 
String queryByIdsToString = byIdQuery . toString ( ) ; 
queryByIdsToString = queryByIdsToString . substring ( 0 , queryByIdsToString . length ( ) - 1 ) ; 
List < Form > returnVal = null ; 
if ( includeFieldDataParam ) { 
returnVal = this . searchAndConvertHitsToFormWithAllFields ( 
QueryBuilders . queryStringQuery ( queryByIdsToString ) , 
new Long [ ] { } ) ; 
returnVal = this . searchAndConvertHitsToFormWithNoFields ( 
if ( returnVal == null || returnVal . isEmpty ( ) ) { 
} public final List < Form > searchAndConvertHitsToFormWithAllFields ( 
( searchHits . getHits ( ) . length != limitParam ) ) { 
String source ; 
if ( ( source = searchHit . getSourceAsString ( ) ) == null ) { 
this . printInfoOnSourceFromES ( searchHit ) ; 
Form formFromSource = new Form ( ) ; 
JSONObject jsonObject = new JSONObject ( source ) ; 
List < Field > fieldsForForm = null ; 
if ( jsonObject . has ( Form . JSONMapping . FORM_TYPE_ID ) ) { 
if ( this . fieldUtil == null ) { 
fieldsForForm = formFromSource . convertTo ( 
this . fieldUtil . getFormFieldMappingForFormDefinition ( 
jsonObject . getLong ( Form . JSONMapping . FORM_TYPE_ID ) ) ) ; 
formFromSource . populateFromElasticSearchJson ( 
jsonObject , fieldsForForm ) ; 
returnVal . add ( formFromSource ) ; 
} public final List < Form > searchAndConvertHitsToFormWithNoFields ( 
new JSONObject ( source ) , 
} protected final List < Form > populateTableFields ( 
boolean addAllTableRecordsForReturnParam , 
List < Field > formFieldsParam ) { 
if ( formFieldsParam == null || formFieldsParam . isEmpty ( ) ) { 
List < Form > allTableRecordsFromAllFields = addAllTableRecordsForReturnParam ? 
new ArrayList ( ) : null ; 
for ( Field descendantField : formFieldsParam ) { 
if ( ! ( descendantField . getFieldValue ( ) instanceof TableField ) ) { 
TableField tableField = ( TableField ) descendantField . getFieldValue ( ) ; 
List < Form > tableRecordWithIdOnly = tableField . getTableRecords ( ) ; 
if ( tableRecordWithIdOnly == null || tableRecordWithIdOnly . isEmpty ( ) ) { 
List < Long > formIdsOnly = new ArrayList ( ) ; 
for ( Form tableRecord : tableRecordWithIdOnly ) { 
formIdsOnly . add ( tableRecord . getId ( ) ) ; 
List < Form > populatedTableRecords = this . getFormsByIds ( 
Index . TABLE_RECORD , 
formIdsOnly , 
includeFieldDataParam , 
DEFAULT_OFFSET , MAX_NUMBER_OF_TABLE_RECORDS ) ; 
if ( addAllTableRecordsForReturnParam && populatedTableRecords != null ) { 
allTableRecordsFromAllFields . addAll ( populatedTableRecords ) ; 
tableField . setTableRecords ( populatedTableRecords ) ; 
descendantField . setFieldValue ( tableField ) ; 
return allTableRecordsFromAllFields ; 
} public boolean doesIndexExist ( String indexToCheckParam ) { 
if ( indexToCheckParam == null || indexToCheckParam . trim ( ) . isEmpty ( ) ) { 
return this . client . admin ( ) . cluster ( ) 
. prepareState ( ) . execute ( ) 
. actionGet ( ) . getState ( ) 
. getMetaData ( ) . hasIndex ( indexToCheckParam ) ; 
public void closeConnection ( ) { 
CloseConnectionRunnable closeConnectionRunnable = 
new CloseConnectionRunnable ( this ) ; 
Thread closeConnThread = new Thread ( 
closeConnThread . start ( ) ; 
public boolean doesNameContain ( String containingTextParam ) { 
if ( this . getName ( ) == null || this . getName ( ) . trim ( ) . isEmpty ( ) ) { 
if ( containingTextParam == null || containingTextParam . trim ( ) . isEmpty ( ) ) { 
String paramLower = containingTextParam . toLowerCase ( ) ; 
String nameLower = this . getName ( ) . toLowerCase ( ) ; 
return nameLower . contains ( paramLower ) ; 
if ( this . getAttachmentDataBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . ATTACHMENT_DATA_BASE64 , 
this . getAttachmentDataBase64 ( ) ) ; 
if ( this . getContentType ( ) != null ) { 
returnVal . put ( JSONMapping . CONTENT_TYPE , this . getContentType ( ) ) ; 
if ( this . getFormId ( ) != null ) { 
returnVal . put ( JSONMapping . FORM_ID , this . getFormId ( ) ) ; 
if ( this . getName ( ) != null ) { 
if ( this . getPath ( ) != null ) { 
returnVal . put ( JSONMapping . PATH , this . getPath ( ) ) ; 
if ( this . getVersion ( ) != null ) { 
returnVal . put ( JSONMapping . VERSION , this . getVersion ( ) ) ; 
if ( this . getDateCreated ( ) != null ) { 
this . getDateCreated ( ) . getTime ( ) ) ; 
if ( this . getDateLastUpdated ( ) != null ) { 
this . getDateLastUpdated ( ) . getTime ( ) ) ; 
} public List < Form > getTableForms ( 
Form formToGetTableFormsForParam , 
boolean includeFieldDataParam ) { 
if ( formToGetTableFormsForParam != null && this . serviceTicket != null ) { 
formToGetTableFormsForParam . setServiceTicket ( this . serviceTicket ) ; 
FormListing formListing = new FormListing ( 
this . postJson ( formToGetTableFormsForParam , 
WS . Path . SQLUtil . Version1 . getTableForms ( 
includeFieldDataParam ) ) ) ; 
return formListing . getListing ( ) ; 
catch ( JSONException e ) { 
throw new FluidClientException ( e . getMessage ( ) , e , 
} public List < Form > getDescendants ( 
Form formToGetDescendantsForParam , 
boolean includeTableFieldsParam , 
boolean inclTableFieldFormInfoParam ) { 
if ( formToGetDescendantsForParam != null && this . serviceTicket != null ) { 
formToGetDescendantsForParam . setServiceTicket ( this . serviceTicket ) ; 
this . postJson ( formToGetDescendantsForParam , 
WS . Path . SQLUtil . Version1 . getDescendants ( 
includeTableFieldsParam , 
inclTableFieldFormInfoParam ) ) ) ; 
} public Form getAncestor ( 
Form formToGetAncestorForParam , 
boolean includeTableFieldsParam ) { 
if ( formToGetAncestorForParam != null && this . serviceTicket != null ) { 
formToGetAncestorForParam . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( 
this . postJson ( formToGetAncestorForParam , 
WS . Path . SQLUtil . Version1 . getAncestor ( 
includeTableFieldsParam ) ) ) ; 
} public List < Field > getFormFields ( 
Form formToGetFieldsForParam , 
if ( formToGetFieldsForParam != null && this . serviceTicket != null ) { 
formToGetFieldsForParam . setServiceTicket ( this . serviceTicket ) ; 
FormFieldListing formFieldListing = new FormFieldListing ( 
this . postJson ( formToGetFieldsForParam , 
WS . Path . SQLUtil . Version1 . getFormFields ( 
return formFieldListing . getListing ( ) ; 
} public String toCamelUpperCase ( String inputParam ) { 
if ( inputParam == null ) 
if ( inputParam . isEmpty ( ) ) 
char [ ] original = inputParam . toCharArray ( ) ; 
StringBuilder titleCase = 
new StringBuilder ( Character . toString ( 
Character . toLowerCase ( original [ 0 ] ) ) ) ; 
boolean nextTitleCase = false ; 
for ( int index = 1 ; index < original . length ; index ++ ) 
char c = original [ index ] ; 
if ( Character . isSpaceChar ( c ) ) { 
nextTitleCase = true ; 
else if ( nextTitleCase ) { 
c = Character . toTitleCase ( c ) ; 
nextTitleCase = false ; 
titleCase . append ( c ) ; 
return titleCase . toString ( ) ; 
} public String getLatitudeFromFluidText ( String textToCheckParam ) { 
if ( textToCheckParam == null || textToCheckParam . isEmpty ( ) ) { 
String [ ] latitudeAndLongitude = textToCheckParam . split ( REG_EX_PIPE ) ; 
if ( latitudeAndLongitude == null || latitudeAndLongitude . length < 2 ) { 
latitudeAndLongitude = textToCheckParam . split ( REG_EX_COMMA ) ; 
if ( latitudeAndLongitude == null || latitudeAndLongitude . length == 0 ) { 
return ZERO ; 
if ( latitudeAndLongitude . length > 1 ) 
return toGoeSafe ( latitudeAndLongitude [ 0 ] ) ; 
} public double getLatitudeFromElasticSearchText ( String textToCheckParam ) 
String [ ] latitudeAndLongitude = textToCheckParam . split ( REG_EX_COMMA ) ; 
latitudeAndLongitude = textToCheckParam . split ( REG_EX_PIPE ) ; 
if ( latitudeAndLongitude . length > 1 ) { 
return toDoubleSafe ( latitudeAndLongitude [ 0 ] ) ; 
} public double getLongitudeFromElasticSearchText ( String textToCheckParam ) 
if ( textToCheckParam == null || textToCheckParam . trim ( ) . isEmpty ( ) ) { 
return this . toDoubleSafe ( latitudeAndLongitude [ 1 ] ) ; 
} public final double toDoubleSafe ( String toParseParam ) { 
if ( toParseParam == null || toParseParam . trim ( ) . isEmpty ( ) ) { 
return 0D ; 
return Double . parseDouble ( toParseParam ) ; 
} public final String toGoeSafe ( String toParseParam ) { 
for ( char charToCheck : toParseParam . toCharArray ( ) ) { 
if ( ! Character . isDigit ( charToCheck ) && '.' != charToCheck ) { 
if ( toParseParam . length ( ) > 12 ) { 
return toParseParam . substring ( 0 , 12 ) ; 
return toParseParam ; 
} public static byte [ ] decodeBase64 ( String base64StringParam ) 
if ( base64StringParam == null ) 
if ( base64StringParam . isEmpty ( ) ) 
return new byte [ ] { } ; 
return Base64 . getDecoder ( ) . decode ( base64StringParam ) ; 
} public static String encodeBase16 ( byte [ ] bytesParam ) 
if ( bytesParam == null ) 
if ( bytesParam . length == 0 ) 
return UtilGlobal . EMPTY ; 
return DatatypeConverter . printHexBinary ( bytesParam ) . toUpperCase ( ) ; 
} public static byte [ ] decodeBase16 ( String stringParam ) { 
if ( stringParam == null ) 
if ( stringParam . trim ( ) . isEmpty ( ) ) 
int len = stringParam . length ( ) ; 
byte [ ] data = new byte [ len / 2 ] ; 
for ( int i = 0 ; i < len ; i += 2 ) { 
data [ i / 2 ] = ( byte ) ( ( Character . digit ( stringParam . charAt ( i ) , 16 ) << 4 ) 
+ Character . digit ( stringParam . charAt ( i + 1 ) , 16 ) ) ; 
} public static String encodeBase64 ( byte [ ] bytesParam ) 
return Base64 . getEncoder ( ) . encodeToString ( bytesParam ) ; 
} public void setFlatFieldOnJSONObj ( 
String fieldNamePrefixParam , 
String fieldNameIdPrefixParam , 
Field fieldToExtractFromParam , 
JSONObject objectToSetFieldOnParam ) 
if ( fieldToExtractFromParam == null ) 
String fieldName = fieldToExtractFromParam . getFieldNameAsUpperCamel ( ) ; 
if ( fieldName == null || fieldName . trim ( ) . isEmpty ( ) ) 
String completeFieldName = fieldNamePrefixParam . concat ( fieldName ) ; 
String completeFieldNameId = fieldNameIdPrefixParam . concat ( fieldName ) ; 
objectToSetFieldOnParam . put ( completeFieldNameId , 
fieldToExtractFromParam . getId ( ) ) ; 
Object fieldValue = fieldToExtractFromParam . getFieldValue ( ) ; 
objectToSetFieldOnParam . put ( 
completeFieldName , 
JSONObject . NULL ) ; 
else if ( fieldValue instanceof TableField ) 
else if ( fieldValue instanceof MultiChoice ) { 
MultiChoice multiChoice = ( MultiChoice ) fieldValue ; 
if ( multiChoice . getSelectedMultiChoices ( ) == null || 
multiChoice . getSelectedMultiChoices ( ) . isEmpty ( ) ) 
multiChoice . getSelectedMultiChoices ( ) . forEach ( selectedChoice -> 
builder . append ( selectedChoice ) ; 
String selectVal = builder . toString ( ) ; 
if ( selectVal != null && ! selectVal . trim ( ) . isEmpty ( ) ) 
selectVal = selectVal . substring ( 0 , selectVal . length ( ) - 2 ) ; 
objectToSetFieldOnParam . put ( completeFieldName , selectVal ) ; 
if ( ( fieldValue instanceof String ) && 
Field . LATITUDE_AND_LONGITUDE . equals ( 
fieldToExtractFromParam . getTypeMetaData ( ) ) ) 
String latitudeTxt = this . getLatitudeFromFluidText ( formFieldValueStr ) ; 
String longitudeTxt = this . getLongitudeFromFluidText ( formFieldValueStr ) ; 
fieldValue = ( latitudeTxt . concat ( UtilGlobal . COMMA ) . concat ( longitudeTxt ) ) ; 
objectToSetFieldOnParam . put ( completeFieldName , fieldValue ) ; 
objectToSetFieldOnParam . put ( completeFieldName , ( ( Date ) fieldValue ) . getTime ( ) ) ; 
} public Object doesHandlerQualifyForProcessing ( String messageParam ) { 
JSONObject jsonObject = null ; 
jsonObject = new JSONObject ( messageParam ) ; 
jsonExcept . getMessage ( ) , 
Error fluidError = new Error ( jsonObject ) ; 
if ( fluidError . getErrorCode ( ) > 0 ) { 
return fluidError ; 
String echo = fluidError . getEcho ( ) ; 
if ( this . expectedEchoMessagesBeforeComplete . contains ( echo ) ) { 
public void handleMessage ( Object objectToProcess ) { 
if ( objectToProcess instanceof Error ) { 
Error fluidError = ( ( Error ) objectToProcess ) ; 
this . errors . add ( fluidError ) ; 
if ( this . messageReceivedCallback != null ) 
this . messageReceivedCallback . errorMessageReceived ( fluidError ) ; 
if ( this . completableFuture != null ) 
this . completableFuture . completeExceptionally ( 
new FluidClientException ( 
fluidError . getErrorMessage ( ) , 
fluidError . getErrorCode ( ) ) ) ; 
JSONObject jsonObject = ( JSONObject ) objectToProcess ; 
if ( this . compressedResponse ) { 
CompressedResponse compressedResponse = new CompressedResponse ( jsonObject ) ; 
byte [ ] compressedJsonList = 
UtilGlobal . decodeBase64 ( compressedResponse . getDataBase64 ( ) ) ; 
byte [ ] uncompressedJson = null ; 
uncompressedJson = this . uncompress ( compressedJsonList ) ; 
} catch ( IOException eParam ) { 
eParam , 
FluidClientException . ErrorCode . IO_ERROR ) ; 
jsonObject = new JSONObject ( new String ( uncompressedJson ) ) ; 
T messageForm = this . getNewInstanceBy ( jsonObject ) ; 
this . returnValue . add ( messageForm ) ; 
String echo = messageForm . getEcho ( ) ; 
if ( echo != null && ! echo . trim ( ) . isEmpty ( ) ) 
this . expectedEchoMessagesBeforeComplete . remove ( echo ) ; 
if ( this . expectedEchoMessagesBeforeComplete . isEmpty ( ) ) 
this . completableFuture . complete ( this . returnValue ) ; 
this . messageReceivedCallback . messageReceived ( messageForm ) ; 
public void connectionClosed ( ) { 
this . isConnectionClosed = true ; 
if ( this . getErrors ( ) . isEmpty ( ) ) 
Error firstFluidError = this . getErrors ( ) . get ( 0 ) ; 
this . completableFuture . completeExceptionally ( new FluidClientException ( 
firstFluidError . getErrorMessage ( ) , 
firstFluidError . getErrorCode ( ) ) ) ; 
} public void addExpectedMessage ( String expectedMessageEchoParam ) 
if ( expectedMessageEchoParam == null || 
expectedMessageEchoParam . trim ( ) . isEmpty ( ) ) { 
this . expectedEchoMessagesBeforeComplete . add ( expectedMessageEchoParam ) ; 
} private List < String > getEchoMessagesFromReturnValue ( ) 
List < String > returnListing = new ArrayList ( ) ; 
if ( this . returnValue == null ) 
return returnListing ; 
Iterator < T > iterForReturnVal = 
this . returnValue . iterator ( ) ; 
while ( iterForReturnVal . hasNext ( ) ) 
T returnVal = iterForReturnVal . next ( ) ; 
if ( returnVal . getEcho ( ) == null ) 
returnListing . add ( returnVal . getEcho ( ) ) ; 
} public boolean doReturnValueEchoMessageContainAll ( 
List < String > echoMessageParam ) 
if ( echoMessageParam == null || echoMessageParam . isEmpty ( ) ) 
List < String > allReturnValueEchoMessages = 
this . getEchoMessagesFromReturnValue ( ) ; 
for ( String toCheckFor : echoMessageParam ) 
if ( ! allReturnValueEchoMessages . contains ( toCheckFor ) ) 
} protected byte [ ] uncompress ( 
byte [ ] compressedBytesParam 
) throws IOException { 
byte [ ] returnVal = null ; 
ZipInputStream zis = null ; 
if ( CHARSET == null ) { 
zis = new ZipInputStream ( 
new ByteArrayInputStream ( compressedBytesParam ) ) ; 
new ByteArrayInputStream ( compressedBytesParam ) , 
CHARSET ) ; 
ZipEntry ze = zis . getNextEntry ( ) ; 
if ( ze == null ) { 
while ( ( len = zis . read ( buffer ) ) > 0 ) { 
bos . write ( buffer , 0 , len ) ; 
zis . closeEntry ( ) ; 
zis . close ( ) ; 
bos . flush ( ) ; 
bos . close ( ) ; 
returnVal = bos . toByteArray ( ) ; 
} public List < FluidItem > getPersonalInventoryItems ( ) 
User loggedInUser = new User ( ) ; 
loggedInUser . setServiceTicket ( this . serviceTicket ) ; 
return new FluidItemListing ( this . postJson ( 
loggedInUser , 
WS . Path . PersonalInventory . Version1 . getAllByLoggedInUser ( ) ) ) . getListing ( ) ; 
} public Form removeFromPersonalInventory ( Form formToRemoveParam ) 
if ( formToRemoveParam != null && 
this . serviceTicket != null ) 
formToRemoveParam . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( this . postJson ( 
formToRemoveParam , 
WS . Path . PersonalInventory . Version1 . removeFromPersonalInventory ( ) ) ) ; 
if ( this . getEncryptedDataBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . ENCRYPTED_DATA_BASE_64 , this . getEncryptedDataBase64 ( ) ) ; 
if ( this . getEncryptedDataHmacBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . ENCRYPTED_DATA_HMAC_BASE_64 , this . getEncryptedDataHmacBase64 ( ) ) ; 
if ( this . getIvBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . IV_BASE_64 , this . getIvBase64 ( ) ) ; 
if ( this . getSeedBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . SEED_BASE_64 , this . getSeedBase64 ( ) ) ; 
if ( this . getServiceTicket ( ) != null ) { 
returnVal . put ( ABaseFluidJSONObject . JSONMapping . SERVICE_TICKET , this . getServiceTicket ( ) ) ; 
if ( this . getSalt ( ) != null ) { 
if ( this . getPrincipalClient ( ) != null ) { 
returnVal . put ( JSONMapping . PRINCIPAL_CLIENT , this . getPrincipalClient ( ) ) ; 
if ( this . getRoleString ( ) != null ) { 
returnVal . put ( JSONMapping . ROLE_STRING , this . getRoleString ( ) ) ; 
if ( this . getTimestamp ( ) != null ) { 
returnVal . put ( JSONMapping . TIMESTAMP , this . getTimestamp ( ) ) ; 
} public Form createFormContainer ( Form formParam ) { 
return new Form ( this . putJson ( 
formParam , WS . Path . FormContainer . Version1 . formContainerCreate ( ) ) ) ; 
} public TableRecord createTableRecord ( TableRecord tableRecordParam ) { 
if ( tableRecordParam != null && this . serviceTicket != null ) { 
tableRecordParam . setServiceTicket ( this . serviceTicket ) ; 
return new TableRecord ( this . putJson ( 
tableRecordParam , 
WS . Path . FormContainerTableRecord . Version1 . formContainerTableRecordCreate ( ) ) ) ; 
} public Form updateFormContainer ( Form formParam ) { 
formParam , WS . Path . FormContainer . Version1 . formContainerUpdate ( ) ) ) ; 
} public Form executeCustomWebAction ( 
String customWebActionParam , 
Form formParam ) { 
return this . executeCustomWebAction ( 
customWebActionParam , 
formParam ) ; 
boolean isTableRecordParam , 
Long formContainerTableRecordBelowsToParam , 
if ( customWebActionParam == null || customWebActionParam . trim ( ) . isEmpty ( ) ) { 
formParam , WS . Path . FormContainer . Version1 . executeCustomWebAction ( 
isTableRecordParam , 
formContainerTableRecordBelowsToParam ) ) ) ; 
} catch ( UnsupportedEncodingException unsEncExcept ) { 
} public Form deleteFormContainer ( Form formContainerParam ) { 
if ( formContainerParam != null && this . serviceTicket != null ) { 
formContainerParam . setServiceTicket ( this . serviceTicket ) ; 
return new Form ( this . postJson ( formContainerParam , 
WS . Path . FormContainer . Version1 . formContainerDelete ( ) ) ) ; 
} public List < FormFlowHistoricData > getFormFlowHistoricData ( Form formParam ) { 
return new FormFlowHistoricDataListing ( this . postJson ( 
formParam , WS . Path . FlowItemHistory . Version1 . getByFormContainer ( ) ) ) . getListing ( ) ; 
} public List < FormHistoricData > getFormAndFieldHistoricData ( 
Form formParam , 
boolean includeCurrentParam 
if ( formParam != null && this . serviceTicket != null ) 
return new FormHistoricDataListing ( this . postJson ( 
formParam , WS . Path . FormHistory . Version1 . getByFormContainer ( 
includeCurrentParam ) ) ) . getListing ( ) ; 
} public FormHistoricData getMostRecentFormAndFieldHistoricData ( Form formParam ) { 
return new FormHistoricData ( this . postJson ( 
formParam , WS . Path . FormHistory . Version1 . getByMostRecentByFormContainer ( ) ) ) ; 
} public Form getFormContainerById ( Long formContainerIdParam ) { 
Form form = new Form ( formContainerIdParam ) ; 
form . setServiceTicket ( this . serviceTicket ) ; 
form , WS . Path . FormContainer . Version1 . getById ( ) ) ) ; 
} public Form lockFormContainer ( 
JobView jobViewParam 
return this . lockFormContainer ( 
formParam , jobViewParam , null ) ; 
JobView jobViewParam , 
User userToLockAsParam 
if ( this . serviceTicket != null && formParam != null ) { 
Long jobViewId = ( jobViewParam == null ) ? 
null : jobViewParam . getId ( ) ; 
Long lockAsUserId = ( userToLockAsParam == null ) ? 
null : userToLockAsParam . getId ( ) ; 
formParam , 
WS . Path . FormContainer . Version1 . lockFormContainer ( 
jobViewId , lockAsUserId ) ) ) ; 
} public Form unLockFormContainer ( 
boolean unlockAsyncParam ) { 
return this . unLockFormContainer ( 
formParam , null , unlockAsyncParam , false ) ; 
User userToUnLockAsParam ) { 
formParam , userToUnLockAsParam , true , false ) ; 
User userToUnLockAsParam , 
userToUnLockAsParam , 
unlockAsyncParam , 
boolean unlockAsyncParam , 
boolean removeFromPersonalInventoryParam ) { 
Long unLockAsUserId = ( userToUnLockAsParam == null ) ? 
null : userToUnLockAsParam . getId ( ) ; 
WS . Path . FormContainer . Version1 . unLockFormContainer ( 
unLockAsUserId , 
removeFromPersonalInventoryParam ) ) ) ; 
} public List < Form > getFormTableForms ( 
Long electronicFormIdParam , 
boolean includeFieldDataParam 
List < Form > returnVal = new ArrayList ( ) ; 
if ( electronicFormIdParam == null ) { 
Map < Long , String > definitionAndTitle = 
this . formDefUtil . getFormDefinitionIdAndTitle ( ) ; 
PreparedStatement preparedStatement = null ; 
ResultSet resultSet = null ; 
ISyntax syntax = SyntaxFactory . getInstance ( ) . getSyntaxFor ( 
this . getSQLTypeFromConnection ( ) , 
ISyntax . ProcedureMapping . Form . GetFormContainersTableFieldFormContainers ) ; 
preparedStatement = this . getConnection ( ) . prepareStatement ( 
syntax . getPreparedStatement ( ) ) ; 
preparedStatement . setLong ( 1 , electronicFormIdParam ) ; 
resultSet = preparedStatement . executeQuery ( ) ; 
while ( resultSet . next ( ) ) 
returnVal . add ( this . mapFormContainerTo ( 
definitionAndTitle , 
resultSet ) ) ; 
if ( includeFieldDataParam ) 
for ( Form form : returnVal ) 
List < Field > formFields = this . fieldUtil . getFormFields ( 
form . getId ( ) , 
form . setFormFields ( formFields ) ; 
} catch ( SQLException sqlError ) { 
throw new FluidSQLException ( sqlError ) ; 
this . closeStatement ( preparedStatement , resultSet ) ; 
public List < Form > getFormDescendants ( 
List < Long > electronicFormIdsParam , 
boolean includeTableFieldFormRecordInfoParam ) { 
if ( electronicFormIdsParam == null || electronicFormIdsParam . isEmpty ( ) ) { 
for ( Long electronicFormId : electronicFormIdsParam ) { 
List < Form > forTheCycle = this . getFormDescendants ( 
electronicFormId , 
includeTableFieldFormRecordInfoParam ) ; 
if ( forTheCycle == null ) { 
returnVal . addAll ( forTheCycle ) ; 
} public Form getFormAncestor ( 
boolean includeTableFieldsParam 
Form returnVal = null ; 
ISyntax . ProcedureMapping . Form . GetFormContainersParentFormContainer ) ; 
if ( resultSet . next ( ) ) { 
returnVal = this . mapFormContainerTo ( 
resultSet ) ; 
if ( includeFieldDataParam && returnVal != null ) { 
returnVal . setFormFields ( 
this . fieldUtil . getFormFields ( 
returnVal . getId ( ) , 
false ) ) ; 
} private Form mapFormContainerTo ( 
Map < Long , String > definitionAndTitleParam , 
ResultSet resultSetParam 
) throws SQLException { 
Long formId = resultSetParam . getLong ( SQLColumnIndex . _01_FORM_ID ) ; 
String formType = definitionAndTitleParam . get ( 
resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) ) ; 
String title = resultSetParam . getString ( SQLColumnIndex . _03_TITLE ) ; 
Date created = resultSetParam . getDate ( SQLColumnIndex . _04_CREATED ) ; 
Date lastUpdated = resultSetParam . getDate ( SQLColumnIndex . _05_LAST_UPDATED ) ; 
Long currentUserId = resultSetParam . getLong ( SQLColumnIndex . _06_CURRENT_USER_ID ) ; 
if ( formType == null ) { 
resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) + "'." ) ; 
Form toAdd = new Form ( formType ) ; 
toAdd . setId ( formId ) ; 
toAdd . setTitle ( title ) ; 
if ( created != null ) { 
toAdd . setDateCreated ( new Date ( created . getTime ( ) ) ) ; 
if ( lastUpdated != null ) { 
toAdd . setDateLastUpdated ( new Date ( lastUpdated . getTime ( ) ) ) ; 
if ( currentUserId != null && 
currentUserId . longValue ( ) > 0 ) { 
User currentUser = new User ( ) ; 
currentUser . setId ( currentUserId ) ; 
toAdd . setCurrentUser ( currentUser ) ; 
} private void mapFormContainerStatesTo ( 
Form previousMappedForm , 
if ( previousMappedForm == null ) { 
Long formContainerState = resultSetParam . getLong ( 
SQLColumnIndex . _07_FORM_CONTAINER_STATE ) ; 
long formContStateId = ( formContainerState == null ) ? 
0 : formContainerState . longValue ( ) ; 
if ( formContStateId > 0 ) { 
if ( formContStateId == 1 ) 
previousMappedForm . setState ( Form . State . OPEN ) ; 
else if ( formContStateId == 2 ) 
previousMappedForm . setState ( Form . State . LOCKED ) ; 
Long formContainerFlowState = resultSetParam . getLong ( 
SQLColumnIndex . _08_FORM_CONTAINER_FLOW_STATE ) ; 
long formContFlowStateId = ( formContainerFlowState == null ) ? 
0 : formContainerFlowState . longValue ( ) ; 
if ( formContFlowStateId > 0 ) { 
if ( formContFlowStateId == 1 ) { 
previousMappedForm . setFlowState ( 
FluidItem . FlowState . NotInFlow . name ( ) ) ; 
else if ( formContFlowStateId == 2 ) { 
FluidItem . FlowState . WorkInProgress . name ( ) ) ; 
else if ( formContFlowStateId == 3 ) { 
FluidItem . FlowState . UserSend . name ( ) ) ; 
else if ( formContFlowStateId == 4 ) { 
FluidItem . FlowState . UserSendWorkInProgress . name ( ) ) ; 
else if ( formContFlowStateId == 5 ) { 
previousMappedForm . setFlowState ( FluidItem . FlowState . Archive . name ( ) ) ; 
public static List < Role > convertToObjects ( String roleListingParam ) 
if ( roleListingParam == null || roleListingParam . trim ( ) . isEmpty ( ) ) 
String [ ] listOfRoles = roleListingParam . split ( UtilGlobal . REG_EX_COMMA ) ; 
List < Role > returnVal = new ArrayList < > ( ) ; 
for ( String roleName : listOfRoles ) 
Role roleToAdd = new Role ( ) ; 
roleToAdd . setName ( roleName . trim ( ) ) ; 
returnVal . add ( roleToAdd ) ; 
if ( this . getAdminPermissions ( ) != null && 
! this . getAdminPermissions ( ) . isEmpty ( ) ) 
JSONArray adminPerArr = new JSONArray ( ) ; 
for ( String toAdd : this . getAdminPermissions ( ) ) 
adminPerArr . put ( toAdd ) ; 
returnVal . put ( JSONMapping . ADMIN_PERMISSIONS , adminPerArr ) ; 
if ( this . getRoleToFormDefinitions ( ) != null && 
! this . getRoleToFormDefinitions ( ) . isEmpty ( ) ) 
JSONArray roleToFormDefArr = new JSONArray ( ) ; 
for ( RoleToFormDefinition toAdd : this . getRoleToFormDefinitions ( ) ) 
roleToFormDefArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ROLE_TO_FORM_DEFINITIONS , roleToFormDefArr ) ; 
if ( this . getRoleToFormFieldToFormDefinitions ( ) != null && 
! this . getRoleToFormFieldToFormDefinitions ( ) . isEmpty ( ) ) 
JSONArray roleToJobViewArr = new JSONArray ( ) ; 
for ( RoleToFormFieldToFormDefinition toAdd : this . getRoleToFormFieldToFormDefinitions ( ) ) 
roleToJobViewArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ROLE_TO_FORM_FIELD_TO_FORM_DEFINITIONS , roleToJobViewArr ) ; 
if ( this . getRoleToJobViews ( ) != null && 
! this . getRoleToJobViews ( ) . isEmpty ( ) ) 
for ( RoleToJobView toAdd : this . getRoleToJobViews ( ) ) 
returnVal . put ( JSONMapping . ROLE_TO_JOB_VIEWS , roleToJobViewArr ) ; 
if ( this . getRoleToUserQueries ( ) != null && 
! this . getRoleToUserQueries ( ) . isEmpty ( ) ) 
JSONArray userQueriesArr = new JSONArray ( ) ; 
for ( RoleToUserQuery toAdd : this . getRoleToUserQueries ( ) ) 
userQueriesArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ROLE_TO_USER_QUERIES , userQueriesArr ) ; 
} public Form createFormDefinition ( Form formDefinitionParam ) 
if ( formDefinitionParam != null && this . serviceTicket != null ) 
formDefinitionParam . setServiceTicket ( this . serviceTicket ) ; 
formDefinitionParam , WS . Path . FormDefinition . Version1 . formDefinitionCreate ( ) ) ) ; 
} public Form updateFormDefinition ( Form formDefinitionParam ) 
formDefinitionParam , 
WS . Path . FormDefinition . Version1 . formDefinitionUpdate ( ) ) ) ; 
} public Form getFormDefinitionById ( Long formDefinitionIdParam ) 
Form form = new Form ( formDefinitionIdParam ) ; 
form , WS . Path . FormDefinition . Version1 . getById ( ) ) ) ; 
} public Form getFormDefinitionByName ( String formDefinitionNameParam ) 
Form form = new Form ( formDefinitionNameParam ) ; 
form , WS . Path . FormDefinition . Version1 . getByName ( ) ) ) ; 
} public List < Form > getAllByLoggedInUser ( boolean includeTableRecordTypesParam ) 
Form form = new Form ( ) ; 
if ( includeTableRecordTypesParam ) 
return new FormListing ( this . postJson ( 
form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUserIncludeTableTypes ( ) ) ) . getListing ( ) ; 
form , WS . Path . FormDefinition . Version1 . getAllByLoggedInUser ( ) ) ) . getListing ( ) ; 
} public List < Form > getAllByLoggedInUserWhereCanCreateInstanceOf ( ) 
form , WS . Path . FormDefinition . Version1 . getAllByLoggedInAndCanCreateInstanceOf ( ) ) ) . 
getListing ( ) ; 
} public Form deleteFormDefinition ( Form formDefinitionParam ) 
return new Form ( this . postJson ( formDefinitionParam , 
WS . Path . FormDefinition . Version1 . formDefinitionDelete ( ) ) ) ; 
} public CachedFieldValue getCachedFieldValueFrom ( 
Long formDefIdParam , 
Long formContIdParam , 
Long formFieldIdParam ) 
if ( ( formDefIdParam == null || formContIdParam == null ) || 
formFieldIdParam == null ) 
String storageKey = this . getStorageKeyFrom ( 
formDefIdParam , 
formContIdParam , 
formFieldIdParam ) ; 
Object objWithKey ; 
objWithKey = this . memcachedClient . get ( storageKey ) ; 
catch ( MemcachedException e ) { 
} catch ( TimeoutException e ) { 
return this . getCacheFieldValueFromObject ( objWithKey ) ; 
private CachedFieldValue getCacheFieldValueFromObject ( Object objWithKeyParam ) 
if ( objWithKeyParam == null ) 
Method methodGetWord = CacheUtil . getMethod ( 
objWithKeyParam . getClass ( ) , 
CustomCode . IWord . METHOD_getWord ) ; 
Method methodGetValue = CacheUtil . getMethod ( 
CustomCode . ADataType . METHOD_getValue ) ; 
Object getWordObj = CacheUtil . invoke ( methodGetWord , objWithKeyParam ) ; 
String getWordVal = null ; 
if ( getWordObj instanceof String ) 
getWordVal = ( String ) getWordObj ; 
Object getValueObj ; 
if ( FlowJobType . MULTIPLE_CHOICE . equals ( getWordVal ) ) 
MultiChoice multiChoice = new MultiChoice ( ) ; 
Method methodAvailableChoices = getMethod ( 
CustomCode . MultipleChoice . METHOD_getAvailableChoices ) ; 
Object availChoicesObj = 
CacheUtil . invoke ( methodAvailableChoices , objWithKeyParam ) ; 
if ( availChoicesObj instanceof List ) 
multiChoice . setAvailableMultiChoices ( ( List ) availChoicesObj ) ; 
Method methodSelectedChoices = getMethod ( 
CustomCode . MultipleChoice . METHOD_getSelectedChoices ) ; 
Object selectedChoicesObj = 
invoke ( methodSelectedChoices , objWithKeyParam ) ; 
if ( selectedChoicesObj instanceof List ) 
multiChoice . setSelectedMultiChoices ( ( List ) selectedChoicesObj ) ; 
getValueObj = multiChoice ; 
getValueObj = CacheUtil . invoke ( methodGetValue , objWithKeyParam ) ; 
if ( getValueObj == null ) 
if ( getWordVal == null ) 
throw new FluidCacheException ( 
CachedFieldValue returnVal = new CachedFieldValue ( ) ; 
returnVal . dataType = getWordVal ; 
returnVal . cachedFieldValue = getValueObj ; 
private static Method getMethod ( Class clazzParam , String nameParam ) 
if ( clazzParam == null || nameParam == null ) 
Method returnVal = clazzParam . getDeclaredMethod ( nameParam ) ; 
returnVal . setAccessible ( true ) ; 
catch ( NoSuchMethodException e ) { 
} private static Object invoke ( Method methodParam , Object objParam ) 
return methodParam . invoke ( objParam ) ; 
} private String getStorageKeyFrom ( 
StringBuilder stringBuff = new StringBuilder ( ) ; 
if ( formDefIdParam == null ) 
stringBuff . append ( NULL ) ; 
stringBuff . append ( formDefIdParam . toString ( ) ) ; 
stringBuff . append ( DASH ) ; 
if ( formContIdParam == null ) 
stringBuff . append ( formContIdParam . toString ( ) ) ; 
if ( formFieldIdParam == null ) 
stringBuff . append ( formFieldIdParam . toString ( ) ) ; 
return stringBuff . toString ( ) ; 
} private MemcachedClient initXMemcachedClient ( ) 
if ( this . memcachedClient != null && ! this . memcachedClient . isShutdown ( ) ) 
return this . memcachedClient ; 
this . memcachedClient = new XMemcachedClient ( 
this . cacheHost , this . cachePort ) ; 
if ( this . memcachedClient != null && 
! this . memcachedClient . isShutdown ( ) ) 
this . memcachedClient . shutdown ( ) ; 
catch ( IOException eParam ) { 
if ( this . getOrder ( ) != null ) 
returnVal . put ( JSONMapping . ORDER , this . getOrder ( ) ) ; 
if ( this . getRule ( ) != null ) 
returnVal . put ( JSONMapping . RULE , this . getRule ( ) ) ; 
if ( this . getCurrentTypedSyntax ( ) != null ) 
returnVal . put ( JSONMapping . CURRENT_TYPED_SYNTAX , 
this . getCurrentTypedSyntax ( ) ) ; 
returnVal . put ( JSONMapping . FLOW , this . getFlow ( ) . toJsonObject ( ) ) ; 
if ( this . getFlowStep ( ) != null ) 
returnVal . put ( JSONMapping . FLOW_STEP , this . getFlowStep ( ) . toJsonObject ( ) ) ; 
if ( this . getNextValidSyntaxWords ( ) != null && ! this . getNextValidSyntaxWords ( ) . isEmpty ( ) ) 
JSONArray jsonArrayOfValidWords = new JSONArray ( ) ; 
for ( String validWord : this . getNextValidSyntaxWords ( ) ) 
jsonArrayOfValidWords . put ( validWord ) ; 
returnVal . put ( JSONMapping . NEXT_VALID_SYNTAX_WORDS , jsonArrayOfValidWords ) ; 
} public List < FormListing > getDescendantsSynchronized ( 
Form ... formToGetDescendantsForParam ) { 
if ( formToGetDescendantsForParam == null || 
formToGetDescendantsForParam . length == 0 ) { 
String uniqueReqId = this . initNewRequest ( ) ; 
int numberOfSentForms = 0 ; 
if ( this . massFetch ) { 
FormListing listingToSend = new FormListing ( ) ; 
List < Form > listOfValidForms = new ArrayList ( ) ; 
for ( Form formToSend : formToGetDescendantsForParam ) { 
if ( formToSend == null ) { 
FluidClientException . ErrorCode . ILLEGAL_STATE_ERROR ) ; 
listOfValidForms . add ( new Form ( formToSend . getId ( ) ) ) ; 
listingToSend . setEcho ( UUID . randomUUID ( ) . toString ( ) ) ; 
listingToSend . setListing ( listOfValidForms ) ; 
this . sendMessage ( listingToSend , uniqueReqId ) ; 
numberOfSentForms ++ ; 
this . setEchoIfNotSet ( formToSend ) ; 
this . sendMessage ( formToSend , uniqueReqId ) ; 
List < FormListing > returnValue = 
this . getHandler ( uniqueReqId ) . getCF ( ) . get ( 
this . getTimeoutInMillis ( ) , TimeUnit . MILLISECONDS ) ; 
if ( this . getHandler ( uniqueReqId ) . isConnectionClosed ( ) ) { 
} catch ( InterruptedException exceptParam ) { 
exceptParam . getMessage ( ) , 
exceptParam , 
FluidClientException . ErrorCode . STATEMENT_EXECUTION_ERROR ) ; 
} catch ( ExecutionException executeProblem ) { 
Throwable cause = executeProblem . getCause ( ) ; 
if ( cause instanceof FluidClientException ) { 
throw ( FluidClientException ) cause ; 
cause . getMessage ( ) , cause , 
} catch ( TimeoutException eParam ) { 
String errMessage = this . getExceptionMessageVerbose ( 
"SQLUtil-WebSocket-GetDescendants" , 
uniqueReqId , 
numberOfSentForms ) ; 
errMessage , FluidClientException . ErrorCode . IO_ERROR ) ; 
this . removeHandler ( uniqueReqId ) ; 
} protected static String getStringPropertyFromProperties ( 
Properties propertiesParam , 
String propertyKeyParam 
if ( propertiesParam == null || propertiesParam . isEmpty ( ) ) { 
return propertiesParam . getProperty ( propertyKeyParam ) ; 
} protected static int getIntPropertyFromProperties ( 
String strProp = getStringPropertyFromProperties ( 
propertiesParam , propertyKeyParam ) ; 
if ( strProp == null || strProp . trim ( ) . isEmpty ( ) ) { 
return Integer . parseInt ( strProp ) ; 
} protected long toLongSafe ( String toParseParam ) { 
return Long . parseLong ( toParseParam . trim ( ) ) ; 
returnVal . put ( JSONMapping . FLOW , this . getFlow ( ) ) ; 
if ( this . getForm ( ) != null ) 
returnVal . put ( JSONMapping . FORM , this . getForm ( ) . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . USER_FIELDS , fieldsArr ) ; 
if ( this . getAttachments ( ) != null ) 
for ( Attachment toAdd : this . getAttachments ( ) ) 
jsonArray . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ATTACHMENTS , jsonArray ) ; 
if ( this . getFlowState ( ) != null ) 
returnVal . put ( JSONMapping . FLOW_STATE , this . getFlowState ( ) . toString ( ) ) ; 
public JSONObject convertToFlatJSONObject ( ) 
FlatFormJSONMapping . FLUID_ITEM_ID , 
this . getId ( ) == null ? 
JSONObject . NULL : this . getId ( ) ) ; 
FlatFormJSONMapping . FLOW_STATE , 
( this . getFlowState ( ) == null ) ? 
JSONObject . NULL : this . getFlowState ( ) . name ( ) ) ; 
JSONObject formJSONObjFlat = 
( this . getForm ( ) == null ) ? null : 
this . getForm ( ) . convertToFlatJSONObject ( ) ; 
if ( formJSONObjFlat != null ) 
formJSONObjFlat . keySet ( ) . forEach ( 
( toAdd ) -> 
returnVal . put ( toAdd , formJSONObjFlat . get ( toAdd ) ) ; 
if ( this . isCanCreate ( ) != null ) 
returnVal . put ( JSONMapping . CAN_CREATE , 
this . isCanCreate ( ) . booleanValue ( ) ) ; 
if ( this . getFormDefinition ( ) != null ) 
returnVal . put ( JSONMapping . FORM_DEFINITION , 
this . getFormDefinition ( ) . toJsonObject ( ) ) ; 
} public String getListOfProvidersFromIdentities ( ) 
if ( this . getIdentities ( ) == null || this . getIdentities ( ) . isEmpty ( ) ) 
StringBuilder returnVal = new StringBuilder ( ) ; 
for ( Identity identity : this . getIdentities ( ) ) 
returnVal . append ( identity . getProvider ( ) ) ; 
returnVal . append ( "," ) ; 
String toString = returnVal . toString ( ) ; 
return toString . substring ( 0 , toString . length ( ) - 1 ) ; 
if ( this . getUserId ( ) != null ) 
returnVal . put ( JSONMapping . USER_ID , this . getUserId ( ) ) ; 
if ( this . getEmail ( ) != null ) 
returnVal . put ( JSONMapping . EMAIL , this . getEmail ( ) ) ; 
returnVal . put ( JSONMapping . EMAIL_VERIFIED , this . isEmailVerified ( ) ) ; 
if ( this . getNickname ( ) != null ) 
returnVal . put ( JSONMapping . NICKNAME , this . getNickname ( ) ) ; 
if ( this . getPicture ( ) != null ) 
returnVal . put ( JSONMapping . PICTURE , this . getPicture ( ) ) ; 
if ( this . getGivenName ( ) != null ) 
returnVal . put ( JSONMapping . GIVEN_NAME , this . getGivenName ( ) ) ; 
if ( this . getFamilyName ( ) != null ) 
returnVal . put ( JSONMapping . FAMILY_NAME , this . getFamilyName ( ) ) ; 
if ( this . getLocale ( ) != null ) 
if ( this . getIdentities ( ) != null && ! this . getIdentities ( ) . isEmpty ( ) ) 
JSONArray identitiesArr = new JSONArray ( ) ; 
for ( Identity toAdd : this . getIdentities ( ) ) 
identitiesArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . IDENTITIES , identitiesArr ) ; 
} public File convertDocumentToPDF ( File inputDocumentParam ) { 
if ( inputDocumentParam == null || 
! inputDocumentParam . exists ( ) ) 
throw new UtilException ( 
UtilException . ErrorCode . COMMAND ) ; 
if ( ! inputDocumentParam . isFile ( ) ) 
File parentFolder = inputDocumentParam . getParentFile ( ) ; 
String inputFilenameWithoutExt = inputDocumentParam . getName ( ) ; 
int indexOfDot = - 1 ; 
if ( ( indexOfDot = inputFilenameWithoutExt . indexOf ( '.' ) ) > - 1 ) 
inputFilenameWithoutExt = inputFilenameWithoutExt . substring ( 0 , indexOfDot ) ; 
File generatedPdfFileOut = new File ( parentFolder . getAbsolutePath ( ) . concat ( 
File . separator ) . concat ( inputFilenameWithoutExt ) . concat ( ".pdf" ) ) ; 
String completeOutputPath = generatedPdfFileOut . getAbsolutePath ( ) ; 
CommandUtil . CommandResult commandResult = 
this . commandUtil . executeCommand ( 
CommandUtil . FLUID_CLI , 
COMMAND_CONVERT_DOC_TO_PDF , 
"-i" , 
inputDocumentParam . getAbsolutePath ( ) , 
"-o" , 
completeOutputPath ) ; 
if ( commandResult . getExitCode ( ) != 0 ) 
inputDocumentParam . getName ( ) + 
File returnVal = new File ( completeOutputPath ) ; 
if ( ! returnVal . exists ( ) ) 
completeOutputPath + "'." , 
UtilException . ErrorCode . GENERAL ) ; 
eParam , UtilException . ErrorCode . GENERAL ) ; 
if ( DISABLE_WS ) { 
this . mode = Mode . RESTfulActive ; 
if ( this . getAncestorClient == null && 
Mode . RESTfulActive != this . mode ) { 
this . getAncestorClient = new SQLUtilWebSocketGetAncestorClient ( 
this . baseURL , 
this . loggedInUser . getServiceTicketAsHexUpper ( ) , 
this . timeoutMillis , 
COMPRESS_RSP , 
COMPRESS_RSP_CHARSET ) ; 
this . mode = Mode . WebSocketActive ; 
} catch ( FluidClientException clientExcept ) { 
if ( clientExcept . getErrorCode ( ) != 
FluidClientException . ErrorCode . WEB_SOCKET_DEPLOY_ERROR ) { 
throw clientExcept ; 
Form formToUse = ( formToGetAncestorForParam == null ) ? null : 
new Form ( formToGetAncestorForParam . getId ( ) ) ; 
return ( this . getAncestorClient == null ) ? 
this . sqlUtilClient . getAncestor ( 
formToUse , 
includeTableFieldsParam ) : 
this . getAncestorClient . getAncestorSynchronized ( formToUse ) ; 
} public List < FormListing > getDescendants ( 
boolean includeTableFieldFormRecordInfoParam , 
boolean massFetchParam , 
Form ... formsToGetDescForParam ) 
if ( this . getDescendantsClient == null && Mode . RESTfulActive != this . mode ) { 
this . getDescendantsClient = new SQLUtilWebSocketGetDescendantsClient ( 
includeTableFieldFormRecordInfoParam , 
massFetchParam , 
if ( formsToGetDescForParam == null || formsToGetDescForParam . length < 1 ) { 
Form [ ] formsToFetchFor = 
new Form [ formsToGetDescForParam . length ] ; 
for ( int index = 0 ; index < formsToFetchFor . length ; index ++ ) { 
formsToFetchFor [ index ] = new Form ( formsToGetDescForParam [ index ] . getId ( ) ) ; 
if ( this . getDescendantsClient != null ) { 
return this . getDescendantsClient . getDescendantsSynchronized ( 
formsToFetchFor ) ; 
List < FormListing > returnVal = new ArrayList < > ( ) ; 
for ( Form formToFetchFor : formsToFetchFor ) { 
List < Form > listOfForms = 
this . sqlUtilClient . getDescendants ( 
formToFetchFor , 
FormListing toAdd = new FormListing ( ) ; 
toAdd . setListing ( listOfForms ) ; 
toAdd . setListingCount ( ( listOfForms == null ) ? 0 : listOfForms . size ( ) ) ; 
returnVal . add ( toAdd ) ; 
} public List < FormListing > getTableForms ( 
Form ... formsToGetTableFormsForParam 
if ( this . getTableFormsClient == null && 
this . getTableFormsClient = new SQLUtilWebSocketGetTableFormsClient ( 
if ( formsToGetTableFormsForParam == null || formsToGetTableFormsForParam . length < 1 ) { 
new Form [ formsToGetTableFormsForParam . length ] ; 
formsToFetchFor [ index ] = new Form ( formsToGetTableFormsForParam [ index ] . getId ( ) ) ; 
if ( this . getTableFormsClient != null ) { 
return this . getTableFormsClient . getTableFormsSynchronized ( formsToFetchFor ) ; 
this . sqlUtilClient . getTableForms ( 
includeFieldDataParam ) ; 
} public List < FormFieldListing > getFormFields ( 
Form ... formsToGetFieldsForParam 
if ( this . getFormFieldsClient == null && Mode . RESTfulActive != this . mode ) { 
this . getFormFieldsClient = new SQLUtilWebSocketGetFormFieldsClient ( 
if ( formsToGetFieldsForParam == null || 
formsToGetFieldsForParam . length < 1 ) { 
new Form [ formsToGetFieldsForParam . length ] ; 
formsToFetchFor [ index ] = new Form ( formsToGetFieldsForParam [ index ] . getId ( ) ) ; 
if ( this . getFormFieldsClient != null ) { 
return this . getFormFieldsClient . getFormFieldsSynchronized ( 
List < FormFieldListing > returnVal = new ArrayList < > ( ) ; 
List < Field > listOfFields = 
this . sqlUtilClient . getFormFields ( 
FormFieldListing toAdd = new FormFieldListing ( ) ; 
toAdd . setListing ( listOfFields ) ; 
toAdd . setListingCount ( ( listOfFields == null ) ? 0 : listOfFields . size ( ) ) ; 
} public void massPopulateFormFields ( 
Form ... formsToPopulateFormFieldsForParam 
if ( formsToPopulateFormFieldsForParam == null || 
formsToPopulateFormFieldsForParam . length < 1 ) { 
Form [ ] formsToFetchForLocalCacheArr = 
new Form [ formsToPopulateFormFieldsForParam . length ] ; 
for ( int index = 0 ; index < formsToFetchForLocalCacheArr . length ; index ++ ) { 
formsToFetchForLocalCacheArr [ index ] = new Form ( formsToPopulateFormFieldsForParam [ index ] . getId ( ) ) ; 
formsToFetchForLocalCacheArr [ index ] . setEcho ( UUID . randomUUID ( ) . toString ( ) ) ; 
List < FormFieldListing > listingReturnFieldValsPopulated = new ArrayList < > ( ) ; 
listingReturnFieldValsPopulated = 
this . getFormFieldsClient . getFormFieldsSynchronized ( formsToFetchForLocalCacheArr ) ; 
for ( Form formToFetchFor : formsToFetchForLocalCacheArr ) { 
toAdd . setEcho ( formToFetchFor . getEcho ( ) ) ; 
listingReturnFieldValsPopulated . add ( toAdd ) ; 
for ( Form formToSetFieldsOn : formsToPopulateFormFieldsForParam ) { 
formToSetFieldsOn . setFormFields ( 
this . getFieldValuesForFormFromCache ( 
formToSetFieldsOn . getId ( ) , 
listingReturnFieldValsPopulated , 
formsToFetchForLocalCacheArr ) ) ; 
} private List < Field > getFieldValuesForFormFromCache ( 
Long formIdParam , 
List < FormFieldListing > listingReturnFieldValsPopulatedParam , 
Form [ ] formsToFetchForLocalCacheArrParam ) { 
if ( formIdParam == null || formIdParam . longValue ( ) < 1 ) { 
if ( listingReturnFieldValsPopulatedParam == null || 
listingReturnFieldValsPopulatedParam . isEmpty ( ) ) { 
if ( formsToFetchForLocalCacheArrParam == null || 
formsToFetchForLocalCacheArrParam . length == 0 ) { 
for ( Form formIter : formsToFetchForLocalCacheArrParam ) { 
if ( formIdParam . equals ( formIter . getId ( ) ) ) { 
String echoToUse = formIter . getEcho ( ) ; 
for ( FormFieldListing fieldListing : listingReturnFieldValsPopulatedParam ) { 
if ( echoToUse . equals ( fieldListing . getEcho ( ) ) ) { 
return fieldListing . getListing ( ) ; 
} public void closeAndClean ( ) { 
if ( this . sqlUtilClient != null ) { 
this . sqlUtilClient . closeAndClean ( ) ; 
if ( this . getAncestorClient != null ) { 
this . getAncestorClient . closeAndClean ( ) ; 
this . getDescendantsClient . closeAndClean ( ) ; 
this . getTableFormsClient . closeAndClean ( ) ; 
this . getFormFieldsClient . closeAndClean ( ) ; 
if ( this . getColumnName ( ) != null ) 
returnVal . put ( JSONMapping . COLUMN_NAME , 
this . getColumnName ( ) ) ; 
if ( this . getColumnIndex ( ) != null ) 
returnVal . put ( JSONMapping . COLUMN_INDEX , 
this . getColumnIndex ( ) ) ; 
if ( this . getSqlType ( ) != null ) 
JSONMapping . SQL_TYPE , this . getSqlType ( ) ) ; 
if ( this . getSqlValue ( ) != null ) 
returnVal . put ( JSONMapping . SQL_VALUE , 
this . getSqlValue ( ) ) ; 
if ( this . getId ( ) != null ) 
returnVal . put ( JSONMapping . ID , this . getId ( ) ) ; 
if ( this . getServiceTicket ( ) != null ) 
returnVal . put ( JSONMapping . SERVICE_TICKET , this . getServiceTicket ( ) ) ; 
if ( this . getEcho ( ) != null ) 
returnVal . put ( JSONMapping . ECHO , this . getEcho ( ) ) ; 
private Date getLongAsDateFromJson ( Long longValueParam ) 
if ( longValueParam == null ) 
return new Date ( longValueParam ) ; 
public Date getDateFieldValueFromFieldWithName ( String fieldNameParam ) 
if ( ( fieldNameParam == null || fieldNameParam . trim ( ) . isEmpty ( ) ) || 
( this . jsonObject == null || this . jsonObject . isNull ( fieldNameParam ) ) ) 
Object objectAtIndex = this . jsonObject . get ( fieldNameParam ) ; 
if ( objectAtIndex instanceof Number ) 
return this . getLongAsDateFromJson ( ( ( Number ) objectAtIndex ) . longValue ( ) ) ; 
else if ( objectAtIndex instanceof String ) 
Date validDate = null ; 
for ( SimpleDateFormat format : SUPPORTED_FORMATS ) 
validDate = format . parse ( ( String ) objectAtIndex ) ; 
if ( validDate != null ) 
catch ( ParseException parseExcept ) 
validDate = null ; 
return validDate ; 
public Long getDateAsLongFromJson ( Date dateValueParam ) 
if ( dateValueParam == null ) 
return dateValueParam . getTime ( ) ; 
} public FlowStepRule createFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) 
if ( flowStepRuleParam != null && this . serviceTicket != null ) 
flowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; 
return new FlowStepRule ( this . putJson ( 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleEntryCreate ( ) ) ) ; 
} public FlowStepRule createFlowStepExitRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleExitCreate ( ) ) ) ; 
} public FlowStepRule createFlowStepViewRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleViewCreate ( ) ) ) ; 
} public FlowStepRule updateFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) 
return new FlowStepRule ( this . postJson ( 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateEntry ( ) ) ) ; 
} public FlowStepRule updateFlowStepExitRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateExit ( ) ) ) ; 
} public FlowStepRule updateFlowStepViewRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateView ( ) ) ) ; 
} public FlowStepRule compileFlowStepViewRule ( String viewRuleSyntaxParam ) 
FlowStepRule flowStepRule = new FlowStepRule ( ) ; 
flowStepRule . setRule ( viewRuleSyntaxParam ) ; 
flowStepRule . setServiceTicket ( this . serviceTicket ) ; 
flowStepRule , WS . Path . FlowStepRule . Version1 . compileViewSyntax ( ) ) ) ; 
} public FlowStepRuleListing getExitRulesByStep ( FlowStep flowStepParam ) 
if ( flowStepParam == null ) 
return new FlowStepRuleListing ( this . postJson ( 
flowStepParam , WS . Path . FlowStepRule . Version1 . getExitRulesByStep ( ) ) ) ; 
} public FlowItemExecuteResult compileFlowStepViewRuleAndExecute ( 
String viewRuleSyntaxParam , FluidItem fluidItemToExecuteOnParam ) 
FlowItemExecutePacket toPost = new FlowItemExecutePacket ( ) ; 
toPost . setServiceTicket ( this . serviceTicket ) ; 
toPost . setFlowStepRule ( flowStepRule ) ; 
toPost . setFluidItem ( fluidItemToExecuteOnParam ) ; 
return new FlowItemExecuteResult ( this . postJson ( 
toPost , WS . Path . FlowStepRule . Version1 . compileViewSyntaxAndExecute ( ) ) ) ; 
} public FlowStepRule compileFlowStepEntryRule ( String entryRuleSyntaxParam ) 
flowStepRule . setRule ( entryRuleSyntaxParam ) ; 
flowStepRule , WS . Path . FlowStepRule . Version1 . compileEntrySyntax ( ) ) ) ; 
} public FlowItemExecuteResult compileFlowStepEntryRuleAndExecute ( 
String entryRuleSyntaxParam , FluidItem fluidItemToExecuteOnParam ) 
toPost , WS . Path . FlowStepRule . Version1 . compileEntrySyntaxAndExecute ( ) ) ) ; 
} public FlowStepRule moveFlowStepEntryRuleUp ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryUp ( ) ) ) ; 
} public FlowStepRule moveFlowStepEntryRuleDown ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryDown ( ) ) ) ; 
} public FlowStepRule deleteFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteEntry ( ) ) ) ; 
} public FlowStep deleteFlowStepExitRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteExit ( ) ) ) ; 
} public FlowStep deleteFlowStepViewRule ( FlowStepRule flowStepRuleParam ) 
flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteView ( ) ) ) ; 
} public List < String > getNextValidSyntaxWordsEntryRule ( String inputRuleParam ) 
if ( inputRuleParam == null ) 
inputRuleParam = UtilGlobal . EMPTY ; 
flowStepRule . setRule ( inputRuleParam ) ; 
FlowStepRule returnedObj = new FlowStepRule ( this . postJson ( 
flowStepRule , WS . Path . FlowStepRule . Version1 . getNextValidEntrySyntax ( ) ) ) ; 
return returnedObj . getNextValidSyntaxWords ( ) ; 
} public AppRequestToken login ( 
String usernameParam , String passwordParam ) { 
return this . login ( usernameParam , passwordParam , TimeUnit . HOURS . toSeconds ( 9 ) ) ; 
String usernameParam , String passwordParam , Long sessionLifespanSecondsParam ) { 
if ( this . isEmpty ( usernameParam ) || this . isEmpty ( passwordParam ) ) { 
AuthRequest authRequest = new AuthRequest ( ) ; 
authRequest . setUsername ( usernameParam ) ; 
authRequest . setLifetime ( sessionLifespanSecondsParam ) ; 
AuthResponse authResponse ; 
authResponse = new AuthResponse ( 
this . postJson ( 
authRequest , 
WS . Path . User . Version1 . userInitSession ( ) ) ) ; 
catch ( JSONException jsonException ) { 
jsonException . getMessage ( ) , jsonException , FluidClientException . ErrorCode . JSON_PARSING ) ; 
AuthEncryptedData authEncData = 
this . initializeSession ( passwordParam , authResponse ) ; 
AppRequestToken appReqToken = this . issueAppRequestToken ( 
authResponse . getServiceTicketBase64 ( ) , 
usernameParam , authEncData ) ; 
appReqToken . setRoleString ( authEncData . getRoleListing ( ) ) ; 
appReqToken . setSalt ( authResponse . getSalt ( ) ) ; 
return appReqToken ; 
} private AuthEncryptedData initializeSession ( 
String passwordParam , 
AuthResponse authResponseParam ) { 
byte [ ] ivBytes = UtilGlobal . decodeBase64 ( 
authResponseParam . getIvBase64 ( ) ) ; 
byte [ ] seedBytes = UtilGlobal . decodeBase64 ( 
authResponseParam . getSeedBase64 ( ) ) ; 
byte [ ] encryptedData = UtilGlobal . decodeBase64 ( 
authResponseParam . getEncryptedDataBase64 ( ) ) ; 
byte [ ] hMacFromResponse = UtilGlobal . decodeBase64 ( 
authResponseParam . getEncryptedDataHmacBase64 ( ) ) ; 
byte [ ] localGeneratedHMac = AES256Local . generateLocalHMAC ( 
encryptedData , passwordParam , authResponseParam . getSalt ( ) , seedBytes ) ; 
if ( ! Arrays . equals ( hMacFromResponse , localGeneratedHMac ) ) { 
FluidClientException . ErrorCode . LOGIN_FAILURE ) ; 
byte [ ] decryptedEncryptedData = 
AES256Local . decryptInitPacket ( encryptedData , 
passwordParam , 
authResponseParam . getSalt ( ) , 
ivBytes , 
seedBytes ) ; 
JSONObject jsonObj = new JSONObject ( new String ( decryptedEncryptedData ) ) ; 
return new AuthEncryptedData ( jsonObj ) ; 
} private AppRequestToken issueAppRequestToken ( 
String serviceTicketBase64Param , 
String usernameParam , 
AuthEncryptedData authEncryptDataParam ) 
byte [ ] iv = AES256Local . generateRandom ( AES256Local . IV_SIZE_BYTES ) ; 
byte [ ] seed = AES256Local . generateRandom ( AES256Local . SEED_SIZE_BYTES ) ; 
byte [ ] sessionKey = UtilGlobal . decodeBase64 ( 
authEncryptDataParam . getSessionKeyBase64 ( ) ) ; 
byte [ ] dataToEncrypt = usernameParam . getBytes ( ) ; 
byte [ ] encryptedData = AES256Local . encrypt ( 
sessionKey , 
dataToEncrypt , 
iv ) ; 
byte [ ] encryptedDataHMac = 
AES256Local . generateLocalHMACForReqToken ( encryptedData , sessionKey , seed ) ; 
AppRequestToken requestToServer = new AppRequestToken ( ) ; 
requestToServer . setEncryptedDataBase64 ( UtilGlobal . encodeBase64 ( encryptedData ) ) ; 
requestToServer . setEncryptedDataHmacBase64 ( UtilGlobal . encodeBase64 ( encryptedDataHMac ) ) ; 
requestToServer . setIvBase64 ( UtilGlobal . encodeBase64 ( iv ) ) ; 
requestToServer . setSeedBase64 ( UtilGlobal . encodeBase64 ( seed ) ) ; 
requestToServer . setServiceTicket ( serviceTicketBase64Param ) ; 
return new AppRequestToken ( 
this . postJson ( requestToServer , WS . Path . User . Version1 . userIssueToken ( ) ) ) ; 
if ( this . getAssignmentRuleValue ( ) != null ) 
returnVal . put ( JSONMapping . ASSIGNMENT_RULE_VALUE , 
this . getAssignmentRuleValue ( ) ) ; 
if ( this . getStatementResultAsString ( ) != null ) 
returnVal . put ( JSONMapping . STATEMENT_RESULT_AS_STRING , 
this . getStatementResultAsString ( ) ) ; 
if ( this . getExecutePerFluidItemQuery ( ) != null ) 
returnVal . put ( JSONMapping . EXECUTE_PER_FLUID_ITEM_QUERY , 
this . getExecutePerFluidItemQuery ( ) ) ; 
if ( this . getFluidItemQuery ( ) != null ) 
returnVal . put ( JSONMapping . FLUID_ITEM_QUERY , 
this . getFluidItemQuery ( ) ) ; 
if ( this . getExecutionResult ( ) != null ) 
returnVal . put ( JSONMapping . EXECUTION_RESULT , 
this . getExecutionResult ( ) ) ; 
if ( this . getProgressToNextPhase ( ) != null ) 
returnVal . put ( JSONMapping . PROGRESS_TO_NEXT_PHASE , 
this . getProgressToNextPhase ( ) ) ; 
if ( this . getFluidItems ( ) != null && ! this . getFluidItems ( ) . isEmpty ( ) ) 
for ( FluidItem item : this . getFluidItems ( ) ) 
jsonArray . put ( item . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . FLUID_ITEMS , jsonArray ) ; 
if ( this . getExecuteUsers ( ) != null && ! this . getExecuteUsers ( ) . isEmpty ( ) ) 
for ( User item : this . getExecuteUsers ( ) ) 
returnVal . put ( JSONMapping . EXECUTE_USERS , jsonArray ) ; 
if ( this . getMailMessagesToSend ( ) != null && 
! this . getMailMessagesToSend ( ) . isEmpty ( ) ) 
for ( MailMessage item : this . getMailMessagesToSend ( ) ) 
returnVal . put ( JSONMapping . MAIL_MESSAGES_TO_SEND , jsonArray ) ; 
if ( this . getAvailableMultiChoices ( ) != null ) { 
List < String > availChoices = this . getAvailableMultiChoices ( ) ; 
returnVal . put ( JSONMapping . AVAILABLE_MULTI_CHOICES , 
new JSONArray ( availChoices . toArray ( ) ) ) ; 
returnVal . put ( JSONMapping . AVAILABLE_CHOICES , 
JSONMapping . AVAILABLE_CHOICES_COMBINED , 
this . combineStringArrayWith ( 
availChoices , 
UtilGlobal . PIPE ) ) ; 
if ( this . getSelectedMultiChoices ( ) != null ) { 
List < String > selectChoices = this . getSelectedMultiChoices ( ) ; 
returnVal . put ( JSONMapping . SELECTED_MULTI_CHOICES , 
new JSONArray ( selectChoices . toArray ( ) ) ) ; 
returnVal . put ( JSONMapping . SELECTED_CHOICES , 
JSONMapping . SELECTED_CHOICES_COMBINED , 
selectChoices , 
public String combineStringArrayWith ( 
List < String > listToCombineParam , 
String separatorCharsParam ) { 
String returnValue = UtilGlobal . EMPTY ; 
int lengthOfSepChars = ( separatorCharsParam == null ) ? 0 : 
separatorCharsParam . length ( ) ; 
if ( listToCombineParam != null && ! listToCombineParam . isEmpty ( ) ) { 
StringBuffer concatBuffer = new StringBuffer ( ) ; 
for ( String toAdd : listToCombineParam ) { 
concatBuffer . append ( toAdd ) ; 
concatBuffer . append ( separatorCharsParam ) ; 
String concatString = concatBuffer . toString ( ) ; 
returnValue = concatString . substring ( 0 , concatString . length ( ) - lengthOfSepChars ) ; 
} public UserQuery createUserQuery ( UserQuery userQueryParam ) 
if ( userQueryParam != null && this . serviceTicket != null ) 
userQueryParam . setServiceTicket ( this . serviceTicket ) ; 
return new UserQuery ( this . putJson ( 
userQueryParam , 
WS . Path . UserQuery . Version1 . userQueryCreate ( ) ) ) ; 
} public UserQuery updateUserQuery ( UserQuery userQueryParam ) { 
if ( userQueryParam != null && this . serviceTicket != null ) { 
return new UserQuery ( this . postJson ( 
WS . Path . UserQuery . Version1 . userQueryUpdate ( ) ) ) ; 
} public UserQuery deleteUserQuery ( 
UserQuery userQueryToDeleteParam 
if ( userQueryToDeleteParam != null && this . serviceTicket != null ) { 
userQueryToDeleteParam . setServiceTicket ( this . serviceTicket ) ; 
return new UserQuery ( this . postJson ( userQueryToDeleteParam , 
WS . Path . UserQuery . Version1 . userQueryDelete ( ) ) ) ; 
} public UserQuery getUserQueryById ( Long userQueryIdParam ) { 
UserQuery userQueryToGetInfoFor = new UserQuery ( ) ; 
userQueryToGetInfoFor . setId ( userQueryIdParam ) ; 
userQueryToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; 
userQueryToGetInfoFor , WS . Path . UserQuery . Version1 . getById ( ) ) ) ; 
} public UserQueryListing getAllUserQueries ( ) { 
return new UserQueryListing ( this . postJson ( 
userQueryToGetInfoFor , WS . Path . UserQuery . Version1 . getAllUserQueries ( ) ) ) ; 
} public FluidItemListing executeUserQuery ( 
UserQuery queryToExecuteParam , 
boolean populateAncestorIdParam , 
int queryLimitParam , 
int offsetParam 
return this . executeUserQuery ( 
queryToExecuteParam , 
populateAncestorIdParam , 
queryLimitParam , 
boolean forceUseDatabaseParam 
if ( this . serviceTicket != null && queryToExecuteParam != null ) { 
queryToExecuteParam . setServiceTicket ( this . serviceTicket ) ; 
queryToExecuteParam , WS . Path . UserQuery . Version1 . executeUserQuery ( 
forceUseDatabaseParam , 
offsetParam ) ) ) ; 
} public List < FormFieldMapping > getFormFieldMappingForForm ( 
Long electronicFormIdParam ) 
List < FormFieldMapping > returnVal = new ArrayList ( ) ; 
if ( electronicFormIdParam == null ) 
Long formDefinitionId = this . getFormDefinitionId ( electronicFormIdParam ) ; 
if ( this . localDefinitionToFieldsMapping . containsKey ( formDefinitionId ) ) 
return this . localDefinitionToFieldsMapping . get ( formDefinitionId ) ; 
ISyntax . ProcedureMapping . Field . GetFormFieldsForFormContainer ) ; 
returnVal . add ( this . mapFormFieldMapping ( resultSet ) ) ; 
this . localDefinitionToFieldsMapping . put ( formDefinitionId , returnVal ) ; 
} public List < FormFieldMapping > getFormFieldMappingForFormDefinition ( 
Long formDefinitionIdParam 
if ( formDefinitionIdParam == null || formDefinitionIdParam . longValue ( ) < 1 ) 
if ( this . localDefinitionToFieldsMapping . containsKey ( formDefinitionIdParam ) ) 
return this . localDefinitionToFieldsMapping . get ( formDefinitionIdParam ) ; 
ISyntax . ProcedureMapping . Field . GetFormFieldsForFormDefinition ) ; 
preparedStatement . setLong ( 1 , formDefinitionIdParam ) ; 
this . localDefinitionToFieldsMapping . put ( formDefinitionIdParam , returnVal ) ; 
catch ( SQLException sqlError ) { 
} public Long getFormDefinitionId ( Long electronicFormIdParam ) 
ResultSet resultSet ; 
ISyntax . ProcedureMapping . Field . GetFormDefinitionForFormContainer ) ; 
return resultSet . getLong ( 1 ) ; 
this . closeStatement ( preparedStatement ) ; 
boolean includeTableFieldFormRecordInfoParam 
List < Field > returnVal = new ArrayList ( ) ; 
List < FormFieldMapping > fieldMappings = 
this . getFormFieldMappingForForm ( electronicFormIdParam ) ; 
if ( fieldMappings == null || fieldMappings . isEmpty ( ) ) { 
for ( FormFieldMapping fieldMapping : fieldMappings ) { 
if ( ! includeTableFieldsParam && 
fieldMapping . dataType == UtilGlobal . FieldTypeId . _7_TABLE_FIELD ) { 
Field fieldToAdd = this . getFormFieldValueFor ( 
fieldMapping , 
electronicFormIdParam , 
if ( fieldToAdd == null ) { 
if ( includeTableFieldsParam && ( fieldToAdd . getFieldValue ( ) instanceof TableField ) ) { 
TableField tableField = ( TableField ) fieldToAdd . getFieldValue ( ) ; 
if ( tableField . getTableRecords ( ) != null && ! tableField . getTableRecords ( ) . isEmpty ( ) ) { 
for ( Form tableRecordForm : tableField . getTableRecords ( ) ) { 
tableRecordForm . setFormFields ( 
this . getFormFields ( 
tableRecordForm . getId ( ) , 
returnVal . add ( fieldToAdd ) ; 
} public Field getFormFieldValueFor ( 
FormFieldMapping formFieldMappingParam , 
Long formContainerIdParam , 
if ( formFieldMappingParam == null ) { 
if ( this . getCacheUtil ( ) != null ) { 
CacheUtil . CachedFieldValue cachedFieldValue = 
this . getCacheUtil ( ) . getCachedFieldValueFrom ( 
formFieldMappingParam . formDefinitionId , 
formContainerIdParam , 
formFieldMappingParam . formFieldId ) ; 
if ( cachedFieldValue != null ) 
Field field = cachedFieldValue . getCachedFieldValueAsField ( ) ; 
if ( field != null ) 
field . setFieldName ( formFieldMappingParam . name ) ; 
Field returnVal = null ; 
PreparedStatement preparedStatement = null , preparedStatementForTblInfo = null ; 
ResultSet resultSet = null , resultSetForTblInfo = null ; 
ISyntax syntax = SyntaxFactory . getInstance ( ) . getFieldValueSyntaxFor ( 
formFieldMappingParam ) ; 
if ( syntax != null ) { 
preparedStatement . setLong ( 1 , formFieldMappingParam . formDefinitionId ) ; 
preparedStatement . setLong ( 2 , formFieldMappingParam . formFieldId ) ; 
preparedStatement . setLong ( 3 , formContainerIdParam ) ; 
switch ( formFieldMappingParam . dataType . intValue ( ) ) { 
case UtilGlobal . FieldTypeId . _1_TEXT : 
returnVal = new Field ( 
formFieldMappingParam . name , 
resultSet . getString ( 1 ) , 
Field . Type . Text ) ; 
case UtilGlobal . FieldTypeId . _2_TRUE_FALSE : 
resultSet . getBoolean ( 1 ) , 
Field . Type . TrueFalse ) ; 
case UtilGlobal . FieldTypeId . _3_PARAGRAPH_TEXT : 
Field . Type . ParagraphText ) ; 
case UtilGlobal . FieldTypeId . _4_MULTI_CHOICE : 
List < String > selectedValues = new ArrayList ( ) ; 
while ( resultSet . next ( ) ) { 
selectedValues . add ( resultSet . getString ( 1 ) ) ; 
multiChoice . setSelectedMultiChoices ( selectedValues ) ; 
if ( ! selectedValues . isEmpty ( ) ) { 
multiChoice ) ; 
case UtilGlobal . FieldTypeId . _5_DATE_TIME : 
resultSet . getDate ( 1 ) , 
Field . Type . DateTime ) ; 
case UtilGlobal . FieldTypeId . _6_DECIMAL : 
resultSet . getDouble ( 1 ) , 
Field . Type . Decimal ) ; 
case UtilGlobal . FieldTypeId . _7_TABLE_FIELD : 
List < Long > formContainerIds = new ArrayList ( ) ; 
formContainerIds . add ( resultSet . getLong ( 1 ) ) ; 
if ( formContainerIds . isEmpty ( ) ) { 
TableField tableField = new TableField ( ) ; 
final List < Form > formRecords = new ArrayList ( ) ; 
formContainerIds . forEach ( formContId -> { 
formRecords . add ( new Form ( formContId ) ) ; 
if ( includeTableFieldFormRecordInfoParam ) { 
ISyntax syntaxForFormContInfo = SyntaxFactory . getInstance ( ) . getSyntaxFor ( 
ISyntax . ProcedureMapping . Form . GetFormContainerInfo ) ; 
preparedStatementForTblInfo = this . getConnection ( ) . prepareStatement ( 
syntaxForFormContInfo . getPreparedStatement ( ) ) ; 
for ( Form formRecordToSetInfoOn : formRecords ) { 
preparedStatementForTblInfo . setLong ( 
1 , formRecordToSetInfoOn . getId ( ) ) ; 
resultSetForTblInfo = preparedStatementForTblInfo . executeQuery ( ) ; 
if ( resultSetForTblInfo . next ( ) ) { 
Long formTypeId = resultSetForTblInfo . getLong ( 
SQLFormUtil . SQLColumnIndex . _02_FORM_TYPE ) ; 
formRecordToSetInfoOn . setFormTypeId ( formTypeId ) ; 
formRecordToSetInfoOn . setFormType ( 
this . sqlFormDefinitionUtil == null ? null : 
this . sqlFormDefinitionUtil . getFormDefinitionIdAndTitle ( ) . get ( formTypeId ) 
formRecordToSetInfoOn . setTitle ( resultSetForTblInfo . getString ( 
SQLFormUtil . SQLColumnIndex . _03_TITLE ) ) ; 
Date created = resultSetForTblInfo . getDate ( SQLFormUtil . SQLColumnIndex . _04_CREATED ) ; 
Date lastUpdated = resultSetForTblInfo . getDate ( SQLFormUtil . SQLColumnIndex . _05_LAST_UPDATED ) ; 
if ( created != null ) 
formRecordToSetInfoOn . setDateCreated ( new Date ( created . getTime ( ) ) ) ; 
if ( lastUpdated != null ) 
formRecordToSetInfoOn . setDateLastUpdated ( new Date ( lastUpdated . getTime ( ) ) ) ; 
tableField . setTableRecords ( formRecords ) ; 
tableField , 
Field . Type . Table ) ; 
case UtilGlobal . FieldTypeId . _9_LABEL : 
formFieldMappingParam . description , 
Field . Type . Label ) ; 
this . closeStatement ( preparedStatementForTblInfo ) ; 
} private FormFieldMapping mapFormFieldMapping ( ResultSet resultSetParam ) 
throws SQLException { 
return new FormFieldMapping ( 
resultSetParam . getLong ( 1 ) , 
resultSetParam . getLong ( 2 ) , 
resultSetParam . getLong ( 3 ) , 
resultSetParam . getString ( 4 ) , 
resultSetParam . getString ( 5 ) , 
resultSetParam . getString ( 6 ) ) ; 
} public Role createRole ( Role roleParam ) 
if ( roleParam != null && this . serviceTicket != null ) 
return new Role ( this . putJson ( 
roleParam , WS . Path . Role . Version1 . roleCreate ( ) ) ) ; 
} public Role updateRole ( Role roleParam ) 
return new Role ( this . postJson ( 
roleParam , WS . Path . Role . Version1 . roleUpdate ( ) ) ) ; 
} public Role deleteRole ( 
Role roleToDeleteParam ) 
if ( roleToDeleteParam != null && this . serviceTicket != null ) 
roleToDeleteParam . setServiceTicket ( this . serviceTicket ) ; 
return new Role ( this . postJson ( roleToDeleteParam , 
WS . Path . Role . Version1 . roleDelete ( ) ) ) ; 
} public Role getRoleById ( Long roleIdParam ) 
Role roleToGetInfoFor = new Role ( ) ; 
roleToGetInfoFor . setId ( roleIdParam ) ; 
roleToGetInfoFor . setServiceTicket ( this . serviceTicket ) ; 
roleToGetInfoFor , WS . Path . Role . Version1 . getById ( ) ) ) ; 
} public RoleListing getAllRoles ( ) 
RoleListing roleToGetInfoFor = new RoleListing ( ) ; 
return new RoleListing ( this . postJson ( 
roleToGetInfoFor , WS . Path . Role . Version1 . getAllRoles ( ) ) ) ; 
if ( this . getAttachmentPath ( ) != null ) 
returnVal . put ( JSONMapping . ATTACHMENT_PATH , 
this . getAttachmentPath ( ) ) ; 
if ( this . getAttachmentDataBase64 ( ) != null ) 
} public CommandResult executeCommand ( String ... commandParams ) throws IOException { 
if ( commandParams == null || commandParams . length == 0 ) { 
List < String > returnedLines = new ArrayList ( ) ; 
Charset charset = Charset . forName ( ENCODING_UTF_8 ) ; 
Process process = null ; 
if ( commandParams . length == 1 ) { 
process = Runtime . getRuntime ( ) . exec ( commandParams [ 0 ] ) ; 
process = Runtime . getRuntime ( ) . exec ( commandParams ) ; 
BufferedReader reader = new BufferedReader ( 
new InputStreamReader ( 
process . getInputStream ( ) , charset ) ) ; 
String readLine = null ; 
while ( ( readLine = reader . readLine ( ) ) != null ) { 
returnedLines . add ( readLine ) ; 
BufferedReader errorReader = new BufferedReader ( 
new InputStreamReader ( process . getErrorStream ( ) , charset ) ) ; 
while ( ( readLine = errorReader . readLine ( ) ) != null ) { 
int exitValue = - 1000 ; 
exitValue = process . waitFor ( ) ; 
String commandString = ( commandParams == null || commandParams . length == 0 ) ? 
"<unknown>" : commandParams [ 0 ] ; 
String [ ] rtnArr = { } ; 
return new CommandResult ( exitValue , returnedLines . toArray ( rtnArr ) ) ; 
} catch ( IOException ioExeption ) { 
} public CommandResult executeCommand ( String objectCommandParam ) throws Exception { 
if ( objectCommandParam == null ) { 
return new CommandResult ( 333 , new String [ ] { 
return this . executeCommand ( new String [ ] { objectCommandParam } ) ; 
if ( this . getAccessToken ( ) != null ) 
returnVal . put ( JSONMapping . ACCESS_TOKEN , this . getAccessToken ( ) ) ; 
if ( this . getIdToken ( ) != null ) 
returnVal . put ( JSONMapping . ID_TOKEN , this . getIdToken ( ) ) ; 
if ( this . getTokenType ( ) != null ) 
returnVal . put ( JSONMapping . TOKEN_TYPE , this . getTokenType ( ) ) ; 
if ( this . getDate ( ) != null ) { 
returnVal . put ( JSONMapping . DATE , 
this . getDateAsLongFromJson ( this . getDate ( ) ) ) ; 
if ( this . getDateAndFieldName ( ) != null ) { 
returnVal . put ( JSONMapping . DATE_AND_FIELD_NAME , 
this . getDateAndFieldName ( ) ) ; 
if ( this . getFormContainerFieldValuesJSON ( ) != null ) { 
returnVal . put ( JSONMapping . FORM_CONTAINER_FIELD_VALUES_JSON , 
this . getFormContainerFieldValuesJSON ( ) ) ; 
if ( this . getLogEntryType ( ) != null ) { 
returnVal . put ( JSONMapping . LOG_ENTRY_TYPE , 
this . getLogEntryType ( ) ) ; 
if ( this . getDescription ( ) != null ) { 
returnVal . put ( JSONMapping . DESCRIPTION , 
this . getDescription ( ) ) ; 
if ( this . getHistoricEntryType ( ) != null ) { 
returnVal . put ( JSONMapping . HISTORIC_ENTRY_TYPE , 
this . getHistoricEntryType ( ) ) ; 
if ( this . getUser ( ) != null ) { 
returnVal . put ( JSONMapping . USER , 
this . getUser ( ) . toJsonObject ( ) ) ; 
if ( this . getField ( ) != null ) { 
returnVal . put ( JSONMapping . FIELD , 
this . getField ( ) . toJsonObject ( ) ) ; 
if ( this . getIsFieldDifferentFromPrevious ( ) != null ) { 
returnVal . put ( JSONMapping . IS_FIELD_DIFFERENT_FROM_PREVIOUS , 
this . getIsFieldDifferentFromPrevious ( ) ) ; 
if ( this . getIsFieldTypeSignature ( ) != null ) { 
returnVal . put ( JSONMapping . IS_FIELD_TYPE_SIGNATURE , 
this . getIsFieldTypeSignature ( ) ) ; 
if ( this . getIsEscapeText ( ) != null ) { 
JSONMapping . IS_ESCAPE_TEXT , 
this . getIsEscapeText ( ) ) ; 
if ( this . isAttachmentsView ( ) != null ) 
returnVal . put ( JSONMapping . ATTACHMENTS_VIEW , 
this . isAttachmentsView ( ) . booleanValue ( ) ) ; 
if ( this . isAttachmentsCreateUpdate ( ) != null ) 
returnVal . put ( JSONMapping . ATTACHMENTS_CREATE_UPDATE , 
this . isAttachmentsCreateUpdate ( ) . booleanValue ( ) ) ; 
public Object getFieldValueForField ( String fieldNameParam ) { 
Field fieldWithName = this . getField ( fieldNameParam ) ; 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValue ( ) ; 
public String getFieldValueAsString ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsString ( ) ; 
public TableField getFieldValueAsTableField ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsTableField ( ) ; 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsMultiChoice ( ) ; 
public Date getFieldValueAsDate ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsDate ( ) ; 
public Boolean getFieldValueAsBoolean ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsBoolean ( ) ; 
public Double getFieldValueAsDouble ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsDouble ( ) ; 
public Integer getFieldValueAsInt ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsInteger ( ) ; 
public Long getFieldValueAsLong ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsLong ( ) ; 
public Number getFieldValueAsNumber ( String fieldNameParam ) { 
return ( fieldWithName == null ) ? null : fieldWithName . getFieldValueAsNumber ( ) ; 
public void setFieldValue ( String fieldNameParam , Object fieldValueParam ) { 
if ( fieldNameParam == null || fieldNameParam . trim ( ) . length ( ) == 0 ) 
if ( this . getFormFields ( ) == null || this . getFormFields ( ) . isEmpty ( ) ) 
this . setFormFields ( new ArrayList ( ) ) ; 
String fieldNameParamLower = fieldNameParam . toLowerCase ( ) ; 
for ( Iterator < Field > fieldIter = this . getFormFields ( ) . iterator ( ) ; 
fieldIter . hasNext ( ) ; ) { 
Field field = fieldIter . next ( ) ; 
if ( field . getFieldName ( ) == null || field . getFieldName ( ) . trim ( ) . length ( ) == 0 ) 
String fieldNameLower = field . getFieldName ( ) . toLowerCase ( ) ; 
if ( fieldNameParamLower . equals ( fieldNameLower ) ) 
field . setFieldValue ( fieldValueParam ) ; 
this . getFormFields ( ) . add ( new Field ( fieldNameParam , fieldValueParam ) ) ; 
public void setFieldValue ( String fieldNameParam , Object fieldValueParam , Field . Type typeParam ) { 
if ( fieldNameParam == null ) { 
if ( this . getFormFields ( ) == null || this . getFormFields ( ) . isEmpty ( ) ) { 
String paramLower = fieldNameParam . toLowerCase ( ) . trim ( ) ; 
boolean valueFound = false ; 
int fieldIndex = 0 ; 
fieldIter . hasNext ( ) ; fieldIndex ++ ) { 
String toCheckNameLower = field . getFieldName ( ) ; 
if ( toCheckNameLower == null || toCheckNameLower . trim ( ) . isEmpty ( ) ) { 
toCheckNameLower = toCheckNameLower . trim ( ) . toLowerCase ( ) ; 
if ( paramLower . equals ( toCheckNameLower ) ) { 
valueFound = true ; 
this . getFormFields ( ) . get ( fieldIndex ) . setFieldValue ( fieldValueParam ) ; 
this . getFormFields ( ) . get ( fieldIndex ) . setTypeAsEnum ( typeParam ) ; 
if ( ! valueFound ) { 
this . getFormFields ( ) . add ( new Field ( fieldNameParam , fieldValueParam , typeParam ) ) ; 
public boolean isFormType ( String formTypeParam ) { 
if ( ( formTypeParam == null || formTypeParam . trim ( ) . isEmpty ( ) ) || 
( this . getFormType ( ) == null || this . getFormType ( ) . trim ( ) . isEmpty ( ) ) ) { 
return formTypeParam . toLowerCase ( ) . equals ( getFormType ( ) . toLowerCase ( ) ) ; 
if ( this . getFormType ( ) != null ) { 
returnVal . put ( JSONMapping . FORM_TYPE , this . getFormType ( ) ) ; 
if ( this . getFormTypeId ( ) != null ) { 
returnVal . put ( JSONMapping . FORM_TYPE_ID , this . getFormTypeId ( ) ) ; 
if ( this . getTitle ( ) != null ) { 
returnVal . put ( JSONMapping . TITLE , this . getTitle ( ) ) ; 
if ( this . getFormDescription ( ) != null ) { 
returnVal . put ( JSONMapping . FORM_DESCRIPTION , this . getFormDescription ( ) ) ; 
if ( this . getAncestorLabel ( ) != null ) { 
returnVal . put ( JSONMapping . ANCESTOR_LABEL , 
this . getAncestorLabel ( ) ) ; 
if ( this . getDescendantsLabel ( ) != null ) { 
returnVal . put ( JSONMapping . DESCENDANTS_LABEL , 
this . getDescendantsLabel ( ) ) ; 
if ( this . getNumberInputs ( ) != null ) { 
returnVal . put ( JSONMapping . NUMBER_INPUTS , 
this . getNumberInputs ( ) ) ; 
if ( this . getCurrentUser ( ) != null ) { 
JSONMapping . CURRENT_USER , 
this . getCurrentUser ( ) . toJsonObject ( ) ) ; 
if ( this . getState ( ) != null ) { 
JSONMapping . STATE , 
this . getState ( ) ) ; 
if ( this . getFlowState ( ) != null ) { 
JSONMapping . FLOW_STATE , 
this . getFlowState ( ) ) ; 
if ( this . getFormFields ( ) != null && ! this . getFormFields ( ) . isEmpty ( ) ) { 
JSONArray formFieldsArr = new JSONArray ( ) ; 
for ( Field toAdd : this . getFormFields ( ) ) 
formFieldsArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . FORM_FIELDS , formFieldsArr ) ; 
if ( this . getAssociatedFlows ( ) != null && ! this . getAssociatedFlows ( ) . isEmpty ( ) ) { 
JSONArray assoJobsArr = new JSONArray ( ) ; 
for ( Flow toAdd : this . getAssociatedFlows ( ) ) 
assoJobsArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . ASSOCIATED_FLOWS , assoJobsArr ) ; 
Long ancestorIdLcl = this . getAncestorId ( ) ; 
if ( ancestorIdLcl != null ) { 
returnVal . put ( JSONMapping . ANCESTOR_ID , ancestorIdLcl ) ; 
if ( this . getTableFieldParentId ( ) != null ) { 
returnVal . put ( JSONMapping . TABLE_FIELD_PARENT_ID , 
this . getTableFieldParentId ( ) ) ; 
if ( this . getDescendantIds ( ) != null && ! this . getDescendantIds ( ) . isEmpty ( ) ) { 
for ( Long formId : this . getDescendantIds ( ) ) { 
array . put ( formId ) ; 
returnVal . put ( JSONMapping . DESCENDANT_IDS , array ) ; 
JSONObject idJsonObj = new JSONObject ( ) ; 
idJsonObj . put ( 
Field . JSONMapping . Elastic . MAPPING_ONLY_TYPE , 
Field . ElasticSearchType . LONG ) ; 
returnVal . put ( ABaseFluidJSONObject . JSONMapping . ID , idJsonObj ) ; 
JSONObject formTypeJsonObj = new JSONObject ( ) ; 
formTypeJsonObj . put ( 
Field . ElasticSearchType . KEYWORD ) ; 
returnVal . put ( JSONMapping . FORM_TYPE , formTypeJsonObj ) ; 
JSONObject formTypeIdJsonObj = new JSONObject ( ) ; 
formTypeIdJsonObj . put ( 
returnVal . put ( JSONMapping . FORM_TYPE_ID , formTypeIdJsonObj ) ; 
JSONObject titleJsonObj = new JSONObject ( ) ; 
titleJsonObj . put ( 
Field . ElasticSearchType . TEXT ) ; 
returnVal . put ( JSONMapping . TITLE , titleJsonObj ) ; 
JSONObject formDescJsonObj = new JSONObject ( ) ; 
formDescJsonObj . put ( 
returnVal . put ( JSONMapping . FORM_DESCRIPTION , formDescJsonObj ) ; 
JSONObject stateJsonObj = new JSONObject ( ) ; 
stateJsonObj . put ( 
returnVal . put ( JSONMapping . STATE , stateJsonObj ) ; 
JSONObject flowStateJsonObj = new JSONObject ( ) ; 
flowStateJsonObj . put ( 
returnVal . put ( JSONMapping . FLOW_STATE , flowStateJsonObj ) ; 
JSONObject currentUserJsonObj = new JSONObject ( ) ; 
currentUserJsonObj . put ( 
Field . ElasticSearchType . OBJECT ) ; 
JSONObject properties = new JSONObject ( ) ; 
JSONObject currentUserUserIdJsonObj = new JSONObject ( ) ; 
currentUserUserIdJsonObj . put ( 
properties . put ( User . JSONMapping . Elastic . USER_ID , currentUserUserIdJsonObj ) ; 
JSONObject currentUserUsernameJsonObj = new JSONObject ( ) ; 
currentUserUsernameJsonObj . put ( 
properties . put ( User . JSONMapping . USERNAME , currentUserUsernameJsonObj ) ; 
ABaseFluidJSONObject . JSONMapping . Elastic . PROPERTIES , 
properties ) ; 
returnVal . put ( JSONMapping . CURRENT_USER , currentUserJsonObj ) ; 
JSONObject dateCreatedJsonObj = new JSONObject ( ) ; 
dateCreatedJsonObj . put ( 
Field . ElasticSearchType . DATE ) ; 
returnVal . put ( JSONMapping . DATE_CREATED , dateCreatedJsonObj ) ; 
JSONObject dateLastUpdatedJsonObj = new JSONObject ( ) ; 
dateLastUpdatedJsonObj . put ( 
returnVal . put ( JSONMapping . DATE_LAST_UPDATED , dateLastUpdatedJsonObj ) ; 
if ( this . getFormFields ( ) != null && 
! this . getFormFields ( ) . isEmpty ( ) ) 
JSONObject convertedField = toAdd . toJsonMappingForElasticSearch ( ) ; 
if ( convertedField == null ) 
String fieldNameAsCamel = toAdd . getFieldNameAsUpperCamel ( ) ; 
returnVal . put ( fieldNameAsCamel , convertedField ) ; 
JSONObject ancestorJsonObj = new JSONObject ( ) ; 
ancestorJsonObj . put ( 
returnVal . put ( JSONMapping . ANCESTOR_ID , ancestorJsonObj ) ; 
JSONObject tblFieldParentIdJsonObj = new JSONObject ( ) ; 
tblFieldParentIdJsonObj . put ( 
returnVal . put ( JSONMapping . TABLE_FIELD_PARENT_ID , tblFieldParentIdJsonObj ) ; 
if ( this . getFormType ( ) != null ) 
if ( this . getFormTypeId ( ) != null ) 
if ( this . getTitle ( ) != null ) 
if ( this . getFormDescription ( ) != null ) 
if ( this . getState ( ) != null ) 
returnVal . put ( JSONMapping . STATE , this . getState ( ) ) ; 
returnVal . put ( JSONMapping . FLOW_STATE , this . getFlowState ( ) ) ; 
if ( this . getCurrentUser ( ) == null ) { 
User . JSONMapping . Elastic . USER_ID , JSONObject . NULL ) ; 
currentUserJsonObj . put ( User . JSONMapping . USERNAME , JSONObject . NULL ) ; 
if ( this . getCurrentUser ( ) . getId ( ) == null || 
this . getCurrentUser ( ) . getId ( ) . longValue ( ) < 1 ) 
User . JSONMapping . Elastic . USER_ID , 
this . getCurrentUser ( ) . getId ( ) ) ; 
if ( this . getCurrentUser ( ) . getUsername ( ) == null || 
this . getCurrentUser ( ) . getUsername ( ) . trim ( ) . isEmpty ( ) ) 
currentUserJsonObj . put ( User . JSONMapping . USERNAME , 
this . getCurrentUser ( ) . getUsername ( ) ) ; 
if ( this . getFormFields ( ) != null && ! this . getFormFields ( ) . isEmpty ( ) ) 
JSONObject convertedFieldObj = toAdd . toJsonForElasticSearch ( ) ; 
if ( convertedFieldObj == null ) 
Iterator < String > iterKeys = convertedFieldObj . keys ( ) ; 
while ( iterKeys . hasNext ( ) ) 
String key = iterKeys . next ( ) ; 
returnVal . put ( key , convertedFieldObj . get ( key ) ) ; 
if ( ancestorIdLcl != null ) 
if ( this . getTableFieldParentId ( ) != null ) 
if ( this . getDescendantIds ( ) != null && ! this . getDescendantIds ( ) . isEmpty ( ) ) 
for ( Long formId : this . getDescendantIds ( ) ) 
FlatFormJSONMapping . FORM_ID , 
FlatFormJSONMapping . FORM_TITLE , 
this . getTitle ( ) == null ? 
JSONObject . NULL : this . getTitle ( ) ) ; 
FlatFormJSONMapping . FORM_TYPE , 
this . getFormType ( ) == null ? 
JSONObject . NULL : this . getFormType ( ) ) ; 
FlatFormJSONMapping . FORM_STATE , 
this . getState ( ) == null ? 
JSONObject . NULL : this . getState ( ) ) ; 
FlatFormJSONMapping . FORM_FLOW_STATE , 
this . getFlowState ( ) == null ? 
JSONObject . NULL : this . getFlowState ( ) ) ; 
FlatFormJSONMapping . FORM_DATE_CREATED , 
( this . getDateCreated ( ) == null ) ? 
JSONObject . NULL : this . getDateCreated ( ) . getTime ( ) ) ; 
FlatFormJSONMapping . FORM_DATE_LAST_UPDATED , 
( this . getDateLastUpdated ( ) == null ) ? 
JSONObject . NULL : this . getDateLastUpdated ( ) . getTime ( ) ) ; 
this . getFormFields ( ) . forEach ( 
( formFieldItem ) -> 
utilGlobal . setFlatFieldOnJSONObj ( 
FlatFormJSONMapping . FORM_FIELD_PREFIX , 
FlatFormJSONMapping . FORM_FIELD_ID_PREFIX , 
formFieldItem , 
returnVal 
if ( this . getMailTemplate ( ) != null ) 
returnVal . put ( JSONMapping . MAIL_TEMPLATE , this . getMailTemplate ( ) ) ; 
if ( this . getMailSMTPServer ( ) != null ) 
returnVal . put ( JSONMapping . MAIL_SMTP_SERVER , this . getMailSMTPServer ( ) ) ; 
if ( this . getRecipients ( ) != null && this . getRecipients ( ) . length > 0 ) 
for ( String item : this . getRecipients ( ) ) 
jsonArray . put ( item ) ; 
returnVal . put ( JSONMapping . RECIPIENTS , jsonArray ) ; 
if ( this . getAttachments ( ) != null && ! this . getAttachments ( ) . isEmpty ( ) ) 
for ( MailMessageAttachment item : this . getAttachments ( ) ) 
if ( this . getNameValues ( ) != null && 
! this . getNameValues ( ) . isEmpty ( ) ) 
for ( MailMessageNameValue item : this . getNameValues ( ) ) 
returnVal . put ( JSONMapping . NAME_VALUES , jsonArray ) ; 
returnVal . put ( JSONMapping . CLIENT , this . getPrincipalClient ( ) ) ; 
returnVal . put ( JSONMapping . SESSION_KEY , this . getSessionKeyBase64 ( ) ) ; 
returnVal . put ( JSONMapping . TICKET_EXPIRES , this . getTicketExpires ( ) ) ; 
returnVal . put ( JSONMapping . AUTHORISED_USERNAME , this . getAuthorisedUsername ( ) ) ; 
} public FluidItem sendToFlowSynchronized ( 
Form formToSendToFlowParam , 
String destinationFlowParam ) { 
if ( formToSendToFlowParam == null ) 
if ( destinationFlowParam == null || 
destinationFlowParam . trim ( ) . isEmpty ( ) ) 
FluidItem itemToSend = new FluidItem ( ) ; 
itemToSend . setFlow ( destinationFlowParam ) ; 
itemToSend . setForm ( formToSendToFlowParam ) ; 
itemToSend . setEcho ( UUID . randomUUID ( ) . toString ( ) ) ; 
this . sendMessage ( itemToSend , uniqueReqId ) ; 
List < FluidItem > returnValue = this . getHandler ( uniqueReqId ) . getCF ( ) . get ( 
if ( returnValue == null || returnValue . isEmpty ( ) ) 
return returnValue . get ( 0 ) ; 
catch ( InterruptedException exceptParam ) { 
catch ( ExecutionException executeProblem ) { 
if ( cause instanceof FluidClientException ) 
catch ( TimeoutException eParam ) { 
+ this . getHandler ( uniqueReqId ) . getReturnValue ( ) . size ( ) 
, FluidClientException . ErrorCode . IO_ERROR ) ; 
} public String getServiceTicketAsHexUpper ( ) { 
String serviceTicket = this . getServiceTicket ( ) ; 
if ( serviceTicket == null ) 
if ( serviceTicket . isEmpty ( ) ) 
return serviceTicket ; 
byte [ ] base64Bytes = Base64 . getDecoder ( ) . decode ( serviceTicket ) ; 
return this . bytesToHex ( base64Bytes ) ; 
} private String bytesToHex ( byte [ ] bytesToConvert ) { 
if ( bytesToConvert == null ) 
if ( bytesToConvert . length == 0 ) 
char [ ] hexChars = new char [ bytesToConvert . length * 2 ] ; 
for ( int index = 0 ; index < bytesToConvert . length ; index ++ ) { 
int andWith127 = ( bytesToConvert [ index ] & 0xFF ) ; 
hexChars [ index * 2 ] = HEX_ARRAY [ andWith127 > > > 4 ] ; 
hexChars [ index * 2 + 1 ] = HEX_ARRAY [ andWith127 & 0x0F ] ; 
return new String ( hexChars ) ; 
if ( this . getUserQuery ( ) != null ) 
returnVal . put ( JSONMapping . USER_QUERY , 
this . getUserQuery ( ) . toJsonObject ( ) ) ; 
} public Field createFieldTextMasked ( 
Field formFieldParam , String maskValueParam ) 
if ( formFieldParam != null && this . serviceTicket != null ) 
formFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( maskValueParam == null || maskValueParam . trim ( ) . isEmpty ( ) ) 
maskValueParam = "" ; 
if ( formFieldParam != null ) 
formFieldParam . setTypeAsEnum ( Field . Type . Text ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . Text . MASKED . concat ( maskValueParam ) ) ; 
return new Field ( this . putJson ( 
formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; 
} public Field createFieldTextBarcode ( 
Field formFieldParam , String barcodeTypeParam ) 
if ( barcodeTypeParam == null || barcodeTypeParam . trim ( ) . isEmpty ( ) ) 
formFieldParam . setTypeMetaData ( FieldMetaData . Text . BARCODE . concat ( barcodeTypeParam ) ) ; 
} public Field createFieldMultiChoicePlain ( 
Field formFieldParam , List < String > multiChoiceValuesParam ) 
if ( multiChoiceValuesParam == null ) 
multiChoiceValuesParam = new ArrayList ( ) ; 
formFieldParam . setTypeAsEnum ( Field . Type . MultipleChoice ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . MultiChoice . PLAIN ) ; 
formFieldParam . setFieldValue ( new MultiChoice ( multiChoiceValuesParam ) ) ; 
} public Field createFieldDecimalSpinner ( 
Field formFieldParam , 
String prefixParam ) 
formFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; 
formFieldParam . setTypeMetaData ( 
this . getMetaDataForDecimalAs ( 
FieldMetaData . Decimal . SPINNER , 
minParam , maxParam , stepFactorParam , prefixParam ) ) ; 
} public Field createFieldDecimalSlider ( 
double stepFactorParam ) 
FieldMetaData . Decimal . SLIDER , 
minParam , maxParam , stepFactorParam , 
null ) ) ; 
} public Field createFieldTable ( 
Form formDefinitionParam , 
boolean sumDecimalsParam ) 
formFieldParam . setTypeAsEnum ( Field . Type . Table ) ; 
this . getMetaDataForTableField ( 
formDefinitionParam , sumDecimalsParam ) ) ; 
} public Field updateFieldTextMasked ( Field formFieldParam , String maskValueParam ) 
return new Field ( this . postJson ( 
formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; 
} public Field updateFieldTextBarcode ( Field formFieldParam , String barcodeTypeParam ) 
} public Field updateFieldParagraphTextPlain ( Field formFieldParam ) 
formFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . PLAIN ) ; 
} public Field updateFieldMultiChoicePlain ( 
List < String > multiChoiceValuesParam ) { 
if ( formFieldParam != null && this . serviceTicket != null ) { 
if ( multiChoiceValuesParam == null || 
multiChoiceValuesParam . isEmpty ( ) ) { 
List < String > beforeAvail = null , beforeSelected = null ; 
if ( formFieldParam != null ) { 
if ( formFieldParam . getFieldValue ( ) instanceof MultiChoice ) { 
MultiChoice casted = ( MultiChoice ) formFieldParam . getFieldValue ( ) ; 
beforeAvail = casted . getAvailableMultiChoices ( ) ; 
beforeSelected = casted . getSelectedMultiChoices ( ) ; 
Field returnVal = new Field ( this . postJson ( 
formFieldParam . setFieldValue ( new MultiChoice ( beforeSelected , beforeAvail ) ) ; 
} public Field updateFieldDecimalSpinner ( 
} public Field updateFieldDecimalSlider ( 
minParam , maxParam , stepFactorParam , null ) ) ; 
} public Field updateFieldTable ( 
} public Field getFieldByName ( String fieldNameParam ) 
Field field = new Field ( ) ; 
field . setFieldName ( fieldNameParam ) ; 
field . setServiceTicket ( this . serviceTicket ) ; 
field , WS . Path . FormField . Version1 . getByName ( ) ) ) ; 
} public FormFieldListing getFieldsByFormNameAndLoggedInUser ( 
String formNameParam , 
boolean editOnlyFieldsParam ) 
form . setFormType ( formNameParam ) ; 
return new FormFieldListing ( this . postJson ( 
form , WS . Path . FormField . Version1 . getByFormDefinitionAndLoggedInUser ( 
editOnlyFieldsParam ) ) ) ; 
} public FormFieldListing getFieldsByFormTypeIdAndLoggedInUser ( 
Long formTypeIdParam , 
form . setFormTypeId ( formTypeIdParam ) ; 
} public Field deleteField ( Field fieldParam ) 
if ( fieldParam != null && this . serviceTicket != null ) 
fieldParam . setServiceTicket ( this . serviceTicket ) ; 
return new Field ( this . postJson ( fieldParam , WS . Path . FormField . Version1 . formFieldDelete ( ) ) ) ; 
} public Field forceDeleteField ( Field fieldParam ) 
fieldParam , WS . Path . FormField . Version1 . formFieldDelete ( true ) ) ) ; 
} private String getMetaDataForTableField ( 
StringBuilder returnBuffer = new StringBuilder ( ) ; 
Long definitionId = 
( formDefinitionParam == null ) ? - 1L : 
formDefinitionParam . getId ( ) ; 
returnBuffer . append ( definitionId ) ; 
returnBuffer . append ( FieldMetaData . TableField . UNDERSCORE ) ; 
returnBuffer . append ( FieldMetaData . TableField . SUM_DECIMALS ) ; 
returnBuffer . append ( sumDecimalsParam ) ; 
returnVal . put ( JSONMapping . ROLE_LISTING , this . getRoleListing ( ) ) ; 
} public Field createFieldTrueFalse ( Field formFieldParam ) 
formFieldParam . setTypeAsEnum ( Field . Type . TrueFalse ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . TrueFalse . TRUE_FALSE ) ; 
formFieldParam , WS . Path . UserField . Version1 . userFieldCreate ( ) ) ) ; 
} public Field createFieldDateTimeDateAndTime ( Field formFieldParam ) 
formFieldParam . setTypeAsEnum ( Field . Type . DateTime ) ; 
formFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE_AND_TIME ) ; 
} public Field createFieldDecimalPlain ( Field formFieldParam ) 
formFieldParam . setTypeMetaData ( FieldMetaData . Decimal . PLAIN ) ; 
} public Field updateFieldTrueFalse ( Field formFieldParam ) 
formFieldParam , WS . Path . UserField . Version1 . userFieldUpdate ( ) ) ) ; 
List < String > multiChoiceValuesParam ) 
} public Field updateFieldDateTimeDate ( Field formFieldParam ) 
formFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE ) ; 
} public Field updateFieldValue ( Field userFieldValueParam ) { 
if ( userFieldValueParam != null && this . serviceTicket != null ) { 
userFieldValueParam . setServiceTicket ( this . serviceTicket ) ; 
userFieldValueParam , 
WS . Path . UserField . Version1 . userFieldUpdateValue ( ) ) ) ; 
} public Field getFieldByName ( String fieldNameParam ) { 
field . setFieldValue ( new MultiChoice ( ) ) ; 
field , WS . Path . UserField . Version1 . getByName ( ) ) ) ; 
} public Field deleteField ( Field fieldParam ) { 
if ( fieldParam != null && this . serviceTicket != null ) { 
return new Field ( this . postJson ( fieldParam , WS . Path . UserField . Version1 . userFieldDelete ( ) ) ) ; 
fieldParam , WS . Path . UserField . Version1 . userFieldDelete ( true ) ) ) ; 
} public void mergeMappingForIndex ( 
String parentTypeParam , 
Form fluidFormMappingToUpdateParam 
if ( indexParam == null ) { 
if ( fluidFormMappingToUpdateParam == null ) { 
if ( fluidFormMappingToUpdateParam . getFormTypeId ( ) == null || 
fluidFormMappingToUpdateParam . getFormTypeId ( ) . longValue ( ) < 1 ) { 
String formTypeString = 
fluidFormMappingToUpdateParam . getFormTypeId ( ) . toString ( ) ; 
JSONObject newContentMappingBuilderFromParam = 
fluidFormMappingToUpdateParam . toJsonMappingForElasticSearch ( ) ; 
GetIndexResponse getExistingIndex = this . getOrCreateIndex ( indexParam ) ; 
JSONObject existingPropsToUpdate = null ; 
for ( ObjectCursor mappingKey : getExistingIndex . getMappings ( ) . keys ( ) ) { 
if ( ! mappingKey . value . toString ( ) . equals ( indexParam ) ) { 
Object obj = getExistingIndex . getMappings ( ) . get ( mappingKey . value . toString ( ) ) ; 
if ( obj instanceof ImmutableOpenMap ) { 
ImmutableOpenMap casted = ( ImmutableOpenMap ) obj ; 
if ( casted . containsKey ( formTypeString ) && 
casted . get ( formTypeString ) instanceof MappingMetaData ) { 
MappingMetaData mappingMetaData = ( MappingMetaData ) casted . get ( formTypeString ) ; 
existingPropsToUpdate = new JSONObject ( mappingMetaData . source ( ) . string ( ) ) ; 
eParam . getMessage ( ) , eParam ) ; 
if ( existingPropsToUpdate == null ) { 
existingPropsToUpdate = new JSONObject ( ) ; 
existingPropsToUpdate . put ( 
newContentMappingBuilderFromParam ) ; 
this . setAdditionalProps ( 
existingPropsToUpdate , parentTypeParam ) ; 
PutMappingRequestBuilder putMappingRequestBuilder = 
this . client . admin ( ) . indices ( ) . preparePutMapping ( indexParam ) ; 
putMappingRequestBuilder = putMappingRequestBuilder . setType ( formTypeString ) ; 
putMappingRequestBuilder = putMappingRequestBuilder . setSource ( 
existingPropsToUpdate . toString ( ) , XContentType . JSON ) ; 
PutMappingResponse putMappingResponse = putMappingRequestBuilder . get ( ) ; 
if ( ! putMappingResponse . isAcknowledged ( ) ) { 
JSONObject existingPropertiesUpdated = 
existingPropsToUpdate . getJSONObject ( formTypeString ) . getJSONObject ( 
ABaseFluidJSONObject . JSONMapping . Elastic . PROPERTIES ) ; 
for ( String existingKey : existingPropertiesUpdated . keySet ( ) ) { 
newContentMappingBuilderFromParam . put ( existingKey , 
existingPropertiesUpdated . get ( existingKey ) ) ; 
boolean noChanges = true ; 
for ( String possibleExistingKey : newContentMappingBuilderFromParam . keySet ( ) ) { 
if ( ! existingPropertiesUpdated . has ( possibleExistingKey ) ) { 
noChanges = false ; 
if ( noChanges ) { 
existingPropsToUpdate , 
parentTypeParam ) ; 
} private void setAdditionalProps ( 
JSONObject existingPropsToUpdateParam , 
String parentTypeParam 
if ( parentTypeParam == null || parentTypeParam . trim ( ) . length ( ) == 0 ) { 
JSONObject typeJson = new JSONObject ( ) ; 
typeJson . put ( Field . JSONMapping . FIELD_TYPE , parentTypeParam ) ; 
existingPropsToUpdateParam . put ( 
Form . JSONMapping . _PARENT , typeJson ) ; 
} public GetIndexResponse getOrCreateIndex ( String indexParam ) { 
if ( this . doesIndexExist ( indexParam ) ) { 
return this . client . admin ( ) . indices ( ) . prepareGetIndex ( ) . get ( ) ; 
CreateIndexRequestBuilder createIndexRequestBuilder = 
this . client . admin ( ) . indices ( ) . prepareCreate ( indexParam ) ; 
CreateIndexResponse mappingCreateResponse = 
createIndexRequestBuilder . execute ( ) . actionGet ( ) ; 
if ( ! mappingCreateResponse . isAcknowledged ( ) ) { 
if ( this . getViewName ( ) != null ) 
returnVal . put ( JSONMapping . VIEW_NAME , this . getViewName ( ) ) ; 
if ( this . getViewGroupName ( ) != null ) 
returnVal . put ( JSONMapping . VIEW_GROUP_NAME , this . getViewGroupName ( ) ) ; 
returnVal . put ( JSONMapping . VIEW_FLOW_NAME , this . getViewFlowName ( ) ) ; 
returnVal . put ( JSONMapping . VIEW_STEP_NAME , this . getViewStepName ( ) ) ; 
if ( this . getViewPriority ( ) != null ) 
returnVal . put ( JSONMapping . VIEW_PRIORITY , this . getViewPriority ( ) ) ; 
if ( this . getViewType ( ) != null ) 
returnVal . put ( JSONMapping . VIEW_TYPE , this . getViewType ( ) ) ; 
if ( this . getDatasourceName ( ) != null ) { 
returnVal . put ( JSONMapping . DATASOURCE_NAME , 
this . getDatasourceName ( ) ) ; 
if ( this . getQuery ( ) != null ) { 
returnVal . put ( JSONMapping . QUERY , this . getQuery ( ) ) ; 
if ( this . getStoredProcedure ( ) != null ) { 
JSONMapping . STORED_PROCEDURE , 
this . getStoredProcedure ( ) ) ; 
if ( this . getSqlInputs ( ) != null ) 
for ( SQLColumn toAdd : this . getSqlInputs ( ) ) 
returnVal . put ( JSONMapping . SQL_INPUTS , jsonArray ) ; 
public void addSqlInput ( SQLColumn sqlInputToAddParam ) { 
if ( this . sqlInputs == null ) { 
this . sqlInputs = new ArrayList < > ( ) ; 
if ( sqlInputToAddParam == null ) { 
this . sqlInputs . add ( sqlInputToAddParam ) ; 
} public Flow createFlow ( Flow flowParam ) 
if ( flowParam != null && this . serviceTicket != null ) 
return new Flow ( this . putJson ( 
flowParam , WS . Path . Flow . Version1 . flowCreate ( ) ) ) ; 
} public Flow updateFlow ( Flow flowParam ) 
return new Flow ( this . postJson ( 
flowParam , WS . Path . Flow . Version1 . flowUpdate ( ) ) ) ; 
} public Flow getFlowById ( Long flowIdParam ) 
Flow flow = new Flow ( flowIdParam ) ; 
flow . setServiceTicket ( this . serviceTicket ) ; 
flow , WS . Path . Flow . Version1 . getById ( ) ) ) ; 
} public Flow getFlowByName ( String flowNameParam ) 
Flow flow = new Flow ( ) ; 
flow . setName ( flowNameParam ) ; 
flow , WS . Path . Flow . Version1 . getByName ( ) ) ) ; 
} public Flow deleteFlow ( Flow flowParam ) 
return new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowDelete ( ) ) ) ; 
} public Flow forceDeleteFlow ( Flow flowParam ) 
return new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowDelete ( true ) ) ) ; 
} public Field updateFieldValue ( Field globalFieldValueParam ) 
if ( globalFieldValueParam != null && this . serviceTicket != null ) 
globalFieldValueParam . setServiceTicket ( this . serviceTicket ) ; 
globalFieldValueParam , 
Version1 . globalFieldUpdateValue ( ) ) ) ; 
} public Field getFieldValueByName ( String fieldNameParam ) 
return this . getFieldValueBy ( field ) ; 
} private Field getFieldValueBy ( Field fieldParam ) 
if ( fieldParam != null ) 
fieldParam . setFieldValue ( new MultiChoice ( ) ) ; 
fieldParam , Version1 . getValueBy ( ) ) ) ; 
} public List < Field > getAllGlobalFieldValues ( ) 
return new GlobalFieldListing ( this . postJson ( 
field , Version1 . getAllValues ( ) ) ) . getListing ( ) ; 
boolean includeTableFieldsParam ) 
StringBuffer ancestorQuery = new StringBuffer ( 
Form . JSONMapping . DESCENDANT_IDS ) ; 
ancestorQuery . append ( ":\"" ) ; 
ancestorQuery . append ( electronicFormIdParam ) ; 
ancestorQuery . append ( "\"" ) ; 
List < Form > ancestorForms = null ; 
ancestorForms = this . searchAndConvertHitsToFormWithAllFields ( 
QueryBuilders . queryStringQuery ( ancestorQuery . toString ( ) ) , 
Index . DOCUMENT , 
DEFAULT_OFFSET , 
ancestorForms = this . searchAndConvertHitsToFormWithNoFields ( 
if ( ancestorForms != null && ! ancestorForms . isEmpty ( ) ) 
returnVal = ancestorForms . get ( 0 ) ; 
if ( ! includeTableFieldsParam ) 
this . populateTableFields ( 
returnVal . getFormFields ( ) ) ; 
List < Long > electronicFormIds = new ArrayList ( ) ; 
electronicFormIds . add ( electronicFormIdParam ) ; 
return this . getFormDescendants ( 
electronicFormIds , 
} public List < Form > getFormDescendants ( 
boolean includeTableFieldFormRecordInfoParam ) 
if ( electronicFormIdsParam == null || 
electronicFormIdsParam . isEmpty ( ) ) 
StringBuffer descendantQuery = new StringBuffer ( Form . JSONMapping . ANCESTOR_ID ) ; 
descendantQuery . append ( ":(" ) ; 
for ( Long electronicFormId : electronicFormIdsParam ) 
descendantQuery . append ( "\"" ) ; 
descendantQuery . append ( electronicFormId ) ; 
String fullQueryToExec = descendantQuery . toString ( ) ; 
fullQueryToExec = fullQueryToExec . substring ( 
0 , fullQueryToExec . length ( ) - 1 ) ; 
fullQueryToExec = fullQueryToExec . concat ( ")" ) ; 
QueryBuilders . queryStringQuery ( fullQueryToExec ) , 
DEFAULT_OFFSET , MAX_NUMBER_OF_TABLE_RECORDS , 
for ( Form descendantForm : returnVal ) 
descendantForm . getFormFields ( ) ) ; 
boolean includeFieldDataParam ) 
StringBuffer primaryQuery = new StringBuffer ( 
ABaseFluidJSONObject . JSONMapping . ID ) ; 
primaryQuery . append ( ":\"" ) ; 
primaryQuery . append ( electronicFormIdParam ) ; 
primaryQuery . append ( "\"" ) ; 
List < Form > formsWithId = null ; 
formsWithId = this . searchAndConvertHitsToFormWithAllFields ( 
QueryBuilders . queryStringQuery ( primaryQuery . toString ( ) ) , 
formsWithId = this . searchAndConvertHitsToFormWithNoFields ( 
if ( formsWithId != null && ! formsWithId . isEmpty ( ) ) 
returnVal = formsWithId . get ( 0 ) ; 
if ( returnVal == null ) { 
return this . populateTableFields ( 
} public Map < Long , String > getFormDefinitionIdAndTitle ( ) 
if ( ! LOCAL_MAPPING . isEmpty ( ) ) 
Map < Long , String > returnVal = new HashMap < > ( LOCAL_MAPPING ) ; 
if ( System . currentTimeMillis ( ) > timeToUpdateAgain ) { 
synchronized ( LOCAL_MAPPING ) 
LOCAL_MAPPING . clear ( ) ; 
return new HashMap < > ( LOCAL_MAPPING ) ; 
ISyntax . ProcedureMapping . FormDefinition . GetFormDefinitions ) ; 
Long id = resultSet . getLong ( 1 ) ; 
String title = resultSet . getString ( 2 ) ; 
LOCAL_MAPPING . put ( id , title ) ; 
timeToUpdateAgain = 
( System . currentTimeMillis ( ) + 
TimeUnit . MINUTES . toMillis ( 10 ) ) ; 
if ( this . getServiceTicketBase64 ( ) != null ) { 
returnVal . put ( JSONMapping . SERVICE_TICKET_BASE_64 , this . getServiceTicketBase64 ( ) ) ; 
if ( this . getDataBase64 ( ) != null ) 
returnVal . put ( JSONMapping . DATA_BASE_64 , 
this . getDataBase64 ( ) ) ; 
if ( this . getSumDecimals ( ) != null ) 
returnVal . put ( JSONMapping . SUM_DECIMALS , this . getSumDecimals ( ) ) ; 
if ( this . getTableRecords ( ) != null && ! this . getTableRecords ( ) . isEmpty ( ) ) 
JSONArray assoFormsArr = new JSONArray ( ) ; 
for ( Form toAdd : this . getTableRecords ( ) ) 
assoFormsArr . put ( toAdd . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . TABLE_RECORDS , assoFormsArr ) ; 
int listingCountFromListing = 0 ; 
if ( this . getListing ( ) != null && ! this . getListing ( ) . isEmpty ( ) ) 
listingCountFromListing = this . getListing ( ) . size ( ) ; 
for ( T toAdd : this . getListing ( ) ) 
returnVal . put ( JSONMapping . LISTING , jsonArray ) ; 
if ( this . getListingCount ( ) == null ) 
returnVal . put ( JSONMapping . LISTING_COUNT , new Integer ( listingCountFromListing ) ) ; 
returnVal . put ( JSONMapping . LISTING_COUNT , this . getListingCount ( ) ) ; 
if ( this . getListingIndex ( ) != null ) 
returnVal . put ( JSONMapping . LISTING_INDEX , this . getListingIndex ( ) ) ; 
returnVal . put ( JSONMapping . LISTING_PAGE , this . getListingPage ( ) ) ; 
} public boolean isExpired ( ) 
if ( this . getExpirationTime ( ) == null ) 
Date expirationTime = new Date ( this . getExpirationTime ( ) ) ; 
return ( expirationTime . before ( new Date ( ) ) ) ; 
} public UserNotification createUserNotification ( UserNotification userNotificationParam ) 
if ( userNotificationParam != null && this . serviceTicket != null ) 
userNotificationParam . setServiceTicket ( this . serviceTicket ) ; 
return new UserNotification ( this . putJson ( 
userNotificationParam , 
WS . Path . UserNotification . Version1 . userNotificationCreate ( ) ) ) ; 
} public UserNotification updateUserNotification ( 
UserNotification userNotificationParam ) 
return new UserNotification ( this . postJson ( 
WS . Path . UserNotification . Version1 . userNotificationUpdate ( ) ) ) ; 
} public UserNotification markUserNotificationAsRead ( 
UserNotification userNotificationParam , 
boolean asyncParam ) 
WS . Path . UserNotification . Version1 . userNotificationMarkAsRead ( asyncParam ) ) ) ; 
} public UserNotification deleteUserNotification ( 
UserNotification userNotificationToDeleteParam ) 
if ( userNotificationToDeleteParam != null && this . serviceTicket != null ) 
userNotificationToDeleteParam . setServiceTicket ( this . serviceTicket ) ; 
return new UserNotification ( this . postJson ( userNotificationToDeleteParam , 
WS . Path . UserNotification . Version1 . userNotificationDelete ( ) ) ) ; 
} public UserNotification getUserNotificationById ( 
Long userNotificationPkParam ) 
UserNotification userNoti = new UserNotification ( ) ; 
userNoti . setId ( userNotificationPkParam ) ; 
userNoti . setServiceTicket ( this . serviceTicket ) ; 
userNoti , WS . Path . UserNotification . Version1 . getById ( ) ) ) ; 
} public List < UserNotification > getAllReadByLoggedInUser ( 
return new UserNotificationListing ( this . postJson ( 
WS . Path . UserNotification . Version1 . getAllReadByUser ( 
offsetParam ) ) ) . getListing ( ) ; 
} public List < UserNotification > getAllByUserAndDateBetween ( 
User userParam , 
Date fromDateParam , 
Date toDateParam 
return this . getAllByUserAndDateBetween ( 
- 1 , 
fromDateParam , 
toDateParam 
if ( this . serviceTicket != null && userParam != null ) { 
long fromDate = 
( fromDateParam == null ) ? 
System . currentTimeMillis ( ) - TimeUnit . DAYS . toMillis ( 7 ) 
: fromDateParam . getTime ( ) ; 
long toDate = 
( toDateParam == null ) ? 
System . currentTimeMillis ( ) : toDateParam . getTime ( ) ; 
WS . Path . UserNotification . Version1 . getAllByUserAndDate ( 
fromDate , 
toDate 
) ) ) . getListing ( ) ; 
} public static byte [ ] generateRandom ( int seedParam ) { 
if ( AES256Local . secureRandom == null ) 
AES256Local . secureRandom = new SecureRandom ( ) ; 
return new IvParameterSpec ( AES256Local . secureRandom . generateSeed ( seedParam ) ) . getIV ( ) ; 
} public static byte [ ] hmacSha256 ( byte [ ] hMacKeyParam , byte [ ] encryptedDataParam ) { 
Mac hmac = Mac . getInstance ( HMAC_ALGO ) ; 
hmac . init ( new SecretKeySpec ( hMacKeyParam , HMAC_ALGO ) ) ; 
return hmac . doFinal ( encryptedDataParam ) ; 
catch ( NoSuchAlgorithmException except ) { 
FluidClientException . ErrorCode . AES_256 ) ; 
catch ( InvalidKeyException except ) { 
} public static byte [ ] generateLocalHMAC ( 
byte [ ] encryptedDataParam , String passwordParam , String saltParam , byte [ ] seedParam ) { 
byte [ ] poisonedSeed = poisonBytes ( seedParam ) ; 
byte [ ] passwordSha256 = sha256 ( 
passwordParam . concat ( saltParam ) . getBytes ( ) ) ; 
byte [ ] derivedKey = sha256 ( UtilGlobal . addAll ( passwordSha256 , poisonedSeed ) ) ; 
return hmacSha256 ( derivedKey , encryptedDataParam ) ; 
} public static byte [ ] generateLocalHMACForReqToken ( 
byte [ ] encryptedDataParam , byte [ ] keyParam , byte [ ] seedParam ) { 
byte [ ] derivedKey = sha256 ( UtilGlobal . addAll ( keyParam , poisonedSeed ) ) ; 
} private static byte [ ] poisonBytes ( byte [ ] bytesToPoisonParam ) { 
if ( bytesToPoisonParam == null ) { 
byte [ ] returnVal = new byte [ bytesToPoisonParam . length ] ; 
for ( int index = 0 ; index < bytesToPoisonParam . length ; index ++ ) { 
byte poisoned = ( byte ) ( bytesToPoisonParam [ index ] ^ 222 ) ; 
returnVal [ index ] = poisoned ; 
} public static byte [ ] decryptInitPacket ( 
byte [ ] encryptedDataParam , 
String saltParam , 
byte [ ] ivParam , 
byte [ ] seedParam ) { 
byte [ ] passwordSha256 = sha256 ( passwordParam . concat ( saltParam ) . getBytes ( ) ) ; 
byte [ ] derivedKey = sha256 ( UtilGlobal . addAll ( passwordSha256 , seedParam ) ) ; 
return decrypt ( derivedKey , encryptedDataParam , ivParam ) ; 
} public static byte [ ] decrypt ( byte [ ] keyParam , byte [ ] dataToDecryptParam , byte [ ] ivParam ) { 
Key key = new SecretKeySpec ( keyParam , KEY_ALGO ) ; 
Cipher cipher = Cipher . getInstance ( ALGO_CBC ) ; 
cipher . init ( Cipher . DECRYPT_MODE , key , new IvParameterSpec ( ivParam ) ) ; 
return cipher . doFinal ( dataToDecryptParam ) ; 
except . getMessage ( ) , except , FluidClientException . ErrorCode . AES_256 ) ; 
} catch ( InvalidAlgorithmParameterException except ) { 
} catch ( IllegalBlockSizeException except ) { 
} catch ( NoSuchPaddingException except ) { 
} catch ( NoSuchAlgorithmException except ) { 
} catch ( BadPaddingException except ) { 
} public static byte [ ] encrypt ( byte [ ] keyParam , byte [ ] dataToEncryptParam , byte [ ] ivParam ) { 
if ( dataToEncryptParam == null ) { 
cipher . init ( Cipher . ENCRYPT_MODE , key , new IvParameterSpec ( ivParam ) ) ; 
return cipher . doFinal ( dataToEncryptParam ) ; 
} public static byte [ ] sha256 ( final byte [ ] dataParam ) { 
if ( dataParam == null || dataParam . length == 0 ) { 
final MessageDigest digest = MessageDigest . getInstance ( "SHA-256" ) ; 
return digest . digest ( dataParam ) ; 
catch ( final NoSuchAlgorithmException e ) { 
} public void sendMessage ( 
ABaseFluidJSONObject baseFluidJSONObjectParam , 
String requestIdParam ) 
if ( baseFluidJSONObjectParam != null ) { 
baseFluidJSONObjectParam . setServiceTicket ( this . serviceTicket ) ; 
if ( this . getHandler ( requestIdParam ) instanceof AGenericListMessageHandler ) { 
AGenericListMessageHandler listHandler = 
( AGenericListMessageHandler ) this . getHandler ( requestIdParam ) ; 
listHandler . addExpectedMessage ( baseFluidJSONObjectParam . getEcho ( ) ) ; 
this . webSocketClient . sendMessage ( baseFluidJSONObjectParam ) ; 
public void closeAndClean ( ) 
} public synchronized String initNewRequest ( ) { 
String returnVal = UUID . randomUUID ( ) . toString ( ) ; 
this . messageHandler . put ( returnVal , this . getNewHandlerInstance ( ) ) ; 
} private String getWebSocketBaseURIFrom ( String webServiceURLParam ) 
if ( webServiceURLParam == null ) 
if ( webServiceURLParam . trim ( ) . length ( ) == 0 ) 
URI uri = URI . create ( webServiceURLParam ) ; 
String scheme = uri . getScheme ( ) ; 
if ( scheme == null ) 
scheme = scheme . trim ( ) . toLowerCase ( ) ; 
if ( Constant . HTTP . equals ( scheme ) ) { 
returnBuffer . append ( Constant . WS ) ; 
else if ( Constant . HTTPS . equals ( scheme ) ) { 
returnBuffer . append ( Constant . WSS ) ; 
returnBuffer . append ( uri . getScheme ( ) ) ; 
returnBuffer . append ( Constant . SCHEME_SEP ) ; 
returnBuffer . append ( uri . getHost ( ) ) ; 
if ( uri . getPort ( ) > 0 ) 
returnBuffer . append ( Constant . COLON ) ; 
returnBuffer . append ( uri . getPort ( ) ) ; 
returnBuffer . append ( uri . getPath ( ) ) ; 
} protected void setEchoIfNotSet ( ABaseFluidVO baseToSetEchoOnIfNotSetParam ) { 
if ( baseToSetEchoOnIfNotSetParam == null ) { 
} else if ( baseToSetEchoOnIfNotSetParam . getEcho ( ) == null || 
baseToSetEchoOnIfNotSetParam . getEcho ( ) . trim ( ) . isEmpty ( ) ) { 
baseToSetEchoOnIfNotSetParam . setEcho ( UUID . randomUUID ( ) . toString ( ) ) ; 
} protected String getExceptionMessageVerbose ( 
String prefixParam , 
String uniqueReqIdParam , 
int numberOfSentItemsParam 
StringBuilder formFieldsCombined = new StringBuilder ( ) ; 
int returnValSize = - 1 ; 
RespHandler respHandler = this . getHandler ( uniqueReqIdParam ) ; 
if ( respHandler instanceof AGenericListMessageHandler ) { 
List < ? extends ABaseFluidJSONObject > returnValue = 
( ( AGenericListMessageHandler ) respHandler ) . getReturnValue ( ) ; 
if ( returnValue != null ) { 
returnValSize = returnValue . size ( ) ; 
returnValue . forEach ( listingItm -> { 
if ( listingItm instanceof ABaseListing ) { 
ABaseListing castedToListing = ( ABaseListing ) listingItm ; 
if ( castedToListing != null ) { 
castedToListing . getListing ( ) . forEach ( formItm -> { 
formFieldsCombined . append ( formItm . toString ( ) ) ; 
formFieldsCombined . append ( listingItm . toString ( ) ) ; 
formFieldsCombined . toString ( ) + "'." ) ; 
} public User createAdminUser ( String passwordParam ) { 
User adminUserCreate = new User ( ) ; 
adminUserCreate . setPasswordClear ( passwordParam ) ; 
adminUserCreate , WS . Path . User . Version1 . userCreateAdmin ( ) ) ) ; 
if ( this . getUser ( ) != null ) 
if ( this . getDateRead ( ) != null ) 
returnVal . put ( JSONMapping . DATE_READ , 
this . getDateAsLongFromJson ( this . getDateRead ( ) ) ) ; 
if ( this . getExpiringLink ( ) != null ) 
returnVal . put ( JSONMapping . EXPIRING_LINK , this . getExpiringLink ( ) ) ; 
if ( this . getMessage ( ) != null ) 
returnVal . put ( JSONMapping . MESSAGE , this . getMessage ( ) ) ; 
returnVal . put ( JSONMapping . USER_NOTIFICATION_TYPE , this . getUserNotificationType ( ) ) ; 
if ( this . getFormContainer ( ) != null ) { 
if ( this . getMessage ( ) != null ) { 
if ( this . getDateRead ( ) != null ) { 
if ( this . getDateSent ( ) != null ) { 
returnVal . put ( JSONMapping . DATE_SENT , 
this . getDateAsLongFromJson ( this . getDateSent ( ) ) ) ; 
if ( this . getFromUser ( ) != null ) { 
JSONMapping . FROM_USER , 
this . getFromUser ( ) . toJsonObject ( ) ) ; 
if ( this . getToUser ( ) != null ) { 
JSONMapping . TO_USER , 
this . getToUser ( ) . toJsonObject ( ) ) ; 
} public AccessToken getAccessToken ( 
String clientIdParam , 
String clientSecretParam , 
String codeParam , 
String redirectUrlParam ) 
if ( clientIdParam == null || clientIdParam . trim ( ) . isEmpty ( ) ) 
if ( clientSecretParam == null || clientSecretParam . trim ( ) . isEmpty ( ) ) 
if ( codeParam == null || codeParam . trim ( ) . isEmpty ( ) ) 
AccessTokenRequest tokenRequest = new AccessTokenRequest ( ) ; 
tokenRequest . setClientId ( clientIdParam ) ; 
tokenRequest . setClientSecret ( clientSecretParam ) ; 
tokenRequest . setGrantType ( AUTHORIZATION_CODE ) ; 
tokenRequest . setCode ( codeParam ) ; 
tokenRequest . setRedirectUri ( redirectUrlParam ) ; 
return new AccessToken ( this . postJson ( 
tokenRequest , WS . Path . Auth0 . Version1 . userToken ( ) ) ) ; 
} public NormalizedUserProfile getUserProfileInfo ( AccessToken accessTokenParam ) 
if ( accessTokenParam == null || ( accessTokenParam . getAccessToken ( ) == null || 
accessTokenParam . getAccessToken ( ) . trim ( ) . isEmpty ( ) ) ) 
String accessToken = accessTokenParam . getAccessToken ( ) ; 
List < HeaderNameValue > headerListing = new ArrayList < HeaderNameValue > ( ) ; 
headerListing . add ( new HeaderNameValue ( 
NormalizedUserProfile . HeaderMapping . AUTHORIZATION , 
return new NormalizedUserProfile ( 
this . getJson ( true , WS . Path . Auth0 . Version1 . userInfo ( ) , headerListing ) ) ; 
} public Form getFormFields ( Long electronicFormIdParam , boolean includeTableFieldsParam ) { 
StringBuffer primaryQuery = new StringBuffer ( ABaseFluidJSONObject . JSONMapping . ID ) ; 
List < Form > formsWithId = this . searchAndConvertHitsToFormWithAllFields ( 
QueryBuilders . queryStringQuery ( primaryQuery . toString ( ) ) , Index . DOCUMENT , 
DEFAULT_OFFSET , 1 , 
if ( formsWithId != null && ! formsWithId . isEmpty ( ) ) { 
if ( ! includeTableFieldsParam ) { 
this . populateTableFields ( false , true , returnVal . getFormFields ( ) ) ; 
if ( this . getFilename ( ) != null ) 
returnVal . put ( JSONMapping . FILENAME , this . getFilename ( ) ) ; 
if ( this . getSha256sum ( ) != null ) 
returnVal . put ( JSONMapping . SHA_256_SUM , this . getSha256sum ( ) ) ; 
if ( this . isAddToolsToClassPath ( ) != null ) 
returnVal . put ( JSONMapping . ADD_TOOLS_TO_CLASS_PATH , this . isAddToolsToClassPath ( ) ) ; 
if ( this . getLibraryDataBase64 ( ) != null ) 
returnVal . put ( JSONMapping . LIBRARY_DATA_BASE64 , 
this . getLibraryDataBase64 ( ) ) ; 
} private String executeHttp ( 
HttpClient httpClientParam , 
HttpUriRequest httpUriRequestParam , 
ResponseHandler responseHandlerParam , 
String postfixUrlParam 
Object returnedObj = httpClientParam . execute ( httpUriRequestParam , responseHandlerParam ) ; 
if ( returnedObj instanceof String ) { 
return ( String ) returnedObj ; 
} else if ( returnedObj == null ) { 
( returnedObj == null ) ? null : returnedObj . getClass ( ) . getName ( ) ) + "'." , 
} catch ( IOException except ) { 
if ( except instanceof UnknownHostException ) { 
except , FluidClientException . ErrorCode . CONNECT_ERROR ) ; 
if ( except instanceof ConnectException ) { 
throw new FluidClientException ( except . getMessage ( ) , 
except , 
FluidClientException . ErrorCode . CONNECT_ERROR ) ; 
except . getMessage ( ) , 
} public JSONObject getJson ( 
String postfixUrlParam , 
List < HeaderNameValue > headerNameValuesParam ) { 
return this . getJson ( 
postfixUrlParam , 
headerNameValuesParam ) ; 
boolean checkConnectionValidParam , 
if ( checkConnectionValidParam && ! this . isConnectionValid ( ) ) { 
this . endpointUrl . concat ( postfixUrlParam ) + "'." , 
CloseableHttpClient httpclient = this . getClient ( ) ; 
HttpGet httpGet = new HttpGet ( this . endpointUrl . concat ( postfixUrlParam ) ) ; 
if ( headerNameValuesParam != null && ! headerNameValuesParam . isEmpty ( ) ) { 
for ( HeaderNameValue headerNameVal : headerNameValuesParam ) { 
if ( headerNameVal . getName ( ) == null || headerNameVal . getName ( ) . trim ( ) . isEmpty ( ) ) { 
if ( headerNameVal . getValue ( ) == null ) { 
httpGet . setHeader ( headerNameVal . getName ( ) , headerNameVal . getValue ( ) ) ; 
ResponseHandler < String > responseHandler = this . getJsonResponseHandler ( 
this . endpointUrl . concat ( postfixUrlParam ) ) ; 
String responseBody = this . executeHttp ( 
httpclient , httpGet , responseHandler , postfixUrlParam ) ; 
if ( responseBody == null || responseBody . trim ( ) . isEmpty ( ) ) { 
JSONObject jsonOjb = new JSONObject ( responseBody ) ; 
if ( jsonOjb . isNull ( Error . JSONMapping . ERROR_CODE ) ) { 
return jsonOjb ; 
int errorCode = jsonOjb . getInt ( Error . JSONMapping . ERROR_CODE ) ; 
if ( errorCode > 0 ) { 
String errorMessage = ( jsonOjb . isNull ( Error . JSONMapping . ERROR_MESSAGE ) 
jsonOjb . getString ( Error . JSONMapping . ERROR_MESSAGE ) ) ; 
throw new FluidClientException ( errorMessage , errorCode ) ; 
} protected JSONObject postJson ( 
ABaseFluidJSONObject baseDomainParam , 
String postfixUrlParam ) { 
return this . postJson ( false , baseDomainParam , postfixUrlParam ) ; 
List < HeaderNameValue > headerNameValuesParam , 
return this . executeJson ( 
HttpMethod . POST , 
headerNameValuesParam , 
checkConnectionValidParam , 
baseDomainParam , 
ContentType . APPLICATION_JSON , 
postfixUrlParam ) ; 
} protected JSONObject deleteJson ( 
return this . deleteJson ( false , baseDomainParam , postfixUrlParam ) ; 
HttpMethod . DELETE , 
} protected JSONObject postForm ( 
List < FormNameValue > formNameValuesParam , 
return this . executeForm ( 
formNameValuesParam , 
ContentType . APPLICATION_FORM_URLENCODED , 
} protected JSONObject putJson ( 
HttpMethod . PUT , 
return this . putJson ( false , baseDomainParam , postfixUrlParam ) ; 
} protected JSONObject executeJson ( 
HttpMethod httpMethodParam , 
ContentType contentTypeParam , 
if ( baseDomainParam == null ) { 
String bodyJsonString = baseDomainParam . toJsonObject ( ) . toString ( ) ; 
return this . executeString ( 
httpMethodParam , 
bodyJsonString , 
contentTypeParam , 
} protected JSONObject executeForm ( 
if ( formNameValuesParam == null || formNameValuesParam . isEmpty ( ) ) { 
StringBuilder strBuilder = new StringBuilder ( ) ; 
for ( FormNameValue nameValue : formNameValuesParam ) { 
if ( nameValue . getName ( ) == null || nameValue . getName ( ) . trim ( ) . isEmpty ( ) ) { 
if ( nameValue . getValue ( ) == null ) { 
strBuilder . append ( nameValue . getName ( ) ) ; 
strBuilder . append ( EQUALS ) ; 
strBuilder . append ( nameValue . getValue ( ) ) ; 
strBuilder . append ( AMP ) ; 
String bodyJsonString = strBuilder . toString ( ) ; 
bodyJsonString = bodyJsonString . substring ( 0 , bodyJsonString . length ( ) - 1 ) ; 
bodyJsonString , contentTypeParam , postfixUrlParam ) ; 
} protected JSONObject executeString ( 
String stringParam , 
String responseBody = this . executeTxtReceiveTxt ( 
stringParam , 
if ( jsonOjb . isNull ( Error . JSONMapping . ERROR_CODE ) ) 
if ( errorCode > 0 ) 
if ( responseBody != null && ! responseBody . trim ( ) . isEmpty ( ) ) { 
responseBody , 
} protected String executeTxtReceiveTxt ( 
if ( stringParam == null || stringParam . isEmpty ( ) ) { 
String responseBody = null ; 
HttpUriRequest uriRequest = null ; 
if ( httpMethodParam == HttpMethod . POST ) { 
if ( contentTypeParam == ContentType . APPLICATION_FORM_URLENCODED ) { 
RequestBuilder builder = RequestBuilder . post ( ) . setUri ( 
builder = this . addParamsToBuildFromString ( builder , stringParam ) ; 
uriRequest = builder . build ( ) ; 
uriRequest = new HttpPost ( this . endpointUrl . concat ( postfixUrlParam ) ) ; 
uriRequest . setHeader ( CONTENT_TYPE_HEADER , contentTypeParam . toString ( ) ) ; 
} else if ( httpMethodParam == HttpMethod . PUT ) { 
RequestBuilder builder = RequestBuilder . put ( ) . setUri ( 
uriRequest = new HttpPut ( this . endpointUrl . concat ( postfixUrlParam ) ) ; 
} else if ( httpMethodParam == HttpMethod . DELETE ) { 
uriRequest = new HttpDelete ( this . endpointUrl . concat ( postfixUrlParam ) ) ; 
if ( uriRequest == null ) { 
uriRequest . setHeader ( headerNameVal . getName ( ) , headerNameVal . getValue ( ) ) ; 
if ( uriRequest instanceof HttpEntityEnclosingRequestBase ) { 
HttpEntity httpEntity = new StringEntity ( stringParam , contentTypeParam ) ; 
( ( HttpEntityEnclosingRequestBase ) uriRequest ) . setEntity ( httpEntity ) ; 
responseBody = this . executeHttp ( httpclient , uriRequest , 
responseHandler , postfixUrlParam ) ; 
} catch ( FluidClientException fluidClientExcept ) { 
throw fluidClientExcept ; 
} catch ( Exception otherExcept ) { 
throw new FluidClientException ( otherExcept . getMessage ( ) , 
otherExcept , FluidClientException . ErrorCode . ILLEGAL_STATE_ERROR ) ; 
} private RequestBuilder addParamsToBuildFromString ( 
RequestBuilder builderParam , 
String formDataToAddParam 
String [ ] nameValuePairs = formDataToAddParam . split ( REGEX_AMP ) ; 
if ( nameValuePairs . length > 0 ) { 
for ( String nameValuePair : nameValuePairs ) { 
String [ ] nameValuePairArr = nameValuePair . split ( REGEX_EQUALS ) ; 
if ( nameValuePairArr . length > 1 ) { 
String name = nameValuePairArr [ 0 ] ; 
String value = nameValuePairArr [ 1 ] ; 
builderParam = builderParam . addParameter ( name , value ) ; 
return builderParam ; 
} private ResponseHandler < String > getJsonResponseHandler ( final String urlCalledParam ) { 
ResponseHandler < String > responseHandler = new ResponseHandler < String > ( ) { 
public String handleResponse ( final HttpResponse responseParam ) throws IOException { 
int status = responseParam . getStatusLine ( ) . getStatusCode ( ) ; 
if ( status == 404 ) { 
urlCalledParam + "]." , 
} else if ( status >= 200 && status < 300 ) { 
HttpEntity entity = responseParam . getEntity ( ) ; 
String responseJsonString = ( entity == null ) ? null : 
EntityUtils . toString ( entity ) ; 
return responseJsonString ; 
} else if ( status == 400 ) { 
String responseString = ( entity != null ) ? 
EntityUtils . toString ( entity ) : null ; 
responseString + "]" , 
return responseHandler ; 
} public static String encodeParam ( String textParam ) { 
if ( textParam == null ) { 
return URLEncoder . encode ( textParam , ENCODING_UTF_8 ) ; 
} public boolean isConnectionValid ( ) { 
WS . Path . Test . Version1 . testConnection ( ) ) ; 
} catch ( FluidClientException flowJobExcept ) { 
if ( flowJobExcept . getErrorCode ( ) == FluidClientException . ErrorCode . CONNECT_ERROR ) { 
throw flowJobExcept ; 
} protected boolean isError ( ABaseFluidJSONObject baseDomainParam ) { 
if ( baseDomainParam instanceof Error && ( ( Error ) baseDomainParam ) . getErrorCode ( ) > 0 ) { 
} private CloseableHttpClient getClient ( ) { 
if ( this . closeableHttpClient != null ) { 
return this . closeableHttpClient ; 
String pathToFluidTrustStore = this . getPathToFluidSpecificTrustStore ( ) ; 
if ( IS_IN_JUNIT_TEST_MODE || pathToFluidTrustStore != null ) { 
SSLContextBuilder builder = new SSLContextBuilder ( ) ; 
if ( pathToFluidTrustStore == null ) { 
builder . loadTrustMaterial ( new SSLTrustAll ( ) ) ; 
String password = this . getFluidSpecificTrustStorePassword ( ) ; 
if ( password == null ) { 
password = UtilGlobal . EMPTY ; 
if ( IS_IN_JUNIT_TEST_MODE ) { 
builder . loadTrustMaterial ( 
new File ( pathToFluidTrustStore ) , 
password . toCharArray ( ) , 
new SSLTrustAll ( ) ) ; 
password . toCharArray ( ) ) ; 
SSLContext sslContext = builder . build ( ) ; 
this . closeableHttpClient = HttpClients . custom ( ) . setSSLSocketFactory ( 
new SSLConnectionSocketFactory ( sslContext ) ) . build ( ) ; 
} catch ( NoSuchAlgorithmException e ) { 
e , FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; 
} catch ( KeyManagementException e ) { 
FluidClientException . ErrorCode . CRYPTOGRAPHY ) ; 
} catch ( KeyStoreException e ) { 
} catch ( CertificateException e ) { 
this . closeableHttpClient = HttpClients . createDefault ( ) ; 
} private String getPathToFluidSpecificTrustStore ( ) { 
String fluidSystemTrustStore = 
System . getProperty ( SYSTEM_PROP_FLUID_TRUST_STORE ) ; 
if ( fluidSystemTrustStore == null || fluidSystemTrustStore . trim ( ) . isEmpty ( ) ) { 
File certFile = new File ( fluidSystemTrustStore ) ; 
if ( certFile . exists ( ) && certFile . isFile ( ) ) { 
return fluidSystemTrustStore ; 
} protected void closeConnectionNonThreaded ( ) { 
this . closeableHttpClient . close ( ) ; 
e . getMessage ( ) , 
e , FluidClientException . ErrorCode . IO_ERROR ) ; 
this . closeableHttpClient = null ; 
} public void closeConnection ( ) { 
if ( this . connection == null ) { 
if ( this . connection . isClosed ( ) ) { 
this . connection . close ( ) ; 
} catch ( SQLException sqlExcept ) { 
throw new FluidSQLException ( sqlExcept ) ; 
} public SQLServerType getSQLTypeFromConnection ( ) { 
if ( this . databaseMetaData == null ) { 
this . databaseMetaData = this . getConnection ( ) . getMetaData ( ) ; 
return SQLServerType . getSQLTypeFromProductName ( 
this . databaseMetaData . getDatabaseProductName ( ) ) ; 
} protected void closeStatement ( PreparedStatement preparedStatementParam , 
if ( resultSetParam == null ) { 
this . closeStatement ( preparedStatementParam ) ; 
resultSetParam . close ( ) ; 
} protected void closeStatement ( PreparedStatement preparedStatementParam ) { 
if ( preparedStatementParam == null ) 
preparedStatementParam . close ( ) ; 
} public FluidItem getFluidItemByFormId ( Long formIdParam ) { 
Form form = new Form ( formIdParam ) ; 
return new FluidItem ( this . postJson ( 
form , WS . Path . FlowItem . Version1 . getByForm ( ) ) ) ; 
} public FluidItem createFlowItem ( 
FluidItem flowJobItemParam , 
String flowNameParam ) { 
if ( flowJobItemParam != null && this . serviceTicket != null ) { 
flowJobItemParam . setServiceTicket ( this . serviceTicket ) ; 
if ( flowJobItemParam != null ) 
flowJobItemParam . setFlow ( flowNameParam ) ; 
return new FluidItem ( this . putJson ( 
flowJobItemParam , WS . Path . FlowItem . Version1 . flowItemCreate ( ) ) ) ; 
} public FluidItemListing getFluidItemsForView ( 
String sortFieldParam , 
String sortOrderParam ) 
if ( this . serviceTicket != null && jobViewParam != null ) 
WS . Path . FlowItem . Version1 . getByJobView ( 
sortFieldParam , 
sortOrderParam 
) ) ) ; 
} public FluidItem sendFlowItemOn ( 
boolean allowCollaboratorToSendOnParam 
flowJobItemParam , WS . Path . FlowItem . Version1 . sendFlowItemOn ( 
allowCollaboratorToSendOnParam ) ) ) ; 
} public FluidItem sendFormToFlow ( 
String flowParam ) { 
itemToSend . setFlow ( flowParam ) ; 
itemToSend . setServiceTicket ( this . serviceTicket ) ; 
itemToSend , WS . Path . FlowItem . Version1 . sendFlowItemToFlow ( ) ) ) ; 
} @ OnClose 
public void onClose ( Session userSessionParam , CloseReason reasonParam ) { 
this . userSession = null ; 
if ( this . messageHandlers != null ) { 
this . messageHandlers . values ( ) . forEach ( handle -> { 
handle . connectionClosed ( ) ; 
} @ OnMessage 
public void onMessage ( String messageParam ) { 
boolean handlerFoundForMsg = false ; 
for ( IMessageResponseHandler handler : new ArrayList < > ( this . messageHandlers . values ( ) ) ) { 
Object qualifyObj = handler . doesHandlerQualifyForProcessing ( messageParam ) ; 
if ( qualifyObj instanceof Error ) { 
handler . handleMessage ( qualifyObj ) ; 
} else if ( qualifyObj instanceof JSONObject ) { 
handlerFoundForMsg = true ; 
if ( ! handlerFoundForMsg ) { 
} public void sendMessage ( ABaseFluidJSONObject aBaseFluidJSONObjectParam ) { 
if ( aBaseFluidJSONObjectParam == null ) { 
this . sendMessage ( aBaseFluidJSONObjectParam . toJsonObject ( ) . toString ( ) ) ; 
} public void sendMessage ( String messageToSendParam ) { 
if ( this . userSession == null ) { 
RemoteEndpoint . Async asyncRemote = null ; 
if ( ( asyncRemote = this . userSession . getAsyncRemote ( ) ) == null ) { 
asyncRemote . sendText ( messageToSendParam ) ; 
} public void closeSession ( ) { 
this . userSession . close ( ) ; 
returnVal . put ( JSONMapping . ERROR_CODE , this . getErrorCode ( ) ) ; 
returnVal . put ( JSONMapping . ERROR_CODE_OTHER , this . getErrorCode ( ) ) ; 
if ( this . getErrorMessage ( ) != null ) 
returnVal . put ( JSONMapping . ERROR_MESSAGE , this . getErrorMessage ( ) ) ; 
returnVal . put ( JSONMapping . ERROR_MESSAGE_OTHER , this . getErrorMessage ( ) ) ; 
} public List < FormFieldListing > getFormFieldsSynchronized ( 
Form ... formsToGetFieldListingForForParam 
if ( formsToGetFieldListingForForParam == null ) { 
if ( formsToGetFieldListingForForParam . length == 0 ) { 
for ( Form formToSend : formsToGetFieldListingForForParam ) { 
List < FormFieldListing > returnValue = 
"SQLUtil-WebSocket-GetFormFields" , 
if ( this . getRuleExecuted ( ) != null ) 
returnVal . put ( JSONMapping . RULE_EXECUTED , 
this . getRuleExecuted ( ) ) ; 
if ( this . getRuleExecutedResult ( ) != null ) 
returnVal . put ( JSONMapping . RULE_EXECUTED_RESULT , 
this . getRuleExecutedResult ( ) ) ; 
if ( this . getFlowRuleOrder ( ) != null ) 
returnVal . put ( JSONMapping . FLOW_RULE_ORDER , 
this . getFlowRuleOrder ( ) ) ; 
if ( this . getLogEntryType ( ) != null ) 
returnVal . put ( JSONMapping . FLOW_STEP , 
this . getFlowStep ( ) . toJsonObject ( ) ) ; 
returnVal . put ( JSONMapping . FORM , 
this . getForm ( ) . toJsonObject ( ) ) ; 
this . getJobView ( ) ) ; 
} public List < SQLResultSet > executeNativeSQLSynchronized ( 
NativeSQLQuery nativeSQLQueryParam ) { 
if ( nativeSQLQueryParam == null ) 
if ( nativeSQLQueryParam . getDatasourceName ( ) == null || 
nativeSQLQueryParam . getDatasourceName ( ) . isEmpty ( ) ) 
if ( ( nativeSQLQueryParam . getQuery ( ) == null || 
nativeSQLQueryParam . getQuery ( ) . isEmpty ( ) ) && 
( nativeSQLQueryParam . getStoredProcedure ( ) == null || 
nativeSQLQueryParam . getStoredProcedure ( ) . isEmpty ( ) ) ) 
this . setEchoIfNotSet ( nativeSQLQueryParam ) ; 
this . sendMessage ( nativeSQLQueryParam , uniqueReqId ) ; 
List < SQLResultSet > returnValue = 
if ( this . getHandler ( uniqueReqId ) . isConnectionClosed ( ) ) 
} public static SyntaxFactory getInstance ( ) { 
if ( SyntaxFactory . syntaxFactory == null ) { 
SyntaxFactory . syntaxFactory = new SyntaxFactory ( ) ; 
return SyntaxFactory . syntaxFactory ; 
} public ISyntax getSyntaxFor ( 
ABaseSQLUtil . SQLServerType sqlTypeParam , 
String aliasParam ) { 
if ( ISyntax . ProcedureMapping . isStoredProcedureMapping ( aliasParam ) ) { 
return new StoredProcedureSyntax ( 
aliasParam , 
ISyntax . ProcedureMapping . getParamCountForAlias ( aliasParam ) ) ; 
throw new FluidSQLException ( 
} public ISyntax getFieldValueSyntaxFor ( 
SQLFormFieldUtil . FormFieldMapping formFieldMappingParam 
Long dataType = formFieldMappingParam . dataType ; 
switch ( dataType . intValue ( ) ) { 
return this . getSyntaxFor ( 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_1_Text ) ; 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_2_TrueFalse ) ; 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_3_ParagraphText ) ; 
if ( this . isPlain ( formFieldMappingParam . metaData ) ) 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_4_MultiChoice ) ; 
else if ( this . isSelectMany ( formFieldMappingParam . metaData ) ) 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldMultipleValue_4_MultiChoice ) ; 
dataType 
formFieldMappingParam . metaData + "'." ) ) ; 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_5_DateTime ) ; 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_6_Decimal ) ; 
sqlTypeParam , ISyntax . ProcedureMapping . Field . GetFormFieldValue_7_TableField ) ; 
case UtilGlobal . FieldTypeId . _8_TEXT_ENCRYPTED : 
} private boolean isPlain ( String textToCheckParam ) { 
String toCheckLower = textToCheckParam . toLowerCase ( ) ; 
return toCheckLower . startsWith ( PLAIN . toLowerCase ( ) ) ; 
} private boolean isSelectMany ( String textToCheckParam ) { 
return toCheckLower . startsWith ( SELECT_MANY . toLowerCase ( ) ) ; 
if ( this . getSqlColumns ( ) != null ) 
for ( SQLColumn toAdd : this . getSqlColumns ( ) ) 
returnVal . put ( JSONMapping . SQL_COLUMNS , jsonArray ) ; 
} public String requestLicense ( LicenseRequest licenseRequestParam ) { 
if ( licenseRequestParam != null && 
licenseRequestParam . setServiceTicket ( this . serviceTicket ) ; 
return this . executeTxtReceiveTxt ( 
( licenseRequestParam == null ) ? null : 
licenseRequestParam . toJsonObject ( ) . toString ( ) , 
Version1 . licenseRequest ( ) ) ; 
} public LicenseRequest applyLicense ( String licenseToApplyParam ) 
LicenseRequest liceReq = new LicenseRequest ( ) ; 
liceReq . setLicenseCipherText ( licenseToApplyParam ) ; 
liceReq . setServiceTicket ( this . serviceTicket ) ; 
return new LicenseRequest ( this . postJson ( 
liceReq , Version1 . licenseApply ( ) ) ) ; 
if ( this . getInputs ( ) != null ) 
for ( Field toAdd : this . getInputs ( ) ) 
returnVal . put ( JSONMapping . INPUTS , jsonArray ) ; 
if ( this . getRules ( ) != null ) 
for ( String toAdd : this . getRules ( ) ) 
jsonArray . put ( toAdd ) ; 
returnVal . put ( JSONMapping . RULES , jsonArray ) ; 
} public Field createFieldTextPlain ( Field routeFieldParam ) { 
if ( routeFieldParam != null && this . serviceTicket != null ) { 
routeFieldParam . setServiceTicket ( this . serviceTicket ) ; 
if ( routeFieldParam != null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . Text ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . Text . PLAIN ) ; 
routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; 
} public Field createFieldTrueFalse ( Field routeFieldParam ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . TrueFalse ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . TrueFalse . TRUE_FALSE ) ; 
} public Field createFieldParagraphTextPlain ( Field routeFieldParam ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . PLAIN ) ; 
} public Field createFieldParagraphTextHTML ( Field routeFieldParam ) { 
routeFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . HTML ) ; 
Field routeFieldParam , 
List < String > multiChoiceValuesParam 
if ( multiChoiceValuesParam == null ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . MultipleChoice ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . MultiChoice . PLAIN ) ; 
routeFieldParam . setFieldValue ( new MultiChoice ( multiChoiceValuesParam ) ) ; 
} public Field createFieldMultiChoiceSelectMany ( 
routeFieldParam . setTypeMetaData ( FieldMetaData . MultiChoice . SELECT_MANY ) ; 
} public Field createFieldDateTimeDate ( Field routeFieldParam ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . DateTime ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE ) ; 
} public Field createFieldDateTimeDateAndTime ( Field routeFieldParam ) { 
routeFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE_AND_TIME ) ; 
} public Field createFieldDecimalPlain ( Field routeFieldParam ) { 
routeFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; 
routeFieldParam . setTypeMetaData ( FieldMetaData . Decimal . PLAIN ) ; 
} public Field updateFieldTextPlain ( Field routeFieldParam ) { 
routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; 
} public Field updateFieldTrueFalse ( Field routeFieldParam ) { 
} public Field updateFieldParagraphTextPlain ( Field routeFieldParam ) { 
} public Field updateFieldParagraphTextHTML ( Field routeFieldParam ) { 
} public Field updateFieldDateTimeDate ( Field routeFieldParam ) { 
} public Field updateFieldDateTimeDateAndTime ( Field routeFieldParam ) { 
} public Field updateFieldDecimalPlain ( Field routeFieldParam ) { 
} public Field updateFieldValue ( Field routeFieldValueParam ) { 
if ( routeFieldValueParam != null && this . serviceTicket != null ) { 
routeFieldValueParam . setServiceTicket ( this . serviceTicket ) ; 
routeFieldValueParam , Version1 . routeFieldUpdateValue ( ) ) ) ; 
} public Field createFieldValue ( 
Field routeFieldValueToCreateParam , 
FluidItem fluidItemParam ) { 
if ( routeFieldValueToCreateParam != null && this . serviceTicket != null ) { 
routeFieldValueToCreateParam . setServiceTicket ( this . serviceTicket ) ; 
Long fluidItmId = ( fluidItemParam == null ) ? null : fluidItemParam . getId ( ) ; 
routeFieldValueToCreateParam , 
Version1 . routeFieldCreateValue ( fluidItmId ) ) ) ; 
} public Field getFieldById ( Long fieldIdParam ) { 
Field field = new Field ( fieldIdParam ) ; 
field , Version1 . getById ( ) ) ) ; 
} public List < Field > getRouteFieldValuesBy ( FluidItem fluidItemParam ) { 
if ( this . serviceTicket != null && fluidItemParam != null ) { 
fluidItemParam . setServiceTicket ( this . serviceTicket ) ; 
return new RouteFieldListing ( this . postJson ( 
fluidItemParam , Version1 . getValuesBy ( ) ) ) . getListing ( ) ; 
return new Field ( this . postJson ( fieldParam , Version1 . routeFieldDelete ( ) ) ) ; 
} public Field forceDeleteField ( Field fieldParam ) { 
fieldParam , Version1 . routeFieldDelete ( true ) ) ) ; 
public List < Field > convertTo ( List < SQLFormFieldUtil . FormFieldMapping > formFieldMappingsParam ) 
if ( formFieldMappingsParam == null ) 
for ( SQLFormFieldUtil . FormFieldMapping mappingToConvert : formFieldMappingsParam ) 
returnVal . add ( this . convertTo ( mappingToConvert ) ) ; 
public Field convertTo ( SQLFormFieldUtil . FormFieldMapping formFieldMappingParam ) 
switch ( formFieldMappingParam . dataType . intValue ( ) ) 
return new Field ( 
formFieldMappingParam . formFieldId , 
null , Field . Type . Text ) ; 
null , Field . Type . TrueFalse ) ; 
Field . Type . MultipleChoice ) ; 
} public Configuration getConfigurationByKey ( String configurationKeyParam ) 
Configuration configuration = new Configuration ( ) ; 
configuration . setKey ( configurationKeyParam ) ; 
configuration . setServiceTicket ( this . serviceTicket ) ; 
return new Configuration ( this . postJson ( 
configuration , WS . Path . Configuration . Version1 . getByKey ( ) ) ) ; 
} public ConfigurationListing getAllConfigurations ( ) 
return new ConfigurationListing ( this . postJson ( 
configuration , WS . Path . Configuration . Version1 . getAllConfigurations ( ) ) ) ; 
if ( this . getMachineName ( ) != null ) 
returnVal . put ( JSONMapping . MACHINE_NAME , 
this . getMachineName ( ) ) ; 
if ( this . getLicenseCipherText ( ) != null ) 
returnVal . put ( JSONMapping . LICENSE_CIPHER_TEXT , 
this . getLicenseCipherText ( ) ) ; 
if ( this . getLicenseType ( ) != null ) 
returnVal . put ( JSONMapping . LICENSE_TYPE , 
this . getLicenseType ( ) ) ; 
if ( this . getUserCount ( ) != null ) 
returnVal . put ( JSONMapping . USER_COUNT , 
this . getUserCount ( ) ) ; 
if ( this . getDateValidFrom ( ) != null ) 
returnVal . put ( JSONMapping . DATE_VALID_FROM , 
this . getDateAsLongFromJson ( this . getDateValidFrom ( ) ) ) ; 
if ( this . getDateValidTo ( ) != null ) 
returnVal . put ( JSONMapping . DATE_VALID_TO , 
this . getDateAsLongFromJson ( this . getDateValidTo ( ) ) ) ; 
} public Form createFormContainerSynchronized ( 
Form formToCreateParam ) { 
if ( formToCreateParam == null ) 
if ( formToCreateParam . getEcho ( ) == null || formToCreateParam . getEcho ( ) . trim ( ) . isEmpty ( ) ) 
formToCreateParam . setEcho ( UUID . randomUUID ( ) . toString ( ) ) ; 
this . sendMessage ( formToCreateParam , uniqueReqId ) ; 
List < Form > returnValue = this . getHandler ( uniqueReqId ) . getCF ( ) . get ( 
for ( Client client : this . getIdentities ( ) ) 
returnVal . append ( client . getProvider ( ) ) ; 
} public Attachment createAttachment ( Attachment attachmentParam ) 
if ( attachmentParam != null && this . serviceTicket != null ) 
attachmentParam . setServiceTicket ( this . serviceTicket ) ; 
return new Attachment ( this . putJson ( 
attachmentParam , WS . Path . Attachment . Version1 . attachmentCreate ( ) ) ) ; 
} public Attachment getAttachmentById ( 
Long attachmentIdParam , 
boolean includeAttachmentDataParam ) 
Attachment attachment = new Attachment ( attachmentIdParam ) ; 
attachment . setServiceTicket ( this . serviceTicket ) ; 
return new Attachment ( this . postJson ( 
attachment , WS . Path . Attachment . Version1 . getById ( 
includeAttachmentDataParam ) ) ) ; 
} public List < Attachment > getAttachmentsByForm ( 
AttachmentListing returnedListing = 
new AttachmentListing ( postJson ( 
formParam , WS . Path . Attachment . Version1 . getAllByFormContainer ( 
includeAttachmentDataParam , false ) ) ) ; 
return ( returnedListing == null ) ? null : 
returnedListing . getListing ( ) ; 
} public Attachment deleteAttachment ( Attachment attachmentParam ) 
attachmentParam , WS . Path . Attachment . Version1 . attachmentDelete ( ) ) ) ; 
} public Attachment forceDeleteAttachment ( Attachment attachmentParam ) 
attachmentParam , 
WS . Path . Attachment . Version1 . attachmentDelete ( true ) ) ) ; 
} public static boolean hasDifferentValue ( XsdStringRestrictions o1 , XsdStringRestrictions o2 ) { 
if ( o1 == null && o2 == null ) { 
String o1Value = null ; 
String o2Value ; 
if ( o1 != null ) { 
o1Value = o1 . getValue ( ) ; 
if ( o2 != null ) { 
o2Value = o2 . getValue ( ) ; 
return o2Value . equals ( o1Value ) ; 
} public void replaceUnsolvedAttributes ( NamedConcreteElement element ) { 
if ( element . getElement ( ) instanceof XsdAttributeGroup ) { 
attributeGroups . stream ( ) 
. filter ( attributeGroup -> attributeGroup instanceof UnsolvedReference && ( ( UnsolvedReference ) attributeGroup ) . getRef ( ) . equals ( element . getName ( ) ) ) 
. findFirst ( ) . ifPresent ( referenceBase -> { 
attributeGroups . remove ( referenceBase ) ; 
attributeGroups . add ( element ) ; 
attributes . addAll ( element . getElement ( ) . getElements ( ) ) ; 
element . getElement ( ) . setParent ( getOwner ( ) ) ; 
if ( element . getElement ( ) instanceof XsdAttribute ) { 
attributes . stream ( ) 
. filter ( attribute -> attribute instanceof UnsolvedReference && ( ( UnsolvedReference ) attribute ) . getRef ( ) . equals ( element . getName ( ) ) ) 
attributes . remove ( referenceBase ) ; 
attributes . add ( element ) ; 
public void replaceUnsolvedElements ( NamedConcreteElement elementWrapper ) { 
if ( elementWrapper . getElement ( ) instanceof XsdElement ) { 
super . replaceUnsolvedElements ( elementWrapper ) ; 
if ( elementWrapper . getElement ( ) instanceof XsdGroup ) { 
elements . add ( elementWrapper ) ; 
this . elements . removeIf ( element -> 
element instanceof UnsolvedReference && ( ( UnsolvedReference ) element ) . getRef ( ) . equals ( elementWrapper . getName ( ) ) 
} private void parseJarFile ( InputStream inputStream ) { 
Node schemaNode = getSchemaNode ( inputStream ) ; 
if ( isXsdSchema ( schemaNode ) ) { 
XsdSchema . parse ( this , schemaNode ) ; 
} catch ( SAXException | IOException | ParserConfigurationException e ) { 
} private void setClassLoader ( String jarPath ) { 
if ( ! jarPath . endsWith ( ".jar" ) ) { 
ClassLoader originalCl = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
URL url = originalCl . getResource ( jarPath ) ; 
url = new URL ( "file:/" + jarPath ) ; 
ClassLoader urlCl = URLClassLoader . newInstance ( new URL [ ] { url } , originalCl ) ; 
Thread . currentThread ( ) . setContextClassLoader ( urlCl ) ; 
classLoader = urlCl ; 
} static ReferenceBase xsdAnnotationChildrenParse ( Node node , XsdAnnotationChildren annotationChildren ) { 
annotationChildren . content = xsdRawContentParse ( node ) ; 
return ReferenceBase . createFromXsd ( annotationChildren ) ; 
} boolean isXsdSchema ( Node node ) { 
String schemaNodeName = node . getNodeName ( ) ; 
return schemaNodeName . equals ( XsdSchema . XSD_TAG ) || schemaNodeName . equals ( XsdSchema . XS_TAG ) ; 
} void resolveRefs ( ) { 
Map < String , List < NamedConcreteElement > > concreteElementsMap = 
parseElements . stream ( ) 
. filter ( concreteElement -> concreteElement instanceof NamedConcreteElement ) 
. map ( concreteElement -> ( NamedConcreteElement ) concreteElement ) 
. collect ( groupingBy ( NamedConcreteElement :: getName ) ) ; 
unsolvedElements . forEach ( unsolvedElement -> replaceUnsolvedReference ( concreteElementsMap , unsolvedElement ) ) ; 
} private void replaceUnsolvedReference ( Map < String , List < NamedConcreteElement > > concreteElementsMap , UnsolvedReference unsolvedReference ) { 
List < NamedConcreteElement > concreteElements = concreteElementsMap . get ( unsolvedReference . getRef ( ) ) ; 
if ( concreteElements != null ) { 
Map < String , String > oldElementAttributes = unsolvedReference . getElement ( ) . getAttributesMap ( ) ; 
for ( NamedConcreteElement concreteElement : concreteElements ) { 
NamedConcreteElement substitutionElementWrapper ; 
if ( ! unsolvedReference . isTypeRef ( ) ) { 
XsdNamedElements substitutionElement = concreteElement . getElement ( ) . clone ( oldElementAttributes ) ; 
substitutionElementWrapper = ( NamedConcreteElement ) ReferenceBase . createFromXsd ( substitutionElement ) ; 
substitutionElementWrapper = concreteElement ; 
unsolvedReference . getParent ( ) . replaceUnsolvedElements ( substitutionElementWrapper ) ; 
storeUnsolvedItem ( unsolvedReference ) ; 
} private void storeUnsolvedItem ( UnsolvedReference unsolvedReference ) { 
if ( parserUnsolvedElementsMap . isEmpty ( ) ) { 
parserUnsolvedElementsMap . add ( new UnsolvedReferenceItem ( unsolvedReference ) ) ; 
Optional < UnsolvedReferenceItem > innerEntry = 
parserUnsolvedElementsMap . stream ( ) 
. filter ( unsolvedReferenceObj -> 
unsolvedReferenceObj . getUnsolvedReference ( ) 
. getRef ( ) 
. equals ( unsolvedReference . getRef ( ) ) ) 
if ( innerEntry . isPresent ( ) ) { 
innerEntry . ifPresent ( entry -> entry . getParents ( ) . add ( unsolvedReference . getParent ( ) ) ) ; 
} public void addFileToParse ( String schemaLocation ) { 
if ( ! schemaLocations . contains ( schemaLocation ) && schemaLocation . endsWith ( ".xsd" ) ) { 
schemaLocations . add ( schemaLocation ) ; 
} private void rule2 ( ) { 
if ( ! ( parent instanceof XsdSchema ) && name != null ) { 
} private void rule3 ( ) { 
if ( parent instanceof XsdSchema && name == null ) { 
} public static boolean hasDifferentValue ( XsdDoubleRestrictions o1 , XsdDoubleRestrictions o2 ) { 
double o1Value = Double . MAX_VALUE ; 
double o2Value ; 
return o2Value == o1Value ; 
} public List < XsdRestriction > getAllRestrictions ( ) { 
Map < String , XsdRestriction > restrictions = new HashMap < > ( ) ; 
Map < String , String > xsdBuiltinTypes = XsdParserCore . getXsdTypesToJava ( ) ; 
if ( restriction != null ) { 
restrictions . put ( xsdBuiltinTypes . get ( restriction . getBase ( ) ) , restriction ) ; 
if ( union != null ) { 
union . getUnionElements ( ) . forEach ( unionMember -> { 
XsdRestriction unionMemberRestriction = unionMember . getRestriction ( ) ; 
if ( unionMemberRestriction != null ) { 
XsdRestriction existingRestriction = restrictions . getOrDefault ( xsdBuiltinTypes . get ( unionMemberRestriction . getBase ( ) ) , null ) ; 
if ( existingRestriction != null ) { 
if ( existsRestrictionOverlap ( existingRestriction , unionMemberRestriction ) ) { 
updateExistingRestriction ( existingRestriction , unionMemberRestriction ) ; 
restrictions . put ( xsdBuiltinTypes . get ( unionMemberRestriction . getBase ( ) ) , unionMemberRestriction ) ; 
return new ArrayList < > ( restrictions . values ( ) ) ; 
} private void updateExistingRestriction ( XsdRestriction existing , XsdRestriction newRestriction ) { 
XsdPattern pattern = newRestriction . getPattern ( ) ; 
XsdMaxExclusive maxExclusive = newRestriction . getMaxExclusive ( ) ; 
XsdMaxInclusive maxInclusive = newRestriction . getMaxInclusive ( ) ; 
XsdMaxLength maxLength = newRestriction . getMaxLength ( ) ; 
XsdMinExclusive minExclusive = newRestriction . getMinExclusive ( ) ; 
XsdMinInclusive minInclusive = newRestriction . getMinInclusive ( ) ; 
XsdMinLength minLength = newRestriction . getMinLength ( ) ; 
XsdLength length = newRestriction . getLength ( ) ; 
XsdFractionDigits fractionDigits = newRestriction . getFractionDigits ( ) ; 
XsdTotalDigits totalDigits = newRestriction . getTotalDigits ( ) ; 
XsdWhiteSpace whiteSpace = newRestriction . getWhiteSpace ( ) ; 
if ( pattern != null ) { 
existing . setPattern ( pattern ) ; 
if ( maxExclusive != null ) { 
existing . setMaxExclusive ( maxExclusive ) ; 
if ( maxInclusive != null ) { 
existing . setMaxInclusive ( maxInclusive ) ; 
if ( maxLength != null ) { 
existing . setMaxLength ( maxLength ) ; 
if ( minExclusive != null ) { 
existing . setMinExclusive ( minExclusive ) ; 
if ( minInclusive != null ) { 
existing . setMinInclusive ( minInclusive ) ; 
if ( minLength != null ) { 
existing . setMinLength ( minLength ) ; 
if ( length != null ) { 
existing . setLength ( length ) ; 
if ( fractionDigits != null ) { 
existing . setFractionDigits ( fractionDigits ) ; 
if ( totalDigits != null ) { 
existing . setTotalDigits ( totalDigits ) ; 
if ( whiteSpace != null ) { 
existing . setWhiteSpace ( whiteSpace ) ; 
updateExistingRestrictionEnumerations ( existing , newRestriction ) ; 
} private void updateExistingRestrictionEnumerations ( XsdRestriction existing , XsdRestriction newRestriction ) { 
List < XsdEnumeration > existingEnumeration = existing . getEnumeration ( ) ; 
List < XsdEnumeration > newRestrictionEnumeration = newRestriction . getEnumeration ( ) ; 
if ( existingEnumeration == null ) { 
existing . setEnumeration ( newRestrictionEnumeration ) ; 
if ( newRestrictionEnumeration != null ) { 
for ( XsdEnumeration enumerationElem : newRestrictionEnumeration ) { 
if ( existingEnumeration . stream ( ) . noneMatch ( existingEnumerationElem -> existingEnumerationElem . getValue ( ) . equals ( enumerationElem . getValue ( ) ) ) ) { 
existingEnumeration . add ( enumerationElem ) ; 
} private boolean existsRestrictionOverlap ( XsdRestriction existing , XsdRestriction newRestriction ) { 
return hasDifferentValue ( existing . getPattern ( ) , newRestriction . getPattern ( ) ) || 
hasDifferentValue ( existing . getWhiteSpace ( ) , newRestriction . getWhiteSpace ( ) ) || 
hasDifferentValue ( existing . getTotalDigits ( ) , newRestriction . getTotalDigits ( ) ) || 
hasDifferentValue ( existing . getFractionDigits ( ) , newRestriction . getFractionDigits ( ) ) || 
hasDifferentValue ( existing . getMaxExclusive ( ) , newRestriction . getMaxExclusive ( ) ) || 
hasDifferentValue ( existing . getMaxInclusive ( ) , newRestriction . getMaxInclusive ( ) ) || 
hasDifferentValue ( existing . getMaxLength ( ) , newRestriction . getMaxLength ( ) ) || 
hasDifferentValue ( existing . getMinExclusive ( ) , newRestriction . getMinExclusive ( ) ) || 
hasDifferentValue ( existing . getMinInclusive ( ) , newRestriction . getMinInclusive ( ) ) || 
hasDifferentValue ( existing . getMinLength ( ) , newRestriction . getMinLength ( ) ) || 
hasDifferentValue ( existing . getLength ( ) , newRestriction . getLength ( ) ) ; 
if ( attributesMap . containsKey ( REF_TAG ) && ( simpleType != null || form != null || type != null ) ) { 
XsdAbstractElement element = elementWrapper . getElement ( ) ; 
if ( element instanceof XsdSimpleType && simpleType != null && type . equals ( elementWrapper . getName ( ) ) ) { 
this . simpleType = elementWrapper ; 
} private void parseFile ( String filePath ) { 
if ( ! new File ( filePath ) . exists ( ) ) { 
throw new FileNotFoundException ( ) ; 
Node schemaNode = getSchemaNode ( filePath ) ; 
} private Node getSchemaNode ( String filePath ) throws IOException , SAXException , ParserConfigurationException { 
Document doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . parse ( filePath ) ; 
return doc . getFirstChild ( ) ; 
} private void rule7 ( ) { 
if ( parent instanceof XsdSchema && attributesMap . containsKey ( FORM_TAG ) ) { 
if ( parent instanceof XsdSchema && attributesMap . containsKey ( REF_TAG ) ) { 
public void replaceUnsolvedElements ( NamedConcreteElement element ) { 
super . replaceUnsolvedElements ( element ) ; 
XsdNamedElements elem = element . getElement ( ) ; 
boolean isComplexOrSimpleType = elem instanceof XsdComplexType || elem instanceof XsdSimpleType ; 
if ( this . type instanceof UnsolvedReference && isComplexOrSimpleType && ( ( UnsolvedReference ) this . type ) . getRef ( ) . equals ( element . getName ( ) ) ) { 
this . type = element ; 
elem . setParent ( this ) ; 
if ( this . substitutionGroup instanceof UnsolvedReference && elem instanceof XsdElement && ( ( UnsolvedReference ) this . substitutionGroup ) . getRef ( ) . equals ( element . getName ( ) ) ) { 
XsdElement xsdElement = ( XsdElement ) elem ; 
this . type = xsdElement . type ; 
this . simpleType = xsdElement . simpleType ; 
this . complexType = xsdElement . complexType ; 
this . substitutionGroup = element ; 
} static ReferenceBase xsdParseSkeleton ( Node node , XsdAbstractElement element ) { 
XsdParserCore parser = element . getParser ( ) ; 
if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { 
String nodeName = child . getNodeName ( ) ; 
BiFunction < XsdParserCore , Node , ReferenceBase > parserFunction = XsdParserCore . getParseMappers ( ) . get ( nodeName ) ; 
if ( parserFunction != null ) { 
XsdAbstractElement childElement = parserFunction . apply ( parser , child ) . getElement ( ) ; 
childElement . accept ( element . getVisitor ( ) ) ; 
childElement . validateSchemaRules ( ) ; 
ReferenceBase wrappedElement = ReferenceBase . createFromXsd ( element ) ; 
parser . addParsedElement ( wrappedElement ) ; 
return wrappedElement ; 
} protected static Map < String , String > convertNodeMap ( NamedNodeMap nodeMap ) { 
HashMap < String , String > attributesMapped = new HashMap < > ( ) ; 
for ( int i = 0 ; i < nodeMap . getLength ( ) ; i ++ ) { 
Node node = nodeMap . item ( i ) ; 
attributesMapped . put ( node . getNodeName ( ) , node . getNodeValue ( ) ) ; 
return attributesMapped ; 
} public void replaceUnsolvedElements ( NamedConcreteElement element ) { 
List < ReferenceBase > elements = this . getElements ( ) ; 
if ( elements != null ) { 
elements . stream ( ) 
. filter ( referenceBase -> referenceBase instanceof UnsolvedReference ) 
. map ( referenceBase -> ( UnsolvedReference ) referenceBase ) 
. filter ( unsolvedReference -> unsolvedReference . getRef ( ) . equals ( element . getName ( ) ) ) 
. ifPresent ( oldElement -> elements . set ( elements . indexOf ( oldElement ) , element ) ) ; 
} static String xsdRawContentParse ( Node node ) { 
StringBuilder stringBuilder = new StringBuilder ( ) ; 
if ( child . getNodeType ( ) == Node . TEXT_NODE ) { 
stringBuilder . append ( child . getTextContent ( ) ) ; 
return stringBuilder . toString ( ) ; 
} public static boolean hasDifferentValue ( XsdIntegerRestrictions o1 , XsdIntegerRestrictions o2 ) { 
int o1Value = Integer . MAX_VALUE ; 
int o2Value ; 
} public static < T extends XsdEnum > T belongsToEnum ( final XsdEnum < T > instance , final String value ) { 
Optional < T > enumValue = Arrays . stream ( instance . getValues ( ) ) . filter ( enumField -> enumField . getValue ( ) . equals ( value ) ) . findFirst ( ) ; 
if ( enumValue . isPresent ( ) ) { 
return enumValue . get ( ) ; 
StringBuilder possibleValues = new StringBuilder ( ) ; 
String values = possibleValues . toString ( ) ; 
values = values . substring ( 0 , values . length ( ) - 2 ) ; 
values ) ; 
} static String maxOccursValidation ( String elementName , String value ) { 
if ( value . equals ( "unbounded" ) ) { 
validateNonNegativeInteger ( elementName , MAX_OCCURS_TAG , value ) ; 
} static Integer validateNonNegativeInteger ( String elementName , String attributeName , String value ) { 
int intValue = Integer . parseInt ( value ) ; 
if ( intValue < 0 ) { 
return intValue ; 
} public static Integer validateRequiredNonNegativeInteger ( String elementName , String attributeName , String value ) { 
if ( value == null ) throw new ParsingException ( attributeMissingMessage ( elementName , attributeName ) ) ; 
return validateNonNegativeInteger ( elementName , attributeName , value ) ; 
} public static Integer validateRequiredPositiveInteger ( String elementName , String attributeName , String value ) { 
return validatePositiveInteger ( elementName , attributeName , value ) ; 
} private static Double validateDouble ( String elementName , String attributeName , String value ) { 
return Double . parseDouble ( value ) ; 
} public static Double validateRequiredDouble ( String elementName , String attributeName , String value ) { 
return validateDouble ( elementName , attributeName , value ) ; 
} static String getFormDefaultValue ( XsdAbstractElement parent ) { 
if ( parent == null ) return null ; 
if ( parent instanceof XsdSchema ) { 
return ( ( XsdSchema ) parent ) . getElementFormDefault ( ) ; 
return getFormDefaultValue ( parent . getParent ( ) ) ; 
} static String getFinalDefaultValue ( XsdAbstractElement parent ) { 
return ( ( XsdSchema ) parent ) . getFinalDefault ( ) ; 
return getFinalDefaultValue ( parent . getParent ( ) ) ; 
} static String getBlockDefaultValue ( XsdAbstractElement parent ) { 
return ( ( XsdSchema ) parent ) . getBlockDefault ( ) ; 
return getBlockDefaultValue ( parent . getParent ( ) ) ; 
} public static ReferenceBase createFromXsd ( XsdAbstractElement element ) { 
String ref = getRef ( element ) ; 
String name = getName ( element ) ; 
if ( ! ( element instanceof XsdNamedElements ) ) { 
return new ConcreteElement ( element ) ; 
if ( ref == null ) { 
return new NamedConcreteElement ( ( XsdNamedElements ) element , name ) ; 
return new UnsolvedReference ( ( XsdNamedElements ) element ) ; 
String elemName = elem . getRawName ( ) ; 
if ( this . base instanceof UnsolvedReference && isComplexOrSimpleType && ( ( UnsolvedReference ) this . base ) . getRef ( ) . equals ( elemName ) ) { 
this . base = element ; 
if ( this . childElement instanceof UnsolvedReference && 
elem instanceof XsdGroup && ( ( UnsolvedReference ) this . childElement ) . getRef ( ) . equals ( elemName ) ) { 
this . childElement = element ; 
visitor . replaceUnsolvedAttributes ( element ) ; 
} public void addHeaderView ( View v , Object data , boolean isSelectable ) { 
final FixedViewInfo info = new FixedViewInfo ( ) ; 
FrameLayout fl = new FullWidthFixedViewLayout ( getContext ( ) ) ; 
fl . addView ( v ) ; 
info . view = v ; 
info . viewContainer = fl ; 
info . data = data ; 
info . isSelectable = isSelectable ; 
mHeaderViewInfos . add ( info ) ; 
if ( mAdapter != null ) { 
if ( ! ( mAdapter instanceof FooterViewGridAdapter ) ) { 
mAdapter = new FooterViewGridAdapter ( mHeaderViewInfos , mFooterViewInfos , mAdapter ) ; 
notifiyChanged ( ) ; 
} public boolean removeFooterView ( View v ) { 
if ( mFooterViewInfos . size ( ) > 0 ) { 
boolean result = false ; 
if ( mAdapter != null && ( ( FooterViewGridAdapter ) mAdapter ) . removeFooter ( v ) ) { 
removeFixedViewInfo ( v , mFooterViewInfos ) ; 
public boolean supportsParameter ( 
ParameterContext parameterContext , ExtensionContext extensionContext ) 
throws ParameterResolutionException { 
return parameterContext . getParameter ( ) . getAnnotation ( Random . class ) != null ; 
public Object resolveParameter ( 
parameterContext . getParameter ( ) . getType ( ) , 
parameterContext . getParameter ( ) . getAnnotation ( Random . class ) ) ; 
} private Object resolve ( Class < ? > targetType , Random annotation ) { 
if ( targetType . isAssignableFrom ( List . class ) || targetType . isAssignableFrom ( Collection . class ) ) { 
return random 
. objects ( annotation . type ( ) , annotation . size ( ) , annotation . excludes ( ) ) 
} else if ( targetType . isAssignableFrom ( Set . class ) ) { 
} else if ( targetType . isAssignableFrom ( Stream . class ) ) { 
return random . objects ( annotation . type ( ) , annotation . size ( ) , annotation . excludes ( ) ) ; 
return random . nextObject ( targetType , annotation . excludes ( ) ) ; 
} public File createFile ( String fileName ) throws IOException { 
Path path = Paths . get ( rootFolder . getPath ( ) , fileName ) ; 
return Files . createFile ( path ) . toFile ( ) ; 
} public File createDirectory ( String directoryName ) { 
Path path = Paths . get ( rootFolder . getPath ( ) , directoryName ) ; 
return Files . createDirectory ( path ) . toFile ( ) ; 
throw new TemporaryFolderException ( 
} void destroy ( ) throws IOException { 
if ( rootFolder . exists ( ) ) { 
Files . walkFileTree ( 
rootFolder . toPath ( ) , 
new SimpleFileVisitor < Path > ( ) { 
public FileVisitResult visitFile ( Path file , BasicFileAttributes attributes ) 
return delete ( file ) ; 
public FileVisitResult postVisitDirectory ( Path directory , IOException exception ) 
return delete ( directory ) ; 
@ SuppressWarnings ( "SameReturnValue" ) 
private FileVisitResult delete ( Path file ) throws IOException { 
Files . delete ( file ) ; 
return CONTINUE ; 
Files . delete ( rootFolder . toPath ( ) ) ; 
return appliesTo ( parameterContext . getParameter ( ) . getType ( ) ) ; 
return extensionContext 
. getStore ( NAMESPACE ) 
. getOrComputeIfAbsent ( 
parameterContext , key -> new TemporaryFolder ( ) , TemporaryFolder . class ) ; 
} private Predicate < String > getPredicate ( ExpectedException annotation ) { 
if ( has ( annotation . messageStartsWith ( ) ) ) { 
return s -> s . startsWith ( annotation . messageStartsWith ( ) ) ; 
} else if ( has ( annotation . messageContains ( ) ) ) { 
return s -> s . contains ( annotation . messageContains ( ) ) ; 
} else if ( has ( annotation . messageIs ( ) ) ) { 
return s -> s . equals ( annotation . messageIs ( ) ) ; 
return s -> true ; 
} public static ExtensionContext . Store getStore ( ExtensionContext extensionContext , Class clazz ) { 
return extensionContext . getStore ( namespace ( extensionContext , clazz ) ) ; 
} private static ExtensionContext . Namespace namespace ( 
ExtensionContext extensionContext , Class clazz ) { 
return ExtensionContext . Namespace . create ( clazz , extensionContext ) ; 
public void beforeAll ( ExtensionContext extensionContext ) throws Exception { 
List < SystemProperty > systemProperties = 
getSystemProperties ( extensionContext . getRequiredTestClass ( ) ) ; 
if ( ! systemProperties . isEmpty ( ) ) { 
RestoreContext . Builder builder = RestoreContext . createBuilder ( ) ; 
for ( SystemProperty systemProperty : systemProperties ) { 
builder . addPropertyName ( systemProperty . name ( ) ) ; 
if ( System . getProperty ( systemProperty . name ( ) ) != null ) { 
builder . addRestoreProperty ( 
systemProperty . name ( ) , System . getProperty ( systemProperty . name ( ) ) ) ; 
set ( systemProperty ) ; 
writeRestoreContext ( extensionContext , builder . build ( ) ) ; 
public void afterAll ( ExtensionContext extensionContext ) throws Exception { 
RestoreContext restoreContext = readRestoreContext ( extensionContext ) ; 
if ( restoreContext != null ) { 
restoreContext . restore ( ) ; 
} private List < SystemProperty > getSystemProperties ( AnnotatedElement annotatedElement ) { 
List < SystemProperty > systemProperties = new ArrayList < > ( ) ; 
if ( isAnnotated ( annotatedElement , SystemProperties . class ) ) { 
systemProperties . addAll ( 
Arrays . asList ( annotatedElement . getAnnotation ( SystemProperties . class ) . value ( ) ) ) ; 
if ( isAnnotated ( annotatedElement , SystemProperty . class ) ) { 
systemProperties . add ( annotatedElement . getAnnotation ( SystemProperty . class ) ) ; 
return systemProperties ; 
} public void restore ( ) { 
for ( String propertyName : propertyNames ) { 
if ( restoreProperties . containsKey ( propertyName ) ) { 
System . setProperty ( propertyName , restoreProperties . get ( propertyName ) ) ; 
System . clearProperty ( propertyName ) ; 
} public Logger getLogger ( String name ) { 
String tag = name == null ? ANONYMOUS_TAG : name ; 
Logger logger = loggerMap . get ( tag ) ; 
if ( logger == null ) { 
Logger newInstance = new TimberAndroidLoggerAdapter ( tag ) ; 
Logger oldInstance = loggerMap . putIfAbsent ( tag , newInstance ) ; 
logger = oldInstance == null ? newInstance : oldInstance ; 
} public void trace ( String format , Object arg ) { 
formatAndLog ( Log . VERBOSE , format , arg ) ; 
} public void trace ( String format , Object arg1 , Object arg2 ) { 
formatAndLog ( Log . VERBOSE , format , arg1 , arg2 ) ; 
} public void trace ( String format , Object ... argArray ) { 
formatAndLog ( Log . VERBOSE , format , argArray ) ; 
} public void trace ( String msg , Throwable t ) { 
log ( Log . VERBOSE , msg , t ) ; 
} public void debug ( String format , Object arg ) { 
formatAndLog ( Log . DEBUG , format , arg ) ; 
} public void debug ( String format , Object arg1 , Object arg2 ) { 
formatAndLog ( Log . DEBUG , format , arg1 , arg2 ) ; 
} public void debug ( String format , Object ... argArray ) { 
formatAndLog ( Log . DEBUG , format , argArray ) ; 
} public void debug ( String msg , Throwable t ) { 
log ( Log . DEBUG , msg , t ) ; 
} public void info ( String format , Object arg ) { 
formatAndLog ( Log . INFO , format , arg ) ; 
} public void info ( String format , Object arg1 , Object arg2 ) { 
formatAndLog ( Log . INFO , format , arg1 , arg2 ) ; 
} public void info ( String format , Object ... argArray ) { 
formatAndLog ( Log . INFO , format , argArray ) ; 
} public void info ( String msg , Throwable t ) { 
log ( Log . INFO , msg , t ) ; 
} public void warn ( String format , Object arg ) { 
formatAndLog ( Log . WARN , format , arg ) ; 
} public void warn ( String format , Object arg1 , Object arg2 ) { 
formatAndLog ( Log . WARN , format , arg1 , arg2 ) ; 
} public void warn ( String format , Object ... argArray ) { 
formatAndLog ( Log . WARN , format , argArray ) ; 
} public void warn ( String msg , Throwable t ) { 
log ( Log . WARN , msg , t ) ; 
} public void error ( String format , Object arg ) { 
formatAndLog ( Log . ERROR , format , arg ) ; 
} public void error ( String format , Object arg1 , Object arg2 ) { 
formatAndLog ( Log . ERROR , format , arg1 , arg2 ) ; 
} public void error ( String format , Object ... argArray ) { 
formatAndLog ( Log . ERROR , format , argArray ) ; 
} public void error ( String msg , Throwable t ) { 
log ( Log . ERROR , msg , t ) ; 
public ReadableInstant getLastModified ( 
ServletContext servletContext , 
HttpServletRequest request , 
Page page 
) throws ServletException , IOException { 
return AoArrays . maxNonNull ( 
page . getDateCreated ( ) , 
page . getDatePublished ( ) , 
page . getDateModified ( ) 
public boolean getAllowRobots ( ServletContext servletContext , HttpServletRequest request , HttpServletResponse response , Page page ) throws ServletException , IOException { 
return PageUtils . findAllowRobots ( servletContext , request , response , page ) ; 
FileInputStream fis = new FileInputStream ( new File ( "dic/word-with-attr.dic" ) ) ; 
final Set < String > words = new TreeSet < String > ( ) ; 
final int [ ] num = { 0 } ; 
FileLoading fl = new FileLoading ( ) { 
public void row ( String line , int n ) { 
words . add ( line . trim ( ) ) ; 
num [ 0 ] ++ ; 
Dictionary . load ( fis , fl ) ; 
fis = new FileInputStream ( new File ( "dic/words-rmmseg.dic" ) ) ; 
WriterRow wr = new WriterRow ( new File ( "dic/words-marge-sogou-no-attr-and-rmmseg.dic" ) ) ; 
for ( String word : words ) { 
wr . writerRow ( word ) ; 
wr . close ( ) ; 
int n = 1 ; 
usage ( ) ; 
Properties analyzers = new Properties ( ) ; 
analyzers . load ( new FileInputStream ( new File ( "analyzer.properties" ) ) ) ; 
String mode = System . getProperty ( "mode" , "complex" ) ; 
String a = System . getProperty ( "analyzer" , "mmseg4j" ) ; 
Analyzer analyzer = null ; 
String an = ( String ) analyzers . get ( a ) ; 
if ( an != null ) { 
analyzer = ( Analyzer ) Class . forName ( an ) . newInstance ( ) ; 
mode = a ; 
n = Integer . parseInt ( args [ 1 ] ) ; 
File path = new File ( args [ 0 ] ) ; 
System . out . println ( "analyzer=" + analyzer . getClass ( ) . getName ( ) ) ; 
Effect ef = new Effect ( path , analyzer ) ; 
ef . run ( mode , n ) ; 
} protected File [ ] listWordsFiles ( ) { 
return dicPath . listFiles ( new FilenameFilter ( ) { 
return name . startsWith ( "words" ) && name . endsWith ( ".dic" ) ; 
} public static int load ( InputStream fin , FileLoading loading ) throws IOException { 
BufferedReader br = new BufferedReader ( 
new InputStreamReader ( new BufferedInputStream ( fin ) , "UTF-8" ) ) ; 
while ( ( line = br . readLine ( ) ) != null ) { 
if ( line == null || line . startsWith ( "#" ) ) { 
loading . row ( line , n ) ; 
} private static char [ ] tail ( String str ) { 
char [ ] cs = new char [ str . length ( ) - 1 ] ; 
str . getChars ( 1 , str . length ( ) , cs , 0 ) ; 
} private synchronized void addLastTime ( File wordsFile ) { 
if ( wordsFile != null ) { 
wordsLastTime . put ( wordsFile , wordsFile . lastModified ( ) ) ; 
} public synchronized boolean wordsFileIsChange ( ) { 
for ( Entry < File , Long > flt : wordsLastTime . entrySet ( ) ) { 
File words = flt . getKey ( ) ; 
if ( ! words . canRead ( ) ) { 
if ( words . lastModified ( ) > flt . getValue ( ) ) { 
File [ ] words = listWordsFiles ( ) ; 
if ( words != null ) { 
for ( File wordsFile : words ) { 
if ( ! wordsLastTime . containsKey ( wordsFile ) ) { 
} public synchronized boolean reload ( ) { 
Map < File , Long > oldWordsLastTime = new HashMap < File , Long > ( wordsLastTime ) ; 
Map < Character , CharNode > oldDict = dict ; 
Map < Character , Object > oldUnit = unit ; 
wordsLastTime . clear ( ) ; 
dict = loadDic ( dicPath ) ; 
unit = loadUnit ( dicPath ) ; 
lastLoadTime = System . currentTimeMillis ( ) ; 
wordsLastTime . putAll ( oldWordsLastTime ) ; 
dict = oldDict ; 
unit = oldUnit ; 
if ( log . isLoggable ( Level . WARNING ) ) { 
} public boolean match ( String word ) { 
if ( word == null || word . length ( ) < 2 ) { 
CharNode cn = dict . get ( word . charAt ( 0 ) ) ; 
return search ( cn , word . toCharArray ( ) , 0 , word . length ( ) - 1 ) >= 0 ; 
} public int search ( CharNode node , char [ ] sen , int offset , int tailLen ) { 
if ( node != null ) { 
return node . indexOf ( sen , offset , tailLen ) ; 
} public static File getDefalutPath ( ) { 
if ( defalutPath == null ) { 
String defPath = System . getProperty ( "mmseg.dic.path" ) ; 
if ( defPath == null ) { 
URL url = Dictionary . class . getClassLoader ( ) . getResource ( "data" ) ; 
defPath = url . getFile ( ) ; 
defPath = System . getProperty ( "user.dir" ) + "/data" ; 
defalutPath = new File ( defPath ) ; 
if ( ! defalutPath . exists ( ) ) { 
return defalutPath ; 
} private int readChars ( StringBuilder bufSentence , ReadChar readChar ) throws IOException { 
int data = - 1 ; 
while ( ( data = readNext ( ) ) != - 1 ) { 
int d = readChar . transform ( data ) ; 
if ( readChar . isRead ( d ) ) { 
bufSentence . appendCodePoint ( d ) ; 
num ++ ; 
pushBack ( data ) ; 
return num ; 
} private static char [ ] toChars ( StringBuilder bufSentence ) { 
char [ ] chs = new char [ bufSentence . length ( ) ] ; 
bufSentence . getChars ( 0 , bufSentence . length ( ) , chs , 0 ) ; 
return chs ; 
} private static int toAscii ( int codePoint ) { 
if ( ( codePoint >= 65296 && codePoint <= 65305 ) 
|| ( codePoint >= 65313 && codePoint <= 65338 ) 
|| ( codePoint >= 65345 && codePoint <= 65370 ) 
codePoint -= 65248 ; 
return codePoint ; 
System . out . println ( "Usage:" ) ; 
Seg seg = null ; 
Dictionary dic = Dictionary . getInstance ( ) ; 
if ( "simple" . equals ( mode ) ) { 
seg = new SimpleSeg ( dic ) ; 
seg = new ComplexSeg ( dic ) ; 
File [ ] txts = path . listFiles ( new FilenameFilter ( ) { 
return name . endsWith ( ".txt" ) ; 
long time = 0 ; 
for ( File txt : txts ) { 
MMSeg mmSeg = new MMSeg ( new InputStreamReader ( new FileInputStream ( txt ) ) , seg ) ; 
Word word = null ; 
OutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( new File ( txt . getAbsoluteFile ( ) + "." + mode + ".word" ) ) ) ; 
BufferedWriter bw = new BufferedWriter ( osw ) ; 
while ( ( word = mmSeg . next ( ) ) != null ) { 
bw . append ( new String ( word . getString ( ) ) ) . append ( "\r\n" ) ; 
time += System . currentTimeMillis ( ) - start ; 
} public int getLen ( ) { 
if ( len < 0 ) { 
len = 0 ; 
for ( Word word : words ) { 
if ( word != null ) { 
len += word . getLength ( ) ; 
} public int getCount ( ) { 
} public double getVariance ( ) { 
if ( variance < 0 ) { 
sum += Math . pow ( word . getLength ( ) - getAvgLen ( ) , 2 ) ; 
variance = sum / getCount ( ) ; 
return variance ; 
} public int getSumDegree ( ) { 
if ( sumDegree < 0 ) { 
if ( word != null && word . getDegree ( ) > - 1 ) { 
sum += word . getDegree ( ) ; 
sumDegree = sum ; 
return sumDegree ; 
} protected void printChunk ( List < Chunk > chunks ) { 
for ( Chunk ck : chunks ) { 
} protected int search ( char [ ] chs , int offset , int tailLen ) { 
if ( tailLen == 0 ) { 
CharNode cn = dic . head ( chs [ offset ] ) ; 
return search ( cn , chs , offset , tailLen ) ; 
} protected int search ( CharNode cn , char [ ] chs , int offset , int tailLen ) { 
if ( tailLen == 0 || cn == null ) { 
return dic . search ( cn , chs , offset , tailLen ) ; 
} protected int maxMatch ( CharNode [ ] cns , int cnIdx , char [ ] chs , int offset ) { 
CharNode cn = null ; 
if ( offset < chs . length ) { 
cn = dic . head ( chs [ offset ] ) ; 
cns [ cnIdx ] = cn ; 
return dic . maxMatch ( cn , chs , offset ) ; 
} protected void maxMatch ( CharNode [ ] cns , int cnIdx , char [ ] chs , int offset , ArrayList < Integer > [ ] tailLens , int tailLensIdx ) { 
dic . maxMatch ( cn , tailLens [ tailLensIdx ] , chs , offset ) ; 
String words = "sogou/SogouLabDic.dic" ; 
String charset = "GBK" ; 
words = args [ 0 ] ; 
File file = new File ( words ) ; 
File dist = new File ( "dic/word-with-attr.dic" ) ; 
DicTransform dt = new DicTransform ( ) ; 
dt . transform ( file , charset , dist , new NoAttr ( ) ) ; 
public boolean connectJdbcOnWithUrlAndDriverAndUsernameAndPassword ( String dataBaseId , String url , String driverClassName , String username , String password ) throws ReflectiveOperationException { 
SimpleDriverDataSource dataSource = new SimpleDriverDataSource ( ) ; 
dataSource . setUrl ( url ) ; 
dataSource . setDriverClass ( ( Class < Driver > ) Class . forName ( driverClassName ) ) ; 
this . templateMap . put ( dataBaseId , new JdbcTemplate ( dataSource ) ) ; 
} public boolean runInTheSql ( String database , final String sql ) { 
getDatabaseJdbcTemplate ( database ) . update ( sql ) ; 
} public String queryInWithSql ( String database , String sql ) { 
JdbcTemplate template = getDatabaseJdbcTemplate ( database ) ; 
if ( sql != null && ! sql . trim ( ) . toUpperCase ( ) . startsWith ( JdbcFixture . SELECT_COMMAND_PREFIX ) ) { 
return Objects . toString ( template . update ( sql ) ) ; 
List < String > results = template . queryForList ( sql , String . class ) ; 
if ( results == null || results . isEmpty ( ) ) { 
return results . get ( 0 ) ; 
public void postProcessInstance ( ManagedClassSPI managedClass , Object instance ) { 
if ( ! managedClass . getInstanceScope ( ) . equals ( InstanceScope . APPLICATION ) ) { 
if ( ! managedClass . getInstanceType ( ) . equals ( InstanceType . PROXY ) ) { 
Class < ? > [ ] interfaceClasses = managedClass . getInterfaceClasses ( ) ; 
StringBuilder interfaceNames = new StringBuilder ( interfaceClasses [ 0 ] . getName ( ) ) ; 
for ( int i = 1 ; i < interfaceClasses . length ; ++ i ) { 
interfaceNames . append ( interfaceClasses [ i ] . getName ( ) ) ; 
} public boolean isEndReached ( ) { 
if ( to == null || from == null ) { 
if ( length == null ) { 
return to == length - 1 ; 
public Object [ ] read ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException , IllegalArgumentException { 
if ( formalParameters . length != 1 ) { 
if ( formalParameters [ 0 ] instanceof ParameterizedType ) { 
Class < ? > type = ( Class < ? > ) formalParameters [ 0 ] ; 
Object [ ] arguments = new Object [ 1 ] ; 
if ( type . equals ( Form . class ) ) { 
arguments [ 0 ] = new FormImpl ( httpRequest ) ; 
else if ( type . equals ( FormIterator . class ) ) { 
arguments [ 0 ] = new FormIteratorImpl ( httpRequest ) ; 
else if ( type . equals ( UploadedFile . class ) ) { 
Form form = new FormImpl ( httpRequest ) ; 
arguments [ 0 ] = form . getUploadedFile ( ) ; 
else if ( type . equals ( UploadStream . class ) ) { 
threadLocal . set ( ( Closeable ) ( arguments [ 0 ] = getUploadStream ( httpRequest , formalParameters ) ) ) ; 
else if ( type . equals ( InputStream . class ) ) { 
threadLocal . set ( ( Closeable ) ( arguments [ 0 ] = getUploadStream ( httpRequest , formalParameters ) . openStream ( ) ) ) ; 
arguments [ 0 ] = new FormObject ( httpRequest , type ) . getValue ( ) ; 
return arguments ; 
} private static UploadStream getUploadStream ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException { 
FormIterator form = new FormIteratorImpl ( httpRequest ) ; 
if ( ! form . hasNext ( ) ) { 
Part part = form . next ( ) ; 
if ( ! ( part instanceof UploadStream ) ) { 
return ( UploadStream ) part ; 
public void init ( ServletConfig config ) throws UnavailableException { 
super . init ( config ) ; 
for ( ManagedMethodSPI managedMethod : container . getManagedMethods ( ) ) { 
if ( ! managedMethod . isRemotelyAccessible ( ) ) { 
if ( ! Types . isKindOf ( managedMethod . getReturnType ( ) , Resource . class ) ) { 
restMethods . put ( key ( managedMethod ) , managedMethod ) ; 
protected void handleRequest ( RequestContext context ) throws IOException { 
HttpServletRequest httpRequest = context . getRequest ( ) ; 
HttpServletResponse httpResponse = context . getResponse ( ) ; 
ArgumentsReader argumentsReader = null ; 
ManagedMethodSPI method = null ; 
method = restMethods . get ( key ( httpRequest . getPathInfo ( ) ) ) ; 
throw new NoSuchMethodException ( ) ; 
Type [ ] formalParameters = method . getParameterTypes ( ) ; 
argumentsReader = argumentsReaderFactory . getArgumentsReader ( httpRequest , formalParameters ) ; 
Object [ ] arguments = argumentsReader . read ( httpRequest , formalParameters ) ; 
Object instance = container . getInstance ( method . getDeclaringClass ( ) ) ; 
value = method . invoke ( instance , arguments ) ; 
} catch ( AuthorizationException e ) { 
sendUnauthorized ( context ) ; 
sendNotFound ( context , e ) ; 
sendBadRequest ( context ) ; 
} catch ( InvocationException e ) { 
sendError ( context , e ) ; 
if ( argumentsReader != null ) { 
argumentsReader . clean ( ) ; 
httpResponse . setCharacterEncoding ( "UTF-8" ) ; 
if ( method . isVoid ( ) ) { 
httpResponse . setStatus ( HttpServletResponse . SC_NO_CONTENT ) ; 
ContentType contentType = valueWriterFactory . getContentTypeForValue ( value ) ; 
httpResponse . setStatus ( HttpServletResponse . SC_OK ) ; 
httpResponse . setContentType ( contentType . getValue ( ) ) ; 
ValueWriter valueWriter = valueWriterFactory . getValueWriter ( contentType ) ; 
valueWriter . write ( httpResponse , value ) ; 
} private static String key ( String requestPath ) { 
int queryParametersIndex = requestPath . lastIndexOf ( '?' ) ; 
if ( queryParametersIndex == - 1 ) { 
queryParametersIndex = requestPath . length ( ) ; 
int extensionIndex = requestPath . lastIndexOf ( '.' , queryParametersIndex ) ; 
if ( extensionIndex == - 1 ) { 
extensionIndex = queryParametersIndex ; 
return requestPath . substring ( 0 , extensionIndex ) ; 
} public static ContentType forFile ( File file ) { 
Params . notNull ( file , "File" ) ; 
ContentType contentType = FILE_TYPES . get ( Files . getExtension ( file ) ) ; 
if ( contentType == null ) { 
contentType = TEXT_HTML ; 
} public static ContentType valueOf ( String value ) { 
return ContentType . APPLICATION_JSON ; 
return new ContentType ( value ) ; 
} public boolean hasParameter ( String name , String value ) { 
return value . equals ( parameters . get ( name ) ) ; 
} public String getParameter ( String name ) { 
return parameters . get ( name ) ; 
} private static Map < String , String > parseParameters ( String expression ) { 
Map < String , String > parameters = new HashMap < > ( ) ; 
int parametersSeparatorIndex = 0 ; 
int valueSeparatorIndex = expression . indexOf ( '=' , parametersSeparatorIndex ) ; 
if ( valueSeparatorIndex == - 1 ) { 
String name = expression . substring ( parametersSeparatorIndex , valueSeparatorIndex ) . trim ( ) ; 
++ valueSeparatorIndex ; 
parametersSeparatorIndex = expression . indexOf ( ';' , valueSeparatorIndex ) ; 
if ( parametersSeparatorIndex == - 1 ) { 
parametersSeparatorIndex = expression . length ( ) ; 
if ( valueSeparatorIndex == parametersSeparatorIndex ) { 
if ( parameters . put ( name , expression . substring ( valueSeparatorIndex , parametersSeparatorIndex ) . trim ( ) ) != null ) { 
++ parametersSeparatorIndex ; 
if ( parameters . isEmpty ( ) ) { 
return parameters ; 
public void config ( Config config ) throws Exception { 
log . trace ( "config(Config.Element)" ) ; 
transactionManager . config ( config ) ; 
Config config = managedClass . getConfig ( ) ; 
if ( config == null ) { 
List < Config > fields = config . findChildren ( "instance-field" ) ; 
if ( ! fields . isEmpty ( ) && ! InstanceType . POJO . equals ( managedClass . getInstanceType ( ) ) ) { 
for ( Config field : fields ) { 
Classes . setFieldValue ( instance , field . getAttribute ( "name" ) , field . getAttribute ( "value" ) ) ; 
} private void scanAnnotations ( ) { 
boolean remoteType = false ; 
Controller controllerAnnotation = getAnnotation ( implementationClass , Controller . class ) ; 
if ( controllerAnnotation != null ) { 
remoteType = true ; 
requestPath = controllerAnnotation . value ( ) ; 
Service serviceAnnotation = getAnnotation ( implementationClass , Service . class ) ; 
if ( serviceAnnotation != null ) { 
requestPath = serviceAnnotation . value ( ) ; 
Remote remoteAnnotation = getAnnotation ( implementationClass , Remote . class ) ; 
if ( remoteAnnotation != null ) { 
RequestPath requestPathAnnotation = getAnnotation ( implementationClass , RequestPath . class ) ; 
if ( requestPathAnnotation != null ) { 
requestPath = requestPathAnnotation . value ( ) ; 
if ( requestPath != null && requestPath . isEmpty ( ) ) { 
requestPath = null ; 
if ( remoteType ) { 
remotelyAccessible = true ; 
boolean transactionalType = hasAnnotation ( implementationClass , Transactional . class ) ; 
boolean immutableType = hasAnnotation ( implementationClass , Immutable . class ) ; 
if ( ! transactionalType && immutableType ) { 
if ( transactionalType && ! instanceType . isPROXY ( ) ) { 
Class < ? extends Interceptor > classInterceptor = getInterceptorClass ( implementationClass ) ; 
boolean publicType = hasAnnotation ( implementationClass , Public . class ) ; 
for ( Method method : implementationClass . getDeclaredMethods ( ) ) { 
final int modifiers = method . getModifiers ( ) ; 
if ( Modifier . isStatic ( modifiers ) || ! Modifier . isPublic ( modifiers ) ) { 
Method interfaceMethod = getInterfaceMethod ( method ) ; 
ManagedMethod managedMethod = null ; 
boolean remoteMethod = hasAnnotation ( method , Remote . class ) ; 
if ( ! remoteMethod ) { 
remoteMethod = remoteType ; 
if ( hasAnnotation ( method , Local . class ) ) { 
remoteMethod = false ; 
if ( remoteMethod ) { 
Class < ? extends Interceptor > methodInterceptor = getInterceptorClass ( method ) ; 
if ( methodInterceptor == null ) { 
methodInterceptor = classInterceptor ; 
if ( methodInterceptor != null ) { 
if ( ! instanceType . isPROXY ( ) && ! remotelyAccessible ) { 
managedMethod = new ManagedMethod ( this , methodInterceptor , interfaceMethod ) ; 
boolean publicMethod = hasAnnotation ( method , Public . class ) ; 
if ( publicMethod && ! remotelyAccessible ) { 
if ( ! publicMethod ) { 
publicMethod = publicType ; 
if ( hasAnnotation ( method , Private . class ) ) { 
if ( ! remotelyAccessible ) { 
publicMethod = false ; 
RequestPath methodPath = getAnnotation ( method , RequestPath . class ) ; 
if ( ! remotelyAccessible && methodPath != null ) { 
if ( managedMethod == null ) { 
managedMethod = new ManagedMethod ( this , interfaceMethod ) ; 
managedMethod . setRequestPath ( methodPath != null ? methodPath . value ( ) : null ) ; 
managedMethod . setRemotelyAccessible ( remoteMethod ) ; 
managedMethod . setAccess ( publicMethod ? Access . PUBLIC : Access . PRIVATE ) ; 
if ( ! transactionalType ) { 
transactionalType = hasAnnotation ( method , Transactional . class ) ; 
if ( transactionalType ) { 
transactional = true ; 
if ( ! instanceType . isPROXY ( ) ) { 
boolean immutable = hasAnnotation ( method , Immutable . class ) ; 
if ( immutable && ! transactional ) { 
if ( ! immutable ) { 
immutable = immutableType ; 
if ( hasAnnotation ( method , Mutable . class ) ) { 
if ( ! transactional ) { 
immutable = false ; 
if ( instanceType . isPROXY ( ) && managedMethod == null ) { 
if ( transactional ) { 
managedMethod . setTransactional ( true ) ; 
managedMethod . setImmutable ( immutable ) ; 
boolean asynchronousMethod = hasAnnotation ( method , Asynchronous . class ) ; 
if ( asynchronousMethod ) { 
if ( ! Types . isVoid ( method . getReturnType ( ) ) ) { 
managedMethod . setAsynchronous ( asynchronousMethod ) ; 
Cron cronMethod = getAnnotation ( method , Cron . class ) ; 
if ( cronMethod != null ) { 
if ( remotelyAccessible ) { 
managedMethod . setCronExpression ( cronMethod . value ( ) ) ; 
cronMethodsPool . add ( managedMethod ) ; 
autoInstanceCreation = true ; 
if ( managedMethod != null ) { 
methodsPool . put ( interfaceMethod , managedMethod ) ; 
if ( managedMethod . isRemotelyAccessible ( ) && netMethodsPool . put ( method . getName ( ) , managedMethod ) != null ) { 
for ( Field field : implementationClass . getDeclaredFields ( ) ) { 
ContextParam contextParam = field . getAnnotation ( ContextParam . class ) ; 
if ( contextParam != null ) { 
contextParamFields . put ( contextParam . value ( ) , field ) ; 
} private Class < ? > loadImplementationClass ( Config descriptor ) throws ConfigException { 
String implementationName = descriptor . getAttribute ( "class" ) ; 
if ( implementationName == null ) { 
if ( instanceType . requiresImplementation ( ) ) { 
if ( ! instanceType . requiresImplementation ( ) ) { 
Class < ? > implementationClass = Classes . forOptionalName ( implementationName ) ; 
if ( implementationClass == null ) { 
if ( implementationClass . isInterface ( ) ) { 
int implementationModifiers = implementationClass . getModifiers ( ) ; 
if ( Modifier . isAbstract ( implementationModifiers ) ) { 
if ( Types . isKindOf ( implementationClass , ManagedLifeCycle . class ) && ! InstanceScope . APPLICATION . equals ( instanceScope ) ) { 
return implementationClass ; 
} private Class < ? > [ ] loadInterfaceClasses ( Config descriptor ) throws ConfigException { 
List < String > interfaceNames = new ArrayList < > ( ) ; 
if ( ! descriptor . hasChildren ( ) ) { 
if ( ! descriptor . hasAttribute ( "interface" ) ) { 
if ( instanceType . requiresInterface ( ) ) { 
return new Class < ? > [ ] { implementationClass } ; 
interfaceNames . add ( descriptor . getAttribute ( "interface" ) ) ; 
if ( "REMOTE" . equals ( descriptor . getAttribute ( "type" ) ) ) { 
String url = descriptor . getAttribute ( "url" ) ; 
if ( url == null || url . isEmpty ( ) ) { 
if ( url . startsWith ( "${" ) ) { 
for ( int i = 0 ; i < descriptor . getChildrenCount ( ) ; ++ i ) { 
String interfaceName = descriptor . getChild ( i ) . getAttribute ( "name" ) ; 
if ( interfaceName == null ) { 
interfaceNames . add ( interfaceName ) ; 
Class < ? > [ ] interfaceClasses = new Class < ? > [ interfaceNames . size ( ) ] ; 
for ( int i = 0 ; i < interfaceNames . size ( ) ; ++ i ) { 
final String interfaceName = interfaceNames . get ( i ) ; 
final Class < ? > interfaceClass = Classes . forOptionalName ( interfaceName ) ; 
if ( interfaceClass == null ) { 
if ( Types . isKindOf ( interfaceClass , ManagedLifeCycle . class ) ) { 
if ( instanceType . requiresInterface ( ) && ! interfaceClass . isInterface ( ) ) { 
if ( implementationClass != null && ! Types . isKindOf ( implementationClass , interfaceClass ) ) { 
interfaceClasses [ i ] = interfaceClass ; 
return interfaceClasses ; 
} private InstanceScope loadInstanceScope ( Config descriptor ) throws ConfigException { 
InstanceScope instanceScope = descriptor . getAttribute ( "scope" , InstanceScope . class , InstanceScope . APPLICATION ) ; 
if ( ! container . hasScopeFactory ( instanceScope ) ) { 
return instanceScope ; 
} private InstanceType loadInstanceType ( Config descriptor ) throws ConfigException { 
InstanceType instanceType = descriptor . getAttribute ( "type" , InstanceType . class , InstanceType . POJO ) ; 
if ( ! container . hasInstanceFactory ( instanceType ) ) { 
return instanceType ; 
} private String loadImplementationURL ( Config descriptor ) throws ConfigException { 
String implementationURL = descriptor . getAttribute ( "url" ) ; 
if ( instanceType . equals ( InstanceType . REMOTE ) && implementationURL == null ) { 
return implementationURL ; 
} private static Constructor < ? > getDeclaredConstructor ( Class < ? > implementationClass ) { 
Constructor < ? > [ ] declaredConstructors = ( Constructor < ? > [ ] ) implementationClass . getDeclaredConstructors ( ) ; 
if ( declaredConstructors . length == 0 ) { 
for ( Constructor < ? > declaredConstructor : declaredConstructors ) { 
if ( declaredConstructor . isSynthetic ( ) ) { 
if ( declaredConstructor . getParameterTypes ( ) . length == 0 ) { 
if ( declaredConstructor . getAnnotation ( Test . class ) != null ) { 
if ( constructor != null ) { 
constructor = declaredConstructor ; 
constructor = declaredConstructors [ 0 ] ; 
constructor . setAccessible ( true ) ; 
return constructor ; 
} private static Collection < Field > scanDependencies ( Class < ? > clazz ) { 
Collection < Field > dependencies = new ArrayList < > ( ) ; 
for ( Field field : clazz . getDeclaredFields ( ) ) { 
if ( ! field . isAnnotationPresent ( Inject . class ) ) { 
if ( Modifier . isFinal ( field . getModifiers ( ) ) ) { 
if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { 
dependencies . add ( field ) ; 
return dependencies ; 
} private void initializeStaticFields ( ) throws ConfigException { 
for ( Config config : config . findChildren ( "static-field" ) ) { 
String fieldName = config . getAttribute ( "name" ) ; 
if ( fieldName == null ) { 
if ( ! config . hasAttribute ( "value" ) ) { 
Field field = Classes . getOptionalField ( implementationClass , fieldName ) ; 
if ( field == null ) { 
int modifiers = field . getModifiers ( ) ; 
if ( ! Modifier . isStatic ( modifiers ) ) { 
Object value = config . getAttribute ( "value" , field . getType ( ) ) ; 
Classes . setFieldValue ( null , field , config . getAttribute ( "value" , field . getType ( ) ) ) ; 
} private String buildStringRepresentation ( Config descriptor ) { 
builder . append ( descriptor . getName ( ) ) ; 
builder . append ( ':' ) ; 
if ( implementationClass != null ) { 
builder . append ( implementationClass . getName ( ) ) ; 
for ( Class < ? > interfaceClass : interfaceClasses ) { 
builder . append ( interfaceClass . getName ( ) ) ; 
builder . append ( instanceType ) ; 
builder . append ( instanceScope ) ; 
builder . append ( remotelyAccessible ? "NET" : "LOCAL" ) ; 
if ( implementationURL != null ) { 
builder . append ( implementationURL ) ; 
} private static < T extends Annotation > T getAnnotation ( Class < ? > clazz , Class < T > annotationClass ) { 
T annotation = clazz . getAnnotation ( annotationClass ) ; 
for ( Class < ? > interfaceClass : clazz . getInterfaces ( ) ) { 
annotation = interfaceClass . getAnnotation ( annotationClass ) ; 
if ( annotation != null ) { 
return annotation ; 
} private static boolean hasAnnotation ( Class < ? > clazz , Class < ? extends Annotation > annotationClass ) { 
Annotation annotation = clazz . getAnnotation ( annotationClass ) ; 
} private static < T extends Annotation > T getAnnotation ( Method method , Class < T > annotationClass ) { 
T annotation = method . getAnnotation ( annotationClass ) ; 
for ( Class < ? > interfaceClass : method . getDeclaringClass ( ) . getInterfaces ( ) ) { 
annotation = interfaceClass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) . getAnnotation ( annotationClass ) ; 
} catch ( NoSuchMethodException unused ) { 
} private static Method getInterfaceMethod ( Method method ) { 
return interfaceClass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; 
} private static Class < ? extends Interceptor > getInterceptorClass ( Class < ? > clazz ) { 
Intercepted intercepted = getAnnotation ( clazz , Intercepted . class ) ; 
return intercepted != null ? intercepted . value ( ) : null ; 
} private static Class < ? extends Interceptor > getInterceptorClass ( Method method ) { 
Intercepted intercepted = getAnnotation ( method , Intercepted . class ) ; 
} private void setValue ( String propertyPath , Object value ) throws ConverterException , IllegalAccessException { 
List < String > nodeIDs = Strings . split ( propertyPath , '.' ) ; 
int lastNodeIndex = nodeIDs . size ( ) - 1 ; 
Node node = new ObjectNode ( object ) ; 
for ( int index = 0 ; index < lastNodeIndex ; index ++ ) { 
node = node . getChild ( nodeIDs . get ( index ) ) ; 
node . setValue ( nodeIDs . get ( lastNodeIndex ) , value ) ; 
} private static Class < ? > type ( Field field ) { 
if ( Types . isKindOf ( field . getType ( ) , List . class ) ) { 
return ( Class < ? > ) ( ( ParameterizedType ) field . getGenericType ( ) ) . getActualTypeArguments ( ) [ 0 ] ; 
return field . getType ( ) ; 
protected static Object getDependencyValue ( ManagedClassSPI hostManagedClass , Class < ? > type ) { 
Stack < Class < ? > > stackTrace = dependenciesStack . get ( ) ; 
if ( stackTrace == null ) { 
stackTrace = new Stack < > ( ) ; 
dependenciesStack . set ( stackTrace ) ; 
ContainerSPI container = hostManagedClass . getContainer ( ) ; 
if ( stackTrace . contains ( type ) ) { 
stackTrace . add ( type ) ; 
for ( Class < ? > stackTraceClass : stackTrace ) { 
builder . append ( stackTraceClass . getName ( ) ) ; 
builder . append ( "\r\n" ) ; 
log . error ( builder . toString ( ) ) ; 
dependenciesStack . remove ( ) ; 
stackTrace . push ( type ) ; 
ManagedClassSPI dependencyManagedClass = container . getManagedClass ( type ) ; 
if ( isProxyRequired ( hostManagedClass , dependencyManagedClass ) ) { 
ScopeProxyHandler < ? > handler = new ScopeProxyHandler < > ( container , type ) ; 
return Proxy . newProxyInstance ( dependencyManagedClass . getImplementationClass ( ) . getClassLoader ( ) , dependencyManagedClass . getInterfaceClasses ( ) , handler ) ; 
Object value = container . getOptionalInstance ( ( Class < ? super Object > ) type ) ; 
if ( Types . isKindOf ( type , AppFactory . class ) ) { 
return container ; 
if ( Classes . isInstantiable ( type ) ) { 
return Classes . newInstance ( type ) ; 
stackTrace . pop ( ) ; 
} private static boolean isProxyRequired ( ManagedClassSPI hostManagedClass , ManagedClassSPI dependencyManagedClass ) { 
if ( dependencyManagedClass != null ) { 
InstanceScope dependencyScope = dependencyManagedClass . getInstanceScope ( ) ; 
if ( InstanceScope . THREAD . equals ( dependencyScope ) ) { 
return InstanceScope . APPLICATION . equals ( hostManagedClass . getInstanceScope ( ) ) ; 
return InstanceScope . SESSION . equals ( dependencyScope ) ; 
} StoppableObservable < TEntity > getObservable ( Scheduler scheduler ) { 
return runAsync ( scheduler , ( rx . Observer < ? super TEntity > observer , Subscription subscription ) -> { 
TEntity previousEntity ; 
previousEntity = read ( ) ; 
} catch ( IOException | IllegalArgumentException | IllegalAccessException ex ) { 
observer . onNext ( previousEntity ) ; 
while ( endCondition == null || ! endCondition . test ( previousEntity ) ) { 
sleep ( pollingInterval * 1000 ) ; 
if ( subscription . isUnsubscribed ( ) ) { 
TEntity newEntity ; 
newEntity = read ( ) ; 
if ( ! newEntity . equals ( previousEntity ) ) { 
observer . onNext ( newEntity ) ; 
previousEntity = newEntity ; 
observer . onCompleted ( ) ; 
} public final void setDefaultLink ( String rel , String ... hrefs ) { 
if ( hrefs == null || hrefs . length == 0 ) { 
defaultLinks . remove ( rel ) ; 
defaultLinks . put ( rel , 
stream ( hrefs ) . map ( uri :: resolve ) . collect ( toSet ( ) ) ) ; 
} public final void setDefaultLinkTemplate ( String rel , String href ) { 
if ( href == null ) { 
defaultLinkTemplates . remove ( rel ) ; 
defaultLinkTemplates . put ( rel , href ) ; 
} protected HttpResponse executeAndHandle ( Request request ) 
throws IOException , IllegalArgumentException , IllegalAccessException , FileNotFoundException , IllegalStateException { 
HttpResponse response = execute ( request ) ; 
handleResponse ( response , request ) ; 
} protected HttpResponse execute ( Request request ) 
defaultHeaders . forEach ( request :: addHeader ) ; 
return executor . execute ( request ) . returnResponse ( ) ; 
} protected void handleResponse ( HttpResponse response , Request request ) 
handleLinks ( response ) ; 
handleCapabilities ( response ) ; 
handleErrors ( response , request ) ; 
} protected void handleErrors ( HttpResponse response , Request request ) 
StatusLine statusLine = response . getStatusLine ( ) ; 
if ( statusLine . getStatusCode ( ) <= 299 ) { 
HttpEntity entity = response . getEntity ( ) ; 
String body ; 
if ( entity == null ) { 
body = null ; 
body = EntityUtils . toString ( entity ) ; 
Header contentType = entity . getContentType ( ) ; 
if ( ( contentType != null ) && contentType . getValue ( ) . startsWith ( "application/json" ) ) { 
JsonNode messageNode = serializer . readTree ( body ) . get ( "message" ) ; 
if ( messageNode != null ) { 
message = messageNode . asText ( ) ; 
} catch ( JsonProcessingException ex ) { 
Exception inner = ( body == null ) ? null : new HttpException ( body ) ; 
switch ( statusLine . getStatusCode ( ) ) { 
case HttpStatus . SC_BAD_REQUEST : 
throw new IllegalArgumentException ( message , inner ) ; 
case HttpStatus . SC_UNAUTHORIZED : 
throw new IllegalAccessException ( message ) ; 
case HttpStatus . SC_FORBIDDEN : 
case HttpStatus . SC_NOT_FOUND : 
case HttpStatus . SC_GONE : 
throw new FileNotFoundException ( message ) ; 
case HttpStatus . SC_CONFLICT : 
throw new IllegalStateException ( message , inner ) ; 
case HttpStatus . SC_PRECONDITION_FAILED : 
case HttpStatus . SC_REQUESTED_RANGE_NOT_SATISFIABLE : 
case HttpStatus . SC_REQUEST_TIMEOUT : 
throw new RuntimeException ( message , inner ) ; 
} @ SuppressWarnings ( "LocalVariableHidesMemberVariable" ) 
private void handleLinks ( HttpResponse response ) { 
Map < String , Map < URI , String > > links = new HashMap < > ( ) ; 
Map < String , String > linkTemplates = new HashMap < > ( ) ; 
handleHeaderLinks ( response , links , linkTemplates ) ; 
handleBodyLinks ( serializer . readTree ( entity . getContent ( ) ) , links , linkTemplates ) ; 
throw new RuntimeException ( ) ; 
this . links = unmodifiableMap ( links ) ; 
this . linkTemplates = unmodifiableMap ( linkTemplates ) ; 
} protected void handleHeaderLinks ( HttpResponse response , Map < String , Map < URI , String > > links , Map < String , String > linkTemplates ) { 
getLinkHeaders ( response ) . forEach ( header -> { 
if ( header . getRel ( ) == null ) { 
if ( header . isTemplated ( ) ) { 
linkTemplates . put ( header . getRel ( ) , header . getHref ( ) ) ; 
getOrAdd ( links , header . getRel ( ) ) 
. put ( uri . resolve ( header . getHref ( ) ) , header . getTitle ( ) ) ; 
} protected void handleBodyLinks ( JsonNode jsonBody , Map < String , Map < URI , String > > links , Map < String , String > linkTemplates ) { 
if ( jsonBody . getNodeType ( ) != JsonNodeType . OBJECT ) { 
JsonNode linksNode = jsonBody . get ( "_links" ) ; 
if ( linksNode == null ) { 
linksNode = jsonBody . get ( "links" ) ; 
linksNode . fields ( ) . forEachRemaining ( x -> { 
String rel = x . getKey ( ) ; 
Map < URI , String > linksForRel = getOrAdd ( links , rel ) ; 
switch ( x . getValue ( ) . getNodeType ( ) ) { 
x . getValue ( ) . forEach ( subobj -> { 
if ( subobj . getNodeType ( ) == JsonNodeType . OBJECT ) { 
parseLinkObject ( rel , ( ObjectNode ) subobj , linksForRel , linkTemplates ) ; 
parseLinkObject ( rel , ( ObjectNode ) x . getValue ( ) , linksForRel , linkTemplates ) ; 
} private void parseLinkObject ( String rel , ObjectNode obj , Map < URI , String > linksForRel , Map < String , String > linkTemplates ) { 
JsonNode href = obj . findValue ( "href" ) ; 
JsonNode templated = obj . findValue ( "templated" ) ; 
if ( templated != null && templated . isBoolean ( ) && templated . asBoolean ( ) ) { 
linkTemplates . put ( rel , href . asText ( ) ) ; 
JsonNode title = obj . findValue ( "title" ) ; 
linksForRel . put ( 
uri . resolve ( href . asText ( ) ) , 
( title != null && title . getNodeType ( ) == JsonNodeType . STRING ) ? title . asText ( ) : null ) ; 
} private static Map < URI , String > getOrAdd ( Map < String , Map < URI , String > > map , String key ) { 
Map < URI , String > value = map . get ( key ) ; 
map . put ( key , value = new HashMap < > ( ) ) ; 
} protected void handleCapabilities ( HttpResponse response ) { 
allowedMethods = unmodifiableSet ( stream ( response . getHeaders ( "Allow" ) ) 
. filter ( x -> x . getName ( ) . equals ( "Allow" ) ) 
. flatMap ( x -> stream ( x . getElements ( ) ) ) . map ( x -> x . getName ( ) ) 
. collect ( toSet ( ) ) ) ; 
} protected Optional < Boolean > isMethodAllowed ( String method ) { 
if ( allowedMethods . isEmpty ( ) ) { 
return Optional . of ( allowedMethods . contains ( method ) ) ; 
} @ SuppressWarnings ( "ThrowableResultIgnored" ) 
public static String getFullMessage ( Throwable throwable ) { 
builder . append ( throwable . getLocalizedMessage ( ) ) . append ( "\n" ) ; 
throwable = throwable . getCause ( ) ; 
} while ( throwable != null ) ; 
public < T > T newInstance ( ManagedClassSPI managedClass , Object ... args ) { 
return getRemoteInstance ( managedClass . getImplementationURL ( ) , ( Class < ? super T > ) managedClass . getInterfaceClass ( ) ) ; 
public < T > T getRemoteInstance ( String implementationURL , Class < ? super T > interfaceClass ) throws UnsupportedProtocolException { 
if ( implementationURL == null ) { 
String protocol = Strings . getProtocol ( implementationURL ) ; 
RemoteFactory remoteFactory = remoteFactories . get ( protocol ) ; 
if ( remoteFactory == null ) { 
return remoteFactory . getRemoteInstance ( implementationURL , interfaceClass ) ; 
} protected void registerInstanceProcessor ( ) { 
registerInstanceProcessor ( new InstanceFieldsInjectionProcessor ( ) ) ; 
registerInstanceProcessor ( new InstanceFieldsInitializationProcessor ( ) ) ; 
registerInstanceProcessor ( new ConfigurableInstanceProcessor ( ) ) ; 
registerInstanceProcessor ( new PostConstructInstanceProcessor ( ) ) ; 
registerInstanceProcessor ( new CronMethodsProcessor ( cronManager ) ) ; 
registerInstanceProcessor ( new LoggerInstanceProcessor ( ) ) ; 
} protected void registerScopeFactory ( ScopeFactory scopeFactory ) { 
if ( scopeFactory == null ) { 
scopeFactories . put ( InstanceScope . LOCAL , null ) ; 
final InstanceScope instanceScope = scopeFactory . getInstanceScope ( ) ; 
if ( scopeFactories . put ( instanceScope , scopeFactory ) != null ) { 
} protected void registerInstanceFactory ( InstanceType instanceType , InstanceFactory instanceFactory ) { 
if ( instanceFactories . put ( instanceType , instanceFactory ) != null ) { 
} protected void registerInstanceProcessor ( InstanceProcessor instanceProcessor ) { 
for ( InstanceProcessor existingInstanceProcessoor : instanceProcessors ) { 
if ( existingInstanceProcessoor . getClass ( ) . equals ( instanceProcessor . getClass ( ) ) ) { 
instanceProcessors . add ( instanceProcessor ) ; 
} protected void registerClassProcessor ( ClassProcessor classProcessor ) { 
for ( ClassProcessor existingClassProcessoor : classProcessors ) { 
if ( existingClassProcessoor . getClass ( ) . equals ( classProcessor . getClass ( ) ) ) { 
classProcessors . add ( classProcessor ) ; 
public void config ( Config config ) throws ConfigException { 
log . trace ( "config(Config)" ) ; 
List < Config > classDescriptors = new ArrayList < > ( ) ; 
for ( Config descriptorsSection : config . findChildren ( "managed-classes" , "web-sockets" ) ) { 
CLASS_DESCRIPTORS : for ( Config classDescriptor : descriptorsSection . getChildren ( ) ) { 
if ( ! classDescriptor . hasChildren ( ) ) { 
if ( ! classDescriptor . hasAttribute ( "interface" ) ) { 
classDescriptor . setAttribute ( "interface" , classDescriptor . getAttribute ( "class" ) ) ; 
String interfaceClass = classDescriptor . getAttribute ( "interface" ) ; 
for ( int i = 0 ; i < classDescriptors . size ( ) ; ++ i ) { 
if ( classDescriptors . get ( i ) . hasAttribute ( "interface" , interfaceClass ) ) { 
classDescriptors . set ( i , classDescriptor ) ; 
continue CLASS_DESCRIPTORS ; 
classDescriptors . add ( classDescriptor ) ; 
for ( Config classDescriptor : classDescriptors ) { 
ManagedClass managedClass = new ManagedClass ( this , classDescriptor ) ; 
for ( Class < ? > interfaceClass : managedClass . getInterfaceClasses ( ) ) { 
classesPool . put ( interfaceClass , managedClass ) ; 
for ( ClassProcessor classProcessor : classProcessors ) { 
classProcessor . postProcessClass ( managedClass ) ; 
convertersInitialization ( config ) ; 
pojoStaticInitialization ( config ) ; 
ManagedClassSPI appContext = classesPool . get ( AppContext . class ) ; 
if ( appContext != null && Types . isKindOf ( appContext . getImplementationClass ( ) , ContainerSPI . class ) ) { 
scopeFactories . get ( InstanceScope . APPLICATION ) . persistInstance ( new InstanceKey ( appContext . getKey ( ) ) , this ) ; 
log . trace ( "start()" ) ; 
Set < ManagedClassSPI > sortedClasses = new TreeSet < > ( new Comparator < ManagedClassSPI > ( ) { 
public int compare ( ManagedClassSPI o1 , ManagedClassSPI o2 ) { 
return o1 . getKey ( ) . compareTo ( o2 . getKey ( ) ) ; 
for ( ManagedClassSPI managedClass : classesPool . values ( ) ) { 
if ( managedClass . isAutoInstanceCreation ( ) ) { 
sortedClasses . add ( managedClass ) ; 
for ( ManagedClassSPI managedClass : sortedClasses ) { 
getInstance ( ( Class < ? super Object > ) managedClass . getInterfaceClass ( ) ) ; 
log . trace ( "destroy()" ) ; 
cronManager . destroy ( ) ; 
return o2 . getKey ( ) . compareTo ( o1 . getKey ( ) ) ; 
if ( Types . isKindOf ( managedClass . getImplementationClass ( ) , ManagedPreDestroy . class ) ) { 
ScopeFactory scopeFactory = scopeFactories . get ( managedClass . getInstanceScope ( ) ) ; 
InstanceKey instanceKey = new InstanceKey ( managedClass . getKey ( ) ) ; 
Object instance = scopeFactory . getInstance ( instanceKey ) ; 
ManagedPreDestroy managedInstance = ( ManagedPreDestroy ) Classes . unproxy ( instance ) ; 
managedInstance . preDestroy ( ) ; 
for ( ScopeFactory scopeFactory : scopeFactories . values ( ) ) { 
if ( scopeFactory != null ) { 
scopeFactory . clear ( ) ; 
classesPool . clear ( ) ; 
instanceProcessors . clear ( ) ; 
scopeFactories . clear ( ) ; 
instanceFactories . clear ( ) ; 
public < T > T getInstance ( Class < ? super T > interfaceClass , Object ... args ) { 
ManagedClassSPI managedClass = classesPool . get ( interfaceClass ) ; 
if ( managedClass == null ) { 
return getInstance ( managedClass , instanceKey , args ) ; 
private < T > T getInstance ( ManagedClassSPI managedClass , InstanceKey instanceKey , Object ... args ) { 
InstanceFactory instanceFactory = instanceFactories . get ( managedClass . getInstanceType ( ) ) ; 
args = argumentsProcessor . preProcessArguments ( managedClass , args ) ; 
return instanceFactory . newInstance ( managedClass , args ) ; 
boolean postProcessingEnabled = false ; 
Object instance = null ; 
synchronized ( scopeMutex ) { 
instance = scopeFactory . getInstance ( instanceKey ) ; 
postProcessingEnabled = true ; 
instance = instanceFactory . newInstance ( managedClass , args ) ; 
scopeFactory . persistInstance ( instanceKey , instance ) ; 
if ( ! postProcessingEnabled ) { 
return ( T ) instance ; 
Object pojoInstance = null ; 
if ( instance instanceof Proxy ) { 
if ( Proxy . getInvocationHandler ( instance ) instanceof InstanceInvocationHandler ) { 
InstanceInvocationHandler < T > handler = ( InstanceInvocationHandler < T > ) Proxy . getInvocationHandler ( instance ) ; 
pojoInstance = handler . getWrappedInstance ( ) ; 
pojoInstance = instance ; 
if ( pojoInstance != null ) { 
for ( InstanceProcessor instanceProcessor : instanceProcessors ) { 
instanceProcessor . postProcessInstance ( managedClass , pojoInstance ) ; 
} private static void convertersInitialization ( Config config ) throws ConfigException { 
Config section = config . getChild ( "converters" ) ; 
for ( Config el : section . findChildren ( "type" ) ) { 
String className = el . getAttribute ( "class" ) ; 
Class < ? > valueType = Classes . forOptionalName ( className ) ; 
if ( valueType == null ) { 
String converterName = el . getAttribute ( "converter" ) ; 
Class < ? extends Converter > converterClass = Classes . forOptionalName ( converterName ) ; 
if ( converterClass == null ) { 
ConverterRegistry . getInstance ( ) . registerConverter ( valueType , converterClass ) ; 
} private static void pojoStaticInitialization ( Config config ) throws ConfigException { 
Config pojoClassesSection = config . getChild ( "pojo-classes" ) ; 
if ( pojoClassesSection == null ) { 
for ( Config pojoClassElement : pojoClassesSection . getChildren ( ) ) { 
String pojoClassName = pojoClassElement . getAttribute ( "class" ) ; 
if ( pojoClassName == null ) { 
Config configSection = config . getChild ( pojoClassElement . getName ( ) ) ; 
Class < ? > pojoClass = Classes . forOptionalName ( pojoClassName ) ; 
if ( pojoClass == null ) { 
if ( configSection == null ) { 
for ( Config staticElement : configSection . findChildren ( "static-field" ) ) { 
String fieldName = staticElement . getAttribute ( "name" ) ; 
if ( ! staticElement . hasAttribute ( "value" ) ) { 
Field staticField = Classes . getOptionalField ( pojoClass , fieldName ) ; 
if ( staticField == null ) { 
int modifiers = staticField . getModifiers ( ) ; 
Object value = staticElement . getAttribute ( "value" , staticField . getType ( ) ) ; 
Classes . setFieldValue ( null , staticField , value ) ; 
for ( Field dependency : managedClass . getDependencies ( ) ) { 
if ( dependency . isSynthetic ( ) ) { 
Classes . setFieldValue ( instance , dependency , getDependencyValue ( managedClass , dependency . getType ( ) ) ) ; 
} void setRequestPath ( String requestPath ) { 
this . requestPath = requestPath != null ? requestPath : Strings . toDashCase ( method . getName ( ) ) ; 
public < T > T invoke ( Object object , Object ... args ) throws AuthorizationException , IllegalArgumentException , InvocationException { 
if ( remotelyAccessible && ! isPublic ( ) && ! container . isAuthenticated ( ) ) { 
throw new AuthorizationException ( ) ; 
args = argumentsProcessor . preProcessArguments ( this , args ) ; 
if ( object instanceof Proxy ) { 
return ( T ) method . invoke ( object , args ) ; 
throw new InvocationException ( e . getTargetException ( ) ) ; 
if ( meter == null ) { 
return ( T ) invoker . invoke ( object , args ) ; 
meter . incrementInvocationsCount ( ) ; 
meter . startProcessing ( ) ; 
T returnValue = null ; 
returnValue = ( T ) invoker . invoke ( object , args ) ; 
meter . incrementExceptionsCount ( ) ; 
meter . stopProcessing ( ) ; 
if ( currentPart != null ) { 
currentPart . close ( ) ; 
if ( ! fileItemIterator . hasNext ( ) ) { 
FileItemStream fileItemStream = fileItemIterator . next ( ) ; 
if ( fileItemStream . isFormField ( ) ) { 
currentPart = new FormFieldImpl ( fileItemStream ) ; 
currentPart = new UploadStreamImpl ( fileItemStream ) ; 
} catch ( IOException | FileUploadException e ) { 
log . error ( e ) ; 
public ArgumentsReader getArgumentsReader ( HttpServletRequest httpRequest , Type [ ] formalParameters ) { 
if ( formalParameters . length == 0 ) { 
return EmptyArgumentsReader . getInstance ( ) ; 
if ( httpRequest . getQueryString ( ) != null ) { 
return readers . get ( null ) ; 
return getArgumentsReader ( httpRequest . getContentType ( ) , formalParameters [ 0 ] ) ; 
} private ArgumentsReader getArgumentsReader ( String contentType , Type parameterType ) { 
return readers . get ( EncoderKey . APPLICATION_JSON ) ; 
EncoderKey key = new EncoderKey ( ContentType . valueOf ( contentType ) , parameterType ) ; 
ArgumentsReader reader = readers . get ( key ) ; 
if ( reader != null ) { 
return reader ; 
key = new EncoderKey ( ContentType . valueOf ( contentType ) ) ; 
reader = readers . get ( key ) ; 
if ( reader == null ) { 
public ContentType getContentTypeForValue ( Object value ) { 
if ( value instanceof Document ) { 
return ContentType . TEXT_XML ; 
if ( value instanceof StreamHandler ) { 
return ContentType . APPLICATION_STREAM ; 
public ValueWriter getValueWriter ( ContentType contentType ) { 
ValueWriter writer = writers . get ( contentType ) ; 
return writer ; 
} StoppableObservable < TEntity > getObservable ( final long startIndex , Scheduler scheduler ) { 
long currentStartIndex = startIndex ; 
while ( ! subscription . isUnsubscribed ( ) ) { 
PartialResponse < TEntity > response ; 
response = ( currentStartIndex >= 0 ) 
? readRange ( currentStartIndex , null ) 
: readRange ( null , - currentStartIndex ) ; 
} catch ( IllegalStateException ex ) { 
} catch ( IOException | IllegalArgumentException | IllegalAccessException error ) { 
observer . onError ( error ) ; 
response . getElements ( ) . stream ( ) . forEach ( observer :: onNext ) ; 
if ( response . isEndReached ( ) ) { 
currentStartIndex = response . getTo ( ) + 1 ; 
public < T > T asObject ( String string , Class < T > valueType ) { 
return ( T ) new InstanceScope ( string ) ; 
} private void setField ( Field field , String parameterName , Object instance ) { 
final Object value = context . getProperty ( parameterName , field . getType ( ) ) ; 
field . set ( instance , value ) ; 
throw new BugError ( e ) ; 
Object [ ] arguments = new Object [ formalParameters . length ] ; 
int argumentIndex = 0 ; 
ServletFileUpload multipart = new ServletFileUpload ( ) ; 
FileItemIterator iterator = multipart . getItemIterator ( httpRequest ) ; 
FileItemStream fileItemStream = null ; 
fileItemStream = iterator . next ( ) ; 
String contentType = fileItemStream . getContentType ( ) ; 
Type parameterType = formalParameters [ argumentIndex ] ; 
ArgumentPartReader reader = argumentsReaderFactory . getArgumentPartReader ( contentType , parameterType ) ; 
boolean streamArgument = StreamFactory . isStream ( parameterType ) ; 
ArgumentPartReader argumentPartReader = ( ArgumentPartReader ) reader ; 
InputStream inputStream = streamArgument ? new LazyFileItemStream ( fileItemStream ) : fileItemStream . openStream ( ) ; 
arguments [ argumentIndex ] = argumentPartReader . read ( inputStream , parameterType ) ; 
++ argumentIndex ; 
if ( streamArgument ) { 
threadLocal . set ( inputStream ) ; 
if ( argumentIndex != formalParameters . length ) { 
protected void serialize ( OutputStream outputStream ) throws IOException { 
Writer writer = new BufferedWriter ( new OutputStreamWriter ( outputStream , "UTF-8" ) ) ; 
TemplateEngine templateEngine = Classes . loadService ( TemplateEngine . class ) ; 
Template template = templateEngine . getTemplate ( meta . getTemplateFile ( ) ) ; 
boolean operatorSerialization = Boolean . parseBoolean ( meta . getProperty ( OPERATOR_SERIALIZATION ) ) ; 
if ( operatorSerialization ) { 
template . setProperty ( "js.template.serialize.operator" , true ) ; 
template . serialize ( model , writer ) ; 
public < T > T asObject ( String string , Class < T > valueType ) throws IllegalArgumentException , ConverterException { 
return ( T ) new InstanceType ( string ) ; 
return new Object [ ] { read ( httpRequest . getInputStream ( ) , formalParameters [ 0 ] ) } ; 
public Object read ( InputStream inputStream , Type type ) throws IOException { 
if ( Types . isKindOf ( type , Document . class ) ) { 
return documentBuilder . loadXML ( inputStream ) ; 
} else if ( Types . isKindOf ( type , InputStream . class ) ) { 
return inputStream ; 
public void write ( HttpServletResponse httpResponse , Object value ) throws IOException { 
final Document document = ( Document ) value ; 
document . serialize ( new OutputStreamWriter ( httpResponse . getOutputStream ( ) , "UTF-8" ) ) ; 
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { 
T instance = appFactory . getInstance ( interfaceClass ) ; 
return method . invoke ( instance , args ) ; 
} public void attach ( HttpServletRequest httpRequest , HttpServletResponse httpResponse ) { 
if ( requestURL == null ) { 
requestURL = httpRequest . getRequestURI ( ) ; 
if ( locale == null ) { 
locale = httpRequest . getLocale ( ) ; 
if ( requestPath == null ) { 
requestPath = httpRequest . getRequestURI ( ) . substring ( httpRequest . getContextPath ( ) . length ( ) ) ; 
this . httpRequest = httpRequest ; 
this . httpResponse = httpResponse ; 
this . attached = true ; 
} public void detach ( ) { 
attached = false ; 
locale = null ; 
securityDomain = null ; 
cookies = null ; 
requestURL = null ; 
} public Cookies getCookies ( ) { 
assertAttached ( ) ; 
if ( cookies == null ) { 
cookies = new Cookies ( httpRequest , httpResponse ) ; 
return cookies ; 
} public HttpSession getSession ( boolean ... create ) { 
if ( create . length == 0 ) { 
return httpRequest . getSession ( ) ; 
return httpRequest . getSession ( create [ 0 ] ) ; 
if ( ! attached ) { 
StringBuilder message = new StringBuilder ( ) ; 
message . append ( httpRequest . getRequestURI ( ) ) ; 
message . append ( "|:" ) ; 
message . append ( System . lineSeparator ( ) ) ; 
message . append ( httpRequest . getRemoteHost ( ) ) ; 
message . append ( httpRequest . getMethod ( ) ) ; 
message . append ( httpRequest . getQueryString ( ) ) ; 
Enumeration < String > headerNames = httpRequest . getHeaderNames ( ) ; 
String headerName = headerNames . nextElement ( ) ; 
message . append ( headerName ) ; 
message . append ( httpRequest . getHeader ( headerName ) ) ; 
log . error ( message . toString ( ) ) ; 
} private static List < InvocationMeter > getMeters ( ) { 
List < InvocationMeter > invocationMeters = new ArrayList < InvocationMeter > ( ) ; 
ContainerSPI container = ( ContainerSPI ) Factory . getAppFactory ( ) ; 
invocationMeters . add ( ( ( ManagedMethod ) managedMethod ) . getMeter ( ) ) ; 
return invocationMeters ; 
} protected void config ( EventStreamConfig config ) { 
if ( config . hasSecretKey ( ) ) { 
secretKey = config . getSecretKey ( ) ; 
if ( config . hasKeepAlivePeriod ( ) ) { 
keepAlivePeriod = config . getKeepAlivePeriod ( ) ; 
parameters = config . getParameters ( ) ; 
} public void push ( Event event ) { 
if ( ! active . get ( ) ) { 
if ( ! eventsQueue . offer ( event , EVENTS_QUEUE_PUSH_TIMEOUT , TimeUnit . MILLISECONDS ) ) { 
} catch ( InterruptedException unused ) { 
push ( new ShutdownEvent ( ) ) ; 
active . set ( false ) ; 
} protected void setRemoteHost ( String remoteHost ) { 
if ( string == null ) { 
string = Strings . concat ( '#' , STREAM_ID ++ , ':' , remoteHost ) ; 
} protected boolean loop ( ) { 
Event event = null ; 
event = eventsQueue . poll ( keepAlivePeriod , TimeUnit . MILLISECONDS ) ; 
sendKeepAlive ( ) ; 
return ! writer . checkError ( ) ; 
if ( event instanceof ShutdownEvent ) { 
sendEvent ( event ) ; 
onSent ( event ) ; 
} protected < T > T getParameter ( String name , Class < T > type ) { 
String value = parameters . get ( name ) ; 
return ConverterRegistry . getConverter ( ) . asObject ( value , type ) ; 
} protected void sendEvent ( Event event ) { 
write ( "data:" ) ; 
if ( secretKey == null ) { 
json . serialize ( writer , event ) ; 
Cipher cipher = Cipher . getInstance ( secretKey . getAlgorithm ( ) ) ; 
byte [ ] encryptedMessage = cipher . doFinal ( json . serialize ( event ) ) ; 
write ( Base64 . encode ( encryptedMessage ) ) ; 
} catch ( InvalidKeyException | NoSuchPaddingException | BadPaddingException | IllegalBlockSizeException e ) { 
crlf ( ) ; 
container = ( ContainerSPI ) config . getServletContext ( ) . getAttribute ( TinyContainer . ATTR_INSTANCE ) ; 
if ( container == null ) { 
servletName = Strings . concat ( config . getServletContext ( ) . getServletContextName ( ) , '#' , config . getServletName ( ) ) ; 
protected void service ( HttpServletRequest httpRequest , HttpServletResponse httpResponse ) throws IOException , ServletException { 
logContext . put ( LOG_CONTEXT_APP , httpRequest . getContextPath ( ) . isEmpty ( ) ? TinyContainer . ROOT_CONTEXT : httpRequest . getContextPath ( ) . substring ( 1 ) ) ; 
logContext . put ( LOG_CONTEXT_IP , httpRequest . getRemoteHost ( ) ) ; 
logContext . put ( LOG_CONTEXT_ID , Integer . toString ( requestID . getAndIncrement ( ) , Character . MAX_RADIX ) ) ; 
if ( isEmptyUriRequest ( httpRequest ) ) { 
String requestURI = httpRequest . getRequestURI ( ) ; 
Factory . bind ( container ) ; 
RequestContext context = container . getInstance ( RequestContext . class ) ; 
context . attach ( httpRequest , httpResponse ) ; 
handleRequest ( context ) ; 
} catch ( IOException | ServletException | Error | RuntimeException t ) { 
dumpError ( context , t ) ; 
logContext . clear ( ) ; 
context . detach ( ) ; 
} private static boolean isEmptyUriRequest ( HttpServletRequest httpRequest ) { 
if ( ! "GET" . equals ( httpRequest . getMethod ( ) ) ) { 
String acceptValue = httpRequest . getHeader ( HttpHeader . ACCEPT ) ; 
if ( acceptValue != null && acceptValue . contains ( ContentType . TEXT_HTML . getMIME ( ) ) ) { 
String referer = httpRequest . getHeader ( HttpHeader . REFERER ) ; 
if ( referer == null ) { 
StringBuilder uri = new StringBuilder ( httpRequest . getRequestURI ( ) ) ; 
String query = httpRequest . getQueryString ( ) ; 
if ( query . charAt ( 0 ) != '?' ) { 
uri . append ( '?' ) ; 
uri . append ( query ) ; 
return referer . toLowerCase ( ) . endsWith ( uri . toString ( ) . toLowerCase ( ) ) ; 
} protected static void sendUnauthorized ( RequestContext context ) { 
final ContainerSPI container = context . getContainer ( ) ; 
final HttpServletResponse httpResponse = context . getResponse ( ) ; 
if ( httpResponse . isCommitted ( ) ) { 
String loginPage = container . getLoginPage ( ) ; 
if ( HttpHeader . isXHR ( context . getRequest ( ) ) && loginPage != null ) { 
httpResponse . setHeader ( HttpHeader . X_HEADER_LOCATION , container . getLoginPage ( ) ) ; 
httpResponse . setStatus ( HttpServletResponse . SC_UNAUTHORIZED ) ; 
} protected static void sendBadRequest ( RequestContext context ) throws IOException { 
context . dump ( ) ; 
context . getResponse ( ) . sendError ( HttpServletResponse . SC_BAD_REQUEST , context . getRequestURI ( ) ) ; 
} protected static void sendNotFound ( RequestContext context , Exception exception ) throws IOException { 
sendJsonObject ( context , new RemoteException ( exception ) , HttpServletResponse . SC_NOT_FOUND ) ; 
} protected static void sendError ( RequestContext context , Throwable throwable ) throws IOException { 
if ( throwable instanceof InvocationException && throwable . getCause ( ) != null ) { 
if ( throwable instanceof InvocationTargetException ) { 
throwable = ( ( InvocationTargetException ) throwable ) . getTargetException ( ) ; 
if ( throwable instanceof BusinessException ) { 
sendJsonObject ( context , throwable , HttpServletResponse . SC_BAD_REQUEST ) ; 
dumpError ( context , throwable ) ; 
sendJsonObject ( context , new RemoteException ( throwable ) , HttpServletResponse . SC_INTERNAL_SERVER_ERROR ) ; 
} protected static void dumpError ( RequestContext context , Throwable throwable ) { 
} protected static void sendJsonObject ( RequestContext context , Object object , int statusCode ) throws IOException { 
Json json = Classes . loadService ( Json . class ) ; 
String buffer = json . stringify ( object ) ; 
byte [ ] bytes = buffer . getBytes ( "UTF-8" ) ; 
httpResponse . setStatus ( statusCode ) ; 
httpResponse . setContentType ( ContentType . APPLICATION_JSON . getValue ( ) ) ; 
httpResponse . setContentLength ( bytes . length ) ; 
httpResponse . setHeader ( "Content-Language" , context . getLocale ( ) . toLanguageTag ( ) ) ; 
httpResponse . getOutputStream ( ) . write ( bytes ) ; 
httpResponse . getOutputStream ( ) . flush ( ) ; 
( ( StreamHandler < ? > ) value ) . invokeHandler ( httpResponse . getOutputStream ( ) ) ; 
} public void setSaveEnabled ( boolean val ) { 
saveButton . setVisible ( val ) ; 
setReadOnly ( ! val ) ; 
entityForm . setReadOnly ( ! val ) ; 
} protected void delete ( ) { 
ConfirmDialog . show ( getUI ( ) , question , ( ConfirmDialog cd ) -> { 
if ( cd . isConfirmed ( ) ) { 
onDelete ( ) ; 
} catch ( IOException | IllegalArgumentException | IllegalAccessException | IllegalStateException ex ) { 
onError ( ex ) ; 
} catch ( RuntimeException ex ) { 
getUI ( ) . getErrorHandler ( ) . error ( new com . vaadin . server . ErrorEvent ( ex ) ) ; 
} protected void onDelete ( ) 
endpoint . delete ( ) ; 
eventBus . post ( new ElementDeletedEvent < > ( endpoint ) ) ; 
Constructor < ? > constructor = managedClass . getConstructor ( ) ; 
instance = constructor . newInstance ( args ) ; 
throw new InvocationException ( e ) ; 
if ( managedClass . getInstanceType ( ) . equals ( InstanceType . PROXY ) ) { 
ManagedProxyHandler handler = null ; 
if ( managedClass . isTransactional ( ) ) { 
TransactionalResource transactionalResource = managedClass . getContainer ( ) . getInstance ( TransactionalResource . class ) ; 
handler = new ManagedProxyHandler ( transactionalResource , managedClass , instance ) ; 
handler = new ManagedProxyHandler ( managedClass , instance ) ; 
final ClassLoader classLoader = managedClass . getImplementationClass ( ) . getClassLoader ( ) ; 
final Class < ? > [ ] interfaceClasses = managedClass . getInterfaceClasses ( ) ; 
return ( T ) Proxy . newProxyInstance ( classLoader , interfaceClasses , handler ) ; 
} public static Iterable < LinkHeader > getLinkHeaders ( HttpResponse response ) { 
return stream ( response . getHeaders ( "Link" ) ) 
. flatMap ( x -> stream ( x . getElements ( ) ) . map ( LinkHeader :: new ) ) 
. collect ( toList ( ) ) ; 
QueryParametersParser queryParameters = new QueryParametersParser ( httpRequest . getInputStream ( ) ) ; 
return queryParameters . getArguments ( formalParameters ) ; 
} catch ( SyntaxException e ) { 
json . stringify ( new OutputStreamWriter ( httpResponse . getOutputStream ( ) , "UTF-8" ) , value ) ; 
} public static < T > T getInstance ( Class < T > interfaceClass , Object ... args ) { 
return getAppFactory ( ) . getInstance ( interfaceClass , args ) ; 
} public static < T > T getInstance ( String instanceName , Class < T > interfaceClass , Object ... args ) { 
return getAppFactory ( ) . getInstance ( instanceName , interfaceClass , args ) ; 
} public static < T > T getOptionalInstance ( Class < T > interfaceClass , Object ... args ) { 
return getAppFactory ( ) . getOptionalInstance ( interfaceClass , args ) ; 
} public static < T > T getRemoteInstance ( String implementationURL , Class < ? super T > interfaceClass ) { 
return getAppFactory ( ) . getRemoteInstance ( implementationURL , interfaceClass ) ; 
} public static AppFactory getAppFactory ( ) { 
AppFactory appFactory = tls . get ( ) ; 
if ( appFactory == null ) { 
return appFactory ; 
} public static void addFilterRow ( Grid grid ) { 
if ( grid . getHeaderRowCount ( ) < 2 ) { 
grid . appendHeaderRow ( ) ; 
Grid . HeaderRow headerRow = grid . getHeaderRow ( 1 ) ; 
Container . Indexed container = grid . getContainerDataSource ( ) ; 
container . getContainerPropertyIds ( ) . forEach ( pid -> { 
TextField filterField = new TextField ( ) ; 
filterField . setInputPrompt ( "Filter" ) ; 
filterField . addStyleName ( ValoTheme . TEXTFIELD_SMALL ) ; 
filterField . setWidth ( 100 , Sizeable . Unit . PERCENTAGE ) ; 
filterField . addTextChangeListener ( event -> { 
( ( Container . SimpleFilterable ) container ) . removeContainerFilters ( pid ) ; 
if ( ! event . getText ( ) . isEmpty ( ) ) { 
( ( Container . Filterable ) container ) . addContainerFilter ( new SimpleStringFilter ( pid , event . getText ( ) , true , false ) ) ; 
headerRow . getCell ( pid ) . setComponent ( filterField ) ; 
public < I > I newInstance ( ManagedClassSPI managedClass , Object ... args ) { 
if ( interfaceClasses == null ) { 
if ( interfaceClasses . length != 1 ) { 
return ( I ) Classes . loadService ( interfaceClasses [ 0 ] ) ; 
} public void setCandidates ( Collection < T > candidates ) { 
twinColSelect . setContainerDataSource ( 
container = new BeanItemContainer < > ( entityType , candidates ) ) ; 
} protected static void loadXML ( InputStream inputStream , Loader loader ) throws ConfigException { 
SAXParserFactory factory = SAXParserFactory . newInstance ( ) ; 
SAXParser parser = factory . newSAXParser ( ) ; 
XMLReader reader = parser . getXMLReader ( ) ; 
reader . setContentHandler ( loader ) ; 
reader . parse ( new InputSource ( inputStream ) ) ; 
} protected void onError ( Exception ex ) { 
Notification . show ( "Error" , ex . getLocalizedMessage ( ) , Notification . Type . ERROR_MESSAGE ) ; 
} protected Component buildAndBind ( Class < TEntity > entityType ) { 
FormLayout layout = new FormLayout ( ) ; 
getPropertiesWithoutAnnotation ( entityType , EditorHidden . class ) . forEach ( ( property ) -> { 
if ( property . getWriteMethod ( ) == null ) { 
Component component = buildAndBind ( property ) ; 
component . setWidth ( 100 , Unit . PERCENTAGE ) ; 
if ( component . getCaption ( ) == null ) { 
component . setCaption ( propertyIdToHumanFriendly ( property . getName ( ) ) ) ; 
if ( component instanceof DateField ) { 
( ( DateField ) component ) . setResolution ( Resolution . SECOND ) ; 
layout . addComponent ( component ) ; 
getAnnotation ( entityType , property , Description . class ) 
. ifPresent ( x -> layout . addComponent ( buildDescriptionComponent ( property , x . value ( ) ) ) ) ; 
} private static List < Parameter > parse ( Reader reader ) throws IOException { 
List < Parameter > parameters = new ArrayList < Parameter > ( ) ; 
Parameter parameter = new Parameter ( ) ; 
State state = State . NAME ; 
int b = reader . read ( ) ; 
if ( b == - 1 ) { 
if ( parameter . isEmpty ( ) ) { 
if ( parameters . isEmpty ( ) && parameter . isRawValue ( ) ) { 
parameter . commitRawValue ( ) ; 
parameter . commitValue ( ) ; 
parameters . add ( parameter ) ; 
char c = ( char ) b ; 
case NAME : 
case '=' : 
state = State . VALUE ; 
parameter . commitName ( ) ; 
if ( parameter . getBuilder ( ) . isEmpty ( ) ) { 
parameter . append ( c ) ; 
case VALUE : 
state = State . NAME ; 
parameter = new Parameter ( ) ; 
} public Object [ ] getArguments ( Type [ ] formalParameters ) { 
if ( isObject ( formalParameters ) ) { 
Object object = Classes . newInstance ( type ) ; 
Field field = Classes . getField ( type , Strings . toMemberName ( parameter . getName ( ) ) ) ; 
Classes . setFieldValue ( object , field , asObject ( parameter . getValue ( ) , field . getType ( ) ) ) ; 
return new Object [ ] { object } ; 
int i = 0 , argumentsCount = Math . min ( formalParameters . length , parameters . size ( ) ) ; 
for ( i = 0 ; i < argumentsCount ; ++ i ) { 
arguments [ i ] = asObject ( parameters . get ( i ) . getValue ( ) , formalParameters [ i ] ) ; 
for ( ; i < formalParameters . length ; ++ i ) { 
arguments [ i ] = null ; 
for ( ; i < parameters . size ( ) ; ++ i ) { 
private static < T > T asObject ( String value , Type type ) { 
return ( T ) Types . getEmptyValue ( type ) ; 
if ( ! Types . isArrayLike ( type ) ) { 
if ( ! ( type instanceof Class ) ) { 
if ( ConverterRegistry . hasType ( type ) ) { 
return ConverterRegistry . getConverter ( ) . asObject ( value , ( Class < T > ) type ) ; 
List < String > strings = Strings . split ( value , ',' ) ; 
if ( type == String [ ] . class ) { 
return ( T ) strings . toArray ( new String [ strings . size ( ) ] ) ; 
if ( Types . isKindOf ( type , Collection . class ) ) { 
Type collectionType = type ; 
Class < ? > itemType = String . class ; 
if ( type instanceof ParameterizedType ) { 
collectionType = ( ( ParameterizedType ) type ) . getRawType ( ) ; 
itemType = ( Class < ? > ) ( ( ParameterizedType ) type ) . getActualTypeArguments ( ) [ 0 ] ; 
Collection < Object > collection = Classes . newCollection ( collectionType ) ; 
Converter converter = ConverterRegistry . getConverter ( ) ; 
for ( String s : strings ) { 
collection . add ( converter . asObject ( s . trim ( ) , itemType ) ) ; 
return ( T ) collection ; 
} private static boolean isObject ( Type [ ] formalParameters ) { 
final Type type = formalParameters [ 0 ] ; 
if ( Types . isPrimitive ( type ) ) { 
if ( Types . isArrayLike ( type ) ) { 
if ( Types . isMap ( type ) ) { 
JsonReader reader = new JsonReader ( httpRequest . getInputStream ( ) , expectedStartSequence ( formalParameters ) ) ; 
return json . parse ( reader , formalParameters ) ; 
} catch ( JsonException e ) { 
return json . parse ( new InputStreamReader ( inputStream , "UTF-8" ) , type ) ; 
} catch ( JsonException | ClassCastException | UnsupportedEncodingException e ) { 
} public Object [ ] preProcessArguments ( ManagedClassSPI managedClass , Object ... args ) { 
if ( args == null ) { 
args = EMPTY_ARGS ; 
if ( managedClass . getImplementationClass ( ) == null ) { 
return args ; 
final Class < ? > [ ] types = constructor . getParameterTypes ( ) ; 
return preProcessArguments ( managedClass , constructor , types , args ) ; 
} public Object [ ] preProcessArguments ( ManagedMethodSPI managedMethod , Object ... args ) { 
final ManagedClassSPI managedClass = managedMethod . getDeclaringClass ( ) ; 
final Method method = managedMethod . getMethod ( ) ; 
final Class < ? > [ ] types = method . getParameterTypes ( ) ; 
return preProcessArguments ( managedClass , method , types , args ) ; 
} private static Object [ ] preProcessArguments ( ManagedClassSPI managedClass , Member member , Class < ? > [ ] formalParameters , Object ... args ) { 
switch ( args . length ) { 
args = new Object [ formalParameters . length ] ; 
args [ i ] = getDependencyValue ( managedClass , formalParameters [ i ] ) ; 
if ( args [ 0 ] instanceof VarArgs && formalParameters . length == 1 && formalParameters [ 0 ] . isArray ( ) ) { 
args [ 0 ] = ( ( VarArgs < ? > ) args [ 0 ] ) . getArguments ( ) ; 
if ( formalParameters . length != args . length ) { 
for ( int i = 0 ; i < formalParameters . length ; ++ i ) { 
if ( args [ i ] != null && ! Types . isInstanceOf ( args [ i ] , formalParameters [ i ] ) ) { 
} public static boolean isXHR ( HttpServletRequest httpRequest ) { 
String requestedWith = httpRequest . getHeader ( X_REQUESTED_WITH ) ; 
return requestedWith != null ? requestedWith . equalsIgnoreCase ( XML_HTTP_REQUEST ) : false ; 
} public static boolean isAndroid ( HttpServletRequest httpRequest ) { 
return requestedWith != null ? requestedWith . equalsIgnoreCase ( ANDROID_USER_AGENT ) : false ; 
return EMPTY_ARGUMENTS ; 
Closeable closeable = StreamFactory . getInstance ( inputStream , type ) ; 
threadLocal . set ( closeable ) ; 
return closeable ; 
public void persistInstance ( InstanceKey instanceKey , Object instance ) { 
instancesPool . put ( instanceKey , instance ) ; 
public void handle ( ElementEvent < TEntity > message ) { 
if ( message . getEndpoint ( ) . getEntityType ( ) == this . endpoint . getEntityType ( ) ) { 
refresh ( ) ; 
} @ SneakyThrows 
public static List < PropertyDescriptor > getProperties ( Class < ? > beanType ) { 
LinkedList < PropertyDescriptor > properties = new LinkedList < > ( ) ; 
for ( PropertyDescriptor property : Introspector . getBeanInfo ( beanType ) . getPropertyDescriptors ( ) ) { 
if ( getAnnotation ( beanType , property , Id . class ) . isPresent ( ) || property . getName ( ) . equals ( "name" ) ) { 
properties . addFirst ( property ) ; 
} public static < TAnnotation extends Annotation > List < PropertyDescriptor > getPropertiesWithAnnotation ( Class < ? > beanType , Class < TAnnotation > annotationType ) { 
LinkedList < PropertyDescriptor > result = new LinkedList < > ( ) ; 
getProperties ( beanType ) . forEach ( property -> { 
if ( property . getReadMethod ( ) != null && property . getReadMethod ( ) . getAnnotation ( annotationType ) != null 
|| isFieldAnnotated ( beanType , property . getName ( ) , annotationType ) ) { 
result . add ( property ) ; 
} public static < TAnnotation extends Annotation > Optional < TAnnotation > getAnnotation ( Class < ? > beanType , PropertyDescriptor property , Class < TAnnotation > annotationType ) { 
Optional < TAnnotation > annotation = stream ( property . getReadMethod ( ) . getAnnotationsByType ( annotationType ) ) . findAny ( ) ; 
return annotation . isPresent ( ) 
? annotation 
: getAnnotationOnField ( beanType , property . getName ( ) , annotationType ) ; 
} private static String log ( String message , Object ... args ) { 
message = String . format ( message , args ) ; 
java . util . logging . Logger . getLogger ( Server . class . getCanonicalName ( ) ) . log ( java . util . logging . Level . SEVERE , message ) ; 
public void handleRequest ( RequestContext context ) throws IOException { 
Matcher matcher = REQUEST_PATH_PATTERN . matcher ( context . getRequestPath ( ) ) ; 
if ( ! matcher . find ( ) ) { 
String interfaceName = className ( matcher . group ( 1 ) ) ; 
String methodName = matcher . group ( 2 ) ; 
ManagedMethodSPI managedMethod = null ; 
ManagedClassSPI managedClass = getManagedClass ( container , interfaceName , httpRequest . getRequestURI ( ) ) ; 
managedMethod = getManagedMethod ( managedClass , methodName , httpRequest . getRequestURI ( ) ) ; 
final Type [ ] formalParameters = managedMethod . getParameterTypes ( ) ; 
Object instance = container . getInstance ( managedClass ) ; 
value = managedMethod . invoke ( instance , arguments ) ; 
sendError ( context , t ) ; 
if ( managedMethod . isVoid ( ) ) { 
} private static ManagedClassSPI getManagedClass ( ContainerSPI container , String interfaceName , String requestURI ) throws ClassNotFoundException { 
Class < ? > interfaceClass = Classes . forOptionalName ( interfaceName ) ; 
throw new ClassNotFoundException ( requestURI ) ; 
ManagedClassSPI managedClass = container . getManagedClass ( interfaceClass ) ; 
if ( ! managedClass . isRemotelyAccessible ( ) ) { 
return managedClass ; 
} private static ManagedMethodSPI getManagedMethod ( ManagedClassSPI managedClass , String methodName , String requestURI ) throws NoSuchMethodException { 
ManagedMethodSPI managedMethod = managedClass . getNetMethod ( methodName ) ; 
throw new NoSuchMethodException ( requestURI ) ; 
if ( Types . isKindOf ( managedMethod . getReturnType ( ) , Resource . class ) ) { 
return managedMethod ; 
} private static String className ( String classPath ) { 
StringBuilder className = new StringBuilder ( ) ; 
char separator = '.' ; 
char c = classPath . charAt ( 1 ) ; 
for ( int i = 1 ; ; ) { 
if ( c == '/' ) { 
c = separator ; 
className . append ( c ) ; 
if ( ++ i == classPath . length ( ) ) { 
c = classPath . charAt ( i ) ; 
if ( Character . isUpperCase ( c ) ) { 
separator = '$' ; 
return className . toString ( ) ; 
public void serialize ( HttpServletResponse httpResponse ) throws IOException { 
httpResponse . setHeader ( HttpHeader . CACHE_CONTROL , HttpHeader . NO_CACHE ) ; 
httpResponse . addHeader ( HttpHeader . CACHE_CONTROL , HttpHeader . NO_STORE ) ; 
httpResponse . setHeader ( HttpHeader . PRAGMA , HttpHeader . NO_CACHE ) ; 
httpResponse . setDateHeader ( HttpHeader . EXPIRES , 0 ) ; 
httpResponse . setContentType ( getContentType ( ) . getValue ( ) ) ; 
serialize ( httpResponse . getOutputStream ( ) ) ; 
} public String get ( String name ) { 
if ( name . equals ( cookie . getName ( ) ) ) { 
return cookie . getValue ( ) ; 
} public void add ( String name , String value ) { 
Cookie cookie = new Cookie ( name , value ) ; 
cookie . setPath ( "/" ) ; 
httpResponse . addCookie ( cookie ) ; 
} public void add ( String name , Object value ) { 
add ( name , ConverterRegistry . getConverter ( ) . asString ( value ) ) ; 
} public void remove ( String name ) { 
cookie . setMaxAge ( 0 ) ; 
cookie . setValue ( "" ) ; 
} public Iterator < Cookie > iterator ( ) { 
return Collections . emptyIterator ( ) ; 
return Arrays . asList ( cookies ) . iterator ( ) ; 
if ( ! ( instance instanceof Configurable ) ) { 
if ( ! ( instance instanceof OptionalConfigurable ) ) { 
( ( Configurable ) instance ) . config ( config ) ; 
} catch ( ConfigException e ) { 
throw new BugError ( t ) ; 
} public boolean verifyResponse ( String token ) throws NullPointerException { 
return value . equals ( getValue ( tokenedImageFiles . get ( token ) ) ) ; 
} private static String getValue ( File file ) throws NullPointerException { 
public static URI ensureTrailingSlash ( URI uri ) { 
URIBuilder builder = new URIBuilder ( uri ) ; 
if ( ! builder . getPath ( ) . endsWith ( "/" ) ) { 
builder . setPath ( builder . getPath ( ) + "/" ) ; 
public void contextInitialized ( ServletContextEvent contextEvent ) { 
final ServletContext servletContext = contextEvent . getServletContext ( ) ; 
LogContext logContext = LogFactory . getLogContext ( ) ; 
logContext . put ( LOG_CONTEXT_APP , servletContext . getContextPath ( ) . isEmpty ( ) ? TinyContainer . ROOT_CONTEXT : servletContext . getContextPath ( ) . substring ( 1 ) ) ; 
Enumeration < String > parameterNames = servletContext . getInitParameterNames ( ) ; 
while ( parameterNames . hasMoreElements ( ) ) { 
final String name = parameterNames . nextElement ( ) ; 
final String value = servletContext . getInitParameter ( name ) ; 
contextParameters . setProperty ( name , value ) ; 
ConfigBuilder builder = new TinyConfigBuilder ( servletContext , contextParameters ) ; 
config ( builder . build ( ) ) ; 
Factory . bind ( this ) ; 
start ( ) ; 
servletContext . setAttribute ( TinyContainer . ATTR_INSTANCE , this ) ; 
public void contextDestroyed ( ServletContextEvent contextEvent ) { 
public boolean login ( String username , String password ) { 
getHttpServletRequest ( ) . login ( username , password ) ; 
} catch ( ServletException e ) { 
log . debug ( e ) ; 
} private HttpServletRequest getHttpServletRequest ( ) { 
RequestContext context = getInstance ( RequestContext . class ) ; 
HttpServletRequest request = context . getRequest ( ) ; 
if ( request == null ) { 
return request ; 
final ManagedMethodSPI managedMethod = managedClass . getManagedMethod ( method ) ; 
if ( ! managedMethod . isTransactional ( ) ) { 
return managedMethod . invoke ( managedInstance , args ) ; 
if ( managedMethod . isImmutable ( ) ) { 
return executeImmutableTransaction ( managedMethod , args ) ; 
return executeMutableTransaction ( managedMethod , args ) ; 
} private Object executeMutableTransaction ( ManagedMethodSPI managedMethod , Object [ ] args ) throws Throwable { 
Transaction transaction = transactionalResource . createTransaction ( ) ; 
transactionalResource . storeSession ( transaction . getSession ( ) ) ; 
Object result = managedMethod . invoke ( managedInstance , args ) ; 
if ( transaction . unused ( ) ) { 
transaction . rollback ( ) ; 
if ( transaction . close ( ) ) { 
transactionalResource . releaseSession ( ) ; 
} private Object executeImmutableTransaction ( ManagedMethodSPI managedMethod , Object [ ] args ) throws Throwable { 
Transaction transaction = transactionalResource . createReadOnlyTransaction ( ) ; 
} private static Throwable throwable ( Throwable throwable , String message , Object ... args ) { 
Throwable t = throwable ; 
if ( t instanceof InvocationException && t . getCause ( ) != null ) { 
t = t . getCause ( ) ; 
if ( t instanceof InvocationTargetException && ( ( InvocationTargetException ) t ) . getTargetException ( ) != null ) { 
t = ( ( InvocationTargetException ) t ) . getTargetException ( ) ; 
log . dump ( message , t ) ; 
public Object getInstance ( InstanceKey instanceKey ) { 
ThreadLocal < Object > tls = instancesPool . get ( instanceKey ) ; 
if ( tls == null ) { 
synchronized ( instancesPool ) { 
tls = instancesPool . get ( instanceKey ) ; 
tls = new ThreadLocal < > ( ) ; 
instancesPool . put ( instanceKey , tls ) ; 
return tls . get ( ) ; 
tls . set ( instance ) ; 
for ( ThreadLocal < Object > threadLocal : instancesPool . values ( ) ) { 
threadLocal . remove ( ) ; 
instancesPool . clear ( ) ; 
log . trace ( "init(ServletConfig)" ) ; 
eventStreamManager = container . getInstance ( EventStreamManager . class ) ; 
log . trace ( "handleRequest(RequestContext)" ) ; 
final String sessionID = getEventStreamSessionID ( context . getRequestPath ( ) ) ; 
EventStream eventStream = eventStreamManager . createEventStream ( sessionID ) ; 
if ( eventStream == null ) { 
httpResponse . setContentType ( "text/event-stream;charset=UTF-8" ) ; 
httpResponse . setHeader ( HttpHeader . CONNECTION , HttpHeader . KEEP_ALIVE ) ; 
eventStream . setRemoteHost ( context . getRemoteHost ( ) ) ; 
eventStream . setWriter ( httpResponse . getWriter ( ) ) ; 
eventStream . onOpen ( ) ; 
while ( eventStream . loop ( ) ) { 
eventStream . onClose ( ) ; 
eventStreamManager . destroyEventStream ( eventStream ) ; 
} private static String getEventStreamSessionID ( String requestPath ) { 
int extensionSeparator = requestPath . lastIndexOf ( '.' ) ; 
if ( extensionSeparator == - 1 ) { 
extensionSeparator = requestPath . length ( ) ; 
int pathSeparator = requestPath . lastIndexOf ( '/' , extensionSeparator ) + 1 ; 
return requestPath . substring ( pathSeparator , extensionSeparator ) ; 
onSave ( ) ; 
} catch ( IOException | IllegalArgumentException | IllegalAccessException | Validator . InvalidValueException ex ) { 
public void init ( FilterConfig config ) throws UnavailableException { 
log . trace ( "init(FilterConfig)" ) ; 
String localeParameter = config . getInitParameter ( PARAM_LOCALE ) ; 
if ( localeParameter != null ) { 
locales = Strings . split ( localeParameter , ',' ) ; 
for ( String locale : locales ) { 
String securityDomainParameter = config . getInitParameter ( PARAM_SECURITY_DOMAIN ) ; 
if ( securityDomainParameter != null ) { 
securityDomains = Strings . split ( securityDomainParameter , ',' ) ; 
for ( String securityDomain : securityDomains ) { 
public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { 
String contextPath = httpRequest . getContextPath ( ) ; 
String requestPath = requestURI . substring ( contextPath . length ( ) ) ; 
File file = new File ( request . getServletContext ( ) . getRealPath ( requestPath ) ) ; 
String queryString = httpRequest . getQueryString ( ) ; 
context . setRequestURL ( queryString != null ? Strings . concat ( requestURI , '?' , queryString ) : requestURI ) ; 
if ( ! locales . isEmpty ( ) ) { 
if ( startsWith ( requestPath , locale ) ) { 
requestPath = requestPath . substring ( locale . length ( ) + 1 ) ; 
context . setLocale ( new Locale ( locale ) ) ; 
if ( startsWith ( requestPath , securityDomain ) ) { 
requestPath = requestPath . substring ( securityDomain . length ( ) + 1 ) ; 
context . setSecurityDomain ( securityDomain ) ; 
context . setRequestPath ( requestPath ) ; 
request . getRequestDispatcher ( requestPath ) . forward ( request , response ) ; 
} private static boolean startsWith ( String requestPath , String pathComponent ) { 
if ( requestPath . charAt ( 0 ) != '/' ) { 
for ( int j = 0 ; i < requestPath . length ( ) ; ++ i , ++ j ) { 
if ( requestPath . charAt ( i ) == '/' ) { 
return j == pathComponent . length ( ) ; 
if ( j == pathComponent . length ( ) ) { 
if ( Character . toLowerCase ( requestPath . charAt ( i ) ) != Character . toLowerCase ( pathComponent . charAt ( j ) ) ) { 
} protected Window asWindow ( ) { 
if ( containingWindow == null ) { 
containingWindow = new Window ( getCaption ( ) , this ) ; 
containingWindow . setWidth ( 80 , Unit . PERCENTAGE ) ; 
containingWindow . setHeight ( 80 , Unit . PERCENTAGE ) ; 
containingWindow . center ( ) ; 
return containingWindow ; 
HttpSession httpSession = getSession ( instanceKey ) ; 
return httpSession . getAttribute ( instanceKey . getValue ( ) ) ; 
httpSession . setAttribute ( instanceKey . getValue ( ) , instance ) ; 
} private HttpSession getSession ( InstanceKey instanceKey ) { 
RequestContext requestContext = appFactory . getInstance ( RequestContext . class ) ; 
HttpServletRequest httpRequest = requestContext . getRequest ( ) ; 
if ( httpRequest == null ) { 
return httpRequest . getSession ( true ) ; 
httpResponse . setContentType ( contentType ) ; 
httpResponse . setHeader ( HttpHeader . CONTENT_LENGTH , Long . toString ( file . length ( ) ) ) ; 
Files . copy ( file , httpResponse . getOutputStream ( ) ) ; 
} public void readMeta ( ) 
executeAndHandle ( Request . Get ( uri ) ) ; 
for ( ManagedMethodSPI method : container . getManagedMethods ( ) ) { 
if ( Types . isKindOf ( method . getReturnType ( ) , Resource . class ) ) { 
resourceMethods . put ( key ( method ) , method ) ; 
protected void handleRequest ( RequestContext context ) throws ServletException , IOException { 
final HttpServletRequest httpRequest = context . getRequest ( ) ; 
Resource resource = null ; 
ManagedMethodSPI method = resourceMethods . get ( key ( context . getRequestPath ( ) ) ) ; 
throw new NoSuchMethodException ( httpRequest . getRequestURI ( ) ) ; 
final Type [ ] formalParameters = method . getParameterTypes ( ) ; 
Object controller = container . getInstance ( method . getDeclaringClass ( ) ) ; 
resource = method . invoke ( controller , arguments ) ; 
if ( resource == null ) { 
if ( loginPage != null ) { 
httpResponse . sendRedirect ( loginPage ) ; 
httpRequest . authenticate ( httpResponse ) ; 
} catch ( NoSuchMethodException | IllegalArgumentException e ) { 
dumpError ( context , e ) ; 
httpResponse . sendError ( HttpServletResponse . SC_NOT_FOUND , httpRequest . getRequestURI ( ) ) ; 
if ( e . getCause ( ) instanceof NoSuchResourceException ) { 
httpResponse . sendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , e . getCause ( ) . getMessage ( ) ) ; 
resource . serialize ( httpResponse ) ; 
} private static String key ( ManagedMethodSPI resourceMethod ) { 
StringBuilder key = new StringBuilder ( ) ; 
if ( resourceMethod . getDeclaringClass ( ) . getRequestPath ( ) != null ) { 
key . append ( '/' ) ; 
key . append ( resourceMethod . getDeclaringClass ( ) . getRequestPath ( ) ) ; 
key . append ( resourceMethod . getRequestPath ( ) ) ; 
return key . toString ( ) ; 
} protected HttpEntity getContent ( ) 
Request request = Request . Get ( uri ) ; 
request = request . addHeader ( IF_NONE_MATCH , last . etag ) ; 
if ( response . getStatusLine ( ) . getStatusCode ( ) == SC_NOT_MODIFIED && last != null ) { 
return last . content ; 
Header etagHeader = response . getFirstHeader ( HttpHeaders . ETAG ) ; 
last = ( etagHeader == null ) 
? null 
: new Memory ( etagHeader . getValue ( ) , response . getEntity ( ) ) ; 
return response . getEntity ( ) ; 
} protected HttpResponse putContent ( HttpEntity content ) 
Request request = Request . Put ( uri ) . body ( content ) ; 
request . addHeader ( HttpHeaders . IF_MATCH , last . etag ) ; 
return executeAndHandle ( request ) ; 
} protected HttpResponse deleteContent ( ) 
Request request = Request . Delete ( uri ) ; 
if ( ! ( instance instanceof ManagedPostConstruct ) ) { 
ManagedPostConstruct managedInstance = ( ManagedPostConstruct ) instance ; 
managedInstance . postConstruct ( ) ; 
public void preDestroy ( ) { 
if ( eventStreams . isEmpty ( ) ) { 
for ( EventStream eventStream : eventStreams . toArray ( new EventStream [ 0 ] ) ) { 
eventStream . close ( ) ; 
} @ Remote 
@ Public 
public String subscribe ( EventStreamConfig config ) { 
SessionID sessionID = new SessionID ( ) ; 
sessions . put ( sessionID , config ) ; 
return sessionID . getValue ( ) ; 
} protected void handleAllowedMethods ( ) { 
endpoint . isDownloadAllowed ( ) . ifPresent ( this :: setDownloadEnabled ) ; 
endpoint . isUploadAllowed ( ) . ifPresent ( this :: setUploadEnabled ) ; 
endpoint . isDeleteAllowed ( ) . ifPresent ( this :: setDeleteEnabled ) ; 
} protected void upload ( ) { 
onUpload ( ) ; 
eventBus . post ( new BlobUploadEvent ( endpoint ) ) ; 
ConfirmDialog . show ( getUI ( ) , question , new ConfirmDialog . Listener ( ) { 
public void onClose ( ConfirmDialog cd ) { 
} public synchronized void period ( final PeriodicTask periodicTask , long period ) { 
TimerTask task = new PeriodicTaskImpl ( periodicTask ) ; 
this . tasks . put ( periodicTask , task ) ; 
this . timer . schedule ( task , 0L , period ) ; 
} public synchronized void timeout ( final TimeoutTask timeoutTask , long timeout ) { 
TimerTask task = this . tasks . get ( timeoutTask ) ; 
if ( task != null ) { 
this . tasks . values ( ) . remove ( task ) ; 
task = new TimeoutTaskImpl ( timeoutTask ) ; 
this . tasks . put ( timeoutTask , task ) ; 
this . timer . schedule ( task , timeout ) ; 
} private void purgeTask ( Object task ) { 
TimerTask timerTask = this . tasks . get ( task ) ; 
this . tasks . values ( ) . remove ( timerTask ) ; 
public void config ( Config config ) throws ConfigException , IOException { 
for ( Config repositorySection : config . findChildren ( "repository" ) ) { 
String className = repositorySection . getAttribute ( "class" , DEF_IMPLEMENTATION ) ; 
Class < ? > implementation = Classes . forOptionalName ( className ) ; 
if ( implementation == null ) { 
if ( ! Types . isKindOf ( implementation , View . class ) ) { 
if ( ! Classes . isInstantiable ( implementation ) ) { 
Class < ? extends View > viewImplementation = ( Class < ? extends View > ) implementation ; 
String repositoryPath = repositorySection . getAttribute ( "path" ) ; 
if ( repositoryPath == null ) { 
String filesPattern = repositorySection . getAttribute ( "files-pattern" ) ; 
if ( filesPattern == null ) { 
ConfigBuilder builder = new I18nRepository . ConfigBuilder ( repositoryPath , filesPattern ) ; 
I18nRepository repository = new I18nRepository ( builder . build ( ) ) ; 
if ( viewsMetaPool == null ) { 
viewsMetaPool = repository . getPoolInstance ( ) ; 
Properties properties = repositorySection . getProperties ( ) ; 
for ( I18nFile template : repository ) { 
ViewMeta meta = new ViewMeta ( template . getFile ( ) , viewImplementation , properties ) ; 
if ( viewsMetaPool . put ( meta . getName ( ) , meta , template . getLocale ( ) ) ) { 
public View getView ( String viewName ) { 
RequestContext context = Factory . getInstance ( RequestContext . class ) ; 
ViewMeta meta = viewsMetaPool . get ( viewName , context . getLocale ( ) ) ; 
if ( meta == null ) { 
AbstractView view = ( AbstractView ) Classes . newInstance ( meta . getImplementation ( ) ) ; 
view . setMeta ( meta ) ; 
return view ; 
imagesRepositoryDir = config . getProperty ( "captcha.repository.path" , File . class ) ; 
if ( imagesRepositoryDir == null ) { 
challengeSetSize = config . getProperty ( "captcha.set.size" , int . class , 6 ) ; 
if ( ! imagesRepositoryDir . exists ( ) ) { 
if ( ! imagesRepositoryDir . isDirectory ( ) ) { 
if ( ! imagesRepositoryDir . isAbsolute ( ) ) { 
int imagesCount = imagesRepositoryDir . list ( ) . length ; 
if ( imagesCount == 0 ) { 
if ( imagesCount <= challengeSetSize ) { 
public Challenge getChallenge ( int captchaIndex ) { 
"\t<captcha>\r\n" + 
"\t</captcha>" ) ; 
Challenge challenge = new Challenge ( imagesRepositoryDir , challengeSetSize ) ; 
getChallenges ( ) . put ( captchaIndex , challenge ) ; 
return challenge ; 
public Challenge verifyResponse ( int captchaIndex , String challengeResponse ) throws IllegalArgumentException , IllegalStateException { 
Challenge challenge = getChallenges ( ) . get ( captchaIndex ) ; 
if ( challenge == null ) { 
return challenge . verifyResponse ( challengeResponse ) ? null : getChallenge ( captchaIndex ) ; 
@ RequestPath ( "image" ) 
public Resource getImage ( String token ) throws IllegalArgumentException , NoSuchResourceException { 
for ( Challenge challenge : getChallenges ( ) . values ( ) ) { 
File image = challenge . getImage ( token ) ; 
return new FileResource ( image ) ; 
throw new NoSuchResourceException ( ) ; 
} private Map < Integer , Challenge > getChallenges ( ) { 
HttpSession session = context . getInstance ( RequestContext . class ) . getSession ( true ) ; 
Map < Integer , Challenge > challenges = ( Map < Integer , Challenge > ) session . getAttribute ( CHALENGES_KEY ) ; 
if ( challenges == null ) { 
challenges = new HashMap < > ( ) ; 
session . setAttribute ( CHALENGES_KEY , challenges ) ; 
return challenges ; 
} public void trigger ( ) { 
onTrigger ( ) ; 
Notification . show ( getCaption ( ) , "Successful." , Notification . Type . TRAY_NOTIFICATION ) ; 
} protected void onTrigger ( ) 
endpoint . trigger ( ) ; 
eventBus . post ( new TriggerEvent ( endpoint ) ) ; 
} public void registered ( ResteasyProviderFactory factory ) { 
ResourceConstructor constructor = this . resourceClass . getConstructor ( ) ; 
final Class < ? > clazz = this . resourceClass . getClazz ( ) ; 
final Class < ? > aClass = DI . getSubTypesWithoutInterfacesAndGeneratedOf ( clazz ) . stream ( ) . findFirst ( ) . get ( ) ; 
constructor = ResourceBuilder . constructor ( aClass ) ; 
throw new RuntimeException ( Messages . MESSAGES . unableToFindPublicConstructorForClass ( this . scannableClass . getName ( ) ) ) ; 
this . constructorInjector = factory . getInjectorFactory ( ) . createConstructor ( constructor , factory ) ; 
this . propertyInjector = factory . getInjectorFactory ( ) . createPropertyInjector ( this . resourceClass , factory ) ; 
} @ GET ( ) 
@ Path ( ACTIVATE_METRICS_FOR_CLASS ) 
public String activateMetricsForClass ( @ QueryParam ( QUERY_PARAM_CLASS_FQ_NAME ) final String classFQN ) { 
if ( classFQN != null && ! classFQN . isEmpty ( ) ) { 
final Class < ? > aClass = Class . forName ( classFQN ) ; 
DI . activateMetrics ( aClass ) ; 
return e . getMessage ( ) ; 
return OK ; 
@ Path ( DE_ACTIVATE_METRICS_FOR_CLASS ) 
public String deActivateMetricsForClass ( @ QueryParam ( QUERY_PARAM_CLASS_FQ_NAME ) final String classFQN ) { 
DI . deActivateMetrics ( aClass ) ; 
return NOT_OK ; 
} private static DeploymentInfo createServletDeploymentInfos ( ) { 
final Set < Class < ? > > typesAnnotatedWith = DI . getTypesAnnotatedWith ( WebServlet . class , true ) ; 
final List < ServletInfo > servletInfos = typesAnnotatedWith 
. filter ( s -> new ReflectionUtils ( ) . checkInterface ( s , HttpServlet . class ) ) 
. map ( c -> { 
Class < HttpServlet > servletClass = ( Class < HttpServlet > ) c ; 
final ServletInfo servletInfo = servlet ( c . getSimpleName ( ) , servletClass , new ServletInstanceFactory < > ( servletClass ) ) ; 
if ( c . isAnnotationPresent ( WebInitParam . class ) ) { 
final WebInitParam [ ] annotationsByType = c . getAnnotationsByType ( WebInitParam . class ) ; 
for ( WebInitParam webInitParam : annotationsByType ) { 
final String value = webInitParam . value ( ) ; 
final String name = webInitParam . name ( ) ; 
servletInfo . addInitParam ( name , value ) ; 
final WebServlet annotation = c . getAnnotation ( WebServlet . class ) ; 
final String [ ] urlPatterns = annotation . urlPatterns ( ) ; 
for ( String urlPattern : urlPatterns ) { 
servletInfo . addMapping ( urlPattern ) ; 
servletInfo . setAsyncSupported ( annotation . asyncSupported ( ) ) ; 
return servletInfo ; 
. filter ( servletInfo -> ! servletInfo . getMappings ( ) . isEmpty ( ) ) 
final Set < Class < ? > > weblisteners = DI . getTypesAnnotatedWith ( WebListener . class ) ; 
final List < ListenerInfo > listenerInfos = weblisteners . stream ( ) 
. map ( c -> new ListenerInfo ( ( Class < ? extends EventListener > ) c ) ) 
final DeploymentInfo deploymentInfo = deployment ( ) 
. setClassLoader ( Main . class . getClassLoader ( ) ) 
. setContextPath ( MYAPP ) 
. setDeploymentName ( "ROOT" + ".war" ) 
. setDefaultEncoding ( "UTF-8" ) ; 
final Boolean shiroActive = Boolean . valueOf ( System . getProperty ( SHIRO_ACTIVE_PROPERTY , "false" ) ) ; 
final Boolean stagemonitorActive = Boolean . valueOf ( System . getProperty ( STAGEMONITOR_ACTIVE_PROPERTY , "false" ) ) ; 
if ( shiroActive ) addShiroFilter ( ) . apply ( deploymentInfo , DEFAULT_SHIRO_FILTER_NAME , DEFAULT_FILTER_MAPPING ) ; 
if ( stagemonitorActive ) addStagemonitor ( ) . apply ( deploymentInfo ) ; 
return deploymentInfo 
. addListeners ( listenerInfos ) 
. addServletContextAttribute ( WebSocketDeploymentInfo . ATTRIBUTE_NAME , new WebSocketDeploymentInfo ( ) ) 
. addServlets ( servletInfos ) ; 
} private static Object [ ] rehash ( final Object [ ] values , final int newSize ) 
Object [ ] newArray = new Object [ newSize ] ; 
for ( Object value : values ) 
newArray [ predictedPosition ( newArray , value , value . hashCode ( ) ) ] = value ; 
} private static int predictedPosition ( final Object [ ] array , final Object object , final int hash ) 
int arraySize = array . length ; 
int i = Math . abs ( hash ) % arraySize ; 
Object element = array [ i ] ; 
while ( element != null ) 
if ( element . equals ( object ) ) 
i = ( i + 1 ) % arraySize ; 
element = array [ i ] ; 
} private void findNextSeparator ( ) 
mLastSeparatorPos = mNextSeparatorPos ; 
while ( ++ mNextSeparatorPos < mValue . length ( ) ) 
char c = mValue . charAt ( mNextSeparatorPos ) ; 
if ( c == mSeparator ) 
boolean isQuoted = false ; 
if ( ! isQuoted ) 
else if ( c == '"' ) 
isQuoted = ! isQuoted ; 
public void initialize ( InitContext initContext ) { 
if ( initContext . projectStage ( ) . isPresent ( ) ) { 
StageConfig stageConfig = initContext . projectStage ( ) . get ( ) ; 
String configvalue = stageConfig . resolve ( SwarmProperties . CONSUL_URL ) 
. withDefault ( null ) 
this . url = configvalue != null ? new URL ( configvalue ) : DEFAULT_URL ; 
} private static PrintStream unbuffered ( final PrintStream stream ) 
return new PrintStream ( stream , true , "UTF-8" ) ; 
catch ( UnsupportedEncodingException e ) 
return new PrintStream ( stream , true ) ; 
} public void subscribe ( final String pattern , 
final Object instance , 
final String methodName ) 
throws NoSuchMethodException 
this . subscribe ( pattern , new FunctionObject9 ( instance , methodName ) ) ; 
final Class < ? > clazz , 
this . subscribe ( pattern , new FunctionObject9 ( this , clazz , methodName ) ) ; 
final FunctionInterface9 callback ) 
final String s = this . prefix + pattern ; 
LinkedList < FunctionInterface9 > callback_list = this . callbacks . get ( s ) ; 
if ( callback_list == null ) 
callback_list = new LinkedList < FunctionInterface9 > ( ) ; 
callback_list . addLast ( callback ) ; 
this . callbacks . put ( s , callback_list ) ; 
OtpOutputStream subscribe = new OtpOutputStream ( ) ; 
subscribe . write ( OtpExternal . versionTag ) ; 
final OtpErlangObject [ ] tuple = { new OtpErlangAtom ( "subscribe" ) , 
new OtpErlangString ( pattern ) } ; 
subscribe . write_any ( new OtpErlangTuple ( tuple ) ) ; 
send ( subscribe ) ; 
} public int subscribe_count ( final String pattern ) 
throws InvalidInputException , 
TerminateException 
OtpOutputStream subscribe_count = new OtpOutputStream ( ) ; 
subscribe_count . write ( OtpExternal . versionTag ) ; 
final OtpErlangObject [ ] tuple = { new OtpErlangAtom ( "subscribe_count" ) , 
subscribe_count . write_any ( new OtpErlangTuple ( tuple ) ) ; 
send ( subscribe_count ) ; 
return ( Integer ) poll_request ( null , false ) ; 
catch ( MessageDecodingException e ) 
e . printStackTrace ( API . err ) ; 
} public void unsubscribe ( final String pattern ) 
throws InvalidInputException 
throw new InvalidInputException ( ) ; 
callback_list . removeFirst ( ) ; 
if ( callback_list . isEmpty ( ) ) 
this . callbacks . remove ( s ) ; 
OtpOutputStream unsubscribe = new OtpOutputStream ( ) ; 
unsubscribe . write ( OtpExternal . versionTag ) ; 
final OtpErlangObject [ ] tuple = { new OtpErlangAtom ( "unsubscribe" ) , 
unsubscribe . write_any ( new OtpErlangTuple ( tuple ) ) ; 
send ( unsubscribe ) ; 
} public TransId send_async ( final String name , 
final byte [ ] request ) 
MessageDecodingException , 
return send_async ( name , ( "" ) . getBytes ( ) , request , 
this . timeout_async , this . priority_default ) ; 
} public Response send_sync ( final String name , 
return send_sync ( name , ( "" ) . getBytes ( ) , request , 
this . timeout_sync , this . priority_default ) ; 
final byte [ ] request_info , 
final byte [ ] request , 
final Integer timeout , 
final Byte priority ) 
OtpOutputStream send_sync = new OtpOutputStream ( ) ; 
send_sync . write ( OtpExternal . versionTag ) ; 
final OtpErlangObject [ ] tuple = { new OtpErlangAtom ( "send_sync" ) , 
new OtpErlangString ( name ) , 
new OtpErlangBinary ( request_info ) , 
new OtpErlangBinary ( request ) , 
new OtpErlangUInt ( timeout ) , 
new OtpErlangInt ( priority ) } ; 
send_sync . write_any ( new OtpErlangTuple ( tuple ) ) ; 
send ( send_sync ) ; 
return ( Response ) poll_request ( null , false ) ; 
catch ( OtpErlangRangeException e ) 
} public ArrayList < TransId > mcast_async ( final String name , 
return mcast_async ( name , new byte [ 0 ] , request , 
} public void forward_ ( final Integer request_type , 
final Byte priority , 
final byte [ ] trans_id , 
final OtpErlangPid pid ) 
throws ForwardAsyncException , 
ForwardSyncException , 
InvalidInputException 
if ( request_type == API . ASYNC ) 
forward_async ( name , request_info , request , 
timeout , priority , trans_id , pid ) ; 
else if ( request_type == API . SYNC ) 
forward_sync ( name , request_info , request , 
} public void forward_async ( final String name , 
Integer timeout , 
throws ForwardAsyncException 
OtpOutputStream forward_async = new OtpOutputStream ( ) ; 
forward_async . write ( OtpExternal . versionTag ) ; 
final OtpErlangObject [ ] tuple = { new OtpErlangAtom ( "forward_async" ) , 
new OtpErlangInt ( priority ) , 
new OtpErlangBinary ( trans_id ) , 
pid } ; 
forward_async . write_any ( new OtpErlangTuple ( tuple ) ) ; 
send ( forward_async ) ; 
throw new ForwardAsyncException ( ) ; 
} public void return_ ( final Integer request_type , 
final String pattern , 
final byte [ ] response_info , 
final byte [ ] response , 
throws ReturnAsyncException , 
ReturnSyncException , 
return_async ( name , pattern , response_info , response , 
timeout , trans_id , pid ) ; 
return_sync ( name , pattern , response_info , response , 
} public void return_sync ( final String name , 
byte [ ] response_info , 
byte [ ] response , 
throws ReturnSyncException 
OtpOutputStream return_sync = new OtpOutputStream ( ) ; 
return_sync . write ( OtpExternal . versionTag ) ; 
final OtpErlangObject [ ] tuple = { new OtpErlangAtom ( "return_sync" ) , 
new OtpErlangString ( pattern ) , 
new OtpErlangBinary ( response_info ) , 
new OtpErlangBinary ( response ) , 
return_sync . write_any ( new OtpErlangTuple ( tuple ) ) ; 
send ( return_sync ) ; 
throw new ReturnSyncException ( ) ; 
} public Response recv_async ( final Integer timeout ) 
return recv_async ( timeout , TransIdNull , true ) ; 
} public Response recv_async ( final byte [ ] trans_id ) 
return recv_async ( this . timeout_sync , trans_id , true ) ; 
} public Response recv_async ( final boolean consume ) 
return recv_async ( this . timeout_sync , TransIdNull , consume ) ; 
} public Response recv_async ( final byte [ ] trans_id , 
final boolean consume ) 
return recv_async ( this . timeout_sync , trans_id , consume ) ; 
} public Response recv_async ( final Integer timeout , 
OtpOutputStream recv_async = new OtpOutputStream ( ) ; 
recv_async . write ( OtpExternal . versionTag ) ; 
final OtpErlangObject [ ] tuple = { new OtpErlangAtom ( "recv_async" ) , 
consume ? 
new OtpErlangAtom ( "true" ) : 
new OtpErlangAtom ( "false" ) } ; 
recv_async . write_any ( new OtpErlangTuple ( tuple ) ) ; 
send ( recv_async ) ; 
} public boolean poll ( final int timeout ) 
if ( Boolean . TRUE == poll_request ( timeout , true ) ) 
} public void shutdown ( final String reason ) 
OtpOutputStream shutdown = new OtpOutputStream ( ) ; 
shutdown . write ( OtpExternal . versionTag ) ; 
final OtpErlangObject [ ] tuple = { new OtpErlangAtom ( "shutdown" ) , 
new OtpErlangString ( reason ) } ; 
shutdown . write_any ( new OtpErlangTuple ( tuple ) ) ; 
send ( shutdown ) ; 
} public void setIntegerValidator ( Function < Integer , String > valueToErrorMessage ) { 
setValidator ( valueToErrorMessage . compose ( v -> Integer . valueOf ( v ) ) ) ; 
} public void setItems ( List < V > items ) { 
final List < V > its = items == null ? ImmutableList . of ( ) : items ; 
this . items = its ; 
getComboBoxCellEditor ( ) . setInput ( items ) ; 
} public static PermissionDialogFragment getInstance ( PermBean bean , int requestCode ) { 
Bundle extras = new Bundle ( 3 ) ; 
HashMap < Permission , String > map = ( HashMap < Permission , String > ) bean . getPermissions ( ) ; 
extras . putSerializable ( PERMISSION , map ) ; 
extras . putInt ( REQUEST , requestCode ) ; 
PermissionDialogFragment fragment = new PermissionDialogFragment ( ) ; 
fragment . setArguments ( extras ) ; 
public void onResume ( ) { 
super . onResume ( ) ; 
getDialog ( ) . setOnKeyListener ( new DialogInterface . OnKeyListener ( ) { 
public boolean onKey ( DialogInterface dialog , int keyCode , KeyEvent keyEvent ) { 
return keyCode != KeyEvent . ACTION_DOWN ; 
} @ OPermission ( value = Permission . WRITE_EXTERNAL_STORAGE ) 
void onStoragePermission ( @ Result boolean isGranted ) { 
if ( isGranted ) { 
} @ OPermission ( values = { Permission . ACCESS_COARSE_LOCATION , 
Permission . ACCESS_FINE_LOCATION } ) 
void onLocationPermission ( @ Result boolean isGranted ) { 
} public PermBean put ( Permission permission , String message ) { 
mPermissions . put ( permission , message ) ; 
} public RequestPermission with ( PermBean permBean ) { 
if ( permBean . getPermissions ( ) . isEmpty ( ) ) { 
RequestPermission . permBean = permBean ; 
} public void request ( ) { 
mLog . i ( TAG , "Requesting........." ) ; 
resultMap = new LinkedHashMap < > ( permBean . size ( ) ) ; 
if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . M 
&& isPermissionRequired ( permBean ) ) { 
if ( RequestPermission . mBase == null ) { 
RequestPermission . mBase = mActivity ; 
PermBean bean = new PermBean ( ) ; 
Map < Permission , String > map = permBean . getPermissions ( ) ; 
for ( Map . Entry < Permission , String > m : map . entrySet ( ) ) { 
if ( mActivity . checkSelfPermission ( m . getKey ( ) . toString ( ) ) != PackageManager . PERMISSION_GRANTED ) { 
bean . put ( m . getKey ( ) , m . getValue ( ) ) ; 
resultMap . put ( m . getKey ( ) , Result . GRANTED ) ; 
if ( bean . size ( ) > 0 ) { 
showDialog ( bean ) ; 
for ( Map . Entry < Permission , String > m : permBean . getPermissions ( ) . entrySet ( ) ) { 
invokeAnnotatedMethods ( resultMap ) ; 
mLog . e ( TAG , e . getMessage ( ) , e ) ; 
} private static boolean isPermissionRequired ( PermBean permBean ) { 
if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . M ) { 
if ( permBean . size ( ) > 0 ) { 
for ( Permission permission : map . keySet ( ) ) { 
int status = mActivity . checkSelfPermission ( permission . toString ( ) ) ; 
if ( status != PackageManager . PERMISSION_GRANTED ) return true ; 
} private void showDialog ( PermBean permBean ) { 
PermissionDialogFragment fragment = PermissionDialogFragment . getInstance ( permBean , requestCode ) ; 
fragment . show ( mActivity . getSupportFragmentManager ( ) , TAG ) ; 
} public static void onResult ( int requestCode , @ NonNull String [ ] permissions , @ NonNull int [ ] grantResults ) { 
if ( RequestPermission . requestCode == requestCode ) { 
int count = permissions . length ; 
List < String > granted = new ArrayList < > ( count ) ; 
List < String > denied = new ArrayList < > ( count ) ; 
for ( int k = 0 ; k < count ; k ++ ) { 
resultMap . put ( Permission . get ( permissions [ k ] ) , Result . get ( grantResults [ k ] ) ) ; 
if ( grantResults [ k ] == PackageManager . PERMISSION_GRANTED ) { 
granted . add ( permissions [ k ] ) ; 
} else if ( grantResults [ k ] == PackageManager . PERMISSION_DENIED ) { 
denied . add ( permissions [ k ] ) ; 
String [ ] grantedArray = granted . toArray ( new String [ granted . size ( ) ] ) ; 
String [ ] deniedArray = denied . toArray ( new String [ denied . size ( ) ] ) ; 
Intent intent = new Intent ( PERMISSION_RESULT_BROADCAST ) ; 
intent . putExtra ( GRANTED , grantedArray ) ; 
intent . putExtra ( DENIED , deniedArray ) ; 
LocalBroadcastManager . getInstance ( mActivity ) . sendBroadcast ( intent ) ; 
} private static void invokeAnnotatedMethods ( HashMap < Permission , Result > resultMap ) 
throws InvocationTargetException , IllegalAccessException { 
Method [ ] methods = getBase ( ) . getClass ( ) . getDeclaredMethods ( ) ; 
if ( method != null && method . isAnnotationPresent ( GrantedPermission . class ) ) { 
GrantedPermission granted = method . getAnnotation ( GrantedPermission . class ) ; 
if ( granted != null ) { 
if ( ! granted . permission ( ) . equals ( "" ) || granted . value ( ) != Permission . NONE ) { 
for ( Map . Entry < Permission , Result > permResult : resultMap . entrySet ( ) ) { 
if ( ( granted . permission ( ) . equals ( permResult . getKey ( ) . toString ( ) ) || 
granted . value ( ) == permResult . getKey ( ) ) 
&& Result . GRANTED == permResult . getValue ( ) ) { 
method . invoke ( getBase ( ) ) ; 
if ( granted . values ( ) . length > 0 ) { 
if ( allValuesGranted ( granted . values ( ) , resultMap ) ) { 
if ( granted . permissions ( ) . length > 0 ) { 
if ( allValuesGranted ( granted . permissions ( ) , resultMap ) ) { 
} else if ( method != null && method . isAnnotationPresent ( DeniedPermission . class ) ) { 
DeniedPermission denied = method . getAnnotation ( DeniedPermission . class ) ; 
if ( denied != null ) { 
if ( ! denied . permission ( ) . equals ( "" ) || denied . value ( ) != Permission . NONE ) { 
if ( ( denied . permission ( ) . equals ( permResult . getKey ( ) . toString ( ) ) 
|| denied . value ( ) == permResult . getKey ( ) ) 
&& Result . DENIED == permResult . getValue ( ) ) { 
if ( denied . values ( ) . length > 0 ) { 
if ( anyValueDenied ( denied . values ( ) , resultMap ) ) { 
if ( denied . permissions ( ) . length > 0 ) { 
if ( anyValueDenied ( denied . permissions ( ) , resultMap ) ) { 
} else if ( method != null && method . isAnnotationPresent ( OPermission . class ) ) { 
OPermission oPermission = method . getAnnotation ( OPermission . class ) ; 
final Annotation [ ] [ ] paramAnnotations = method . getParameterAnnotations ( ) ; 
final Class [ ] paramTypes = method . getParameterTypes ( ) ; 
if ( oPermission != null 
&& paramAnnotations [ 0 ] [ 0 ] instanceof co . omkar . utility . opermission . annotation . Result 
&& ( paramTypes [ 0 ] == boolean . class 
|| paramTypes [ 0 ] == Boolean . class ) ) { 
if ( oPermission . permission ( ) . equals ( permResult . getKey ( ) . toString ( ) ) 
|| oPermission . value ( ) . equals ( permResult . getKey ( ) ) ) { 
switch ( permResult . getValue ( ) ) { 
case GRANTED : 
method . invoke ( getBase ( ) , true ) ; 
case DENIED : 
method . invoke ( getBase ( ) , false ) ; 
if ( oPermission . values ( ) . length > 0 ) { 
if ( allValuesGranted ( oPermission . values ( ) , resultMap ) ) { 
if ( oPermission . permissions ( ) . length > 0 ) { 
if ( allValuesGranted ( oPermission . permissions ( ) , resultMap ) ) { 
} private static boolean allValuesGranted ( Object [ ] values , HashMap < Permission , Result > resultMap ) { 
if ( values instanceof Permission [ ] ) { 
Set < Permission > valueSet = new HashSet < > ( Arrays . asList ( ( Permission [ ] ) values ) ) ; 
if ( resultMap . keySet ( ) . containsAll ( valueSet ) ) { 
for ( Object value : values ) { 
if ( Result . GRANTED != resultMap . get ( ( Permission ) value ) ) { 
} else if ( values instanceof String [ ] ) { 
Set < String > valueSet = new HashSet < > ( Arrays . asList ( ( String [ ] ) values ) ) ; 
Set < String > permission = new HashSet < > ( ) ; 
for ( Permission perm : resultMap . keySet ( ) ) { 
permission . add ( perm . toString ( ) ) ; 
if ( permission . containsAll ( valueSet ) ) { 
if ( Result . GRANTED != resultMap . get ( Permission . get ( String . valueOf ( value ) ) ) ) { 
} private static boolean anyValueDenied ( Object [ ] values , HashMap < Permission , Result > resultMap ) { 
Set < Permission > valueSet = new LinkedHashSet < > ( Arrays . asList ( ( Permission [ ] ) values ) ) ; 
if ( Result . DENIED == resultMap . get ( ( Permission ) value ) ) { 
Set < String > permissionSet = new HashSet < > ( ) ; 
permissionSet . add ( perm . toString ( ) ) ; 
if ( permissionSet . containsAll ( valueSet ) ) { 
if ( Result . DENIED == resultMap . get ( Permission . get ( ( String ) value ) ) ) { 
} public static LoginException newLoginException ( final String message , final Throwable cause ) { 
final LoginException loginException = new LoginException ( message ) ; 
loginException . initCause ( cause ) ; 
return loginException ; 
public final void make ( 
final Map < String , Object > pAddParams ) throws Exception { 
this . factoryAppBeans . releaseBeans ( ) ; 
Writer htmlWriter = ( Writer ) pAddParams . get ( "htmlWriter" ) ; 
if ( htmlWriter != null ) { 
+ PrepareDbAfterGetCopy . class . getSimpleName ( ) 
this . logger . info ( null , PrepareDbAfterGetCopy . class , 
} @ SuppressWarnings ( "PMD.NonThreadSafeSingleton" ) 
public static PasswordValidator getSingleton ( final String className , final CommonProperties properties ) 
throws FactoryException { 
if ( passwordValidatorInstance == null ) { 
synchronized ( PasswordValidatorFactory . class ) { 
passwordValidatorInstance = getInstance ( className , properties ) ; 
return passwordValidatorInstance ; 
public final String makeFilter ( final Class < ? > pEntityClass , 
final Map < String , Object > pAddParam ) throws Exception { 
return pEntityClass . getSimpleName ( ) . toUpperCase ( ) + ".ITSVERSION>" 
+ this . lastReplicatedDateEvaluator . evalData ( pAddParam ) . getTime ( ) ; 
} public static void close ( final Connection conn ) { 
if ( conn != null ) { 
conn . close ( ) ; 
} catch ( SQLException e ) { 
LOG . warn ( error , e ) ; 
} public static void close ( final PreparedStatement statement ) { 
if ( statement != null ) { 
statement . close ( ) ; 
} public static void close ( final ResultSet resultSet ) { 
if ( resultSet != null ) { 
resultSet . close ( ) ; 
public final void fill ( final Map < String , Object > pAddParam , 
final Object pEntity , final String pFieldName , 
final String pFieldStrValue ) throws Exception { 
Field rField = getUtlReflection ( ) . retrieveField ( pEntity . getClass ( ) , 
pFieldName ) ; 
rField . setAccessible ( true ) ; 
if ( "NULL" . equals ( pFieldStrValue ) ) { 
rField . set ( pEntity , null ) ; 
boolean isFilled = true ; 
if ( rField . getType ( ) == Double . class ) { 
rField . set ( pEntity , Double . valueOf ( pFieldStrValue ) ) ; 
} else if ( rField . getType ( ) == Float . class ) { 
rField . set ( pEntity , Float . valueOf ( pFieldStrValue ) ) ; 
} else if ( rField . getType ( ) == BigDecimal . class ) { 
rField . set ( pEntity , new BigDecimal ( pFieldStrValue ) ) ; 
} else if ( rField . getType ( ) == Date . class ) { 
rField . set ( pEntity , new Date ( Long . parseLong ( pFieldStrValue ) ) ) ; 
} else if ( Enum . class . isAssignableFrom ( rField . getType ( ) ) ) { 
Integer intVal = Integer . valueOf ( pFieldStrValue ) ; 
Enum val = null ; 
val = ( Enum ) rField . getType ( ) . getEnumConstants ( ) [ intVal ] ; 
rField . set ( pEntity , val ) ; 
} else if ( rField . getType ( ) == Boolean . class ) { 
rField . set ( pEntity , Boolean . valueOf ( pFieldStrValue ) ) ; 
} else if ( Integer . class == rField . getType ( ) ) { 
rField . set ( pEntity , Integer . valueOf ( pFieldStrValue ) ) ; 
} else if ( Long . class == rField . getType ( ) ) { 
rField . set ( pEntity , Long . valueOf ( pFieldStrValue ) ) ; 
} else if ( String . class == rField . getType ( ) ) { 
String unescaped = this . utilXml . unescapeXml ( pFieldStrValue ) ; 
rField . set ( pEntity , unescaped ) ; 
isFilled = false ; 
throw new ExceptionWithCode ( ExceptionWithCode 
if ( ! isFilled ) { 
+ "/" + pFieldName + "/" + pFieldStrValue ) ; 
public final void init ( final CommonProperties properties ) { 
connProps . set ( JaasBasedConnPropsBuilder . build ( properties . getAdditionalProperties ( ) ) ) ; 
dbProps . set ( JaasBasedDbPropsBuilder . build ( properties . getAdditionalProperties ( ) ) ) ; 
} @ SuppressWarnings ( { "PMD.CyclomaticComplexity" , "PMD.NPathComplexity" } ) 
public final Subject authenticate ( final String domain , final String userName , final char [ ] password , 
final PasswordValidator passwordValidator ) 
throws LoginException { 
if ( domain == null || userName == null || password == null ) { 
if ( StringUtils . isBlank ( dbProps . get ( ) . getSqlUserQuery ( ) ) ) { 
LOG . warn ( error ) ; 
throw new LoginException ( error ) ; 
final UserRecord userRecord = getUserRecord ( domain , userName ) ; 
if ( userRecord . getUserId ( ) == null || userRecord . getUserId ( ) . length ( ) == 0 ) { 
if ( userRecord . getCredential ( ) == null || userRecord . getCredential ( ) . length ( ) == 0 ) { 
final char [ ] myPassword = password . clone ( ) ; 
final char [ ] myCredential = userRecord . getCredential ( ) . toCharArray ( ) ; 
if ( ! passwordValidator . validate ( myPassword , myCredential ) ) { 
LOG . info ( error ) ; 
throw new FailedLoginException ( error ) ; 
Cleanser . wipe ( myCredential ) ; 
Cleanser . wipe ( myPassword ) ; 
final UserPrincipal userPrincipal = new UserPrincipal ( userRecord . getUserId ( ) , domain , userName ) ; 
final Subject subject = new Subject ( ) ; 
subject . getPrincipals ( ) . add ( userPrincipal ) ; 
return subject ; 
} @ edu . umd . cs . findbugs . annotations . SuppressWarnings ( "SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING" ) 
private UserRecord getUserRecord ( final String domain , final String userName ) 
String userId ; 
String credential ; 
Connection connection = null ; 
PreparedStatement statement = null ; 
connection = getDatabaseConnection ( ) ; 
statement = connection . prepareStatement ( dbProps . get ( ) . getSqlUserQuery ( ) ) ; 
statement . setString ( 1 , domain ) ; 
statement . setString ( 2 , userName ) ; 
resultSet = statement . executeQuery ( ) ; 
userId = resultSet . getString ( 1 ) ; 
credential = resultSet . getString ( 2 ) ; 
throw Util . newLoginException ( error , e ) ; 
DbUtil . close ( resultSet ) ; 
DbUtil . close ( statement ) ; 
DbUtil . close ( connection ) ; 
return new UserRecord ( domain , userName , userId , credential ) ; 
} private Connection getDatabaseConnection ( ) 
Connection connection ; 
if ( StringUtils . isNotEmpty ( dbProps . get ( ) . getJndiConnectionName ( ) ) ) { 
connection = ConnectionFactory . getConnection ( dbProps . get ( ) . getJndiConnectionName ( ) ) ; 
} catch ( FactoryException e ) { 
if ( connProps . get ( ) == null ) { 
throw new FactoryException ( error ) ; 
if ( StringUtils . isBlank ( connProps . get ( ) . getDriver ( ) ) ) { 
if ( StringUtils . isBlank ( connProps . get ( ) . getUrl ( ) ) ) { 
connection = ConnectionFactory . getConnection ( connProps . get ( ) ) ; 
if ( ! UserRoleTomcat . class . isAssignableFrom ( pEntity . getClass ( ) ) ) { 
+ pEntity + "/" + pFieldName + "/" + pFieldStrValue ) ; 
UserRoleTomcat userRoleTomcat = ( UserRoleTomcat ) pEntity ; 
userRoleTomcat . setItsUser ( null ) ; 
UserTomcat ownedEntity = new UserTomcat ( ) ; 
ownedEntity . setItsUser ( pFieldStrValue ) ; 
userRoleTomcat . setItsUser ( ownedEntity ) ; 
@ SuppressWarnings ( "PMD.GuardLogStatementJavaUtil" ) 
public final void audit ( final Events event , final String domain , final String username ) { 
if ( LOG . isInfoEnabled ( ) ) { 
public static PasswordAuthenticator getSingleton ( final String className , final CommonProperties properties ) 
if ( passwordAuthenticatorInstance == null ) { 
synchronized ( PasswordAuthenticatorFactory . class ) { 
passwordAuthenticatorInstance = getInstance ( className , properties ) ; 
return passwordAuthenticatorInstance ; 
public final void write ( final Map < String , Object > pAddParam , 
final Object pField , final String pFieldName , 
final Writer pWriter ) throws Exception { 
String fieldValue ; 
if ( pField == null ) { 
fieldValue = "NULL" ; 
} else if ( Enum . class . isAssignableFrom ( pField . getClass ( ) ) ) { 
fieldValue = String . valueOf ( ( ( Enum ) pField ) . ordinal ( ) ) ; 
} else if ( pField . getClass ( ) == Date . class ) { 
fieldValue = String . valueOf ( ( ( Date ) pField ) . getTime ( ) ) ; 
fieldValue = pField . toString ( ) ; 
if ( pField instanceof String ) { 
fieldValue = getUtilXml ( ) . escapeXml ( fieldValue ) ; 
+ "\"\n" ) ; 
} public static void postMessage ( final MessageQ messageQ , final String domain , final String username , 
final Events event , final String error ) 
if ( messageQ == null ) { 
messageQ . create ( event , domain , username ) ; 
} catch ( MessageQException e ) { 
@ SuppressWarnings ( "PMD.UseVarargs" ) 
public final void handle ( final Callback [ ] callbacks ) 
throws IOException , UnsupportedCallbackException { 
for ( final Callback callback : callbacks ) { 
if ( callback instanceof NameCallback ) { 
final NameCallback nameCallback = ( NameCallback ) callback ; 
nameCallback . setName ( username ) ; 
} else if ( callback instanceof PasswordCallback ) { 
final PasswordCallback passwordCallback = ( PasswordCallback ) callback ; 
passwordCallback . setPassword ( password ) ; 
} else if ( callback instanceof TextInputCallback ) { 
final TextInputCallback textInputCallback = ( TextInputCallback ) callback ; 
textInputCallback . setText ( domain ) ; 
+ TextInputCallback . class . getCanonicalName ( ) ; 
throw new UnsupportedCallbackException ( callback , error ) ; 
final Object pEntity , final Writer pWriter ) throws Exception { 
Map < String , Map < String , String > > fieldsSettingsMap = 
getMngSettings ( ) . lazFldsSts ( pEntity . getClass ( ) ) ; 
for ( Map . Entry < String , Map < String , String > > entry 
: fieldsSettingsMap . entrySet ( ) ) { 
if ( "true" . equals ( entry . getValue ( ) . get ( "isEnabled" ) ) ) { 
Field field = getUtlReflection ( ) 
. retrieveField ( pEntity . getClass ( ) , entry . getKey ( ) ) ; 
Object fieldValue = field . get ( pEntity ) ; 
ISrvFieldWriter srvFieldWriter = getFieldsWritersMap ( ) 
. get ( entry . getValue ( ) . get ( "ISrvFieldWriter" ) ) ; 
if ( srvFieldWriter == null ) { 
srvFieldWriter . write ( pAddParam , fieldValue , field . getName ( ) , pWriter ) ; 
pWriter . write ( "/>\n" ) ; 
public final < T > int retrieveAndWriteEntities ( 
final Map < String , Object > pAddParam , 
final Class < T > pEntityClass , final Writer pWriter ) throws Exception { 
String conditions = ( String ) pAddParam . get ( "conditions" ) ; 
int requestingDatabaseVersion = Integer 
. parseInt ( ( String ) pAddParam . get ( "requestingDatabaseVersion" ) ) ; 
int databaseVersion = this . srvDatabase . getVersionDatabase ( ) ; 
List < T > entities = null ; 
int entitiesCount = 0 ; 
DatabaseInfo di ; 
if ( requestingDatabaseVersion == databaseVersion ) { 
this . srvDatabase . setIsAutocommit ( false ) ; 
this . srvDatabase . 
setTransactionIsolation ( ISrvDatabase . TRANSACTION_READ_UNCOMMITTED ) ; 
this . srvDatabase . beginTransaction ( ) ; 
di = getSrvOrm ( ) 
. retrieveEntityWithConditions ( pAddParam , DatabaseInfo . class , "" ) ; 
String requestedDatabaseIdStr = ( String ) pAddParam 
. get ( "requestedDatabaseId" ) ; 
if ( requestedDatabaseIdStr != null ) { 
int requestedDatabaseId = Integer . parseInt ( requestedDatabaseIdStr ) ; 
if ( requestedDatabaseId != di . getDatabaseId ( ) ) { 
+ requestedDatabaseId + "/" + di . getDatabaseId ( ) ; 
this . logger . error ( null , DatabaseWriterXml . class , error ) ; 
pWriter . write ( "</message>\n" ) ; 
return entitiesCount ; 
if ( conditions == null ) { 
entities = getSrvOrm ( ) . retrieveList ( pAddParam , pEntityClass ) ; 
entities = getSrvOrm ( ) 
. retrieveListWithConditions ( pAddParam , pEntityClass , conditions ) ; 
entitiesCount = entities . size ( ) ; 
this . srvDatabase . commitTransaction ( ) ; 
this . srvDatabase . rollBackTransaction ( ) ; 
this . srvDatabase . releaseResources ( ) ; 
+ entitiesCount + "\">\n" ) ; 
for ( T entity : entities ) { 
this . srvEntityWriter . write ( pAddParam , entity , pWriter ) ; 
this . logger . info ( null , DatabaseWriterXml . class , 
this . logger . error ( null , DatabaseWriterXml . class , 
public static Audit getSingleton ( final String className , final CommonProperties properties ) 
if ( auditInstance == null ) { 
synchronized ( AuditFactory . class ) { 
auditInstance = getInstance ( className , properties ) ; 
return auditInstance ; 
int preparedEntitiesCount = 0 ; 
for ( Class < ? > entityClass : this . classes ) { 
if ( APersistableBase . class . isAssignableFrom ( entityClass ) ) { 
preparedEntitiesCount ++ ; 
+ entityClass . getSimpleName ( ) . toUpperCase ( ) + ";" ; 
Integer maxId = this . srvDatabase 
. evalIntegerResult ( queryMaxId , "MAXID" ) ; 
if ( maxId != null ) { 
maxId ++ ; 
this . srvDatabase . executeQuery ( querySec ) ; 
+ PrepareDbAfterGetCopyPostgresql . class . getSimpleName ( ) 
this . logger . info ( null , PrepareDbAfterGetCopyPostgresql . class , 
} @ SuppressWarnings ( { "PMD.ExcessiveMethodLength" , "PMD.NPathComplexity" , "PMD.CyclomaticComplexity" , "PMD.StdCyclomaticComplexity" , "PMD.ModifiedCyclomaticComplexity" } ) 
public static CommonProperties build ( final Map < String , ? > properties ) { 
final CommonProperties commonProps = new CommonProperties ( ) ; 
String tmp = getOption ( KEY_AUDIT_CLASS_NAME , properties ) ; 
if ( StringUtils . isNotEmpty ( tmp ) ) { 
commonProps . setAuditClassName ( tmp ) ; 
logValue ( KEY_AUDIT_CLASS_NAME , tmp ) ; 
commonProps . setAuditClassName ( DEFAULT_AUDIT_CLASS_NAME ) ; 
logDefault ( KEY_AUDIT_CLASS_NAME , DEFAULT_AUDIT_CLASS_NAME ) ; 
tmp = getOption ( KEY_AUDIT_IS_ENABLED , properties ) ; 
commonProps . setAuditEnabled ( Boolean . parseBoolean ( tmp ) ) ; 
logValue ( KEY_AUDIT_IS_ENABLED , tmp ) ; 
commonProps . setAuditEnabled ( DEFAULT_AUDIT_IS_ENABLED ) ; 
logDefault ( KEY_AUDIT_IS_ENABLED , String . valueOf ( DEFAULT_AUDIT_IS_ENABLED ) ) ; 
tmp = getOption ( KEY_AUDIT_IS_SINGLETON , properties ) ; 
commonProps . setAuditSingleton ( Boolean . parseBoolean ( tmp ) ) ; 
logValue ( KEY_AUDIT_IS_SINGLETON , tmp ) ; 
commonProps . setAuditSingleton ( DEFAULT_AUDIT_IS_SINGLETON ) ; 
logDefault ( KEY_AUDIT_IS_SINGLETON , String . valueOf ( DEFAULT_AUDIT_IS_SINGLETON ) ) ; 
tmp = getOption ( KEY_MESSAGEQ_CLASS_NAME , properties ) ; 
commonProps . setMessageQueueClassName ( tmp ) ; 
logValue ( KEY_MESSAGEQ_CLASS_NAME , tmp ) ; 
commonProps . setMessageQueueClassName ( DEFAULT_MESSAGEQ_CLASS_NAME ) ; 
logDefault ( KEY_MESSAGEQ_CLASS_NAME , DEFAULT_MESSAGEQ_CLASS_NAME ) ; 
tmp = getOption ( KEY_MESSAGEQ_IS_ENABLED , properties ) ; 
commonProps . setMessageQueueEnabled ( Boolean . parseBoolean ( tmp ) ) ; 
logValue ( KEY_MESSAGEQ_IS_ENABLED , tmp ) ; 
commonProps . setMessageQueueEnabled ( DEFAULT_MESSAGEQ_IS_ENABLED ) ; 
logDefault ( KEY_MESSAGEQ_IS_ENABLED , String . valueOf ( DEFAULT_MESSAGEQ_IS_ENABLED ) ) ; 
tmp = getOption ( KEY_MESSAGEQ_IS_SINGLETON , properties ) ; 
commonProps . setMessageQueueSingleton ( Boolean . parseBoolean ( tmp ) ) ; 
logValue ( KEY_MESSAGEQ_IS_SINGLETON , tmp ) ; 
commonProps . setMessageQueueSingleton ( DEFAULT_MESSAGEQ_IS_SINGLETON ) ; 
logDefault ( KEY_MESSAGEQ_IS_SINGLETON , String . valueOf ( DEFAULT_MESSAGEQ_IS_SINGLETON ) ) ; 
tmp = getOption ( KEY_PASSWORD_AUTHENTICATOR_CLASS_NAME , properties ) ; 
commonProps . setPasswordAuthenticatorClassName ( tmp ) ; 
logValue ( KEY_PASSWORD_AUTHENTICATOR_CLASS_NAME , tmp ) ; 
commonProps . setPasswordAuthenticatorClassName ( DEFAULT_PASSWORD_AUTHENTICATOR_CLASS_NAME ) ; 
logDefault ( KEY_PASSWORD_AUTHENTICATOR_CLASS_NAME , DEFAULT_PASSWORD_AUTHENTICATOR_CLASS_NAME ) ; 
tmp = getOption ( KEY_PASSWORD_AUTHENTICATOR_IS_SINGLETON , properties ) ; 
commonProps . setPasswordAuthenticatorSingleton ( Boolean . parseBoolean ( tmp ) ) ; 
logValue ( KEY_PASSWORD_AUTHENTICATOR_IS_SINGLETON , tmp ) ; 
commonProps . setPasswordAuthenticatorSingleton ( DEFAULT_PASSWORD_AUTHENTICATOR_IS_SINGLETON ) ; 
logDefault ( KEY_PASSWORD_AUTHENTICATOR_IS_SINGLETON , 
String . valueOf ( DEFAULT_PASSWORD_AUTHENTICATOR_IS_SINGLETON ) ) ; 
tmp = getOption ( KEY_PASSWORD_VALIDATOR_CLASS_NAME , properties ) ; 
commonProps . setPasswordValidatorClassName ( tmp ) ; 
logValue ( KEY_PASSWORD_VALIDATOR_CLASS_NAME , tmp ) ; 
commonProps . setPasswordValidatorClassName ( DEFAULT_PASSWORD_VALIDATOR_CLASS_NAME ) ; 
logDefault ( KEY_PASSWORD_VALIDATOR_CLASS_NAME , DEFAULT_PASSWORD_VALIDATOR_CLASS_NAME ) ; 
tmp = getOption ( KEY_PASSWORD_VALIDATOR_IS_SINGLETON , properties ) ; 
commonProps . setPasswordValidatorSingleton ( Boolean . parseBoolean ( tmp ) ) ; 
logValue ( KEY_PASSWORD_VALIDATOR_IS_SINGLETON , tmp ) ; 
commonProps . setPasswordValidatorSingleton ( DEFAULT_PASSWORD_VALIDATOR_IS_SINGLETON ) ; 
logDefault ( KEY_PASSWORD_VALIDATOR_IS_SINGLETON , String . valueOf ( DEFAULT_PASSWORD_VALIDATOR_IS_SINGLETON ) ) ; 
final Map < String , String > tempMap = new ConcurrentHashMap < > ( ) ; 
for ( final Map . Entry < String , ? > entry : properties . entrySet ( ) ) { 
final String key = entry . getKey ( ) ; 
final String value = ( String ) entry . getValue ( ) ; 
tempMap . put ( key , value ) ; 
throw new IllegalArgumentException ( error , e ) ; 
commonProps . setAdditionalProperties ( tempMap ) ; 
return commonProps ; 
private static < T > T getOption ( final String key , final Map < String , ? > properties ) { 
return ( T ) properties . get ( key ) ; 
public final boolean sync ( final Map < String , Object > pAddParam , 
final Object pEntity ) throws Exception { 
IHasVersion entityPb = ( IHasVersion ) pEntity ; 
IHasVersion entityPbDb = getSrvOrm ( ) . retrieveEntity ( pAddParam , entityPb ) ; 
boolean isNew = true ; 
if ( entityPbDb != null ) { 
entityPb . setItsVersion ( entityPbDb . getItsVersion ( ) ) ; 
isNew = false ; 
return isNew ; 
} public static ConnectionProperties build ( final Map < String , ? > properties ) { 
final Map < String , String > tmpConfig = new ConcurrentHashMap < > ( ) ; 
tmpConfig . put ( key , value ) ; 
copyValue ( properties , KEY_DRIVER , tmpConfig , MapBasedConnPropsBuilder . KEY_DRIVER ) ; 
copyValue ( properties , KEY_URL , tmpConfig , MapBasedConnPropsBuilder . KEY_URL ) ; 
copyValue ( properties , KEY_USERNAME , tmpConfig , MapBasedConnPropsBuilder . KEY_USERNAME ) ; 
copyValue ( properties , KEY_PASSWORD , tmpConfig , MapBasedConnPropsBuilder . KEY_PASSWORD ) ; 
copyValue ( properties , KEY_MAX_TOTAL , tmpConfig , MapBasedConnPropsBuilder . KEY_MAX_TOTAL ) ; 
copyValue ( properties , KEY_MAX_IDLE , tmpConfig , MapBasedConnPropsBuilder . KEY_MAX_IDLE ) ; 
copyValue ( properties , KEY_MIN_IDLE , tmpConfig , MapBasedConnPropsBuilder . KEY_MIN_IDLE ) ; 
copyValue ( properties , KEY_MAX_WAIT_MILLIS , tmpConfig , MapBasedConnPropsBuilder . KEY_MAX_WAIT_MILLIS ) ; 
copyValue ( properties , KEY_TEST_ON_CREATE , tmpConfig , MapBasedConnPropsBuilder . KEY_TEST_ON_CREATE ) ; 
copyValue ( properties , KEY_TEST_ON_BORROW , tmpConfig , MapBasedConnPropsBuilder . KEY_TEST_ON_BORROW ) ; 
copyValue ( properties , KEY_TEST_ON_RETURN , tmpConfig , MapBasedConnPropsBuilder . KEY_TEST_ON_RETURN ) ; 
copyValue ( properties , KEY_TEST_WHILE_IDLE , tmpConfig , MapBasedConnPropsBuilder . KEY_TEST_WHILE_IDLE ) ; 
copyValue ( properties , KEY_TIME_BETWEEN_EVICTION_RUNS_MILLIS , 
tmpConfig , MapBasedConnPropsBuilder . KEY_TIME_BETWEEN_EVICTION_RUNS_MILLIS ) ; 
copyValue ( properties , KEY_NUM_TESTS_PER_EVICITON_RUN , 
tmpConfig , MapBasedConnPropsBuilder . KEY_NUM_TESTS_PER_EVICITON_RUN ) ; 
copyValue ( properties , KEY_MIN_EVICTABLE_IDLE_TIME_MILLIS , 
tmpConfig , MapBasedConnPropsBuilder . KEY_MIN_EVICTABLE_IDLE_TIME_MILLIS ) ; 
copyValue ( properties , KEY_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS , 
tmpConfig , MapBasedConnPropsBuilder . KEY_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS ) ; 
copyValue ( properties , KEY_LIFO , tmpConfig , MapBasedConnPropsBuilder . KEY_LIFO ) ; 
copyValue ( properties , KEY_AUTO_COMMIT , tmpConfig , MapBasedConnPropsBuilder . KEY_AUTO_COMMIT ) ; 
copyValue ( properties , KEY_READ_ONLY , tmpConfig , MapBasedConnPropsBuilder . KEY_READ_ONLY ) ; 
copyValue ( properties , KEY_TRANSACTION_ISOLATION , tmpConfig , MapBasedConnPropsBuilder . KEY_TRANSACTION_ISOLATION ) ; 
copyValue ( properties , KEY_CACHE_STATE , tmpConfig , MapBasedConnPropsBuilder . KEY_CACHE_STATE ) ; 
copyValue ( properties , KEY_VALIDATION_QUERY , tmpConfig , MapBasedConnPropsBuilder . KEY_VALIDATION_QUERY ) ; 
copyValue ( properties , KEY_MAX_CONN_LIFETIME_MILLIS , 
tmpConfig , MapBasedConnPropsBuilder . KEY_MAX_CONN_LIFETIME_MILLIS ) ; 
return MapBasedConnPropsBuilder . build ( tmpConfig ) ; 
} private static void copyValue ( final Map < String , ? > sourceMap , final String sourceKey , 
final Map < String , String > targetMap , final String targetKey ) { 
if ( getOption ( sourceKey , sourceMap ) != null && String . class . isInstance ( getOption ( sourceKey , sourceMap ) ) ) { 
targetMap . put ( targetKey , ( String ) getOption ( sourceKey , sourceMap ) ) ; 
} public static void auditEvent ( final Audit audit , final String domain , final String username , 
if ( audit == null ) { 
audit . audit ( event , domain , username ) ; 
} catch ( AuditException e ) { 
public final Object read ( final Map < String , Object > pAddParam , 
final Reader pReader ) throws Exception { 
Map < String , String > attributesMap = readAttributes ( pAddParam , pReader ) ; 
if ( attributesMap . get ( "class" ) == null ) { 
Class entityClass = Class . forName ( attributesMap . get ( "class" ) ) ; 
Constructor constructor = entityClass . getDeclaredConstructor ( ) ; 
Object entity = constructor . newInstance ( ) ; 
getMngSettings ( ) . lazFldsSts ( entityClass ) ; 
if ( "true" . equals ( entry . getValue ( ) . get ( "isEnabled" ) ) 
&& attributesMap . get ( entry . getKey ( ) ) != null ) { 
ISrvEntityFieldFiller srvEntityFieldFiller = getFieldsFillersMap ( ) 
. get ( entry . getValue ( ) . get ( "ISrvEntityFieldFiller" ) ) ; 
if ( srvEntityFieldFiller == null ) { 
srvEntityFieldFiller . fill ( pAddParam , entity , entry . getKey ( ) , 
attributesMap . get ( entry . getKey ( ) ) ) ; 
return entity ; 
public final Map < String , String > readAttributes ( 
return this . utilXml . readAttributes ( pReader , pAddParam ) ; 
if ( ! APersistableBase . class . isAssignableFrom ( pEntityClass ) ) { 
throw new ExceptionWithCode ( ExceptionWithCode . CONFIGURATION_MISTAKE , 
+ pEntityClass ) ; 
int requestedDatabaseId ; 
requestedDatabaseId = Integer . parseInt ( pAddParam 
. get ( "requestedDatabaseId" ) . toString ( ) ) ; 
throw new ExceptionWithCode ( ExceptionWithCode . WRONG_PARAMETER , 
+ pAddParam . get ( "requestedDatabaseId" ) ) ; 
+ requestedDatabaseId + ";" ; 
Long maxIdBirth = this . srvDatabase 
. evalLongResult ( queryMaxIdBirth , "MAX_IDBIRTH" ) ; 
if ( maxIdBirth == null ) { 
maxIdBirth = 0L ; 
String tblNm = pEntityClass . getSimpleName ( ) . toUpperCase ( ) ; 
+ ".IDDATABASEBIRTH=" + requestedDatabaseId + ")" ; 
} public final Subject authenticate ( final String domain , final String userName , final char [ ] password , 
if ( domain == null ) { 
if ( userName == null ) { 
final char [ ] myCredential = userName . toCharArray ( ) ; 
final UserPrincipal userPrincipal = new UserPrincipal ( "ID:" + userName , domain , userName ) ; 
public final void readAndStoreEntities ( final Map < String , Object > pAddParam , 
while ( this . utilXml . readUntilStart ( pReader , "entity" ) ) { 
Object entity = this . srvEntityReader . read ( pAddParam , pReader ) ; 
String nameEntitySync = this . mngSettings . lazClsSts ( entity . getClass ( ) ) 
. get ( "ISrvEntitySync" ) ; 
ISrvEntitySync srvEntitySync = this . srvEntitySyncMap 
. get ( nameEntitySync ) ; 
if ( srvEntitySync == null ) { 
boolean isNew = srvEntitySync . sync ( pAddParam , entity ) ; 
if ( isNew ) { 
this . srvOrm . insertEntity ( pAddParam , entity ) ; 
this . srvOrm . updateEntity ( pAddParam , entity ) ; 
public final boolean validate ( final char [ ] providedPassword , final char [ ] storedCredential ) { 
if ( providedPassword == null || storedCredential == null ) { 
return Arrays . equals ( providedPassword , storedCredential ) ; 
ArrayList < Class < ? > > classesArr = 
new ArrayList < Class < ? > > ( this . mngSettings . getClasses ( ) ) ; 
for ( int i = classesArr . size ( ) - 1 ; i >= 0 ; i -- ) { 
Class < ? > entityClass = classesArr . get ( i ) ; 
this . srvDatabase . executeDelete ( entityClass . getSimpleName ( ) 
. toUpperCase ( ) , null ) ; 
+ SrvClearDatabase . class . getSimpleName ( ) 
if ( ! AHasIdString . class . isAssignableFrom ( rField . getType ( ) ) ) { 
Constructor constructor = rField . getType ( ) . getDeclaredConstructor ( ) ; 
Object ownedEntity = constructor . newInstance ( ) ; 
( ( AHasIdString ) ownedEntity ) . setItsId ( pFieldStrValue ) ; 
rField . set ( pEntity , ownedEntity ) ; 
public final void replicate ( 
String urlSourceStr = "https://" + ( String ) pAddParams . get ( "urlSource" ) ; 
if ( urlSourceStr == null || urlSourceStr . length ( ) < 10 ) { 
URL url = new URL ( urlSourceStr ) ; 
String authMethod = ( String ) pAddParams . get ( "authMethod" ) ; 
if ( "base" . equals ( authMethod ) ) { 
final String userName = ( String ) pAddParams . get ( "userName" ) ; 
final String userPass = ( String ) pAddParams . get ( "userPass" ) ; 
Authenticator . setDefault ( new Authenticator ( ) { 
protected PasswordAuthentication getPasswordAuthentication ( ) { 
return new PasswordAuthentication ( userName , userPass . toCharArray ( ) ) ; 
} else if ( "form" . equals ( authMethod ) ) { 
CookieManager cookieManager = new CookieManager ( ) ; 
CookieHandler . setDefault ( cookieManager ) ; 
cookieManager . setCookiePolicy ( CookiePolicy . ACCEPT_ALL ) ; 
requestCookiesGet ( pAddParams ) ; 
authForm ( pAddParams , cookieManager ) ; 
Map < String , Integer > classesCounts = makeJob ( url , pAddParams ) ; 
htmlWriter . write ( "<h4>" + new Date ( ) . toString ( ) 
+ statusString + "</h4>" ) ; 
+ ReplicatorXmlHttp . class . getSimpleName ( ) 
+ statusString ) ; 
this . logger . info ( null , ReplicatorXmlHttp . class , statusString ) ; 
htmlWriter . write ( "<table>" ) ; 
for ( Map . Entry < String , Integer > entry : classesCounts . entrySet ( ) ) { 
htmlWriter . write ( "<tr>" ) ; 
htmlWriter . write ( "<td>" + entry . getKey ( ) + "</td>" ) ; 
htmlWriter . write ( "<td>" + entry . getValue ( ) + "</td>" ) ; 
htmlWriter . write ( "</tr>" ) ; 
htmlWriter . write ( "</table>" ) ; 
} catch ( ExceptionWithCode ex ) { 
this . logger . error ( null , ReplicatorXmlHttp . class , 
ex . getShortMessage ( ) ) ; 
} public final Map < String , Integer > makeJob ( final URL pUrl , 
String requestedDatabaseId = ( String ) pAddParams . get ( "requestedDatabaseId" ) ; 
String maxRecordsStr = ( String ) pAddParams . get ( "maxRecords" ) ; 
if ( maxRecordsStr == null || maxRecordsStr . length ( ) == 0 ) { 
int maxRecords = Integer . parseInt ( maxRecordsStr ) ; 
Map < String , Integer > classesCounts = new LinkedHashMap < String , Integer > ( ) ; 
Integer classCount = 0 ; 
boolean isDbPreparedBefore = false ; 
for ( Class < ? > entityClass : this . mngSettings . getClasses ( ) ) { 
int entitiesReceived = 0 ; 
int firstRecord = 0 ; 
HttpsURLConnection urlConnection = ( HttpsURLConnection ) pUrl . openConnection ( ) ; 
if ( ! pUrl . getHost ( ) . equals ( urlConnection . getURL ( ) . getHost ( ) ) ) { 
throw new ExceptionWithCode ( ExceptionWithCode . SOMETHING_WRONG , 
OutputStreamWriter writer = null ; 
BufferedReader reader = null ; 
urlConnection . setDoOutput ( true ) ; 
urlConnection . setRequestMethod ( "POST" ) ; 
if ( getCookies ( ) != null ) { 
urlConnection . addRequestProperty ( "Cookie" , getCookies ( ) ) ; 
writer = new OutputStreamWriter ( urlConnection 
. getOutputStream ( ) , Charset . forName ( "UTF-8" ) . newEncoder ( ) ) ; 
String nameFilterEntities = this . mngSettings . lazClsSts ( entityClass ) 
. get ( "filter" ) ; 
String conditions = "" ; 
if ( nameFilterEntities != null ) { 
IFilterEntities filterEntities = this . filtersEntities 
. get ( nameFilterEntities ) ; 
if ( filterEntities != null ) { 
String cond = filterEntities . makeFilter ( entityClass , pAddParams ) ; 
if ( cond != null ) { 
String requestedDatabaseIdStr = "" ; 
if ( requestedDatabaseId != null ) { 
if ( Integer . parseInt ( requestedDatabaseId ) 
== getSrvDatabase ( ) . getIdDatabase ( ) ) { 
"requested_database_must_be_different" ) ; 
requestedDatabaseIdStr = "&requestedDatabaseId=" 
+ requestedDatabaseId ; 
writer . write ( "entityName=" + entityClass . getCanonicalName ( ) 
+ "&conditions=" + conditions + "&requestingDatabaseVersion=" 
+ databaseVersion + requestedDatabaseIdStr ) ; 
writer . write ( "&writerName=" + pAddParams . get ( "writerName" ) ) ; 
if ( HttpsURLConnection . HTTP_OK == urlConnection . getResponseCode ( ) ) { 
reader = new BufferedReader ( new InputStreamReader ( urlConnection 
. getInputStream ( ) , Charset . forName ( "UTF-8" ) . newDecoder ( ) ) ) ; 
if ( ! this . utilXml . readUntilStart ( reader , "message" ) ) { 
Map < String , String > msgAttrsMap = this . srvEntityReaderXml . 
readAttributes ( pAddParams , reader ) ; 
String error = msgAttrsMap . get ( "error" ) ; 
error ) ; 
String entitiesCountStr = msgAttrsMap . get ( "entitiesCount" ) ; 
if ( entitiesCountStr == null ) { 
entitiesReceived = Integer . parseInt ( entitiesCountStr ) ; 
if ( entitiesReceived > 0 ) { 
classCount += entitiesReceived ; 
this . logger . info ( null , ReplicatorXmlHttp . class , 
+ entityClass . getCanonicalName ( ) ) ; 
if ( ! isDbPreparedBefore ) { 
if ( this . databasePrepearerBefore != null ) { 
this . databasePrepearerBefore . make ( pAddParams ) ; 
isDbPreparedBefore = true ; 
this . databaseReader . readAndStoreEntities ( pAddParams , reader ) ; 
if ( entitiesReceived == maxRecords ) { 
firstRecord += maxRecords ; 
firstRecord = 0 ; 
entitiesReceived = 0 ; 
. getResponseCode ( ) ) ; 
if ( writer != null ) { 
urlConnection . disconnect ( ) ; 
} while ( entitiesReceived > 0 ) ; 
classesCounts . put ( entityClass . getCanonicalName ( ) , classCount ) ; 
classCount = 0 ; 
if ( this . databasePrepearerAfter != null ) { 
this . databasePrepearerAfter . make ( pAddParams ) ; 
return classesCounts ; 
} public final void requestCookiesGet ( 
String urlGetAuthCookStr = ( String ) pAddParams . get ( "urlGetAuthCookies" ) ; 
URL urlGetAuthCookies = new URL ( urlGetAuthCookStr ) ; 
HttpsURLConnection urlConnection = null ; 
urlConnection = ( HttpsURLConnection ) urlGetAuthCookies . openConnection ( ) ; 
urlConnection . setRequestMethod ( "GET" ) ; 
urlConnection . addRequestProperty ( "Connection" , "keep-alive" ) ; 
while ( reader . read ( ) != - 1 ) { 
+ urlConnection . getResponseCode ( ) ) ; 
if ( urlConnection != null ) { 
} public final void authForm ( final Map < String , Object > pAddParams , 
final CookieManager pCookieManager ) throws Exception { 
String authUrl = ( String ) pAddParams . get ( "authUrl" ) ; 
String authUserName = ( String ) pAddParams . get ( "authUserName" ) ; 
String authUserPass = ( String ) pAddParams . get ( "authUserPass" ) ; 
String userName = ( String ) pAddParams . get ( "userName" ) ; 
String userPass = ( String ) pAddParams . get ( "userPass" ) ; 
URL url = new URL ( authUrl ) ; 
HttpsURLConnection urlConnection = ( HttpsURLConnection ) url 
. openConnection ( ) ; 
if ( ! url . getHost ( ) . equals ( urlConnection . getURL ( ) . getHost ( ) ) ) { 
String paramStr = authUserName + "=" + userName + "&" 
+ authUserPass + "=" + userPass ; 
StringBuffer cookiesSb = new StringBuffer ( ) ; 
for ( HttpCookie cookie : pCookieManager . getCookieStore ( ) . getCookies ( ) ) { 
cookiesSb . append ( cookie . getName ( ) + "=" + cookie . getValue ( ) + ";" ) ; 
setCookies ( cookiesSb . toString ( ) ) ; 
urlConnection . addRequestProperty ( "Content-Type" , 
"application/x-www-form-urlencoded" ) ; 
urlConnection . addRequestProperty ( "Content-Length" , 
String . valueOf ( paramStr . length ( ) ) ) ; 
boolean isDbgSh = this . logger . getDbgSh ( this . getClass ( ) ) 
&& this . logger . getDbgFl ( ) < 8001 && this . logger . getDbgCl ( ) > 8003 ; 
if ( isDbgSh ) { 
getLogger ( ) . debug ( null , ReplicatorXmlHttp . class , 
for ( Map . Entry < String , List < String > > entry 
: urlConnection . getRequestProperties ( ) . entrySet ( ) ) { 
this . logger . debug ( null , ReplicatorXmlHttp . class , 
for ( String val : entry . getValue ( ) ) { 
writer . write ( paramStr ) ; 
} @ SuppressWarnings ( "PMD.GuardLogStatementJavaUtil" ) 
public final void create ( final Events event , final String userId ) { 
} public final void setLastDateReplication ( final Date pLastDateReplication ) { 
if ( pLastDateReplication == null ) { 
this . lastDateReplication = null ; 
this . lastDateReplication = new Date ( pLastDateReplication . getTime ( ) ) ; 
public final void initialize ( final Subject subject , final CallbackHandler callbackHandler , 
final Map < String , ? > sharedState , final Map < String , ? > options ) { 
LOG . debug ( "Initializing" ) ; 
this . pSubject = subject ; 
this . pCallbackHandler = callbackHandler ; 
final CommonProperties commonProps = JaasBasedCommonPropsBuilder . build ( options ) ; 
initAudit ( commonProps ) ; 
initMessageQueue ( commonProps ) ; 
initPwValidator ( commonProps ) ; 
initPwAuthenticator ( commonProps ) ; 
public final boolean login ( ) 
if ( pCallbackHandler == null ) { 
LOG . error ( error ) ; 
Callback [ ] callbacks = new Callback [ 3 ] ; 
callbacks [ 0 ] = new TextInputCallback ( "j_domain" ) ; 
callbacks [ 1 ] = new NameCallback ( "j_username" ) ; 
callbacks [ 2 ] = new PasswordCallback ( "j_password" , false ) ; 
pCallbackHandler . handle ( callbacks ) ; 
domain = ( ( TextInputCallback ) callbacks [ 0 ] ) . getText ( ) ; 
username = ( ( NameCallback ) callbacks [ 1 ] ) . getName ( ) ; 
final char [ ] tempPassword = ( ( PasswordCallback ) callbacks [ 2 ] ) . getPassword ( ) ; 
password = tempPassword . clone ( ) ; 
( ( PasswordCallback ) callbacks [ 2 ] ) . clearPassword ( ) ; 
cleanState ( ) ; 
} catch ( UnsupportedCallbackException e ) { 
final String error = 
pendingSubject = pwAuthenticator . authenticate ( domain , username , password , pwValidator ) ; 
Cleanser . wipe ( password ) ; 
final String baseError = new StringBuilder ( ) . 
append ( username ) . 
append ( "@" ) . 
append ( domain ) . 
toString ( ) ; 
AuditHelper . auditEvent ( audit , domain , username , Events . AUTHN_ATTEMPT , 
MessageHelper . postMessage ( messageQ , domain , username , Events . AUTHN_ATTEMPT , 
} catch ( LoginException e ) { 
final String tempUsername = username ; 
final String tempDomain = domain ; 
append ( tempUsername ) . 
append ( tempDomain ) . 
AuditHelper . auditEvent ( audit , tempDomain , tempUsername , Events . AUTHN_FAILURE , 
MessageHelper . postMessage ( messageQ , tempDomain , tempUsername , Events . AUTHN_FAILURE , 
LOG . info ( error , e ) ; 
public final boolean commit ( ) 
if ( pendingSubject == null ) { 
if ( committedSubject == null ) { 
committedSubject = new Subject ( ) ; 
AuditHelper . auditEvent ( audit , tempDomain , tempUsername , Events . AUTHN_ERROR , 
MessageHelper . postMessage ( messageQ , tempDomain , tempUsername , Events . AUTHN_ERROR , 
for ( final Principal p : pendingSubject . getPrincipals ( ) ) { 
if ( ! pSubject . getPrincipals ( ) . contains ( p ) ) { 
pSubject . getPrincipals ( ) . add ( p ) ; 
if ( ! committedSubject . getPrincipals ( ) . contains ( p ) ) { 
committedSubject . getPrincipals ( ) . add ( p ) ; 
AuditHelper . auditEvent ( audit , domain , username , Events . AUTHN_SUCCESS , 
MessageHelper . postMessage ( messageQ , domain , username , Events . AUTHN_SUCCESS , 
public final boolean abort ( ) 
} else if ( committedSubject == null ) { 
AuditHelper . auditEvent ( audit , tempDomain , tempUsername , Events . AUTHN_ABORT_COMMIT , 
MessageHelper . postMessage ( messageQ , tempDomain , tempUsername , Events . AUTHN_ABORT_COMMIT , 
AuditHelper . auditEvent ( audit , domain , username , Events . AUTHN_ABORT_CHAIN , 
MessageHelper . postMessage ( messageQ , domain , username , Events . AUTHN_ABORT_CHAIN , 
logout ( ) ; 
public final boolean logout ( ) 
final StringBuilder principals = new StringBuilder ( ":" ) ; 
if ( committedSubject != null && committedSubject . getPrincipals ( ) != null ) { 
final StringBuilder stringBuilder = new StringBuilder ( ) ; 
for ( final Principal p : committedSubject . getPrincipals ( ) ) { 
pSubject . getPrincipals ( ) . remove ( p ) ; 
principals . append ( p . getName ( ) ) . append ( ':' ) ; 
stringBuilder . delete ( 0 , stringBuilder . length ( ) ) ; 
final String baseError = stringBuilder . 
AuditHelper . auditEvent ( audit , domain , username , Events . AUTHN_LOGOUT , 
MessageHelper . postMessage ( messageQ , domain , username , Events . AUTHN_LOGOUT , 
} @ SuppressWarnings ( "PMD.NullAssignment" ) 
private void cleanState ( ) { 
domain = null ; 
pendingSubject = null ; 
committedSubject = null ; 
} @ SuppressWarnings ( "PMD.ConfusingTernary" ) 
private void initAudit ( final CommonProperties commonProps ) { 
final String auditClassName = commonProps . getAuditClassName ( ) ; 
if ( ! commonProps . isAuditEnabled ( ) ) { 
} else if ( auditClassName == null ) { 
throw new IllegalStateException ( error ) ; 
if ( commonProps . isAuditSingleton ( ) ) { 
this . audit = AuditFactory . getSingleton ( auditClassName , commonProps ) ; 
this . audit = AuditFactory . getInstance ( auditClassName , commonProps ) ; 
LOG . error ( error , e ) ; 
throw new IllegalStateException ( error , e ) ; 
private void initMessageQueue ( final CommonProperties commonProps ) { 
final String messageClassName = commonProps . getMessageQueueClassName ( ) ; 
if ( ! commonProps . isMessageQueueEnabled ( ) ) { 
} else if ( messageClassName == null ) { 
if ( commonProps . isMessageQueueSingleton ( ) ) { 
this . messageQ = MessageQFactory . getSingleton ( messageClassName , commonProps ) ; 
this . messageQ = MessageQFactory . getInstance ( messageClassName , commonProps ) ; 
} private void initPwValidator ( final CommonProperties commonProps ) { 
final String validatorClass = commonProps . getPasswordValidatorClassName ( ) ; 
if ( validatorClass == null ) { 
if ( commonProps . isPasswordValidatorSingleton ( ) ) { 
this . pwValidator = PasswordValidatorFactory . getSingleton ( validatorClass , commonProps ) ; 
this . pwValidator = PasswordValidatorFactory . getInstance ( validatorClass , commonProps ) ; 
} private void initPwAuthenticator ( final CommonProperties commonProps ) { 
final String authNticatorClass = commonProps . getPasswordAuthenticatorClassName ( ) ; 
if ( authNticatorClass == null ) { 
if ( commonProps . isPasswordAuthenticatorSingleton ( ) ) { 
this . pwAuthenticator = PasswordAuthenticatorFactory . getSingleton ( authNticatorClass , commonProps ) ; 
this . pwAuthenticator = PasswordAuthenticatorFactory . getInstance ( authNticatorClass , commonProps ) ; 
Object entityPbDb = getSrvOrm ( ) . retrieveEntity ( pAddParam , pEntity ) ; 
return entityPbDb == null ; 
} public static DbProperties build ( final Map < String , ? > properties ) { 
final DbProperties dbProps = new DbProperties ( ) ; 
String tmp = getOption ( KEY_JNDI_CONNECTION_NAME , properties ) ; 
dbProps . setJndiConnectionName ( tmp ) ; 
logValue ( KEY_JNDI_CONNECTION_NAME , tmp ) ; 
dbProps . setJndiConnectionName ( DEFAULT_JNDI_NAME ) ; 
logDefault ( KEY_JNDI_CONNECTION_NAME , DEFAULT_JNDI_NAME ) ; 
tmp = getOption ( KEY_SQL_USER_QUERY , properties ) ; 
dbProps . setSqlUserQuery ( tmp ) ; 
logValue ( KEY_SQL_USER_QUERY , tmp ) ; 
dbProps . setSqlUserQuery ( DEFAULT_SQL_USER_QUERY ) ; 
logDefault ( KEY_SQL_USER_QUERY , DEFAULT_SQL_USER_QUERY ) ; 
dbProps . setAdditionalProperties ( tempMap ) ; 
return dbProps ; 
} public static MessageQ getInstance ( final String className , final CommonProperties properties ) 
final Class < ? extends MessageQ > messageClazz ; 
messageClazz = Class . forName ( className ) . asSubclass ( MessageQ . class ) ; 
throw new FactoryException ( error , e ) ; 
final MessageQ messageQ ; 
final Constructor < ? extends MessageQ > constructor = messageClazz . getDeclaredConstructor ( ) ; 
if ( ! constructor . isAccessible ( ) ) { 
messageQ = constructor . newInstance ( ) ; 
} catch ( InstantiationException | IllegalAccessException | InvocationTargetException 
| NoSuchMethodException | IllegalArgumentException e ) { 
messageQ . init ( properties ) ; 
return messageQ ; 
public static MessageQ getSingleton ( final String className , final CommonProperties properties ) 
if ( messageQInstance == null ) { 
synchronized ( MessageQFactory . class ) { 
messageQInstance = getInstance ( className , properties ) ; 
return messageQInstance ; 
APersistableBaseVersion entityPb = ( APersistableBaseVersion ) pEntity ; 
int currDbId = getSrvOrm ( ) . getIdDatabase ( ) ; 
if ( currDbId == entityPb . getIdDatabaseBirth ( ) ) { 
+ "," + entityPb . getIdDatabaseBirth ( ) ) ; 
String tblNm = pEntity . getClass ( ) . getSimpleName ( ) . toUpperCase ( ) ; 
APersistableBaseVersion entityPbDb = getSrvOrm ( ) 
. retrieveEntityWithConditions ( pAddParam , entityPb . getClass ( ) , whereStr ) ; 
entityPb . setIdBirth ( entityPb . getItsId ( ) ) ; 
entityPb . setItsId ( null ) ; 
entityPb . setItsId ( entityPbDb . getItsId ( ) ) ; 
} public QueryParameter partialCopy ( final QueryParameterKind ... excludedElements ) { 
List < QueryParameterKind > excludedList = Arrays . asList ( excludedElements ) ; 
QueryParameter returnValue = new QueryParameter ( ) ; 
if ( ! excludedList . contains ( QueryParameterKind . CONSTRAINTS ) ) { 
returnValue . rawConstraints = this . rawConstraints ; 
if ( ! excludedList . contains ( QueryParameterKind . GROUPS ) ) { 
returnValue . groups = this . groups ; 
if ( ! excludedList . contains ( QueryParameterKind . ORDERS ) ) { 
returnValue . orders = this . orders ; 
if ( ! excludedList . contains ( QueryParameterKind . PAGE ) ) { 
returnValue . pageSize = this . pageSize ; 
returnValue . page = this . page ; 
if ( ! excludedList . contains ( QueryParameterKind . TIMEZONE ) ) { 
returnValue . timezoneName = this . timezoneName ; 
public boolean areLinked ( SqlTable table1 , SqlTable table2 ) { 
return predecessorRelation . get ( table1 . getTableName ( ) ) . containsKey ( table2 . getTableName ( ) ) ; 
public DimensionTable getDimensionByName ( String dimensionName , String tzNameAlias ) { 
DimensionTable dimensionTable ; 
if ( StringUtils . isBlank ( tzNameAlias ) || ( StringUtils . isNotBlank ( tzNameAlias ) && tzNameAlias . equals ( getDefaultTimezone ( ) ) ) ) { 
dimensionTable = dimensions . get ( dimensionName . toUpperCase ( ) ) ; 
if ( ! isTimeZoneSupported ( tzNameAlias ) ) { 
String tzName = tzNamesAliases . get ( tzNameAlias ) ; 
dimensionTable = alternateDimensions . get ( Pair . of ( dimensionName . toUpperCase ( ) , tzName ) ) ; 
if ( dimensionTable == null ) { 
return dimensionTable ; 
public List < AbstractSqlColumn > getMeasuresColumn ( ) { 
return Collections . unmodifiableList ( Lists . newArrayList ( factTable . getMeasuresColumn ( ) . values ( ) ) ) ; 
public Optional < AbstractSqlColumn > getMeasuresByName ( String informationName ) { 
for ( AbstractSqlColumn column : factTable . getMeasuresColumn ( ) . values ( ) ) { 
if ( column . getBusinessName ( ) . equalsIgnoreCase ( informationName ) ) { 
return Optional . of ( column ) ; 
return Optional . absent ( ) ; 
public AbstractSqlColumn getInformationColumn ( DimensionTable dimension , String informationName ) { 
final AbstractSqlColumn sqlTableColumn = dimension . getSqlTableColumnByInformationName ( informationName ) ; 
if ( sqlTableColumn == null ) { 
return sqlTableColumn ; 
public boolean isValidDimension ( String dimensionName , String informationName ) { 
if ( StringUtils . isNotBlank ( dimensionName ) ) { 
DimensionTable dim = dimensions . get ( dimensionName . toUpperCase ( ) ) ; 
if ( StringUtils . isBlank ( informationName ) ) { 
if ( dim . getSqlTableColumnByInformationName ( informationName . toUpperCase ( ) ) != null ) { 
public boolean isMandatoryDimension ( String dimensionName ) { 
if ( isValidDimension ( dimensionName , null ) ) { 
return mandatoryDimensionNames . contains ( dimensionName . toUpperCase ( Locale . ENGLISH ) ) ; 
public ColumnDataType getInformationType ( String dimensionName , String informationName ) { 
return dim . getDefaultSearchColumn ( ) . getColumnType ( ) ; 
AbstractSqlColumn information = dim . getSqlTableColumnByInformationName ( informationName ) ; 
if ( information == null ) { 
return information . getColumnType ( ) ; 
} public void addSupportedTZ ( String tzName ) { 
if ( ! StringUtils . isBlank ( tzName ) && ! tzNamesAliases . containsKey ( tzName . trim ( ) ) ) { 
tzNamesAliases . put ( tzName . trim ( ) , tzName . trim ( ) ) ; 
} public void addTZAlternateDimension ( String orignalDimensionName , DimensionTable alternateDimension , String tzName ) { 
addSupportedTZ ( tzName ) ; 
if ( tzNamesAliases . containsValue ( tzName ) ) { 
sqlTables . put ( alternateDimension . getTableName ( ) , alternateDimension ) ; 
alternateDimensions . put ( Pair . of ( orignalDimensionName . toUpperCase ( ) , tzName ) , alternateDimension ) ; 
} public void addDimension ( DimensionTable table , boolean mandatory ) { 
sqlTables . put ( table . getTableName ( ) , table ) ; 
dimensions . put ( table . getDimensionName ( ) . toUpperCase ( ) , table ) ; 
mandatoryDimensionNames . add ( table . getDimensionName ( ) . toUpperCase ( Locale . ENGLISH ) ) ; 
} public Collection < Error > buildAndValidateConfig ( ) { 
Collection < Error > returnValue = new ArrayList < Error > ( ) ; 
if ( defaultTimezone == null ) { 
for ( Pair < Pair < String , String > , Pair < String , String > > fkRelationship : fkRelationshipSet ) { 
Optional < PhysicalSqlColumn > left = getColumnByPair ( fkRelationship . getLeft ( ) ) ; 
Optional < PhysicalSqlColumn > right = getColumnByPair ( fkRelationship . getRight ( ) ) ; 
if ( ! left . isPresent ( ) ) { 
} else if ( ! right . isPresent ( ) ) { 
buildSqlForeignKey ( left . get ( ) , right . get ( ) ) ; 
for ( Entry < Pair < String , String > , DimensionTable > entry : alternateDimensions . entrySet ( ) ) { 
DimensionTable dim = dimensions . get ( entry . getKey ( ) . getLeft ( ) ) ; 
if ( ! dim . isEquivalent ( entry . getValue ( ) , returnValue ) ) { 
+ "." ) ) ; 
public boolean isValidMeasure ( String name ) { 
if ( column . getBusinessName ( ) . equals ( name ) ) { 
} @ RequestMapping ( value = { "/{schema:[^\\.]+}" , "/{schema}.json" } , produces = "application/json" , headers = { "Accept=application/json" } ) 
@ ResponseBody 
public Report processJsonRequest ( @ PathVariable String schema , HttpServletRequest request ) throws ServiceException , InvalidParameterException , 
InvalidSchemaException { 
return processRequest ( schema , request ) ; 
private Report processRequest ( String schema , HttpServletRequest request ) throws ServiceException , InvalidParameterException , 
long begin = System . currentTimeMillis ( ) ; 
SchemaDefinition config = schemaRepository . getStarSchemaConfig ( schema ) ; 
Map < String , String [ ] > params = request . getParameterMap ( ) ; 
for ( String mandatory : MANDATORY_FIELDS ) { 
if ( ! params . containsKey ( mandatory ) ) { 
QueryParameterEnvelope queryParameterDto = new QueryParameterEnvelope ( ) ; 
for ( String key : params . keySet ( ) ) { 
if ( DOMAIN_PARAMETERS . contains ( key ) ) { 
String domainParameter = params . get ( key ) [ 0 ] ; 
final DomainParserAware systemParameter = SystemParameter . valueOf ( key ) ; 
systemParameter . parseValue ( domainParameter , config , queryParameterDto ) ; 
Pair < String , String > pair = splitKey ( key ) ; 
if ( ! config . isValidDimension ( pair . getLeft ( ) , pair . getRight ( ) ) ) { 
String [ ] multiParam = request . getParameterValues ( key ) ; 
for ( String param : multiParam ) { 
queryParameterDto . addConstraints ( new HttpQueryConstraint ( config , key , param ) ) ; 
final Report report = schemaService . generateReport ( config , queryParameterDto ) ; 
report . setRecords ( inMemoryPagination ( report . getRecords ( ) , queryParameterDto ) ) ; 
return report ; 
} @ ExceptionHandler ( ServiceException . class ) 
public ResponseEntity < String > handleServiceException ( ServiceException exception ) { 
HttpHeaders headers = new HttpHeaders ( ) ; 
headers . setContentType ( MediaType . TEXT_PLAIN ) ; 
return new ResponseEntity < String > ( exception . getMessage ( ) , headers , HttpStatus . INTERNAL_SERVER_ERROR ) ; 
} @ ExceptionHandler ( InvalidParameterException . class ) 
public ResponseEntity < String > handleControllerException ( InvalidParameterException exception ) { 
return new ResponseEntity < String > ( exception . getMessage ( ) , headers , HttpStatus . BAD_REQUEST ) ; 
} @ ExceptionHandler ( InvalidSchemaException . class ) 
public ResponseEntity < String > handleInvalidSchemaException ( InvalidSchemaException exception ) { 
return new ResponseEntity < String > ( exception . getMessage ( ) , headers , HttpStatus . NOT_FOUND ) ; 
} private static Pair < String , String > splitKey ( String key ) { 
String dimension = null ; 
String info = null ; 
if ( ! key . contains ( "." ) ) { 
dimension = key ; 
dimension = key . substring ( 0 , key . indexOf ( '.' ) ) ; 
info = key . substring ( key . indexOf ( '.' ) + 1 , key . length ( ) ) ; 
return Pair . of ( dimension , info ) ; 
} private List < ReportRecord > inMemoryPagination ( final List < ReportRecord > recordList , QueryParameterEnvelope queryParameterEnvelope ) { 
final QueryParameterAware pageSize = queryParameterEnvelope . getPageSize ( ) ; 
final QueryParameterAware pageNumber = queryParameterEnvelope . getPageNumber ( ) ; 
if ( pageSize != null && pageNumber != null ) { 
final Integer pageSizeValue = ( ( PageSizeConstraint ) pageSize ) . getPageSizeValue ( ) ; 
final Integer pageValue = ( ( PageNumberConstraint ) pageNumber ) . getPageNumberValue ( ) - 1 ; 
int offset = pageValue * pageSizeValue ; 
return recordList . subList ( offset > recordList . size ( ) ? recordList . size ( ) : offset , offset + pageSizeValue > recordList . size ( ) 
? recordList . size ( ) : offset + pageSizeValue ) ; 
return recordList ; 
} public final boolean containsColumn ( String columnName ) { 
if ( StringUtils . isNotBlank ( columnName ) ) { 
return sqlTableColumns . containsKey ( columnName ) ; 
} public boolean isEquivalent ( DimensionTable otherDim , Collection < Error > errors ) { 
if ( this . informationNameToColumn . size ( ) != otherDim . informationNameToColumn . size ( ) ) { 
for ( Entry < String , AbstractSqlColumn > entry : this . informationNameToColumn . entrySet ( ) ) { 
AbstractSqlColumn otherCol = otherDim . informationNameToColumn . get ( entry . getKey ( ) ) ; 
if ( otherCol == null ) { 
if ( ! otherCol . getBusinessName ( ) . equals ( entry . getValue ( ) . getBusinessName ( ) ) ) { 
if ( otherCol . getColumnType ( ) != entry . getValue ( ) . getColumnType ( ) ) { 
if ( ! otherDim . getDefaultSearchColumn ( ) . getBusinessName ( ) . equals ( this . getDefaultSearchColumn ( ) . getBusinessName ( ) ) ) { 
if ( ! otherDim . getDefaultGroupByColumn ( ) . getBusinessName ( ) . equals ( this . getDefaultGroupByColumn ( ) . getBusinessName ( ) ) ) { 
if ( ! otherDim . getLinkedTables ( ) . equals ( this . getLinkedTables ( ) ) ) { 
} public < T extends MeasureAppender > T retrieveSummary ( SchemaDefinition schemaDefinition , Class < T > resultClazz , QueryParameter queryParameter ) throws NovieRuntimeException { 
final SqlQueryBuilder < T > sqlQueryBuilder = new SqlQueryBuilder < T > ( schemaDefinition , resultClazz , 
queryParameter . partialCopy ( QueryParameterKind . GROUPS , QueryParameterKind . PAGE ) ) ; 
List < T > result = executeQuery ( sqlQueryBuilder ) ; 
return result . get ( 0 ) ; 
} public < T extends MeasureAppender > List < T > retrieveRecords ( SchemaDefinition schemaDefinition , Class < T > resultClazz , QueryParameter queryParameter ) throws NovieRuntimeException { 
final SqlQueryBuilder < T > sqlQueryBuilder = new SqlQueryBuilder < T > ( schemaDefinition , resultClazz , queryParameter ) ; 
return executeQuery ( sqlQueryBuilder ) ; 
} private < T extends MeasureAppender > List < T > executeQuery ( final SqlQueryBuilder < T > sqlQueryBuilder ) throws NovieRuntimeException { 
sqlQueryBuilder . buildQuery ( ) ; 
final String queryString = sqlQueryBuilder . getQueryString ( ) ; 
LOG . debug ( queryString ) ; 
long beforeQuery = System . currentTimeMillis ( ) ; 
List < T > returnValue = jdbcTemplate . query ( queryString , sqlQueryBuilder . getMapSqlParameterSource ( ) , sqlQueryBuilder ) ; 
for ( Entry < String , Object > e : sqlQueryBuilder . getMapSqlParameterSource ( ) . getValues ( ) . entrySet ( ) ) { 
sb . append ( "," ) ; 
sb . append ( e . getKey ( ) ) ; 
sb . append ( "=" ) ; 
sb . append ( e . getValue ( ) ) ; 
LOG . debug ( sb . toString ( ) ) ; 
} private static synchronized void initializeForType1 ( ) { 
if ( type1Initialized == true ) { 
RANDOM = new SecureRandom ( ) ; 
_seq = ( short ) RANDOM . nextInt ( MAX_14BIT ) ; 
byte [ ] ip = null ; 
ip = InetAddress . getLocalHost ( ) . getAddress ( ) ; 
throw new NestableRuntimeException ( ioe ) ; 
IP = new byte [ 6 ] ; 
RANDOM . nextBytes ( IP ) ; 
System . arraycopy ( ip , 0 , IP , 2 , ip . length ) ; 
type1Initialized = true ; 
} public static byte [ ] next ( ) { 
if ( type1Initialized == false ) { 
initializeForType1 ( ) ; 
byte [ ] uuid = new byte [ 16 ] ; 
System . arraycopy ( IP , 0 , uuid , 10 , IP . length ) ; 
long now = 0 ; 
synchronized ( Type1UUID . class ) { 
now = getTime ( ) ; 
uuid [ IDX_TIME_SEQ ] = ( byte ) ( ( _seq & 0x3F00 ) > > > 8 ) ; 
uuid [ IDX_VARIATION ] |= 0x80 ; 
uuid [ IDX_TIME_SEQ + 1 ] = ( byte ) ( _seq & 0xFF ) ; 
byte [ ] timeBytes = toBytes ( now ) ; 
System . arraycopy ( timeBytes , TS_TIME_LO_IDX , uuid , IDX_TIME_LO , TS_TIME_LO_LEN ) ; 
System . arraycopy ( timeBytes , TS_TIME_MID_IDX , uuid , IDX_TIME_MID , TS_TIME_MID_LEN ) ; 
System . arraycopy ( timeBytes , TS_TIME_HI_IDX , uuid , IDX_TIME_HI , TS_TIME_HI_LEN ) ; 
uuid [ IDX_TYPE ] |= TYPE_TIME_BASED ; 
return uuid ; 
} static long getTime ( ) { 
if ( RANDOM == null ) 
long newTime = getUUIDTime ( ) ; 
if ( newTime <= _lastMillis ) { 
incrementSequence ( ) ; 
newTime = getUUIDTime ( ) ; 
_lastMillis = newTime ; 
return newTime ; 
} private static long getUUIDTime ( ) { 
if ( _currentMillis != System . currentTimeMillis ( ) ) { 
_currentMillis = System . currentTimeMillis ( ) ; 
_counter = 0 ; 
if ( _counter + 1 >= MILLI_MULT ) { 
_currentMillis ++ ; 
long currentTime = ( _currentMillis + GREG_OFFSET ) * MILLI_MULT ; 
return currentTime + _counter ++ ; 
} void internalize ( ContentManagerImpl contentManager , boolean readOnly ) { 
this . contentManager = contentManager ; 
updated = false ; 
newcontent = false ; 
this . readOnly = readOnly ; 
} public void reset ( Map < String , Object > updatedMap ) { 
if ( ! readOnly ) { 
this . content = ImmutableMap . copyOf ( updatedMap ) ; 
updatedContent . clear ( ) ; 
} public void setProperty ( String key , Object value ) { 
if ( readOnly ) { 
Object o = content . get ( key ) ; 
if ( ! value . equals ( o ) ) { 
updatedContent . put ( key , value ) ; 
updated = true ; 
} else if ( updatedContent . containsKey ( key ) && ! value . equals ( updatedContent . get ( key ) ) ) { 
} public void processRequest ( HttpServletRequest request ) throws IOException , 
FileUploadException , StorageClientException , AccessDeniedException { 
boolean debug = LOGGER . isDebugEnabled ( ) ; 
if ( ServletFileUpload . isMultipartContent ( request ) ) { 
ServletFileUpload upload = new ServletFileUpload ( ) ; 
FileItemIterator iterator = upload . getItemIterator ( request ) ; 
FileItemStream item = iterator . next ( ) ; 
String name = item . getFieldName ( ) ; 
InputStream stream = item . openStream ( ) ; 
ParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; 
String propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; 
RequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , Streams . asString ( stream ) ) ) ; 
feedback . add ( pt . feedback ( propertyName ) ) ; 
if ( streamProcessor != null ) { 
feedback . addAll ( streamProcessor . processStream ( name , StorageClientUtils . getObjectName ( item . getName ( ) ) , item . getContentType ( ) , stream , this ) ) ; 
Map < String , String [ ] > parameters = request . getParameterMap ( ) ; 
Set < Entry < String , String [ ] > > entries = parameters . entrySet ( ) ; 
for ( Entry < String , String [ ] > param : entries ) { 
String name = ( String ) param . getKey ( ) ; 
RequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , param . getValue ( ) ) ) ; 
} public void resetProperties ( ) { 
for ( Entry < ParameterType , Map < String , Object > > e : stores . entrySet ( ) ) { 
e . getValue ( ) . clear ( ) ; 
} public static String calculateRFC2104HMAC ( String data , String key ) 
throws java . security . SignatureException { 
byte [ ] keyBytes = key . getBytes ( "UTF-8" ) ; 
SecretKeySpec signingKey = new SecretKeySpec ( keyBytes , HMAC_SHA1_ALGORITHM ) ; 
Mac mac = Mac . getInstance ( HMAC_SHA1_ALGORITHM ) ; 
mac . init ( signingKey ) ; 
byte [ ] rawHmac = mac . doFinal ( data . getBytes ( "UTF-8" ) ) ; 
return Base64 . encodeBase64URLSafeString ( rawHmac ) ; 
} catch ( InvalidKeyException e ) { 
protected void batchRequest ( HttpServletRequest request , 
HttpServletResponse response , boolean allowModify ) throws IOException , ServletException { 
String json = request . getParameter ( REQUESTS_PARAMETER ) ; 
String template = request . getParameter ( REQUEST_TEMPLATE ) ; 
if ( template != null && template . length ( ) > 0 ) { 
if ( templateService . checkTemplateExists ( template ) ) { 
StringWriter processedTemplate = new StringWriter ( ) ; 
templateService . process ( request . getParameterMap ( ) , "UTF-8" , processedTemplate , template ) ; 
json = processedTemplate . toString ( ) ; 
batchProcessor . batchRequest ( request , response , json , allowModify ) ; 
} public static void addAcl ( boolean grant , Permission permssion , String key , 
List < AclModification > modifications ) { 
if ( grant ) { 
key = AclModification . grantKey ( key ) ; 
key = AclModification . denyKey ( key ) ; 
modifications . add ( new AclModification ( key , permssion . getPermission ( ) , 
AclModification . Operation . OP_OR ) ) ; 
} public static void removeAcl ( boolean grant , Permission permssion , String key , 
modifications . add ( new AclModification ( key , ~ permssion . getPermission ( ) , 
AclModification . Operation . OP_AND ) ) ; 
} public static void filterAcl ( Map < String , Object > acl , boolean grant , Permission permission , 
boolean set , List < AclModification > modifications ) { 
int perm = permission . getPermission ( ) ; 
Operation op = Operation . OP_OR ; 
if ( ! set ) { 
perm = 0xffff ^ perm ; 
op = Operation . OP_AND ; 
for ( Entry < String , Object > ace : acl . entrySet ( ) ) { 
String key = ace . getKey ( ) ; 
if ( AclModification . isGrant ( key ) == grant ) { 
modifications . add ( new AclModification ( key , perm , op ) ) ; 
} public static String getPrincipal ( String principalKey ) { 
if ( principalKey == null ) { 
return principalKey ; 
if ( principalKey . length ( ) <= GRANTED_MARKER . length ( ) ) { 
if ( principalKey . endsWith ( GRANTED_MARKER ) ) { 
return principalKey . substring ( 0 , principalKey . length ( ) - GRANTED_MARKER . length ( ) ) ; 
} else if ( principalKey . endsWith ( DENIED_MARKER ) ) { 
return principalKey . substring ( 0 , principalKey . length ( ) - DENIED_MARKER . length ( ) ) ; 
} public static Permission [ ] listPermissions ( int perms ) { 
List < Permission > permissions = Lists . newArrayList ( ) ; 
for ( Permission p : Permissions . PRIMARY_PERMISSIONS ) { 
if ( ( perms & p . getPermission ( ) ) == p . getPermission ( ) ) { 
permissions . add ( p ) ; 
return permissions . toArray ( new Permission [ permissions . size ( ) ] ) ; 
} private static < K , V > ImmutableMap < K , V > createDelegate ( 
final Map < K , V > base , 
final Set < ? extends K > keys , 
final Function < K , V > augmentation 
final ImmutableMap . Builder < K , V > builder = ImmutableMap . builder ( ) ; 
builder . putAll ( base ) ; 
keys . stream ( ) 
. filter ( key -> ! base . containsKey ( key ) ) 
. forEach ( key -> builder . put ( key , augmentation . apply ( key ) ) ) ; 
} public < V > Cache < V > getCache ( String name , CacheScope scope ) { 
case INSTANCE : 
return getInstanceCache ( name ) ; 
case CLUSTERINVALIDATED : 
case CLUSTERREPLICATED : 
case REQUEST : 
return getRequestCache ( name ) ; 
case THREAD : 
return getThreadCache ( name ) ; 
private < V > Cache < V > getThreadCache ( String name ) { 
Map < String , Cache < ? > > threadCacheMap = threadCacheMapHolder . get ( ) ; 
Cache < V > threadCache = ( Cache < V > ) threadCacheMap . get ( name ) ; 
if ( threadCache == null ) { 
threadCache = new MapCacheImpl < V > ( ) ; 
threadCacheMap . put ( name , threadCache ) ; 
return threadCache ; 
private < V > Cache < V > getRequestCache ( String name ) { 
Map < String , Cache < ? > > requestCacheMap = requestCacheMapHolder . get ( ) ; 
Cache < V > requestCache = ( Cache < V > ) requestCacheMap . get ( name ) ; 
if ( requestCache == null ) { 
requestCache = new MapCacheImpl < V > ( ) ; 
requestCacheMap . put ( name , requestCache ) ; 
return requestCache ; 
} public void onDelete ( String zone , String path , String user , String resourceType , Map < String , Object > beforeEvent , String ... attributes ) { 
String topic = DEFAULT_DELETE_TOPIC ; 
if ( deleteTopics . containsKey ( zone ) ) { 
topic = deleteTopics . get ( zone ) ; 
postEvent ( topic , path , user , resourceType , beforeEvent , attributes ) ; 
} public void onUpdate ( String zone , String path , String user , String resourceType , boolean isNew , Map < String , Object > beforeEvent , String ... attributes ) { 
String topic = DEFAULT_UPDATE_TOPIC ; 
topic = DEFAULT_CREATE_TOPIC ; 
topic = createTopics . get ( zone ) ; 
topic = updateTopics . get ( zone ) ; 
} public static String getAltField ( String field , String streamId ) { 
if ( streamId == null ) { 
return field + "/" + streamId ; 
} public static String insecureHash ( String naked ) { 
return insecureHash ( naked . getBytes ( UTF8 ) ) ; 
} catch ( UnsupportedEncodingException e3 ) { 
public static < K , V > Map < K , V > getFilterMap ( Map < K , V > source , Map < K , V > modified , Set < K > include , Set < K > exclude , boolean includingRemoveProperties ) { 
if ( ( modified == null || modified . size ( ) == 0 ) && ( include == null ) && ( exclude == null || exclude . size ( ) == 0 ) ) { 
if ( source instanceof ImmutableMap ) { 
return ImmutableMap . copyOf ( source ) ; 
Builder < K , V > filteredMap = new ImmutableMap . Builder < K , V > ( ) ; 
for ( Entry < K , V > e : source . entrySet ( ) ) { 
K k = e . getKey ( ) ; 
if ( include == null || include . contains ( k ) ) { 
if ( exclude == null || ! exclude . contains ( k ) ) { 
if ( modified != null && modified . containsKey ( k ) ) { 
V o = modified . get ( k ) ; 
if ( o instanceof Map ) { 
filteredMap . put ( k , 
( V ) getFilterMap ( ( Map < K , V > ) o , null , null , exclude , includingRemoveProperties ) ) ; 
} else if ( includingRemoveProperties ) { 
filteredMap . put ( k , o ) ; 
} else if ( ! ( o instanceof RemoveProperty ) ) { 
Object o = e . getValue ( ) ; 
( V ) getFilterMap ( ( Map < K , V > ) e . getValue ( ) , null , null , exclude , includingRemoveProperties ) ) ; 
filteredMap . put ( k , e . getValue ( ) ) ; 
if ( modified != null ) { 
for ( Entry < K , V > e : modified . entrySet ( ) ) { 
if ( ! source . containsKey ( k ) ) { 
V v = e . getValue ( ) ; 
if ( ! ( v instanceof RemoveProperty ) && v != null ) { 
filteredMap . put ( k , v ) ; 
return filteredMap . build ( ) ; 
public static Map < String , Object > getFilteredAndEcodedMap ( Map < String , Object > source , 
Set < String > filter ) { 
Map < String , Object > filteredMap = Maps . newHashMap ( ) ; 
for ( Entry < String , Object > e : source . entrySet ( ) ) { 
if ( ! filter . contains ( e . getKey ( ) ) ) { 
filteredMap . put ( e . getKey ( ) , 
getFilteredAndEcodedMap ( ( Map < String , Object > ) o , filter ) ) ; 
filteredMap . put ( e . getKey ( ) , o ) ; 
return filteredMap ; 
} public static String shardPath ( String id ) { 
String hash = insecureHash ( id ) ; 
return hash . substring ( 0 , 2 ) + "/" + hash . substring ( 2 , 4 ) + "/" + hash . substring ( 4 , 6 ) + "/" 
} public static String arrayEscape ( String string ) { 
string = string . replaceAll ( "%" , "%1" ) ; 
string = string . replaceAll ( "," , "%2" ) ; 
} public static String arrayUnEscape ( String string ) { 
string = string . replaceAll ( "%2" , "," ) ; 
string = string . replaceAll ( "%1" , "%" ) ; 
} public static Session adaptToSession ( Object source ) { 
if ( source instanceof SessionAdaptable ) { 
return ( ( SessionAdaptable ) source ) . getSession ( ) ; 
Object userManager = safeMethod ( source , "getUserManager" , new Object [ 0 ] , new Class [ 0 ] ) ; 
if ( userManager != null ) { 
return ( Session ) safeMethod ( userManager , "getSession" , new Object [ 0 ] , new Class [ 0 ] ) ; 
} private static Object safeMethod ( Object target , String methodName , Object [ ] args , 
@ SuppressWarnings ( "rawtypes" ) Class [ ] argsTypes ) { 
Method m = target . getClass ( ) . getMethod ( methodName , argsTypes ) ; 
if ( ! m . isAccessible ( ) ) { 
m . setAccessible ( true ) ; 
return m . invoke ( target , args ) ; 
} public static void deleteTree ( ContentManager contentManager , String path ) 
throws AccessDeniedException , StorageClientException { 
Content content = contentManager . get ( path ) ; 
for ( String childPath : content . listChildPaths ( ) ) { 
deleteTree ( contentManager , childPath ) ; 
contentManager . delete ( path ) ; 
V o = super . remove ( key ) ; 
if ( o instanceof ThreadBound ) { 
( ( ThreadBound ) o ) . unbind ( ) ; 
for ( String k : super . keySet ( ) ) { 
Object o = get ( k ) ; 
super . clear ( ) ; 
} public void removeChildren ( String key ) { 
super . remove ( key ) ; 
if ( ! key . endsWith ( "/" ) ) { 
key = key + "/" ; 
Set < String > keys = super . keySet ( ) ; 
for ( String k : keys ) { 
if ( ( k ) . startsWith ( key ) ) { 
super . remove ( k ) ; 
} public Object getProperty ( QName name ) { 
String n = getFullName ( name ) ; 
Object o = content . getProperty ( n ) ; 
} public LockToken createAndLock ( String name , LockTimeout timeout , 
LockInfo lockInfo ) throws NotAuthorizedException { 
String newPath = StorageClientUtils . newPath ( path , name ) ; 
LockHolder lockHolder = new LockHolder ( lockInfo , timeout ) ; 
String token = session . getLockManager ( ) . lock ( newPath , 
lockHolder . getTimeoutInSeconds ( ) , lockHolder . toString ( ) ) ; 
return new LockToken ( token , lockInfo , timeout ) ; 
} catch ( StorageClientException e ) { 
LOGGER . error ( e . getMessage ( ) , e ) ; 
throw new NotAuthorizedException ( this ) ; 
} catch ( AlreadyLockedException e ) { 
} private static String getSlingHome ( Map < String , String > commandLine ) { 
String source = null ; 
String slingHome = commandLine . get ( "c" ) ; 
if ( slingHome != null ) { 
slingHome = System . getProperty ( SharedConstants . SLING_HOME ) ; 
slingHome = System . getenv ( ENV_SLING_HOME ) ; 
source = "default" ; 
slingHome = SharedConstants . SLING_HOME_DEFAULT ; 
System . setProperty ( SharedConstants . SLING_HOME , slingHome ) ; 
return slingHome ; 
} static Map < String , String > parseCommandLine ( String [ ] args ) { 
Map < String , String > commandLine = new HashMap < String , String > ( ) ; 
boolean readUnparsed = false ; 
for ( int argc = 0 ; args != null && argc < args . length ; argc ++ ) { 
String arg = args [ argc ] ; 
if ( readUnparsed ) { 
commandLine . put ( arg , arg ) ; 
} else if ( arg . startsWith ( "-" ) ) { 
if ( arg . length ( ) == 1 ) { 
readUnparsed = true ; 
String key = String . valueOf ( arg . charAt ( 1 ) ) ; 
if ( arg . length ( ) > 2 ) { 
commandLine . put ( key , arg . substring ( 2 ) ) ; 
argc ++ ; 
if ( argc < args . length 
&& ( args [ argc ] . equals ( "-" ) || ! args [ argc ] 
. startsWith ( "-" ) ) ) { 
commandLine . put ( key , args [ argc ] ) ; 
commandLine . put ( key , key ) ; 
argc -- ; 
return commandLine ; 
} static void info ( String message , Throwable t ) { 
log ( System . out , "*INFO*" , message , t ) ; 
} static void error ( String message , Throwable t ) { 
log ( System . err , "*ERROR*" , message , t ) ; 
} private static void log ( PrintStream out , String prefix , String message , 
Throwable t ) { 
final StringBuilder linePrefixBuilder = new StringBuilder ( ) ; 
synchronized ( fmt ) { 
linePrefixBuilder . append ( fmt . format ( new Date ( ) ) ) ; 
linePrefixBuilder . append ( prefix ) ; 
linePrefixBuilder . append ( Thread . currentThread ( ) . getName ( ) ) ; 
final String linePrefix = linePrefixBuilder . toString ( ) ; 
out . print ( linePrefix ) ; 
out . println ( message ) ; 
if ( t != null ) { 
t . printStackTrace ( new PrintStream ( out ) { 
public void println ( String x ) { 
print ( linePrefix ) ; 
super . println ( x ) ; 
} protected Map < String , Object > getCached ( String keySpace , String columnFamily , String key ) throws StorageClientException { 
Map < String , Object > m = null ; 
String cacheKey = getCacheKey ( keySpace , columnFamily , key ) ; 
CacheHolder cacheHolder = getFromCacheInternal ( cacheKey ) ; 
if ( cacheHolder != null ) { 
m = cacheHolder . get ( ) ; 
if ( m != null ) { 
if ( m == null ) { 
m = client . get ( keySpace , columnFamily , key ) ; 
putToCacheInternal ( cacheKey , new CacheHolder ( m ) , true ) ; 
} private String getCacheKey ( String keySpace , String columnFamily , String key ) throws StorageClientException { 
if ( client instanceof RowHasher ) { 
return ( ( RowHasher ) client ) . rowHash ( keySpace , columnFamily , key ) ; 
return keySpace + ":" + columnFamily + ":" + key ; 
} protected void removeCached ( String keySpace , String columnFamily , String key ) throws StorageClientException { 
if ( sharedCache != null ) { 
final String cacheKey = getCacheKey ( keySpace , columnFamily , key ) ; 
putToCacheInternal ( cacheKey , new CacheHolder ( null , managerId ) , false ) ; 
if ( client instanceof Disposer ) { 
( ( Disposer ) client ) . registerDisposable ( new Disposable ( ) { 
public void setDisposer ( Disposer disposer ) { 
CacheHolder ch = sharedCache . get ( cacheKey ) ; 
if ( ch != null && ch . wasLockedTo ( managerId ) ) { 
sharedCache . remove ( cacheKey ) ; 
client . remove ( keySpace , columnFamily , key ) ; 
} protected void putCached ( String keySpace , String columnFamily , String key , Map < String , Object > encodedProperties , 
boolean probablyNew ) throws StorageClientException { 
String cacheKey = null ; 
cacheKey = getCacheKey ( keySpace , columnFamily , key ) ; 
if ( sharedCache != null && ! probablyNew ) { 
CacheHolder ch = getFromCacheInternal ( cacheKey ) ; 
if ( ch != null && ch . isLocked ( this . managerId ) ) { 
client . insert ( keySpace , columnFamily , key , encodedProperties , probablyNew ) ; 
} protected void activate ( Map < String , Object > properties ) throws Exception { 
configProperties = properties ; 
String [ ] safePostProcessorNames = ( String [ ] ) configProperties 
. get ( SAFE_POSTPROCESSORS ) ; 
if ( safePostProcessorNames == null ) { 
safeOpenProcessors . add ( "rss" ) ; 
safeOpenProcessors . add ( "trustedLoginTokenProxyPostProcessor" ) ; 
for ( String pp : safePostProcessorNames ) { 
safeOpenProcessors . add ( pp ) ; 
String proxyHost = System . getProperty ( "http.proxyHost" , "" ) ; 
if ( ! proxyHost . equals ( "" ) ) { 
useJreProxy = true ; 
} public ProxyResponse executeCall ( Map < String , Object > config , 
Map < String , Object > headers , Map < String , Object > input , 
InputStream requestInputStream , long requestContentLength , 
String requestContentType ) throws ProxyClientException { 
LOGGER . info ( 
new Object [ ] { config , headers , input , requestInputStream , 
requestContentLength , requestContentType } ) ; 
bindConfig ( config ) ; 
if ( config != null 
&& config . containsKey ( CONFIG_REQUEST_PROXY_ENDPOINT ) ) { 
String endpointURL = ( String ) config 
. get ( CONFIG_REQUEST_PROXY_ENDPOINT ) ; 
if ( isUnsafeProxyDefinition ( config ) ) { 
URL u = new URL ( endpointURL ) ; 
String host = u . getHost ( ) ; 
if ( host . indexOf ( '$' ) >= 0 ) { 
throw new ProxyClientException ( 
+ u ) ; 
Map < String , Object > context = Maps . newHashMap ( input ) ; 
context . put ( "config" , configProperties ) ; 
endpointURL = processUrlTemplate ( endpointURL , context ) ; 
ProxyMethod proxyMethod = ProxyMethod . GET ; 
if ( config . containsKey ( CONFIG_REQUEST_PROXY_METHOD ) ) { 
proxyMethod = ProxyMethod . valueOf ( ( String ) config 
. get ( CONFIG_REQUEST_PROXY_METHOD ) ) ; 
HttpClient client = getHttpClient ( ) ; 
HttpUriRequest method = null ; 
switch ( proxyMethod ) { 
case GET : 
if ( config . containsKey ( CONFIG_LIMIT_GET_SIZE ) ) { 
long maxSize = ( Long ) config . get ( CONFIG_LIMIT_GET_SIZE ) ; 
HttpHead h = new HttpHead ( endpointURL ) ; 
HttpParams params = h . getParams ( ) ; 
params . setBooleanParameter ( 
"http.protocol.reject-head-body" , true ) ; 
h . setParams ( params ) ; 
populateMessage ( method , config , headers ) ; 
HttpResponse response = client . execute ( h ) ; 
if ( response . getStatusLine ( ) . getStatusCode ( ) == 200 ) { 
Header contentLengthHeader = response 
. getLastHeader ( "Content-Length" ) ; 
if ( contentLengthHeader != null ) { 
long length = Long 
. parseLong ( contentLengthHeader 
. getValue ( ) ) ; 
if ( length > maxSize ) { 
return new ProxyResponseImpl ( 
HttpServletResponse . SC_PRECONDITION_FAILED , 
return new ProxyResponseImpl ( response ) ; 
method = new HttpGet ( endpointURL ) ; 
case HEAD : 
method = new HttpHead ( endpointURL ) ; 
case OPTIONS : 
method = new HttpOptions ( endpointURL ) ; 
case POST : 
method = new HttpPost ( endpointURL ) ; 
case PUT : 
method = new HttpPut ( endpointURL ) ; 
if ( requestInputStream == null 
&& ! config . containsKey ( CONFIG_PROXY_REQUEST_TEMPLATE ) ) { 
if ( method instanceof HttpPost ) { 
HttpPost postMethod = ( HttpPost ) method ; 
MultipartEntity multipart = new MultipartEntity ( ) ; 
for ( Entry < String , Object > param : input . entrySet ( ) ) { 
String key = param . getKey ( ) ; 
Object value = param . getValue ( ) ; 
if ( value instanceof Object [ ] ) { 
for ( Object val : ( Object [ ] ) value ) { 
addPart ( multipart , key , val ) ; 
addPart ( multipart , key , value ) ; 
postMethod . setEntity ( multipart ) ; 
if ( method instanceof HttpEntityEnclosingRequestBase ) { 
String contentType = requestContentType ; 
if ( contentType == null 
&& config 
. containsKey ( CONFIG_REQUEST_CONTENT_TYPE ) ) { 
contentType = ( String ) config 
. get ( CONFIG_REQUEST_CONTENT_TYPE ) ; 
contentType = APPLICATION_OCTET_STREAM ; 
HttpEntityEnclosingRequestBase eemethod = ( HttpEntityEnclosingRequestBase ) method ; 
if ( requestInputStream != null ) { 
eemethod . setHeader ( HttpHeaders . CONTENT_TYPE , 
contentType ) ; 
eemethod . setEntity ( new InputStreamEntity ( 
requestInputStream , requestContentLength ) ) ; 
StringWriter body = new StringWriter ( ) ; 
templateService . evaluate ( context , body , ( String ) config 
. get ( "path" ) , ( String ) config 
. get ( CONFIG_PROXY_REQUEST_TEMPLATE ) ) ; 
byte [ ] soapBodyContent = body . toString ( ) . getBytes ( 
"UTF-8" ) ; 
new ByteArrayInputStream ( soapBodyContent ) , 
soapBodyContent . length ) ) ; 
HttpResponse response = client . execute ( method ) ; 
if ( response . getStatusLine ( ) . getStatusCode ( ) == 302 
&& method instanceof HttpEntityEnclosingRequestBase ) { 
String url = response . getFirstHeader ( "Location" ) . getValue ( ) ; 
method = new HttpGet ( url ) ; 
response = client . execute ( method ) ; 
} catch ( ProxyClientException e ) { 
unbindConfig ( ) ; 
} public void log ( int level , String msg ) { 
if ( inDebugMode ) { 
logger . info ( msg ) ; 
case LogChute . DEBUG_ID : 
logger . debug ( msg ) ; 
case LogChute . ERROR_ID : 
logger . error ( msg ) ; 
case LogChute . INFO_ID : 
case LogChute . TRACE_ID : 
logger . trace ( msg ) ; 
case LogChute . WARN_ID : 
} private void initComponents ( ) { 
launchButton = new javax . swing . JButton ( ) ; 
statusLabel = new javax . swing . JLabel ( ) ; 
exitButton = new javax . swing . JButton ( ) ; 
headingLabel = new javax . swing . JLabel ( ) ; 
disclaimerLabel = new javax . swing . JLabel ( ) ; 
browserButton = new javax . swing . JButton ( ) ; 
setDefaultCloseOperation ( javax . swing . WindowConstants . EXIT_ON_CLOSE ) ; 
setName ( "mainFrame" ) ; 
setResizable ( false ) ; 
launchButton . setFont ( new java . awt . Font ( "Arial" , 0 , 13 ) ) ; 
launchButton . setText ( "Launch" ) ; 
launchButton . addActionListener ( new java . awt . event . ActionListener ( ) { 
public void actionPerformed ( java . awt . event . ActionEvent evt ) { 
launchButtonActionPerformed ( evt ) ; 
statusLabel . setFont ( new java . awt . Font ( "Arial" , 0 , 12 ) ) ; 
exitButton . setFont ( new java . awt . Font ( "Arial" , 0 , 13 ) ) ; 
exitButton . setText ( "Exit" ) ; 
exitButton . addActionListener ( new java . awt . event . ActionListener ( ) { 
exitButtonActionPerformed ( evt ) ; 
headingLabel . setBorder ( javax . swing . BorderFactory . createEtchedBorder ( ) ) ; 
disclaimerLabel . setFont ( new java . awt . Font ( "Arial" , 0 , 13 ) ) ; 
disclaimerLabel . setText ( "jLabel1" ) ; 
disclaimerLabel . setVerticalAlignment ( javax . swing . SwingConstants . TOP ) ; 
disclaimerLabel . setAutoscrolls ( true ) ; 
disclaimerLabel . setBorder ( javax . swing . BorderFactory . createTitledBorder ( "Disclaimer" ) ) ; 
browserButton . addActionListener ( new java . awt . event . ActionListener ( ) { 
browserButtonActionPerformed ( evt ) ; 
javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; 
getContentPane ( ) . setLayout ( layout ) ; 
layout . setHorizontalGroup ( layout . createParallelGroup ( 
javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( 
layout 
. createSequentialGroup ( ) 
. addGroup ( 
. createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) 
. addGap ( 27 , 27 , 27 ) 
. addComponent ( launchButton ) 
. addGap ( 18 , 18 , 18 ) 
. addComponent ( statusLabel ) 
. addPreferredGap ( 
javax . swing . LayoutStyle . ComponentPlacement . RELATED , 162 , 
Short . MAX_VALUE ) 
. addComponent ( browserButton ) 
javax . swing . LayoutStyle . ComponentPlacement . RELATED ) 
. addComponent ( exitButton ) ) 
javax . swing . GroupLayout . Alignment . CENTER , 
. addContainerGap ( ) 
. addComponent ( headingLabel , 
javax . swing . GroupLayout . PREFERRED_SIZE , 149 , 
javax . swing . GroupLayout . PREFERRED_SIZE ) 
. addComponent ( disclaimerLabel , 
javax . swing . GroupLayout . PREFERRED_SIZE , 493 , 
javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) 
. addContainerGap ( ) ) ) ; 
layout . linkSize ( javax . swing . SwingConstants . HORIZONTAL , new java . awt . Component [ ] { 
exitButton , launchButton } ) ; 
layout . setVerticalGroup ( layout 
javax . swing . GroupLayout . Alignment . TRAILING , 
javax . swing . GroupLayout . PREFERRED_SIZE , 215 , 
javax . swing . GroupLayout . PREFERRED_SIZE , 116 , 
javax . swing . GroupLayout . PREFERRED_SIZE ) ) 
. addGap ( 58 , 58 , 58 ) 
layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . CENTER ) 
. addComponent ( browserButton ) . addComponent ( exitButton ) ) 
. addContainerGap ( ) ) 
. addGap ( 259 , 259 , 259 ) 
. createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) 
. addComponent ( launchButton , 
javax . swing . GroupLayout . PREFERRED_SIZE , 50 , 
. addComponent ( statusLabel ) ) 
. addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) ) ) ; 
pack ( ) ; 
} private void launchButtonActionPerformed ( java . awt . event . ActionEvent evt ) { 
if ( runStatus == APP_NOT_RUNNING ) { 
System . setSecurityManager ( null ) ; 
NakamuraMain . main ( savedArgs ) ; 
JOptionPane . showMessageDialog ( this , 
"Information" , JOptionPane . INFORMATION_MESSAGE ) ; 
runStatus = APP_RUNNING ; 
isStartupFinished ( ) ; 
JOptionPane . WARNING_MESSAGE ) ; 
} private void isStartupFinished ( ) { 
boolean started = false ; 
while ( ! started ) { 
if ( exists ( localhostURL ) ) 
Thread . sleep ( 5 * 1000 ) ; 
if ( started ) { 
statusLabel . setForeground ( Color . green ) ; 
launchButton . setEnabled ( false ) ; 
browserButton . setEnabled ( true ) ; 
} public static boolean exists ( String URLName ) { 
HttpURLConnection . setFollowRedirects ( false ) ; 
HttpURLConnection con = ( HttpURLConnection ) new URL ( URLName ) . openConnection ( ) ; 
con . setRequestMethod ( "HEAD" ) ; 
return ( con . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) ; 
} private void browserButtonActionPerformed ( java . awt . event . ActionEvent evt ) { 
Desktop . getDesktop ( ) . browse ( new URL ( localhostURL ) . toURI ( ) ) ; 
} protected ImageIcon createImageIcon ( String path , String description ) { 
java . net . URL imgURL = getClass ( ) . getResource ( path ) ; 
if ( imgURL != null ) { 
return new ImageIcon ( imgURL , description ) ; 
} protected String getLabelText ( String path ) throws IOException { 
InputStream is = this . getClass ( ) . getResourceAsStream ( path ) ; 
char [ ] buffer = new char [ 1024 ] ; 
Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; 
while ( ( n = reader . read ( buffer ) ) != - 1 ) { 
writer . write ( buffer , 0 , n ) ; 
savedArgs = args ; 
java . awt . EventQueue . invokeLater ( new Runnable ( ) { 
new LaunchNakamura ( ) . setVisible ( true ) ; 
} public boolean allowImpersonate ( Subject impersSubject ) { 
String impersonators = ( String ) getProperty ( IMPERSONATORS_FIELD ) ; 
if ( impersonators == null ) { 
Set < String > impersonatorSet = ImmutableSet . copyOf ( StringUtils . split ( impersonators , ';' ) ) ; 
for ( Principal p : impersSubject . getPrincipals ( ) ) { 
if ( ADMIN_USER . equals ( p . getName ( ) ) || SYSTEM_USER . equals ( p . getName ( ) ) 
|| impersonatorSet . contains ( p . getName ( ) ) ) { 
} public void setLoginEnabled ( long from , long to , boolean day , TimeZone timeZone ) { 
String enabledSetting = EnabledPeriod . getEnableValue ( from , to , day , timeZone ) ; 
if ( enabledSetting == null ) { 
removeProperty ( LOGIN_ENABLED_PERIOD_FIELD ) ; 
setProperty ( LOGIN_ENABLED_PERIOD_FIELD , enabledSetting ) ; 
} public V get ( String key ) { 
Element e = cache . get ( key ) ; 
if ( e == null ) { 
return stats ( null ) ; 
return stats ( e . getObjectValue ( ) ) ; 
public V put ( String key , V payload ) { 
V previous = null ; 
if ( cache . isKeyInCache ( key ) ) { 
previous = ( V ) e . getObjectValue ( ) ; 
cache . put ( new Element ( key , payload ) ) ; 
return previous ; 
cache . remove ( key ) ; 
List < ? > keys = cache . getKeys ( ) ; 
for ( Object k : keys ) { 
if ( ( ( String ) k ) . startsWith ( key ) ) { 
cache . remove ( k ) ; 
public List < V > list ( ) { 
List < String > keys = cache . getKeys ( ) ; 
List < V > values = new ArrayList < V > ( ) ; 
Element e = cache . get ( k ) ; 
values . add ( ( V ) e . getObjectValue ( ) ) ; 
} public void handleEvent ( Event event ) { 
String topic = event . getTopic ( ) ; 
Session session = ( Session ) event . getProperty ( Session . class . getName ( ) ) ; 
RepositorySession repositoryRession = null ; 
Thread thisThread = Thread . currentThread ( ) ; 
ClassLoader classloader = thisThread . getContextClassLoader ( ) ; 
thisThread . setContextClassLoader ( this . getClass ( ) . getClassLoader ( ) ) ; 
repositoryRession = new RepositorySessionImpl ( session , 
repository ) ; 
} catch ( ClientPoolException e1 ) { 
LOGGER . error ( e1 . getMessage ( ) , e1 ) ; 
} catch ( StorageClientException e1 ) { 
} catch ( AccessDeniedException e1 ) { 
Collection < IndexingHandler > contentIndexHandler = handlers 
. get ( topic ) ; 
if ( contentIndexHandler != null && contentIndexHandler . size ( ) > 0 ) { 
BulkRequestBuilder bulk = client . prepareBulk ( ) ; 
int added = 0 ; 
for ( IndexingHandler indexingHandler : contentIndexHandler ) { 
Collection < InputDocument > documents = indexingHandler 
. getDocuments ( repositoryRession , event ) ; 
for ( InputDocument in : documents ) { 
if ( in . isDelete ( ) ) { 
bulk . add ( client . prepareDelete ( in . getIndexName ( ) , 
in . getDocumentType ( ) , in . getDocumentId ( ) ) ) ; 
added ++ ; 
IndexRequestBuilder r = client . prepareIndex ( 
in . getIndexName ( ) , 
in . getDocumentType ( ) , 
in . getDocumentId ( ) ) ; 
XContentBuilder d = XContentFactory 
. jsonBuilder ( ) ; 
d = d . startObject ( ) ; 
for ( Entry < String , Object > e : in . getKeyData ( ) ) { 
d = d . field ( e . getKey ( ) , e . getValue ( ) ) ; 
r . setSource ( d . endObject ( ) ) ; 
bulk . add ( r ) ; 
if ( added > 0 ) { 
BulkResponse resp = bulk . execute ( ) . actionGet ( ) ; 
if ( resp . hasFailures ( ) ) { 
for ( BulkItemResponse br : Iterables . adaptTo ( resp 
. iterator ( ) ) ) { 
if ( br . failed ( ) ) { 
br . getFailureMessage ( ) ) ; 
if ( repositoryRession != null ) { 
repositoryRession . logout ( ) ; 
thisThread . setContextClassLoader ( classloader ) ; 
public void invalidate ( String keySpace , String columnFamily , Map < String , Object > queryProperties ) { 
Map < String , CacheHolder > queryCache = client . getQueryCache ( ) ; 
if ( queryCache == null ) { 
String cacheKey = getCacheKey ( keySpace , columnFamily , queryProperties ) ; 
if ( cacheKey != null ) { 
queryCache . remove ( cacheKey ) ; 
} public static Object toValue ( String name , Object value ) { 
String [ ] parts = StringUtils . split ( name , "@" , 2 ) ; 
String fieldName = null ; 
String fieldType = "String" ; 
if ( parts . length == 2 ) { 
fieldType = parts [ 1 ] ; 
fieldName = parts [ 0 ] ; 
} else if ( parts . length == 1 ) { 
int l = Array . getLength ( value ) ; 
RequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; 
if ( rpt == null ) { 
rpt = TYPES . get ( RequestParameterType . STRING ) ; 
if ( ! fieldName . endsWith ( "[]" ) && l == 1 ) { 
return rpt . newInstance ( Array . get ( value , 0 ) ) ; 
Class < ? > componentType = rpt . getComponentType ( ) ; 
Object [ ] a = ( Object [ ] ) Array . newInstance ( componentType , l ) ; 
for ( int i = 0 ; i < l ; i ++ ) { 
a [ i ] = rpt . newInstance ( Array . get ( value , i ) ) ; 
return rpt . newInstance ( value ) ; 
} protected void activate ( Map < String , Object > props ) { 
sharedSecret = toString ( props . get ( "sharedSecret" ) , 
"e2KS54H35j6vS5Z38nK40" ) ; 
hostname = toString ( props . get ( "hostname" ) , "localhost" ) ; 
port = toInteger ( props . get ( "port" ) , 80 ) ; 
public Map < String , Object > getPropertiesForUpdate ( ) { 
if ( ! readOnly && membersModified ) { 
modifiedMap . put ( MEMBERS_FIELD , StringUtils . join ( members , ';' ) ) ; 
Map < String , Object > propertiesForUpdate = super . getPropertiesForUpdate ( ) ; 
return propertiesForUpdate ; 
public Map < String , Object > getSafeProperties ( ) { 
return super . getSafeProperties ( ) ; 
} public void process ( Map < String , Object > config , Map < String , Object > templateParams , 
HttpServletResponse response , ProxyResponse proxyResponse ) throws IOException { 
for ( Entry < String , String [ ] > h : proxyResponse . getResponseHeaders ( ) . entrySet ( ) ) { 
for ( String v : h . getValue ( ) ) { 
response . setHeader ( h . getKey ( ) , v ) ; 
int code = proxyResponse . getResultCode ( ) ; 
response . setStatus ( code ) ; 
IOUtils . copy ( proxyResponse . getResponseBodyAsInputStream ( ) , response 
. getOutputStream ( ) ) ; 
} public InputStream getResponseBodyAsInputStream ( ) throws IOException { 
InputStream in = response . getEntity ( ) . getContent ( ) ; 
leakedInputStreams . add ( in ) ; 
} public String getResponseBodyAsString ( ) throws IOException { 
String contentEncoding = getContentEncoding ( entity ) ; 
InputStream in = entity . getContent ( ) ; 
BufferedReader r = new BufferedReader ( new InputStreamReader ( in , 
contentEncoding ) ) ; 
String l = r . readLine ( ) ; 
if ( l == null ) { 
sb . append ( l ) . append ( "\n" ) ; 
r . close ( ) ; 
for ( InputStream in : leakedInputStreams ) { 
LOGGER . debug ( e . getMessage ( ) , e ) ; 
} private ImmutableMap < C , V > mapContentToValues ( 
final ImmutableMap < K , V > base 
final ImmutableMap . Builder < C , V > builder = ImmutableMap . builder ( ) ; 
for ( final Entry < K , V > entry : base . entrySet ( ) ) { 
builder . put ( 
this . key ( entry . getKey ( ) ) , 
entry . getValue ( ) 
} public StorageClient getClient ( ) throws ClientPoolException { 
StorageClient client = ( StorageClient ) pool . borrowObject ( ) ; 
return client ; 
} public void releaseClient ( StorageClient client ) { 
if ( client != null ) { 
pool . returnObject ( client ) ; 
} public PropertyAcl getPropertyAcl ( String objectType , String objectPath ) throws AccessDeniedException , StorageClientException { 
long t = System . currentTimeMillis ( ) ; 
checkOpen ( ) ; 
compilingPermissions . inc ( ) ; 
String key = this . getAclKey ( objectType , objectPath ) ; 
Map < String , Object > objectAcl = getCached ( keySpace , aclColumnFamily , key ) ; 
Set < String > orderedPrincipals = Sets . newLinkedHashSet ( ) ; 
String principal = user . getId ( ) ; 
if ( principal . startsWith ( "_" ) ) { 
orderedPrincipals . add ( principal ) ; 
for ( String principal : getPrincipals ( user ) ) { 
if ( ! User . ANON_USER . equals ( user . getId ( ) ) ) { 
orderedPrincipals . add ( Group . EVERYONE ) ; 
Map < String , Integer > grants = Maps . newHashMap ( ) ; 
Map < String , Integer > denies = Maps . newHashMap ( ) ; 
for ( String principal : orderedPrincipals ) { 
String ppk = PROPERTY_PRINCIPAL_STEM + principal ; 
for ( Entry < String , Object > e : objectAcl . entrySet ( ) ) { 
String k = e . getKey ( ) ; 
if ( k . startsWith ( ppk ) ) { 
String [ ] parts = StringUtils . split ( k . substring ( PROPERTY_PRINCIPAL_STEM . length ( ) ) , "@" ) ; 
String propertyName = parts [ 1 ] ; 
if ( AclModification . isDeny ( k ) ) { 
int td = toInt ( e . getValue ( ) ) ; 
denies . put ( propertyName , toInt ( denies . get ( propertyName ) ) | td ) ; 
} else if ( AclModification . isGrant ( k ) ) { 
int tg = toInt ( e . getValue ( ) ) ; 
grants . put ( propertyName , toInt ( grants . get ( propertyName ) ) | tg ) ; 
for ( Entry < String , Integer > g : grants . entrySet ( ) ) { 
String k = g . getKey ( ) ; 
if ( denies . containsKey ( k ) ) { 
denies . put ( k , toInt ( denies . get ( k ) ) & ~ g . getValue ( ) ) ; 
return new PropertyAcl ( denies ) ; 
compilingPermissions . dec ( ) ; 
statsService . apiCall ( AccessControlManagerImpl . class . getName ( ) , "getPropertyAcl" , System . currentTimeMillis ( ) - t ) ; 
} public void signContentToken ( Content token , String securityZone , String objectPath ) throws StorageClientException , 
AccessDeniedException { 
check ( Security . ZONE_CONTENT , objectPath , Permissions . CAN_WRITE_ACL ) ; 
check ( Security . ZONE_CONTENT , objectPath , Permissions . CAN_READ_ACL ) ; 
String key = this . getAclKey ( securityZone , objectPath ) ; 
Map < String , Object > currentAcl = getCached ( keySpace , aclColumnFamily , key ) ; 
String secretKey = ( String ) currentAcl . get ( _SECRET_KEY ) ; 
principalTokenValidator . signToken ( token , secretKey ) ; 
statsService . apiCall ( AccessControlManagerImpl . class . getName ( ) , "signContentToken" , System . currentTimeMillis ( ) - t ) ; 
} private Set < R > multiplication ( ) { 
final Set < R > answer = new LinkedHashSet < > ( 
this . one . size ( ) * this . two . size ( ) 
for ( final A left : this . one ) { 
for ( final B right : this . two ) { 
final R element = this . function . apply ( left , right ) ; 
if ( answer . contains ( element ) ) { 
String . format ( 
element 
answer . add ( element ) ; 
return ImmutableSet . copyOf ( answer ) ; 
} protected void batchRequest ( HttpServletRequest request , 
HttpServletResponse response , String jsonRequest , 
boolean allowModify ) throws IOException , ServletException { 
JsonParser jsonParser = new JsonParser ( ) ; 
JsonElement element = jsonParser . parse ( jsonRequest ) ; 
if ( ! element . isJsonArray ( ) ) { 
response . sendError ( HttpServletResponse . SC_BAD_REQUEST , 
JsonArray arr = element . getAsJsonArray ( ) ; 
response . setContentType ( "application/json" ) ; 
response . setCharacterEncoding ( "UTF-8" ) ; 
MessageDigest md = MessageDigest . getInstance ( "SHA-1" ) ; 
key = Base64 . encodeBase64URLSafeString ( md . digest ( jsonRequest 
. getBytes ( "UTF-8" ) ) ) ; 
String cachedResult = responseCache . get ( key ) ; 
if ( cachedResult != null ) { 
response . getWriter ( ) . write ( cachedResult ) ; 
LOGGER . warn ( e . getMessage ( ) , e ) ; 
boolean cache = ( key != null ) ; 
CaptureResponseWriter captureResponseWriter = new CaptureResponseWriter ( 
response . getWriter ( ) ) ; 
JsonWriter write = new JsonWriter ( captureResponseWriter ) ; 
write . beginObject ( ) ; 
write . name ( "results" ) ; 
write . beginArray ( ) ; 
for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { 
JsonObject obj = arr . get ( i ) . getAsJsonObject ( ) ; 
RequestInfo r = new RequestInfo ( obj ) ; 
if ( r . isValid ( ) && ( allowModify || r . isSafe ( ) ) ) { 
cache = doRequest ( request , response , r , write ) && cache ; 
write ) ; 
write . endArray ( ) ; 
write . endObject ( ) ; 
write . flush ( ) ; 
if ( cache ) { 
responseCache . put ( key , captureResponseWriter . toString ( ) ) ; 
Collection < IndexingHandler > contentIndexHandler = handlers . get ( topic ) ; 
int ttl = Utils . toInt ( event . getProperty ( TopicIndexer . TTL ) , 
Integer . MAX_VALUE ) ; 
if ( indexingHandler instanceof QoSIndexHandler ) { 
ttl = Math . min ( ttl , Utils . defaultMax ( ( ( QoSIndexHandler ) indexingHandler ) . getTtl ( event ) ) ) ; 
QueueManager q = null ; 
if ( ttl < queues [ 0 ] . batchDelay ) { 
ttl , event ) ; 
queues [ 0 ] . saveEvent ( event ) ; 
for ( QueueManager qm : queues ) { 
if ( ttl < qm . batchDelay ) { 
q . saveEvent ( event ) ; 
q = null ; 
q = qm ; 
if ( q != null ) { 
} protected void joinAll ( ) throws InterruptedException { 
if ( queues != null ) { 
for ( QueueManager q : queues ) { 
q . getQueueDispatcher ( ) . join ( ) ; 
} public void setProperty ( String name , Object value ) { 
if ( ! readOnly && ! FILTER_PROPERTIES . contains ( name ) ) { 
Object cv = authorizableMap . get ( name ) ; 
if ( cv != null && ! ( cv instanceof RemoveProperty ) ) { 
modifiedMap . put ( name , new RemoveProperty ( ) ) ; 
} else if ( ! value . equals ( cv ) ) { 
modifiedMap . put ( name , value ) ; 
} else if ( modifiedMap . containsKey ( name ) && ! value . equals ( modifiedMap . get ( name ) ) ) { 
} public void removeProperty ( String key ) { 
if ( ! readOnly && ( authorizableMap . containsKey ( key ) || modifiedMap . containsKey ( key ) ) ) { 
modifiedMap . put ( key , new RemoveProperty ( ) ) ; 
} public void addPrincipal ( String principal ) { 
if ( ! readOnly && ! principals . contains ( principal ) ) { 
principals . add ( principal ) ; 
principalsModified = true ; 
} public void removePrincipal ( String principal ) { 
if ( ! readOnly && principals . contains ( principal ) ) { 
principals . remove ( principal ) ; 
LOG . debug ( 
templateParams ) ; 
if ( templateParams == null || ! tltppp . hostname . equals ( templateParams . get ( "hostname" ) ) 
|| tltppp . port != ( Integer ) templateParams . get ( "port" ) ) { 
response . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; 
dpppi . process ( config , templateParams , response , proxyResponse ) ; 
} public void changePassword ( Authorizable authorizable , String password , String oldPassword ) throws StorageClientException , 
String id = authorizable . getId ( ) ; 
if ( thisUser . isAdmin ( ) || currentUserId . equals ( id ) ) { 
if ( ! thisUser . isAdmin ( ) ) { 
User u = authenticator . authenticate ( id , oldPassword ) ; 
putCached ( keySpace , authorizableColumnFamily , id , ImmutableMap . of ( Authorizable . LASTMODIFIED_FIELD , 
( Object ) System . currentTimeMillis ( ) , Authorizable . ID_FIELD , id , Authorizable . LASTMODIFIED_BY_FIELD , 
accessControlManager . getCurrentUserId ( ) , Authorizable . PASSWORD_FIELD , 
StorageClientUtils . secureHash ( password ) ) , false ) ; 
storeListener . onUpdate ( Security . ZONE_AUTHORIZABLES , id , currentUserId , getType ( authorizable ) , false , null , 
"op:change-password" ) ; 
throw new AccessDeniedException ( Security . ZONE_ADMIN , id , 
statsService . apiCall ( AuthorizableManagerImpl . class . getName ( ) , "changePassword" , System . currentTimeMillis ( ) - t ) ; 
} public void copy ( String from , String to , boolean withStreams ) throws StorageClientException , AccessDeniedException , IOException { 
long ts = System . currentTimeMillis ( ) ; 
Content f = get ( from ) ; 
if ( f . getProperty ( UUID_FIELD ) == null ) { 
Content t = get ( to ) ; 
delete ( to ) ; 
Set < String > streams = Sets . newHashSet ( ) ; 
Map < String , Object > copyProperties = Maps . newHashMap ( ) ; 
if ( withStreams ) { 
for ( Entry < String , Object > p : f . getProperties ( ) . entrySet ( ) ) { 
if ( ! PROTECTED_FIELDS . contains ( p . getKey ( ) ) ) { 
if ( p . getKey ( ) . startsWith ( BLOCKID_FIELD ) ) { 
streams . add ( p . getKey ( ) ) ; 
copyProperties . put ( p . getKey ( ) , p . getValue ( ) ) ; 
copyProperties . putAll ( f . getProperties ( ) ) ; 
copyProperties . put ( COPIED_FROM_PATH_FIELD , from ) ; 
copyProperties . put ( COPIED_FROM_ID_FIELD , f . getProperty ( UUID_FIELD ) ) ; 
copyProperties . put ( COPIED_DEEP_FIELD , withStreams ) ; 
t = new Content ( to , copyProperties ) ; 
update ( t ) ; 
for ( String stream : streams ) { 
String streamId = null ; 
if ( stream . length ( ) > BLOCKID_FIELD . length ( ) ) { 
streamId = stream . substring ( BLOCKID_FIELD . length ( ) + 1 ) ; 
InputStream fromStream = getInputStream ( from , streamId ) ; 
writeBody ( to , fromStream ) ; 
fromStream . close ( ) ; 
eventListener . onUpdate ( Security . ZONE_CONTENT , to , accessControlManager . getCurrentUserId ( ) , getResourceType ( f ) , true , 
null , "op:copy" ) ; 
statsService . apiCall ( ContentManagerImpl . class . getName ( ) , "copy" , System . currentTimeMillis ( ) - ts ) ; 
} public void move ( String from , String to ) throws AccessDeniedException , StorageClientException { 
accessControlManager . check ( Security . ZONE_CONTENT , from , Permissions . CAN_ANYTHING ) ; 
accessControlManager . check ( Security . ZONE_CONTENT , to , Permissions . CAN_READ . combine ( Permissions . CAN_WRITE ) ) ; 
Map < String , Object > fromStructure = Maps . newHashMap ( getCached ( keySpace , contentColumnFamily , from ) ) ; 
if ( ! exists ( fromStructure ) ) { 
if ( exists ( fromStructure ) ) { 
String contentId = ( String ) fromStructure . get ( STRUCTURE_UUID_FIELD ) ; 
Map < String , Object > content = getCached ( keySpace , contentColumnFamily , contentId ) ; 
if ( content == null || content . size ( ) == 0 && TRUE . equals ( content . get ( DELETED_FIELD ) ) ) { 
Map < String , Object > toStructure = getCached ( keySpace , contentColumnFamily , to ) ; 
if ( exists ( toStructure ) ) { 
String contentId = ( String ) toStructure . get ( STRUCTURE_UUID_FIELD ) ; 
if ( exists ( content ) ) { 
String idStore = ( String ) fromStructure . get ( STRUCTURE_UUID_FIELD ) ; 
if ( ! StorageClientUtils . isRoot ( to ) ) { 
String parent = StorageClientUtils . getParentObjectPath ( to ) ; 
Map < String , Object > parentToStructure = getCached ( keySpace , contentColumnFamily , parent ) ; 
if ( ! exists ( parentToStructure ) ) { 
Content content = new Content ( parent , null ) ; 
update ( content ) ; 
putCached ( keySpace , contentColumnFamily , idStore , ImmutableMap . of ( PATH_FIELD , ( Object ) to ) , false ) ; 
fromStructure . put ( PATH_FIELD , to ) ; 
putCached ( keySpace , contentColumnFamily , to , fromStructure , true ) ; 
putCached ( keySpace , contentColumnFamily , from , ImmutableMap . of ( DELETED_FIELD , ( Object ) TRUE ) , false ) ; 
eventListener . onDelete ( Security . ZONE_CONTENT , from , accessControlManager . getCurrentUserId ( ) , null , null , "op:move" ) ; 
eventListener . onUpdate ( Security . ZONE_CONTENT , to , accessControlManager . getCurrentUserId ( ) , null , true , null , "op:move" ) ; 
statsService . apiCall ( ContentManagerImpl . class . getName ( ) , "move" , System . currentTimeMillis ( ) - t ) ; 
} public void link ( String from , String to ) throws AccessDeniedException , StorageClientException { 
accessControlManager . check ( Security . ZONE_CONTENT , to , Permissions . CAN_READ ) ; 
accessControlManager . check ( Security . ZONE_CONTENT , from , Permissions . CAN_READ . combine ( Permissions . CAN_WRITE ) ) ; 
if ( ! exists ( toStructure ) ) { 
Map < String , Object > fromStructure = getCached ( keySpace , contentColumnFamily , from ) ; 
if ( StorageClientUtils . isRoot ( from ) ) { 
Object idStore = toStructure . get ( STRUCTURE_UUID_FIELD ) ; 
String parent = StorageClientUtils . getParentObjectPath ( from ) ; 
putCached ( keySpace , contentColumnFamily , from , ImmutableMap . of ( STRUCTURE_UUID_FIELD , idStore , PATH_FIELD , from , 
LINKED_PATH_FIELD , to , DELETED_FIELD , new RemoveProperty ( ) ) , true ) ; 
statsService . apiCall ( ContentManagerImpl . class . getName ( ) , "link" , System . currentTimeMillis ( ) - t ) ; 
} public InputStream getVersionInputStream ( String path , String versionId ) throws AccessDeniedException , StorageClientException , 
return getVersionInputStream ( path , versionId , null ) ; 
} public InputStream getVersionInputStream ( String path , String versionId , String streamId ) throws AccessDeniedException , 
StorageClientException , IOException { 
accessControlManager . check ( Security . ZONE_CONTENT , path , Permissions . CAN_READ ) ; 
Map < String , Object > structure = getCached ( keySpace , contentColumnFamily , path ) ; 
if ( exists ( structure ) ) { 
String contentId = ( String ) structure . get ( STRUCTURE_UUID_FIELD ) ; 
String versionHistoryId = ( String ) content . get ( VERSION_HISTORY_ID_FIELD ) ; 
if ( versionHistoryId != null ) { 
Map < String , Object > versionHistory = getCached ( keySpace , contentColumnFamily , versionHistoryId ) ; 
if ( versionHistory != null && versionHistory . containsKey ( versionId ) ) { 
return internalGetInputStream ( versionId , streamId ) ; 
statsService . apiCall ( ContentManagerImpl . class . getName ( ) , "egtVersionInputStream" , System . currentTimeMillis ( ) - t ) ; 
} public static void loadFromStream ( String key , Map < String , Object > output , InputStream binaryStream , String type ) 
DataInputStream dis = new DataInputStream ( binaryStream ) ; 
String ckey = dis . readUTF ( ) ; 
if ( ! key . equals ( ckey ) ) { 
readMapFromStream ( output , dis ) ; 
String cftype = null ; 
cftype = dis . readUTF ( ) ; 
if ( cftype != null && ! cftype . equals ( type ) ) { 
dis . close ( ) ; 
binaryStream . close ( ) ; 
} public static InputStream storeMapToStream ( String key , Map < String , Object > m , String type ) 
DataOutputStream dos = new DataOutputStream ( baos ) ; 
dos . writeUTF ( key ) ; 
writeMapToStream ( m , dos ) ; 
dos . writeUTF ( type ) ; 
dos . flush ( ) ; 
baos . flush ( ) ; 
byte [ ] b = baos . toByteArray ( ) ; 
return new ByteArrayInputStream ( b ) ; 
} public static void writeMapToStream ( Map < String , Object > m , 
DataOutputStream dos ) throws IOException { 
for ( Entry < String , ? > e : m . entrySet ( ) ) { 
if ( o != null && ! ( o instanceof RemoveProperty ) ) { 
dos . writeInt ( size ) ; 
dos . writeUTF ( k ) ; 
Type < ? > t = getTypeOfObject ( o ) ; 
dos . writeInt ( t . getTypeId ( ) ) ; 
t . save ( dos , o ) ; 
} private boolean prepareToResearchTMCluster ( ) { 
int count = tryConnectCount . incrementAndGet ( ) ; 
int size = txClientConfig . getManagerAddress ( ) . size ( ) ; 
if ( count == size ) { 
TMSearcher . search ( ) ; 
} else if ( count > size ) { 
return ! TMSearcher . searchedOne ( ) ; 
} @ GetMapping ( { "/exceptions/{page}" , "/exceptions" , "/exceptions/{page}/{limit}" } ) 
public ExceptionList exceptionList ( 
@ RequestParam ( value = "page" , required = false ) @ PathVariable ( value = "page" , required = false ) Integer page , 
@ RequestParam ( value = "limit" , required = false ) @ PathVariable ( value = "limit" , required = false ) Integer limit , 
@ RequestParam ( value = "extState" , required = false ) Integer extState , 
@ RequestParam ( value = "registrar" , required = false ) Integer registrar ) { 
return txExceptionService . exceptionList ( page , limit , extState , null , registrar ) ; 
} @ PostMapping ( "/exceptions" ) 
public boolean deleteExceptions ( @ RequestBody DeleteExceptions deleteExceptions ) throws TxManagerException { 
txExceptionService . deleteExceptions ( deleteExceptions . getId ( ) ) ; 
} @ GetMapping ( "/log/transaction-info" ) 
public JSONObject transactionInfo ( 
@ RequestParam ( "groupId" ) String groupId , 
@ RequestParam ( "unitId" ) String unitId ) throws TxManagerException { 
return txExceptionService . getTransactionInfo ( groupId , unitId ) ; 
} catch ( TransactionStateException e ) { 
throw new TxManagerException ( e ) ; 
} @ GetMapping ( { "/logs/{page}" , "/logs/{page}/{limit}" , "/logs" } ) 
public TxLogList txLogList ( 
@ RequestParam ( value = "groupId" , required = false ) String groupId , 
@ RequestParam ( value = "tag" , required = false ) String tag , 
@ RequestParam ( value = "ld" , required = false ) String lTime , 
@ RequestParam ( value = "rd" , required = false ) String rTime , 
@ RequestParam ( value = "timeOrder" , required = false ) Integer timeOrder ) throws TxManagerException { 
return adminService . txLogList ( page , limit , groupId , tag , lTime , rTime , timeOrder ) ; 
} @ DeleteMapping ( "/logs" ) 
public boolean deleteLogs ( @ RequestBody DeleteLogsReq deleteLogsReq ) throws TxManagerException { 
adminService . deleteLogs ( deleteLogsReq ) ; 
} @ DeleteMapping ( "/transaction-info" ) 
public boolean deleteTransactionInfo ( 
@ RequestParam ( "unitId" ) String unitId , 
@ RequestParam ( "modId" ) String modId ) throws TxManagerException { 
txExceptionService . deleteTransactionInfo ( groupId , unitId , modId ) ; 
} private MessageDto request ( MessageDto messageDto , long timeout , String whenNonManagerMessage ) throws RpcException { 
for ( int i = 0 ; i < rpcClient . loadAllRemoteKey ( ) . size ( ) + 1 ; i ++ ) { 
String remoteKey = rpcClient . loadRemoteKey ( ) ; 
MessageDto result = rpcClient . request ( remoteKey , messageDto , timeout ) ; 
} catch ( RpcException e ) { 
if ( e . getCode ( ) == RpcException . NON_TX_MANAGER ) { 
} public synchronized long nextId ( ) { 
long currentStamp = getTimeMill ( ) ; 
if ( currentStamp < lastStamp ) { 
if ( currentStamp == lastStamp ) { 
sequence = ( sequence + 1 ) & this . maxSequenceValue ; 
if ( sequence == 0L ) { 
lastStamp = tilNextMillis ( ) ; 
sequence = 0L ; 
lastStamp = currentStamp ; 
return ( currentStamp - START_STAMP ) << 
timestampBitLeftOffset | idcId << idcBitLeftOffset | machineId << machineBitLeftOffset | sequence ; 
} public static void transmit ( TracingSetter tracingSetter ) { 
if ( TracingContext . tracing ( ) . hasGroup ( ) ) { 
tracingSetter . set ( TracingConstants . HEADER_KEY_GROUP_ID , TracingContext . tracing ( ) . groupId ( ) ) ; 
tracingSetter . set ( TracingConstants . HEADER_KEY_APP_MAP , 
Base64Utils . encodeToString ( TracingContext . tracing ( ) . appMapString ( ) . getBytes ( StandardCharsets . UTF_8 ) ) ) ; 
} public static void apply ( TracingGetter tracingGetter ) { 
String groupId = Optional . ofNullable ( tracingGetter . get ( TracingConstants . HEADER_KEY_GROUP_ID ) ) . orElse ( "" ) ; 
String appList = Optional . ofNullable ( tracingGetter . get ( TracingConstants . HEADER_KEY_APP_MAP ) ) . orElse ( "" ) ; 
TracingContext . init ( Maps . newHashMap ( TracingConstants . GROUP_ID , groupId , TracingConstants . APP_MAP , 
StringUtils . isEmpty ( appList ) ? appList : new String ( Base64Utils . decodeFromString ( appList ) , StandardCharsets . UTF_8 ) ) ) ; 
} public static MessageDto createGroup ( String groupId ) { 
MessageDto msg = new MessageDto ( ) ; 
msg . setGroupId ( groupId ) ; 
msg . setAction ( MessageConstants . ACTION_CREATE_GROUP ) ; 
return msg ; 
} public static MessageDto joinGroup ( JoinGroupParams joinGroupParams ) { 
msg . setGroupId ( joinGroupParams . getGroupId ( ) ) ; 
msg . setAction ( MessageConstants . ACTION_JOIN_GROUP ) ; 
msg . setData ( joinGroupParams ) ; 
} public static MessageDto notifyGroup ( NotifyGroupParams notifyGroupParams ) { 
msg . setGroupId ( notifyGroupParams . getGroupId ( ) ) ; 
msg . setAction ( MessageConstants . ACTION_NOTIFY_GROUP ) ; 
msg . setData ( notifyGroupParams ) ; 
} public static MessageDto acquireLocks ( String groupId , Set < String > locks , int lockType ) { 
DTXLockParams dtxLockParams = new DTXLockParams ( ) ; 
dtxLockParams . setGroupId ( groupId ) ; 
dtxLockParams . setContextId ( Transactions . APPLICATION_ID_WHEN_RUNNING ) ; 
dtxLockParams . setLocks ( locks ) ; 
dtxLockParams . setLockType ( lockType ) ; 
MessageDto messageDto = new MessageDto ( ) ; 
messageDto . setAction ( MessageConstants . ACTION_ACQUIRE_DTX_LOCK ) ; 
messageDto . setData ( dtxLockParams ) ; 
return messageDto ; 
} public static MessageDto releaseLocks ( Set < String > locks ) { 
messageDto . setAction ( MessageConstants . ACTION_RELEASE_DTX_LOCK ) ; 
} public static MessageDto notifyUnitOkResponse ( Serializable message , String action ) { 
messageDto . setAction ( action ) ; 
messageDto . setState ( MessageConstants . STATE_OK ) ; 
messageDto . setData ( message ) ; 
} public static MessageDto notifyUnitFailResponse ( Serializable message , String action ) { 
messageDto . setState ( MessageConstants . STATE_EXCEPTION ) ; 
} public static MessageDto askTransactionState ( String groupId , String unitId ) { 
messageDto . setGroupId ( groupId ) ; 
messageDto . setAction ( MessageConstants . ACTION_ASK_TRANSACTION_STATE ) ; 
messageDto . setData ( new AskTransactionStateParams ( groupId , unitId ) ) ; 
} public static MessageDto writeTxException ( TxExceptionParams txExceptionParams ) { 
messageDto . setAction ( MessageConstants . ACTION_WRITE_EXCEPTION ) ; 
messageDto . setGroupId ( txExceptionParams . getGroupId ( ) ) ; 
messageDto . setData ( txExceptionParams ) ; 
} public static MessageDto initClient ( String appName , String labelName ) { 
InitClientParams initClientParams = new InitClientParams ( ) ; 
initClientParams . setAppName ( appName ) ; 
initClientParams . setLabelName ( labelName ) ; 
messageDto . setData ( initClientParams ) ; 
messageDto . setAction ( MessageConstants . ACTION_INIT_CLIENT ) ; 
} public static void applySnowFlakeIdGen ( int machineLen , long machineId ) { 
SnowFlakeGenerator . Factory factory = new SnowFlakeGenerator . Factory ( machineLen , 0 ) ; 
SnowFlakeGenerator snowFlakeGenerator = factory . create ( 0 , machineId ) ; 
RandomUtils . init ( ( ) -> String . valueOf ( snowFlakeGenerator . nextId ( ) ) ) ; 
public String getSqlWithValues ( ) { 
if ( namedParameterValues . size ( ) == 0 ) { 
return super . getSqlWithValues ( ) ; 
final String statementQuery = getStatementQuery ( ) ; 
result . append ( statementQuery ) ; 
StringBuilder parameters = new StringBuilder ( ) ; 
for ( Map . Entry < Integer , Value > entry : getParameterValues ( ) . entrySet ( ) ) { 
appendParameter ( parameters , entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; 
for ( Map . Entry < String , Value > entry : namedParameterValues . entrySet ( ) ) { 
appendParameter ( parameters , entry . getKey ( ) , entry . getValue ( ) ) ; 
result . append ( parameters ) ; 
} public void setParameterValue ( final String name , final Object value ) { 
namedParameterValues . put ( name , new Value ( value ) ) ; 
} public void reportTransactionState ( String groupId , String unitId , Short registrar , int state ) { 
TxExceptionParams txExceptionParams = new TxExceptionParams ( ) ; 
txExceptionParams . setGroupId ( groupId ) ; 
txExceptionParams . setRegistrar ( registrar ) ; 
txExceptionParams . setTransactionState ( state ) ; 
txExceptionParams . setUnitId ( unitId ) ; 
report ( txExceptionParams ) ; 
} public void reportTccCleanException ( String groupId , String unitId , int state ) { 
txExceptionParams . setRegistrar ( TxExceptionParams . TCC_CLEAN_ERROR ) ; 
} public void clean ( String groupId , String unitId , String unitType , int state ) throws TransactionClearException { 
cleanWithoutAspectLog ( groupId , unitId , unitType , state ) ; 
aspectLogger . clearLog ( groupId , unitId ) ; 
} catch ( TransactionClearException e ) { 
if ( ! e . isNeedCompensation ( ) ) { 
} public void cleanWithoutAspectLog ( String groupId , String unitId , String unitType , int state ) throws TransactionClearException { 
transactionBeanHelper . loadTransactionCleanService ( unitType ) . clear ( 
groupId , state , unitId , unitType 
globalContext . clearGroup ( groupId ) ; 
dtxChecking . stopDelayChecking ( groupId , unitId ) ; 
} public static MessageDto newTxManager ( NotifyConnectParams notifyConnectParams ) { 
msg . setAction ( MessageConstants . ACTION_NEW_TXMANAGER ) ; 
msg . setData ( notifyConnectParams ) ; 
} public static MessageDto notifyUnit ( NotifyUnitParams notifyUnitParams ) { 
msg . setGroupId ( notifyUnitParams . getGroupId ( ) ) ; 
msg . setAction ( MessageConstants . ACTION_NOTIFY_UNIT ) ; 
msg . setData ( notifyUnitParams ) ; 
} public static MessageDto serverException ( String action ) { 
} public static MessageDto getAspectLog ( String groupId , String unitId ) { 
GetAspectLogParams getAspectLogParams = new GetAspectLogParams ( ) ; 
getAspectLogParams . setGroupId ( groupId ) ; 
getAspectLogParams . setUnitId ( unitId ) ; 
messageDto . setAction ( MessageConstants . ACTION_GET_ASPECT_LOG ) ; 
messageDto . setData ( getAspectLogParams ) ; 
} public static MessageDto deleteAspectLog ( String groupId , String unitId ) { 
DeleteAspectLogParams deleteAspectLogParams = new DeleteAspectLogParams ( ) ; 
deleteAspectLogParams . setGroupId ( groupId ) ; 
deleteAspectLogParams . setUnitId ( unitId ) ; 
messageDto . setData ( deleteAspectLogParams ) ; 
messageDto . setAction ( MessageConstants . ACTION_DELETE_ASPECT_LOG ) ; 
} public synchronized RpcContent addKey ( String key ) { 
RpcContent rpcContent = createRpcContent ( ) ; 
map . put ( key , rpcContent ) ; 
return rpcContent ; 
} private RpcContent findRpcContent ( ) { 
synchronized ( freeList ) { 
RpcContent cacheContent = freeList . getFirst ( ) ; 
if ( ! cacheContent . isUsed ( ) ) { 
cacheContent . init ( ) ; 
freeList . remove ( cacheContent ) ; 
return cacheContent ; 
RpcContent rpcContent = new RpcContent ( getWaitTime ( ) ) ; 
rpcContent . init ( ) ; 
} public void createGroup ( String groupId , String unitId , TransactionInfo transactionInfo , String transactionType ) 
throws TransactionException { 
txLogger . txTrace ( groupId , unitId , 
reliableMessenger . createGroup ( groupId ) ; 
aspectLogger . trace ( groupId , unitId , transactionInfo ) ; 
dtxExceptionHandler . handleCreateGroupMessageException ( groupId , e ) ; 
} catch ( LcnBusinessException e ) { 
dtxExceptionHandler . handleCreateGroupBusinessException ( groupId , e . getCause ( ) ) ; 
} public void joinGroup ( String groupId , String unitId , String transactionType , TransactionInfo transactionInfo ) 
reliableMessenger . joinGroup ( groupId , unitId , transactionType , DTXLocalContext . transactionState ( globalContext . dtxState ( groupId ) ) ) ; 
dtxChecking . startDelayCheckingAsync ( groupId , unitId , transactionType ) ; 
dtxExceptionHandler . handleJoinGroupMessageException ( Arrays . asList ( groupId , unitId , transactionType ) , e ) ; 
dtxExceptionHandler . handleJoinGroupBusinessException ( Arrays . asList ( groupId , unitId , transactionType ) , e ) ; 
} public void notifyGroup ( String groupId , String unitId , String transactionType , int state ) { 
txLogger . txTrace ( 
if ( globalContext . isDTXTimeout ( ) ) { 
state = reliableMessenger . notifyGroup ( groupId , state ) ; 
transactionCleanTemplate . clean ( groupId , unitId , transactionType , state ) ; 
dtxExceptionHandler . handleNotifyGroupMessageException ( Arrays . asList ( groupId , state , unitId , transactionType ) , e ) ; 
dtxExceptionHandler . handleNotifyGroupBusinessException ( Arrays . asList ( groupId , state , unitId , transactionType ) , e . getCause ( ) ) ; 
} public String convertToString ( Object value ) { 
result = "NULL" ; 
if ( value instanceof Timestamp ) { 
result = new SimpleDateFormat ( "yyyy-MM-dd'T'HH:mm:ss.SSSZ" ) . format ( value ) ; 
} else if ( value instanceof Date ) { 
} else if ( value instanceof Boolean ) { 
if ( "numeric" . equals ( "boolean" ) ) { 
result = Boolean . FALSE . equals ( value ) ? "0" : "1" ; 
result = value . toString ( ) ; 
} else if ( value instanceof byte [ ] ) { 
result = toHexString ( ( byte [ ] ) value ) ; 
result = quoteIfNeeded ( result , value ) ; 
private String toHexString ( byte [ ] bytes ) { 
StringBuilder sb = new StringBuilder ( bytes . length * 2 ) ; 
for ( byte b : bytes ) { 
int temp = ( int ) b & 0xFF ; 
sb . append ( HEX_CHARS [ temp / 16 ] ) ; 
sb . append ( HEX_CHARS [ temp % 16 ] ) ; 
private String quoteIfNeeded ( String stringValue , Object obj ) { 
if ( stringValue == null ) { 
if ( Number . class . isAssignableFrom ( obj . getClass ( ) ) || Boolean . class . isAssignableFrom ( obj . getClass ( ) ) ) { 
return stringValue ; 
return "'" + escape ( stringValue ) + "'" ; 
private String escape ( String stringValue ) { 
return stringValue . replaceAll ( "'" , "''" ) ; 
} public static String tableName ( String fieldFullyQualifiedName ) { 
if ( fieldFullyQualifiedName . contains ( "." ) ) { 
return fieldFullyQualifiedName . substring ( 0 , fieldFullyQualifiedName . indexOf ( "." ) ) ; 
} public static void cutSuffix ( String suffix , StringBuilder stringBuilder ) { 
if ( stringBuilder . substring ( stringBuilder . length ( ) - suffix . length ( ) ) . equals ( suffix ) ) { 
stringBuilder . delete ( stringBuilder . length ( ) - suffix . length ( ) , stringBuilder . length ( ) ) ; 
} public static ModifiedRecord recordByColumns ( ResultSet rs , List < String > columns ) throws SQLException { 
ModifiedRecord record = new ModifiedRecord ( ) ; 
for ( String column : columns ) { 
FieldValue fieldValue = new FieldValue ( ) ; 
fieldValue . setFieldName ( column ) ; 
fieldValue . setTableName ( SqlUtils . tableName ( column ) ) ; 
fieldValue . setValue ( rs . getObject ( column ) ) ; 
fieldValue . setValueType ( Objects . isNull ( fieldValue . getValue ( ) ) ? Void . class : fieldValue . getValue ( ) . getClass ( ) ) ; 
if ( record . getFieldClusters ( ) . get ( fieldValue . getTableName ( ) ) != null ) { 
record . getFieldClusters ( ) . get ( fieldValue . getTableName ( ) ) . getFields ( ) . add ( fieldValue ) ; 
FieldCluster fieldCluster = new FieldCluster ( ) ; 
fieldCluster . getFields ( ) . add ( fieldValue ) ; 
record . getFieldClusters ( ) . put ( fieldValue . getTableName ( ) , fieldCluster ) ; 
} public static byte [ ] objectToBlob ( Object o ) { 
return SerializerContext . getInstance ( ) . serialize ( o ) ; 
} catch ( SerializerException e ) { 
} public static < T > T blobToObject ( byte [ ] blob , Class < T > type ) { 
return SerializerContext . getInstance ( ) . deSerialize ( blob , type ) ; 
} public void saveUndoLog ( UndoLogDO undoLogDO ) throws SQLException { 
h2DbHelper . queryRunner ( ) . update ( sql , undoLogDO . getUnitId ( ) , undoLogDO . getGroupId ( ) , undoLogDO . getSqlType ( ) , 
undoLogDO . getRollbackInfo ( ) , undoLogDO . getCreateTime ( ) ) ; 
} public List < UndoLogDO > getUndoLogByGroupAndUnitId ( String groupId , String unitId ) throws SQLException { 
return h2DbHelper . queryRunner ( ) . query ( sql , rs -> { 
List < UndoLogDO > undoLogDOList = new ArrayList < > ( ) ; 
while ( rs . next ( ) ) { 
UndoLogDO undoLogDO = new UndoLogDO ( ) ; 
undoLogDO . setSqlType ( rs . getInt ( "SQL_TYPE" ) ) ; 
undoLogDO . setRollbackInfo ( rs . getBytes ( "ROLLBACK_INFO" ) ) ; 
undoLogDO . setUnitId ( rs . getString ( "UNIT_ID" ) ) ; 
undoLogDO . setGroupId ( "GROUP_ID" ) ; 
undoLogDO . setCreateTime ( rs . getString ( "CREATE_TIME" ) ) ; 
undoLogDOList . add ( undoLogDO ) ; 
return undoLogDOList ; 
} , groupId , unitId ) ; 
} public void deleteUndoLog ( String groupId , String unitId ) throws SQLException { 
h2DbHelper . queryRunner ( ) . update ( sql , groupId , unitId ) ; 
} private void lockDataLine ( String groupId , String unitId , Set < String > lockIdSet , boolean isXLock ) throws TxcLogicException { 
if ( ! reliableMessenger . acquireLocks ( groupId , lockIdSet , isXLock ? DTXLocks . X_LOCK : DTXLocks . S_LOCK ) ) { 
globalContext . addTxcLockId ( groupId , unitId , lockIdSet ) ; 
} private void saveUndoLog ( String groupId , String unitId , int sqlType , TableRecordList recordList ) throws TxcLogicException { 
undoLogDO . setRollbackInfo ( SqlUtils . objectToBlob ( recordList ) ) ; 
undoLogDO . setUnitId ( unitId ) ; 
undoLogDO . setGroupId ( groupId ) ; 
undoLogDO . setSqlType ( sqlType ) ; 
txcLogHelper . saveUndoLog ( undoLogDO ) ; 
throw new TxcLogicException ( e ) ; 
} private String hex ( String content ) { 
return DigestUtils . md5DigestAsHex ( content . getBytes ( StandardCharsets . UTF_8 ) ) ; 
} private void resolveModifiedRecords ( List < ModifiedRecord > modifiedRecords , int sqlType ) throws TxcLogicException { 
TableRecordList tableRecords = new TableRecordList ( ) ; 
Set < String > lockIdSet = new HashSet < > ( ) ; 
for ( ModifiedRecord modifiedRecord : modifiedRecords ) { 
for ( Map . Entry < String , FieldCluster > entry : modifiedRecord . getFieldClusters ( ) . entrySet ( ) ) { 
TableRecord tableRecord = new TableRecord ( ) ; 
tableRecord . setTableName ( entry . getKey ( ) ) ; 
tableRecord . setFieldCluster ( entry . getValue ( ) ) ; 
tableRecords . getTableRecords ( ) . add ( tableRecord ) ; 
lockIdSet . add ( hex ( tableRecord . getFieldCluster ( ) . getPrimaryKeys ( ) . toString ( ) ) ) ; 
if ( lockIdSet . isEmpty ( ) ) { 
String groupId = DTXLocalContext . cur ( ) . getGroupId ( ) ; 
String unitId = DTXLocalContext . cur ( ) . getUnitId ( ) ; 
lockDataLine ( groupId , unitId , lockIdSet , true ) ; 
saveUndoLog ( groupId , unitId , sqlType , tableRecords ) ; 
@ ConditionalOnClass ( name = "org.springframework.data.redis.connection.RedisConnectionFactory" ) 
public RedisTemplate < String , Object > functionDomainRedisTemplate ( RedisConnectionFactory redisConnectionFactory ) { 
JdkSerializationRedisSerializer serializationRedisSerializer = new JdkSerializationRedisSerializer ( ) ; 
StringRedisSerializer stringRedisSerializer = new StringRedisSerializer ( ) ; 
RedisTemplate < String , Object > redisTemplate = new RedisTemplate < > ( ) ; 
redisTemplate . setKeySerializer ( stringRedisSerializer ) ; 
redisTemplate . setHashKeySerializer ( stringRedisSerializer ) ; 
redisTemplate . setHashValueSerializer ( serializationRedisSerializer ) ; 
redisTemplate . setValueSerializer ( serializationRedisSerializer ) ; 
redisTemplate . setConnectionFactory ( redisConnectionFactory ) ; 
return redisTemplate ; 
} public static void search ( ) { 
Objects . requireNonNull ( RPC_CLIENT_INITIALIZER ) ; 
HashSet < String > cluster = RELIABLE_MESSENGER . queryTMCluster ( ) ; 
if ( cluster . isEmpty ( ) ) { 
echoTMClusterSuccessful ( ) ; 
clusterCountLatch = new CountDownLatch ( cluster . size ( ) - knownTMClusterSize ) ; 
RPC_CLIENT_INITIALIZER . init ( TxManagerHost . parserList ( new ArrayList < > ( cluster ) ) , true ) ; 
clusterCountLatch . await ( 10 , TimeUnit . SECONDS ) ; 
} catch ( RpcException | InterruptedException e ) { 
} public static boolean searchedOne ( ) { 
if ( Objects . nonNull ( clusterCountLatch ) ) { 
if ( clusterCountLatch . getCount ( ) == 0 ) { 
clusterCountLatch . countDown ( ) ; 
public String [ ] selectImports ( @ NonNull AnnotationMetadata importingClassMetadata ) { 
boolean enabledTxc = Boolean . valueOf ( 
importingClassMetadata . getAnnotationAttributes ( EnableDistributedTransaction . class . getName ( ) ) ) 
. get ( "enableTxc" ) . toString ( ) ) ; 
List < String > importClasses = new ArrayList < > ( ) ; 
importClasses . add ( "com.codingapi.txlcn.txmsg.MessageConfiguration" ) ; 
if ( enabledTxc ) { 
importClasses . add ( TxcConfiguration . class . getName ( ) ) ; 
return importClasses . toArray ( new String [ 0 ] ) ; 
} public static String modId ( ConfigurableEnvironment environment , ServerProperties serverProperties ) { 
String applicationName = environment . getProperty ( "spring.application.name" ) ; 
applicationName = StringUtils . hasText ( applicationName ) ? applicationName : "application" ; 
return applicationName + ":" + serverPort ( serverProperties ) ; 
} public static String [ ] splitAddress ( String hostAndPort ) { 
if ( hostAndPort . indexOf ( ':' ) == - 1 ) { 
String [ ] result = hostAndPort . split ( ":" ) ; 
if ( StringUtils . isEmpty ( result [ 0 ] ) ) { 
result [ 0 ] = "0.0.0.0" ; 
if ( result [ 0 ] . charAt ( 0 ) == '/' ) { 
result [ 0 ] = result [ 0 ] . substring ( 1 ) ; 
} public static int serverPort ( ServerProperties serverProperties ) { 
return Objects . isNull ( serverProperties ) ? 0 : ( Objects . isNull ( serverProperties . getPort ( ) ) ? 8080 : 
serverProperties . getPort ( ) ) ; 
public void destroyTx ( String groupId ) { 
attachmentCache . remove ( groupId + ".dtx" ) ; 
} public Object transactionRunning ( TxTransactionInfo info ) throws Throwable { 
String transactionType = info . getTransactionType ( ) ; 
DTXPropagationState propagationState = propagationResolver . resolvePropagationState ( info ) ; 
if ( propagationState . isIgnored ( ) ) { 
return info . getBusinessCallback ( ) . call ( ) ; 
DTXLocalControl dtxLocalControl = txLcnBeanHelper . loadDTXLocalControl ( transactionType , propagationState ) ; 
Set < String > transactionTypeSet = globalContext . txContext ( info . getGroupId ( ) ) . getTransactionTypes ( ) ; 
transactionTypeSet . add ( transactionType ) ; 
dtxLocalControl . preBusinessCode ( info ) ; 
Object result = dtxLocalControl . doBusinessCode ( info ) ; 
dtxLocalControl . onBusinessCodeSuccess ( info , result ) ; 
} catch ( TransactionException e ) { 
txLogger . error ( info . getGroupId ( ) , info . getUnitId ( ) , Transactions . TAG_TRANSACTION , 
dtxLocalControl . onBusinessCodeError ( info , e ) ; 
dtxLocalControl . postBusinessCode ( info ) ; 
} public List < String > getFullyQualifiedPrimaryKeys ( ) { 
if ( this . fullyQualifiedPrimaryKeys != null ) { 
return this . fullyQualifiedPrimaryKeys ; 
List < String > pks = new ArrayList < > ( ) ; 
this . getPrimaryKeys ( ) . forEach ( key -> pks . add ( tableName + '.' + key ) ) ; 
this . fullyQualifiedPrimaryKeys = pks ; 
} private long total ( String where , Object ... params ) { 
if ( logDbProperties . isEnabled ( ) ) { 
} public boolean existsTable ( String tableName ) throws SQLException { 
DTXLocalContext . makeUnProxy ( ) ; 
connection = dataSource . getConnection ( ) ; 
connection . setAutoCommit ( true ) ; 
return existsTable ( connection , tableName ) ; 
DbUtils . close ( connection ) ; 
DTXLocalContext . undoProxyStatus ( ) ; 
} public List < String > removeKeys ( String moduleName ) { 
List < String > allKeys = new ArrayList < > ( ) ; 
for ( Channel channel : channels ) { 
if ( moduleName . equals ( getModuleName ( channel ) ) ) { 
allKeys . add ( channel . remoteAddress ( ) . toString ( ) ) ; 
} public void bindModuleName ( String remoteKey , String appName , String labelName ) throws RpcException { 
AppInfo appInfo = new AppInfo ( ) ; 
appInfo . setAppName ( appName ) ; 
appInfo . setLabelName ( labelName ) ; 
appInfo . setCreateTime ( new Date ( ) ) ; 
if ( containsLabelName ( labelName ) ) { 
appNames . put ( remoteKey , appInfo ) ; 
} public String getModuleName ( Channel channel ) { 
String key = channel . remoteAddress ( ) . toString ( ) ; 
return getModuleName ( key ) ; 
} public String getModuleName ( String remoteKey ) { 
AppInfo appInfo = appNames . get ( remoteKey ) ; 
return appInfo == null ? null : appInfo . getAppName ( ) ; 
} public boolean hasGroup ( ) { 
return Objects . nonNull ( fields ) && fields . containsKey ( TracingConstants . GROUP_ID ) && 
StringUtils . hasText ( fields . get ( TracingConstants . GROUP_ID ) ) ; 
} public void addApp ( String serviceId , String address ) { 
if ( hasGroup ( ) ) { 
JSONObject map = JSON . parseObject ( this . fields . get ( TracingConstants . APP_MAP ) ) ; 
if ( map . containsKey ( serviceId ) ) { 
map . put ( serviceId , address ) ; 
this . fields . put ( TracingConstants . APP_MAP , JSON . toJSONString ( map ) ) ; 
raiseNonGroupException ( ) ; 
} public String appMapString ( ) { 
String appMap = Optional . ofNullable ( this . fields . get ( TracingConstants . APP_MAP ) ) . orElse ( "" ) ; 
return appMap ; 
return "{}" ; 
} public static URL locateFile ( String file ) { 
File fp ; 
fp = new File ( file ) ; 
if ( fp . exists ( ) ) { 
result = fp . toURI ( ) . toURL ( ) ; 
result = locateOnClassPath ( file ) ; 
} public static URL locateOnClassPath ( String filename ) { 
URL result ; 
result = Thread . currentThread ( ) . getContextClassLoader ( ) . getResource ( filename ) ; 
result = P6Util . class . getClassLoader ( ) . getResource ( filename ) ; 
result = ClassLoader . getSystemResource ( filename ) ; 
} public static Class < ? > forName ( String name ) throws ClassNotFoundException { 
ClassLoader ctxLoader = null ; 
ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
return Class . forName ( name , true , ctxLoader ) ; 
} catch ( SecurityException ex ) { 
return Class . forName ( name ) ; 
} public static ConnectionInformation fromConnection ( Connection connection ) { 
final ConnectionInformation connectionInformation = new ConnectionInformation ( ) ; 
connectionInformation . connection = connection ; 
return connectionInformation ; 
} public static DTXLocalContext getOrNew ( ) { 
if ( currentLocal . get ( ) == null ) { 
currentLocal . set ( new DTXLocalContext ( ) ) ; 
return currentLocal . get ( ) ; 
} public static void makeProxy ( ) { 
if ( currentLocal . get ( ) != null ) { 
cur ( ) . proxyTmp = cur ( ) . proxy ; 
cur ( ) . proxy = true ; 
} public static void makeUnProxy ( ) { 
cur ( ) . proxy = false ; 
} public static void makeNeverAppeared ( ) { 
currentLocal . set ( null ) ; 
} public static int transactionState ( int userDtxState ) { 
return userDtxState == 1 ? dtxLocalContext . sysTransactionState : userDtxState ; 
public void open ( Solver < Solution_ > solver ) { 
( ( DefaultSolver < Solution_ > ) solver ) . addPhaseLifecycleListener ( listener ) ; 
public PooledEntityPlacer buildEntityPlacer ( HeuristicConfigPolicy configPolicy ) { 
MoveSelectorConfig moveSelectorConfig ; 
if ( ConfigUtils . isEmptyCollection ( moveSelectorConfigList ) ) { 
moveSelectorConfig = buildMoveSelectorConfig ( configPolicy ) ; 
} else if ( moveSelectorConfigList . size ( ) == 1 ) { 
moveSelectorConfig = moveSelectorConfigList . get ( 0 ) ; 
MoveSelector moveSelector = moveSelectorConfig . buildMoveSelector ( 
configPolicy , SelectionCacheType . JUST_IN_TIME , SelectionOrder . ORIGINAL ) ; 
return new PooledEntityPlacer ( moveSelector ) ; 
} public double getAngle ( Location location ) { 
double latitudeDifference = location . latitude - latitude ; 
double longitudeDifference = location . longitude - longitude ; 
return Math . atan2 ( latitudeDifference , longitudeDifference ) ; 
public void solvingStarted ( DefaultSolverScope < Solution_ > solverScope ) { 
InnerScoreDirector < Solution_ > scoreDirector = solverScope . getScoreDirector ( ) ; 
Score score = scoreDirector . calculateScore ( ) ; 
solverScope . setBestScore ( score ) ; 
solverScope . setBestSolutionTimeMillis ( System . currentTimeMillis ( ) ) ; 
solverScope . getSolutionDescriptor ( ) . setScore ( solverScope . getBestSolution ( ) , score ) ; 
if ( score . isSolutionInitialized ( ) ) { 
solverScope . setStartingInitializedScore ( score ) ; 
solverScope . setStartingInitializedScore ( null ) ; 
if ( assertInitialScoreFromScratch ) { 
if ( assertShadowVariablesAreNotStale ) { 
} public < E > E lookUpWorkingObject ( E externalObject ) { 
if ( externalObject == null ) { 
LookUpStrategy lookUpStrategy = lookUpStrategyResolver . determineLookUpStrategy ( externalObject ) ; 
return lookUpStrategy . lookUpWorkingObject ( idToWorkingObjectMap , externalObject ) ; 
} public < E > E lookUpWorkingObjectOrReturnNull ( E externalObject ) { 
return lookUpStrategy . lookUpWorkingObjectIfExists ( idToWorkingObjectMap , externalObject ) ; 
public void stepStarted ( ConstructionHeuristicStepScope stepScope ) { 
super . stepStarted ( stepScope ) ; 
selectedMoveCount = 0L ; 
earlyPickedMoveScope = null ; 
maxScoreMoveScope = null ; 
} public void addEntityMimicRecorder ( String id , EntityMimicRecorder mimicRecordingEntitySelector ) { 
EntityMimicRecorder put = entityMimicRecorderMap . put ( id , mimicRecordingEntitySelector ) ; 
if ( put != null ) { 
} protected EntityDescriptor deduceEntityDescriptor ( SolutionDescriptor solutionDescriptor , 
Class < ? > entityClass ) { 
EntityDescriptor entityDescriptor ; 
entityDescriptor = solutionDescriptor . getEntityDescriptorStrict ( entityClass ) ; 
if ( entityDescriptor == null ) { 
Collection < EntityDescriptor > entityDescriptors = solutionDescriptor . getGenuineEntityDescriptors ( ) ; 
if ( entityDescriptors . size ( ) != 1 ) { 
+ solutionDescriptor . getEntityClassSet ( ) 
entityDescriptor = entityDescriptors . iterator ( ) . next ( ) ; 
return entityDescriptor ; 
public void solvingStarted ( DefaultSolverScope solverScope ) { 
for ( Acceptor acceptor : acceptorList ) { 
acceptor . solvingStarted ( solverScope ) ; 
public void constructCache ( DefaultSolverScope solverScope ) { 
long childSize = childMoveSelector . getSize ( ) ; 
if ( childSize > ( long ) Integer . MAX_VALUE ) { 
cachedMoveList = new ArrayList < > ( ( int ) childSize ) ; 
childMoveSelector . iterator ( ) . forEachRemaining ( cachedMoveList :: add ) ; 
cachedMoveList . size ( ) , this ) ; 
public boolean isMoveDoable ( ScoreDirector < Solution_ > scoreDirector ) { 
Object oldValue = variableDescriptor . getValue ( pillar . get ( 0 ) ) ; 
if ( Objects . equals ( oldValue , toPlanningValue ) ) { 
if ( ! variableDescriptor . isValueRangeEntityIndependent ( ) ) { 
ValueRangeDescriptor < Solution_ > valueRangeDescriptor = variableDescriptor . getValueRangeDescriptor ( ) ; 
Solution_ workingSolution = scoreDirector . getWorkingSolution ( ) ; 
for ( Object entity : pillar ) { 
ValueRange rightValueRange = valueRangeDescriptor . extractValueRange ( workingSolution , entity ) ; 
if ( ! rightValueRange . contains ( toPlanningValue ) ) { 
cachedMoveList = moveListFactory . createMoveList ( solverScope . getScoreDirector ( ) . getWorkingSolution ( ) ) ; 
public LocalSearchPhase buildPhase ( int phaseIndex , HeuristicConfigPolicy solverConfigPolicy , 
BestSolutionRecaller bestSolutionRecaller , Termination solverTermination ) { 
HeuristicConfigPolicy phaseConfigPolicy = solverConfigPolicy . createPhaseConfigPolicy ( ) ; 
DefaultLocalSearchPhase phase = new DefaultLocalSearchPhase ( 
phaseIndex , solverConfigPolicy . getLogIndentation ( ) , bestSolutionRecaller , 
buildPhaseTermination ( phaseConfigPolicy , solverTermination ) ) ; 
phase . setDecider ( buildDecider ( phaseConfigPolicy , 
phase . getTermination ( ) ) ) ; 
EnvironmentMode environmentMode = phaseConfigPolicy . getEnvironmentMode ( ) ; 
if ( environmentMode . isNonIntrusiveFullAsserted ( ) ) { 
phase . setAssertStepScoreFromScratch ( true ) ; 
if ( environmentMode . isIntrusiveFastAsserted ( ) ) { 
phase . setAssertExpectedStepScore ( true ) ; 
phase . setAssertShadowVariablesAreNotStaleAfterStep ( true ) ; 
return phase ; 
} public static XStream buildXStream ( ) { 
XStream xStream = new XStream ( ) ; 
xStream . setMode ( XStream . ID_REFERENCES ) ; 
xStream . aliasSystemAttribute ( "xStreamId" , "id" ) ; 
xStream . aliasSystemAttribute ( "xStreamRef" , "reference" ) ; 
xStream . processAnnotations ( SolverConfig . class ) ; 
XStream . setupDefaultSecurity ( xStream ) ; 
xStream . allowTypesByRegExp ( new String [ ] { "org\\.optaplanner\\.\\w+\\.config\\..*" } ) ; 
return xStream ; 
public int compareTo ( AbstractPersistable other ) { 
return new CompareToBuilder ( ) 
. append ( getClass ( ) . getName ( ) , other . getClass ( ) . getName ( ) ) 
. append ( id , other . id ) 
. toComparison ( ) ; 
} public void solvingStarted ( DefaultSolverScope < Solution_ > solverScope ) { 
solverScope . setWorkingSolutionFromBestSolution ( ) ; 
bestSolutionRecaller . solvingStarted ( solverScope ) ; 
termination . solvingStarted ( solverScope ) ; 
phaseLifecycleSupport . fireSolvingStarted ( solverScope ) ; 
for ( Phase < Solution_ > phase : phaseList ) { 
phase . solvingStarted ( solverScope ) ; 
} public ConstructionHeuristicForager buildForager ( HeuristicConfigPolicy configPolicy ) { 
ConstructionHeuristicPickEarlyType pickEarlyType_ ; 
if ( pickEarlyType == null ) { 
pickEarlyType_ = configPolicy . getScoreDirectorFactory ( ) . getInitializingScoreTrend ( ) . isOnlyDown ( ) 
? ConstructionHeuristicPickEarlyType . FIRST_NON_DETERIORATING_SCORE : ConstructionHeuristicPickEarlyType . NEVER ; 
if ( ( pickEarlyType == ConstructionHeuristicPickEarlyType . FIRST_FEASIBLE_SCORE 
|| pickEarlyType == ConstructionHeuristicPickEarlyType . FIRST_FEASIBLE_SCORE_OR_NON_DETERIORATING_HARD ) 
&& ! ( configPolicy . getScoreDefinition ( ) instanceof FeasibilityScoreDefinition ) ) { 
pickEarlyType_ = pickEarlyType ; 
return new DefaultConstructionHeuristicForager ( pickEarlyType_ ) ; 
long entitySize = entitySelector . getSize ( ) ; 
if ( entitySize > ( long ) Integer . MAX_VALUE ) { 
Map < List < Object > , List < Object > > valueStateToPillarMap = new LinkedHashMap < > ( ( int ) entitySize ) ; 
for ( Object entity : entitySelector ) { 
List < Object > valueState = new ArrayList < > ( variableDescriptors . size ( ) ) ; 
for ( GenuineVariableDescriptor variableDescriptor : variableDescriptors ) { 
Object value = variableDescriptor . getValue ( entity ) ; 
valueState . add ( value ) ; 
List < Object > pillar = valueStateToPillarMap . computeIfAbsent ( valueState , key -> new ArrayList < > ( ) ) ; 
pillar . add ( entity ) ; 
cachedBasePillarList = new ArrayList < > ( valueStateToPillarMap . values ( ) ) ; 
} protected static SingleBenchmarkResult createMerge ( 
SolverBenchmarkResult solverBenchmarkResult , ProblemBenchmarkResult problemBenchmarkResult , 
SingleBenchmarkResult oldResult ) { 
SingleBenchmarkResult newResult = new SingleBenchmarkResult ( solverBenchmarkResult , problemBenchmarkResult ) ; 
newResult . subSingleBenchmarkResultList = new ArrayList < > ( oldResult . getSubSingleBenchmarkResultList ( ) . size ( ) ) ; 
int subSingleBenchmarkIndex = 0 ; 
for ( SubSingleBenchmarkResult oldSubResult : oldResult . subSingleBenchmarkResultList ) { 
SubSingleBenchmarkResult . createMerge ( newResult , oldSubResult , subSingleBenchmarkIndex ) ; 
subSingleBenchmarkIndex ++ ; 
newResult . median = oldResult . median ; 
newResult . best = oldResult . best ; 
newResult . worst = oldResult . worst ; 
solverBenchmarkResult . getSingleBenchmarkResultList ( ) . add ( newResult ) ; 
problemBenchmarkResult . getSingleBenchmarkResultList ( ) . add ( newResult ) ; 
return newResult ; 
public String getSimpleMoveTypeDescription ( ) { 
StringBuilder moveTypeDescription = new StringBuilder ( 20 * ( variableDescriptorList . size ( ) + 1 ) ) ; 
moveTypeDescription . append ( getClass ( ) . getSimpleName ( ) ) . append ( "(" ) ; 
String delimiter = "" ; 
for ( GenuineVariableDescriptor < Solution_ > variableDescriptor : variableDescriptorList ) { 
moveTypeDescription . append ( delimiter ) . append ( variableDescriptor . getSimpleEntityAndVariableName ( ) ) ; 
moveTypeDescription . append ( ")" ) ; 
return moveTypeDescription . toString ( ) ; 
bestSolutionStepIndex = - 1 ; 
startingScore = solverScope . calculateScore ( ) ; 
if ( getLastCompletedStepScope ( ) . getStepIndex ( ) < 0 ) { 
getLastCompletedStepScope ( ) . setScore ( startingScore ) ; 
} @ ProblemFactCollectionProperty 
private List < CourseConflict > calculateCourseConflictList ( ) { 
List < CourseConflict > courseConflictList = new ArrayList < > ( ) ; 
for ( Course leftCourse : courseList ) { 
for ( Course rightCourse : courseList ) { 
if ( leftCourse . getId ( ) < rightCourse . getId ( ) ) { 
int conflictCount = 0 ; 
if ( leftCourse . getTeacher ( ) . equals ( rightCourse . getTeacher ( ) ) ) { 
conflictCount ++ ; 
for ( Curriculum curriculum : leftCourse . getCurriculumList ( ) ) { 
if ( rightCourse . getCurriculumList ( ) . contains ( curriculum ) ) { 
if ( conflictCount > 0 ) { 
courseConflictList . add ( new CourseConflict ( leftCourse , rightCourse , conflictCount ) ) ; 
return courseConflictList ; 
public V computeIfAbsent ( K key , Function < ? super K , ? extends V > mappingFunction ) { 
V value = get ( key ) ; 
return super . computeIfAbsent ( key , mappingFunction ) ; 
} public ConstraintMatch addConstraintMatch ( List < Object > justificationList , Score score ) { 
this . score = this . score . add ( score ) ; 
ConstraintMatch constraintMatch = new ConstraintMatch ( constraintPackage , constraintName , 
justificationList , score ) ; 
boolean added = constraintMatchSet . add ( constraintMatch ) ; 
if ( ! added ) { 
return constraintMatch ; 
public double calculateSolverTimeGradient ( DefaultSolverScope solverScope ) { 
Score startingInitializedScore = solverScope . getStartingInitializedScore ( ) ; 
Score bestScore = solverScope . getBestScore ( ) ; 
return calculateTimeGradient ( startingInitializedScore , bestScoreLimit , bestScore ) ; 
public Termination createChildThreadTermination ( DefaultSolverScope solverScope , ChildThreadType childThreadType ) { 
} public static BendableLongScore ofHard ( int hardLevelsSize , int softLevelsSize , int hardLevel , long hardScore ) { 
long [ ] hardScores = new long [ hardLevelsSize ] ; 
hardScores [ hardLevel ] = hardScore ; 
return new BendableLongScore ( 0 , hardScores , new long [ softLevelsSize ] ) ; 
} public static BendableLongScore ofSoft ( int hardLevelsSize , int softLevelsSize , int softLevel , long softScore ) { 
long [ ] softScores = new long [ softLevelsSize ] ; 
softScores [ softLevel ] = softScore ; 
return new BendableLongScore ( 0 , new long [ hardLevelsSize ] , softScores ) ; 
CloudBalancingGenerator generator = new CloudBalancingGenerator ( ) ; 
generator . writeCloudBalance ( 2 , 6 ) ; 
generator . writeCloudBalance ( 3 , 9 ) ; 
generator . writeCloudBalance ( 4 , 12 ) ; 
generator . writeCloudBalance ( 100 , 300 ) ; 
generator . writeCloudBalance ( 200 , 600 ) ; 
generator . writeCloudBalance ( 400 , 1200 ) ; 
generator . writeCloudBalance ( 800 , 2400 ) ; 
generator . writeCloudBalance ( 1600 , 4800 ) ; 
public boolean isNeverEnding ( ) { 
if ( randomSelection ) { 
for ( MoveSelector moveSelector : childMoveSelectorList ) { 
if ( moveSelector . isNeverEnding ( ) ) { 
if ( ! childMoveSelectorList . isEmpty ( ) 
&& childMoveSelectorList . get ( childMoveSelectorList . size ( ) - 1 ) . isNeverEnding ( ) ) { 
} public Acceptor buildAcceptor ( HeuristicConfigPolicy configPolicy ) { 
EnvironmentMode environmentMode = configPolicy . getEnvironmentMode ( ) ; 
List < Acceptor > acceptorList = new ArrayList < > ( ) ; 
if ( acceptorClassList != null ) { 
for ( Class < ? extends Acceptor > acceptorClass : acceptorClassList ) { 
Acceptor acceptor = ConfigUtils . newInstance ( this , "acceptorClass" , acceptorClass ) ; 
acceptorList . add ( acceptor ) ; 
if ( acceptorTypeList != null && acceptorTypeList . contains ( AcceptorType . HILL_CLIMBING ) ) { 
HillClimbingAcceptor acceptor = new HillClimbingAcceptor ( ) ; 
if ( ( acceptorTypeList != null && acceptorTypeList . contains ( AcceptorType . ENTITY_TABU ) ) 
|| entityTabuSize != null || entityTabuRatio != null 
|| fadingEntityTabuSize != null || fadingEntityTabuRatio != null ) { 
EntityTabuAcceptor acceptor = new EntityTabuAcceptor ( configPolicy . getLogIndentation ( ) ) ; 
if ( entityTabuSize != null ) { 
if ( entityTabuRatio != null ) { 
acceptor . setTabuSizeStrategy ( new FixedTabuSizeStrategy ( entityTabuSize ) ) ; 
} else if ( entityTabuRatio != null ) { 
acceptor . setTabuSizeStrategy ( new EntityRatioTabuSizeStrategy ( entityTabuRatio ) ) ; 
} else if ( fadingEntityTabuSize == null && fadingEntityTabuRatio == null ) { 
acceptor . setTabuSizeStrategy ( new EntityRatioTabuSizeStrategy ( 0.1 ) ) ; 
if ( fadingEntityTabuSize != null ) { 
if ( fadingEntityTabuRatio != null ) { 
+ fadingEntityTabuRatio + ")." ) ; 
acceptor . setFadingTabuSizeStrategy ( new FixedTabuSizeStrategy ( fadingEntityTabuSize ) ) ; 
} else if ( fadingEntityTabuRatio != null ) { 
acceptor . setFadingTabuSizeStrategy ( new EntityRatioTabuSizeStrategy ( fadingEntityTabuRatio ) ) ; 
acceptor . setAssertTabuHashCodeCorrectness ( true ) ; 
if ( ( acceptorTypeList != null && acceptorTypeList . contains ( AcceptorType . VALUE_TABU ) ) 
|| valueTabuSize != null || valueTabuRatio != null 
|| fadingValueTabuSize != null || fadingValueTabuRatio != null ) { 
ValueTabuAcceptor acceptor = new ValueTabuAcceptor ( configPolicy . getLogIndentation ( ) ) ; 
if ( valueTabuSize != null ) { 
if ( valueTabuRatio != null ) { 
acceptor . setTabuSizeStrategy ( new FixedTabuSizeStrategy ( valueTabuSize ) ) ; 
} else if ( valueTabuRatio != null ) { 
acceptor . setTabuSizeStrategy ( new ValueRatioTabuSizeStrategy ( valueTabuRatio ) ) ; 
if ( fadingValueTabuSize != null ) { 
if ( fadingValueTabuRatio != null ) { 
+ fadingValueTabuRatio + ")." ) ; 
acceptor . setFadingTabuSizeStrategy ( new FixedTabuSizeStrategy ( fadingValueTabuSize ) ) ; 
} else if ( fadingValueTabuRatio != null ) { 
acceptor . setFadingTabuSizeStrategy ( new ValueRatioTabuSizeStrategy ( fadingValueTabuRatio ) ) ; 
if ( ( acceptorTypeList != null && acceptorTypeList . contains ( AcceptorType . MOVE_TABU ) ) 
|| moveTabuSize != null || fadingMoveTabuSize != null ) { 
MoveTabuAcceptor acceptor = new MoveTabuAcceptor ( configPolicy . getLogIndentation ( ) ) ; 
acceptor . setUseUndoMoveAsTabuMove ( false ) ; 
if ( moveTabuSize != null ) { 
acceptor . setTabuSizeStrategy ( new FixedTabuSizeStrategy ( moveTabuSize ) ) ; 
if ( fadingMoveTabuSize != null ) { 
acceptor . setFadingTabuSizeStrategy ( new FixedTabuSizeStrategy ( fadingMoveTabuSize ) ) ; 
if ( ( acceptorTypeList != null && acceptorTypeList . contains ( AcceptorType . UNDO_MOVE_TABU ) ) 
|| undoMoveTabuSize != null || fadingUndoMoveTabuSize != null ) { 
acceptor . setUseUndoMoveAsTabuMove ( true ) ; 
if ( undoMoveTabuSize != null ) { 
acceptor . setTabuSizeStrategy ( new FixedTabuSizeStrategy ( undoMoveTabuSize ) ) ; 
if ( fadingUndoMoveTabuSize != null ) { 
acceptor . setFadingTabuSizeStrategy ( new FixedTabuSizeStrategy ( fadingUndoMoveTabuSize ) ) ; 
if ( ( acceptorTypeList != null && acceptorTypeList . contains ( AcceptorType . SOLUTION_TABU ) ) 
|| solutionTabuSize != null || fadingSolutionTabuSize != null ) { 
SolutionTabuAcceptor acceptor = new SolutionTabuAcceptor ( configPolicy . getLogIndentation ( ) ) ; 
if ( solutionTabuSize != null ) { 
acceptor . setTabuSizeStrategy ( new FixedTabuSizeStrategy ( solutionTabuSize ) ) ; 
if ( fadingSolutionTabuSize != null ) { 
acceptor . setFadingTabuSizeStrategy ( new FixedTabuSizeStrategy ( fadingSolutionTabuSize ) ) ; 
if ( ( acceptorTypeList != null && acceptorTypeList . contains ( AcceptorType . SIMULATED_ANNEALING ) ) 
|| simulatedAnnealingStartingTemperature != null ) { 
SimulatedAnnealingAcceptor acceptor = new SimulatedAnnealingAcceptor ( ) ; 
if ( simulatedAnnealingStartingTemperature == null ) { 
+ simulatedAnnealingStartingTemperature + ")." ) ; 
acceptor . setStartingTemperature ( configPolicy . getScoreDefinition ( ) 
. parseScore ( simulatedAnnealingStartingTemperature ) ) ; 
if ( ( acceptorTypeList != null && acceptorTypeList . contains ( AcceptorType . LATE_ACCEPTANCE ) ) 
|| lateAcceptanceSize != null ) { 
LateAcceptanceAcceptor acceptor = new LateAcceptanceAcceptor ( ) ; 
acceptor . setLateAcceptanceSize ( defaultIfNull ( lateAcceptanceSize , 400 ) ) ; 
if ( ( acceptorTypeList != null && acceptorTypeList . contains ( AcceptorType . STEP_COUNTING_HILL_CLIMBING ) ) 
|| stepCountingHillClimbingSize != null ) { 
int stepCountingHillClimbingSize_ = defaultIfNull ( stepCountingHillClimbingSize , 400 ) ; 
StepCountingHillClimbingType stepCountingHillClimbingType_ 
= defaultIfNull ( stepCountingHillClimbingType , StepCountingHillClimbingType . STEP ) ; 
StepCountingHillClimbingAcceptor acceptor = new StepCountingHillClimbingAcceptor ( 
stepCountingHillClimbingSize_ , stepCountingHillClimbingType_ ) ; 
if ( acceptorList . size ( ) == 1 ) { 
return acceptorList . get ( 0 ) ; 
} else if ( acceptorList . size ( ) > 1 ) { 
return new CompositeAcceptor ( acceptorList ) ; 
} public void addConstraintMatch ( ConstraintMatch constraintMatch ) { 
score = score . add ( constraintMatch . getScore ( ) ) ; 
public int compareTo ( Indictment other ) { 
if ( ! ( justification instanceof Comparable ) ) { 
+ other . justification + ")." ) ; 
return ( ( Comparable ) justification ) . compareTo ( other . justification ) ; 
if ( subChain . getEntityList ( ) . contains ( toPlanningValue ) ) { 
Object oldFirstValue = variableDescriptor . getValue ( subChain . getFirstEntity ( ) ) ; 
return ! Objects . equals ( oldFirstValue , toPlanningValue ) ; 
} public static String escapeHtmlId ( String rawHtmlId ) { 
return rawHtmlId 
. replaceAll ( "!" , "-0021" ) 
. replaceAll ( "#" , "-0023" ) 
. replaceAll ( "\\$" , "-0024" ) 
. replaceAll ( "," , "-002C" ) 
. replaceAll ( "-" , "-002D" ) 
. replaceAll ( "\\." , "-002E" ) 
. replaceAll ( "\\(" , "-0028" ) 
. replaceAll ( "\\)" , "-0029" ) 
. replaceAll ( ":" , "-003A" ) 
. replaceAll ( ";" , "-003B" ) 
. replaceAll ( "\\?" , "-003F" ) ; 
} public void accumulateResults ( BenchmarkReport benchmarkReport ) { 
determineTotalsAndAverages ( ) ; 
standardDeviationDoubles = StatisticUtils . determineStandardDeviationDoubles ( singleBenchmarkResultList , averageScore , getSuccessCount ( ) ) ; 
} protected static Map < SolverBenchmarkResult , SolverBenchmarkResult > createMergeMap ( 
PlannerBenchmarkResult newPlannerBenchmarkResult , List < SingleBenchmarkResult > singleBenchmarkResultList ) { 
Map < SolverBenchmarkResult , SolverBenchmarkResult > mergeMap 
= new IdentityHashMap < > ( ) ; 
Map < String , Integer > nameCountMap = new HashMap < > ( ) ; 
for ( SingleBenchmarkResult singleBenchmarkResult : singleBenchmarkResultList ) { 
SolverBenchmarkResult oldResult = singleBenchmarkResult . getSolverBenchmarkResult ( ) ; 
if ( ! mergeMap . containsKey ( oldResult ) ) { 
SolverBenchmarkResult newResult = new SolverBenchmarkResult ( newPlannerBenchmarkResult ) ; 
Integer nameCount = nameCountMap . get ( oldResult . name ) ; 
if ( nameCount == null ) { 
nameCount = 1 ; 
nameCount ++ ; 
nameCountMap . put ( oldResult . name , nameCount ) ; 
newResult . subSingleCount = oldResult . subSingleCount ; 
newResult . solverConfig = oldResult . solverConfig ; 
newResult . scoreDefinition = oldResult . scoreDefinition ; 
newResult . singleBenchmarkResultList = new ArrayList < > ( 
oldResult . singleBenchmarkResultList . size ( ) ) ; 
mergeMap . put ( oldResult , newResult ) ; 
newPlannerBenchmarkResult . getSolverBenchmarkResultList ( ) . add ( newResult ) ; 
for ( Map . Entry < SolverBenchmarkResult , SolverBenchmarkResult > entry : mergeMap . entrySet ( ) ) { 
SolverBenchmarkResult oldResult = entry . getKey ( ) ; 
SolverBenchmarkResult newResult = entry . getValue ( ) ; 
if ( nameCountMap . get ( oldResult . name ) > 1 ) { 
newResult . name = oldResult . name ; 
return mergeMap ; 
public MoveSelector buildBaseMoveSelector ( HeuristicConfigPolicy configPolicy , 
SelectionCacheType minimumCacheType , boolean randomSelection ) { 
EntitySelectorConfig entitySelectorConfig_ = entitySelectorConfig == null ? new EntitySelectorConfig ( ) 
: entitySelectorConfig ; 
EntitySelector leftEntitySelector = entitySelectorConfig_ . buildEntitySelector ( 
configPolicy , 
minimumCacheType , SelectionOrder . fromRandomSelectionBoolean ( randomSelection ) ) ; 
EntitySelectorConfig rightEntitySelectorConfig = defaultIfNull ( secondaryEntitySelectorConfig , 
entitySelectorConfig_ ) ; 
EntitySelector rightEntitySelector = rightEntitySelectorConfig . buildEntitySelector ( 
List < GenuineVariableDescriptor > variableDescriptorList = deduceVariableDescriptorList ( 
leftEntitySelector . getEntityDescriptor ( ) , variableNameIncludeList ) ; 
return new SwapMoveSelector ( leftEntitySelector , rightEntitySelector , variableDescriptorList , 
randomSelection ) ; 
EntitySelector entitySelector = entitySelectorConfig_ . buildEntitySelector ( configPolicy , 
ValueSelectorConfig valueSelectorConfig_ = valueSelectorConfig == null ? new ValueSelectorConfig ( ) 
: valueSelectorConfig ; 
ValueSelector [ ] valueSelectors = new ValueSelector [ K - 1 ] ; 
for ( int i = 0 ; i < valueSelectors . length ; i ++ ) { 
valueSelectors [ i ] = valueSelectorConfig_ . buildValueSelector ( configPolicy , 
entitySelector . getEntityDescriptor ( ) , 
return new KOptMoveSelector ( entitySelector , valueSelectors , randomSelection ) ; 
} public < Solution_ > void buildProblemBenchmarkList ( SolverConfigContext solverConfigContext , 
SolverBenchmarkResult solverBenchmarkResult , Solution_ [ ] extraProblems ) { 
PlannerBenchmarkResult plannerBenchmarkResult = solverBenchmarkResult . getPlannerBenchmarkResult ( ) ; 
List < ProblemBenchmarkResult > unifiedProblemBenchmarkResultList 
= plannerBenchmarkResult . getUnifiedProblemBenchmarkResultList ( ) ; 
for ( ProblemProvider < Solution_ > problemProvider : buildProblemProviderList ( 
solverConfigContext , solverBenchmarkResult , extraProblems ) ) { 
ProblemBenchmarkResult < Solution_ > newProblemBenchmarkResult = buildProblemBenchmark ( 
solverConfigContext , plannerBenchmarkResult , problemProvider ) ; 
ProblemBenchmarkResult problemBenchmarkResult ; 
int index = unifiedProblemBenchmarkResultList . indexOf ( newProblemBenchmarkResult ) ; 
problemBenchmarkResult = newProblemBenchmarkResult ; 
unifiedProblemBenchmarkResultList . add ( problemBenchmarkResult ) ; 
problemBenchmarkResult = unifiedProblemBenchmarkResultList . get ( index ) ; 
buildSingleBenchmark ( solverConfigContext , solverBenchmarkResult , problemBenchmarkResult ) ; 
public HardSoftScore calculateScore ( CloudBalance cloudBalance ) { 
int hardScore = 0 ; 
int softScore = 0 ; 
for ( CloudComputer computer : cloudBalance . getComputerList ( ) ) { 
int cpuPowerUsage = 0 ; 
int memoryUsage = 0 ; 
int networkBandwidthUsage = 0 ; 
boolean used = false ; 
for ( CloudProcess process : cloudBalance . getProcessList ( ) ) { 
if ( computer . equals ( process . getComputer ( ) ) ) { 
cpuPowerUsage += process . getRequiredCpuPower ( ) ; 
memoryUsage += process . getRequiredMemory ( ) ; 
networkBandwidthUsage += process . getRequiredNetworkBandwidth ( ) ; 
used = true ; 
int cpuPowerAvailable = computer . getCpuPower ( ) - cpuPowerUsage ; 
if ( cpuPowerAvailable < 0 ) { 
hardScore += cpuPowerAvailable ; 
int memoryAvailable = computer . getMemory ( ) - memoryUsage ; 
if ( memoryAvailable < 0 ) { 
hardScore += memoryAvailable ; 
int networkBandwidthAvailable = computer . getNetworkBandwidth ( ) - networkBandwidthUsage ; 
if ( networkBandwidthAvailable < 0 ) { 
hardScore += networkBandwidthAvailable ; 
if ( used ) { 
softScore -= computer . getCost ( ) ; 
return HardSoftScore . of ( hardScore , softScore ) ; 
} public void initBenchmarkReportDirectory ( File benchmarkDirectory ) { 
String timestampString = startingTimestamp . format ( DateTimeFormatter . ofPattern ( "yyyy-MM-dd_HHmmss" ) ) ; 
if ( StringUtils . isEmpty ( name ) ) { 
name = timestampString ; 
if ( ! benchmarkDirectory . mkdirs ( ) ) { 
if ( ! benchmarkDirectory . isDirectory ( ) ) { 
if ( ! benchmarkDirectory . canWrite ( ) ) { 
int duplicationIndex = 0 ; 
String directoryName = timestampString + ( duplicationIndex == 0 ? "" : "_" + duplicationIndex ) ; 
duplicationIndex ++ ; 
benchmarkReportDirectory = new File ( benchmarkDirectory , 
BooleanUtils . isFalse ( aggregation ) ? directoryName : directoryName + "_aggregation" ) ; 
} while ( ! benchmarkReportDirectory . mkdir ( ) ) ; 
for ( ProblemBenchmarkResult problemBenchmarkResult : unifiedProblemBenchmarkResultList ) { 
problemBenchmarkResult . makeDirs ( ) ; 
} public static PlannerBenchmarkResult createMergedResult ( 
List < SingleBenchmarkResult > singleBenchmarkResultList ) { 
PlannerBenchmarkResult mergedResult = createMergeSingleton ( singleBenchmarkResultList ) ; 
Map < SolverBenchmarkResult , SolverBenchmarkResult > solverMergeMap 
= SolverBenchmarkResult . createMergeMap ( mergedResult , singleBenchmarkResultList ) ; 
Map < ProblemBenchmarkResult , ProblemBenchmarkResult > problemMergeMap 
= ProblemBenchmarkResult . createMergeMap ( mergedResult , singleBenchmarkResultList ) ; 
SolverBenchmarkResult solverBenchmarkResult = solverMergeMap . get ( 
singleBenchmarkResult . getSolverBenchmarkResult ( ) ) ; 
ProblemBenchmarkResult problemBenchmarkResult = problemMergeMap . get ( 
singleBenchmarkResult . getProblemBenchmarkResult ( ) ) ; 
SingleBenchmarkResult . createMerge ( 
solverBenchmarkResult , problemBenchmarkResult , singleBenchmarkResult ) ; 
return mergedResult ; 
public QueuedValuePlacer buildEntityPlacer ( HeuristicConfigPolicy configPolicy ) { 
EntityDescriptor entityDescriptor = deduceEntityDescriptor ( configPolicy . getSolutionDescriptor ( ) , entityClass ) ; 
boolean reinitializeVariableFilterEnabled = configPolicy . isReinitializeVariableFilterEnabled ( ) ; 
configPolicy . setReinitializeVariableFilterEnabled ( false ) ; 
ValueSelectorConfig valueSelectorConfig_ = buildValueSelectorConfig ( configPolicy , entityDescriptor ) ; 
ValueSelector valueSelector = valueSelectorConfig_ . buildValueSelector ( configPolicy , entityDescriptor , 
SelectionCacheType . PHASE , SelectionOrder . ORIGINAL ) ; 
configPolicy . setReinitializeVariableFilterEnabled ( reinitializeVariableFilterEnabled ) ; 
moveSelectorConfig = buildChangeMoveSelectorConfig ( configPolicy , 
valueSelectorConfig_ . getId ( ) , valueSelector . getVariableDescriptor ( ) ) ; 
if ( ! ( valueSelector instanceof EntityIndependentValueSelector ) ) { 
return new QueuedValuePlacer ( ( EntityIndependentValueSelector ) valueSelector , moveSelector ) ; 
super . constructCache ( solverScope ) ; 
sorter . sort ( solverScope . getScoreDirector ( ) , cachedEntityList ) ; 
cachedEntityList . size ( ) , this ) ; 
public PartitionedSearchPhase buildPhase ( int phaseIndex , HeuristicConfigPolicy solverConfigPolicy , 
ThreadFactory threadFactory ; 
if ( threadFactoryClass != null ) { 
threadFactory = ConfigUtils . newInstance ( this , "threadFactoryClass" , threadFactoryClass ) ; 
threadFactory = solverConfigPolicy . buildThreadFactory ( ChildThreadType . PART_THREAD ) ; 
DefaultPartitionedSearchPhase phase = new DefaultPartitionedSearchPhase ( 
buildPhaseTermination ( phaseConfigPolicy , solverTermination ) , 
buildSolutionPartitioner ( ) , threadFactory , resolvedActiveThreadCount ( ) ) ; 
List < PhaseConfig > phaseConfigList_ = phaseConfigList ; 
if ( ConfigUtils . isEmptyCollection ( phaseConfigList_ ) ) { 
phaseConfigList_ = Arrays . asList ( 
new ConstructionHeuristicPhaseConfig ( ) , 
new LocalSearchPhaseConfig ( ) ) ; 
phase . setPhaseConfigList ( phaseConfigList_ ) ; 
phase . setConfigPolicy ( phaseConfigPolicy . createChildThreadConfigPolicy ( ChildThreadType . PART_THREAD ) ) ; 
} public void processAnnotations ( DescriptorPolicy descriptorPolicy ) { 
processEntityAnnotations ( descriptorPolicy ) ; 
declaredGenuineVariableDescriptorMap = new LinkedHashMap < > ( ) ; 
declaredShadowVariableDescriptorMap = new LinkedHashMap < > ( ) ; 
declaredPinEntityFilterList = new ArrayList < > ( 2 ) ; 
List < Member > memberList = ConfigUtils . getDeclaredMembers ( entityClass ) ; 
for ( Member member : memberList ) { 
processValueRangeProviderAnnotation ( descriptorPolicy , member ) ; 
processPlanningVariableAnnotation ( descriptorPolicy , member ) ; 
processPlanningPinAnnotation ( descriptorPolicy , member ) ; 
if ( declaredGenuineVariableDescriptorMap . isEmpty ( ) && declaredShadowVariableDescriptorMap . isEmpty ( ) ) { 
processVariableAnnotations ( descriptorPolicy ) ; 
} public void reward ( RuleContext kcontext , long weightMultiplier ) { 
Rule rule = kcontext . getRule ( ) ; 
BiConsumer < RuleContext , Long > matchExecutor = matchExecutorByNumberMap . get ( rule ) ; 
if ( matchExecutor == null ) { 
matchExecutor . accept ( kcontext , weightMultiplier ) ; 
} private void addProblemFactsFromClass ( List < Object > factList , Class < ? > instanceClass ) { 
if ( instanceClass . equals ( AbstractSolution . class ) ) { 
for ( Field field : instanceClass . getDeclaredFields ( ) ) { 
if ( isFieldAPlanningEntityPropertyOrPlanningEntityCollectionProperty ( field , instanceClass ) ) { 
value = field . get ( this ) ; 
if ( value instanceof Collection ) { 
factList . addAll ( ( Collection ) value ) ; 
factList . add ( value ) ; 
Class < ? > superclass = instanceClass . getSuperclass ( ) ; 
if ( superclass != null ) { 
addProblemFactsFromClass ( factList , superclass ) ; 
public AnchorVariableSupply createExternalizedSupply ( InnerScoreDirector scoreDirector ) { 
SingletonInverseVariableSupply inverseVariableSupply = scoreDirector . getSupplyManager ( ) 
. demand ( new SingletonInverseVariableDemand ( sourceVariableDescriptor ) ) ; 
return new ExternalizedAnchorVariableSupply ( sourceVariableDescriptor , inverseVariableSupply ) ; 
} public static String getGetterPropertyName ( Member member ) { 
if ( member instanceof Field ) { 
return member . getName ( ) ; 
} else if ( member instanceof Method ) { 
String methodName = member . getName ( ) ; 
for ( String prefix : PROPERTY_ACCESSOR_PREFIXES ) { 
if ( methodName . startsWith ( prefix ) ) { 
return decapitalizePropertyName ( methodName . substring ( prefix . length ( ) ) ) ; 
} public static boolean isGetterMethod ( Method method ) { 
if ( method . getParameterTypes ( ) . length != 0 ) { 
String methodName = method . getName ( ) ; 
if ( methodName . startsWith ( PROPERTY_ACCESSOR_PREFIX_GET ) && method . getReturnType ( ) != void . class ) { 
} else if ( methodName . startsWith ( PROPERTY_ACCESSOR_PREFIX_IS ) && method . getReturnType ( ) == boolean . class ) { 
return ! childMoveSelectorList . isEmpty ( ) 
&& childMoveSelectorList . get ( childMoveSelectorList . size ( ) - 1 ) . isNeverEnding ( ) ; 
Object oldValue = variableDescriptor . getValue ( entity ) ; 
return ! Objects . equals ( oldValue , toPlanningValue ) ; 
public void configureConstraintWeight ( Rule rule , HardMediumSoftBigDecimalScore constraintWeight ) { 
super . configureConstraintWeight ( rule , constraintWeight ) ; 
BiConsumer < RuleContext , BigDecimal > matchExecutor ; 
if ( constraintWeight . equals ( HardMediumSoftBigDecimalScore . ZERO ) ) { 
matchExecutor = ( RuleContext kcontext , BigDecimal matchWeight ) -> { } ; 
} else if ( constraintWeight . getMediumScore ( ) . equals ( BigDecimal . ZERO ) && constraintWeight . getSoftScore ( ) . equals ( BigDecimal . ZERO ) ) { 
matchExecutor = ( RuleContext kcontext , BigDecimal matchWeight ) 
-> addHardConstraintMatch ( kcontext , constraintWeight . getHardScore ( ) . multiply ( matchWeight ) ) ; 
} else if ( constraintWeight . getHardScore ( ) . equals ( BigDecimal . ZERO ) && constraintWeight . getSoftScore ( ) . equals ( BigDecimal . ZERO ) ) { 
-> addMediumConstraintMatch ( kcontext , constraintWeight . getMediumScore ( ) . multiply ( matchWeight ) ) ; 
} else if ( constraintWeight . getHardScore ( ) . equals ( BigDecimal . ZERO ) && constraintWeight . getMediumScore ( ) . equals ( BigDecimal . ZERO ) ) { 
-> addSoftConstraintMatch ( kcontext , constraintWeight . getSoftScore ( ) . multiply ( matchWeight ) ) ; 
-> addMultiConstraintMatch ( kcontext , 
constraintWeight . getHardScore ( ) . multiply ( matchWeight ) , 
constraintWeight . getMediumScore ( ) . multiply ( matchWeight ) , 
constraintWeight . getSoftScore ( ) . multiply ( matchWeight ) ) ; 
matchExecutorByNumberMap . put ( rule , matchExecutor ) ; 
matchExecutorByScoreMap . put ( rule , ( RuleContext kcontext , 
HardMediumSoftBigDecimalScore weightMultiplier ) -> addMultiConstraintMatch ( kcontext , 
constraintWeight . getHardScore ( ) . multiply ( weightMultiplier . getHardScore ( ) ) , 
constraintWeight . getMediumScore ( ) . multiply ( weightMultiplier . getMediumScore ( ) ) , 
constraintWeight . getSoftScore ( ) . multiply ( weightMultiplier . getSoftScore ( ) ) ) ) ; 
} public void penalize ( RuleContext kcontext , BigDecimal hardWeightMultiplier , BigDecimal mediumWeightMultiplier , BigDecimal softWeightMultiplier ) { 
reward ( kcontext , hardWeightMultiplier . negate ( ) , mediumWeightMultiplier . negate ( ) , softWeightMultiplier . negate ( ) ) ; 
} public void reward ( RuleContext kcontext , BigDecimal hardWeightMultiplier , BigDecimal mediumWeightMultiplier , BigDecimal softWeightMultiplier ) { 
BiConsumer < RuleContext , HardMediumSoftBigDecimalScore > matchExecutor = matchExecutorByScoreMap . get ( rule ) ; 
matchExecutor . accept ( kcontext , HardMediumSoftBigDecimalScore . of ( hardWeightMultiplier , mediumWeightMultiplier , softWeightMultiplier ) ) ; 
} public void addHardConstraintMatch ( RuleContext kcontext , BigDecimal hardWeight ) { 
hardScore = hardScore . add ( hardWeight ) ; 
registerConstraintMatch ( kcontext , 
( ) -> hardScore = hardScore . subtract ( hardWeight ) , 
( ) -> HardMediumSoftBigDecimalScore . of ( hardWeight , BigDecimal . ZERO , BigDecimal . ZERO ) ) ; 
} public void addMediumConstraintMatch ( RuleContext kcontext , BigDecimal mediumWeight ) { 
mediumScore = mediumScore . add ( mediumWeight ) ; 
( ) -> mediumScore = mediumScore . subtract ( mediumWeight ) , 
( ) -> HardMediumSoftBigDecimalScore . of ( BigDecimal . ZERO , mediumWeight , BigDecimal . ZERO ) ) ; 
} public void addSoftConstraintMatch ( RuleContext kcontext , BigDecimal softWeight ) { 
softScore = softScore . add ( softWeight ) ; 
( ) -> softScore = softScore . subtract ( softWeight ) , 
( ) -> HardMediumSoftBigDecimalScore . of ( BigDecimal . ZERO , BigDecimal . ZERO , softWeight ) ) ; 
DefaultSolver < Solution_ > defaultSolver = ( DefaultSolver < Solution_ > ) solver ; 
defaultSolver . getSolverScope ( ) . getScoreDirector ( ) . overwriteConstraintMatchEnabledPreference ( true ) ; 
defaultSolver . addPhaseLifecycleListener ( listener ) ; 
for ( Termination termination : terminationList ) { 
} protected List < Termination > createChildThreadTerminationList ( DefaultSolverScope solverScope , ChildThreadType childThreadType ) { 
List < Termination > childThreadTerminationList = new ArrayList < > ( terminationList . size ( ) ) ; 
childThreadTerminationList . add ( termination . createChildThreadTermination ( solverScope , childThreadType ) ) ; 
return childThreadTerminationList ; 
List < MoveSelector > moveSelectorList = new ArrayList < > ( moveSelectorConfigList . size ( ) ) ; 
for ( MoveSelectorConfig moveSelectorConfig : moveSelectorConfigList ) { 
moveSelectorList . add ( 
moveSelectorConfig . buildMoveSelector ( configPolicy , 
minimumCacheType , SelectionOrder . fromRandomSelectionBoolean ( randomSelection ) ) ) ; 
boolean ignoreEmptyChildIterators_ = defaultIfNull ( ignoreEmptyChildIterators , true ) ; 
return new CartesianProductMoveSelector ( moveSelectorList , ignoreEmptyChildIterators_ , randomSelection ) ; 
CommonApp . prepareSwingEnvironment ( ) ; 
OptaPlannerExamplesApp optaPlannerExamplesApp = new OptaPlannerExamplesApp ( ) ; 
optaPlannerExamplesApp . pack ( ) ; 
optaPlannerExamplesApp . setLocationRelativeTo ( null ) ; 
optaPlannerExamplesApp . setVisible ( true ) ; 
} public int calculateOverlap ( MeetingAssignment other ) { 
if ( startingTimeGrain == null || other . getStartingTimeGrain ( ) == null ) { 
int start = startingTimeGrain . getGrainIndex ( ) ; 
int end = start + meeting . getDurationInGrains ( ) ; 
int otherStart = other . startingTimeGrain . getGrainIndex ( ) ; 
int otherEnd = otherStart + other . meeting . getDurationInGrains ( ) ; 
if ( end < otherStart ) { 
} else if ( otherEnd < start ) { 
return Math . min ( end , otherEnd ) - Math . max ( start , otherStart ) ; 
for ( Object leftEntity : leftSubChain . getEntityList ( ) ) { 
if ( rightSubChain . getEntityList ( ) . contains ( leftEntity ) ) { 
public void writeGraphFiles ( BenchmarkReport benchmarkReport ) { 
XYPlot plot = createPlot ( benchmarkReport ) ; 
int seriesIndex = 0 ; 
for ( SingleBenchmarkResult singleBenchmarkResult : problemBenchmarkResult . getSingleBenchmarkResultList ( ) ) { 
XYIntervalSeries series = new XYIntervalSeries ( singleBenchmarkResult . getSolverBenchmarkResult ( ) . getNameWithFavoriteSuffix ( ) ) ; 
XYItemRenderer renderer = new YIntervalRenderer ( ) ; 
if ( singleBenchmarkResult . hasAllSuccess ( ) ) { 
BestSolutionMutationSubSingleStatistic subSingleStatistic = ( BestSolutionMutationSubSingleStatistic ) 
singleBenchmarkResult . getSubSingleStatistic ( problemStatisticType ) ; 
List < BestSolutionMutationStatisticPoint > points = subSingleStatistic . getPointList ( ) ; 
for ( BestSolutionMutationStatisticPoint point : points ) { 
long timeMillisSpent = point . getTimeMillisSpent ( ) ; 
long mutationCount = point . getMutationCount ( ) ; 
double yValue = mutationCount ; 
series . add ( timeMillisSpent , timeMillisSpent , timeMillisSpent , 
yValue , ( yValue > 0.0 ) ? 0.0 : yValue , ( yValue > 0.0 ) ? yValue : 0.0 ) ; 
XYIntervalSeriesCollection dataset = new XYIntervalSeriesCollection ( ) ; 
dataset . addSeries ( series ) ; 
plot . setDataset ( seriesIndex , dataset ) ; 
if ( singleBenchmarkResult . getSolverBenchmarkResult ( ) . isFavorite ( ) ) { 
renderer . setSeriesStroke ( 0 , new BasicStroke ( 2.0f ) ) ; 
plot . setRenderer ( seriesIndex , renderer ) ; 
seriesIndex ++ ; 
JFreeChart . DEFAULT_TITLE_FONT , plot , true ) ; 
graphFile = writeChartToImageFile ( chart , problemBenchmarkResult . getName ( ) + "BestSolutionMutationStatistic" ) ; 
public AndCompositeTermination createChildThreadTermination ( 
DefaultSolverScope solverScope , ChildThreadType childThreadType ) { 
return new AndCompositeTermination ( createChildThreadTerminationList ( solverScope , childThreadType ) ) ; 
private List < TopicConflict > calculateTopicConflictList ( ) { 
List < TopicConflict > topicConflictList = new ArrayList < > ( ) ; 
for ( Topic leftTopic : topicList ) { 
for ( Topic rightTopic : topicList ) { 
if ( leftTopic . getId ( ) < rightTopic . getId ( ) ) { 
int studentSize = 0 ; 
for ( Student student : leftTopic . getStudentList ( ) ) { 
if ( rightTopic . getStudentList ( ) . contains ( student ) ) { 
studentSize ++ ; 
if ( studentSize > 0 ) { 
topicConflictList . add ( new TopicConflict ( leftTopic , rightTopic , studentSize ) ) ; 
return topicConflictList ; 
} public void addMove ( int partIndex , PartitionChangeMove < Solution_ > move ) { 
long eventIndex = nextEventIndexMap . get ( partIndex ) . getAndIncrement ( ) ; 
PartitionChangedEvent < Solution_ > event = new PartitionChangedEvent < > ( 
partIndex , eventIndex , move ) ; 
moveEventMap . put ( event . getPartIndex ( ) , event ) ; 
queue . add ( event ) ; 
} public void addFinish ( int partIndex , long partCalculationCount ) { 
partIndex , eventIndex , partCalculationCount ) ; 
} public void addExceptionThrown ( int partIndex , Throwable throwable ) { 
partIndex , eventIndex , throwable ) ; 
public void setWorkingSolution ( Solution_ workingSolution ) { 
super . setWorkingSolution ( workingSolution ) ; 
if ( incrementalScoreCalculator instanceof ConstraintMatchAwareIncrementalScoreCalculator ) { 
( ( ConstraintMatchAwareIncrementalScoreCalculator < Solution_ > ) incrementalScoreCalculator ) 
. resetWorkingSolution ( workingSolution , constraintMatchEnabledPreference ) ; 
incrementalScoreCalculator . resetWorkingSolution ( workingSolution ) ; 
public void beforeEntityAdded ( EntityDescriptor < Solution_ > entityDescriptor , Object entity ) { 
incrementalScoreCalculator . beforeEntityAdded ( entity ) ; 
super . beforeEntityAdded ( entityDescriptor , entity ) ; 
} protected void assertWorkingSolutionInitialized ( AbstractPhaseScope < Solution_ > phaseScope ) { 
if ( ! phaseScope . getStartingScore ( ) . isSolutionInitialized ( ) ) { 
InnerScoreDirector < Solution_ > scoreDirector = phaseScope . getScoreDirector ( ) ; 
SolutionDescriptor < Solution_ > solutionDescriptor = scoreDirector . getSolutionDescriptor ( ) ; 
for ( Iterator < Object > it = solutionDescriptor . extractAllEntitiesIterator ( workingSolution ) ; it . hasNext ( ) ; ) { 
Object entity = it . next ( ) ; 
EntityDescriptor < Solution_ > entityDescriptor = solutionDescriptor . findEntityDescriptorOrFail ( 
entity . getClass ( ) ) ; 
if ( ! entityDescriptor . isEntityInitializedOrImmovable ( scoreDirector , entity ) ) { 
String variableRef = null ; 
for ( GenuineVariableDescriptor < Solution_ > variableDescriptor : entityDescriptor . getGenuineVariableDescriptors ( ) ) { 
if ( ! variableDescriptor . isInitialized ( entity ) ) { 
variableRef = variableDescriptor . getSimpleEntityAndVariableName ( ) ; 
} public ScoreDefinition buildDeprecatedScoreDefinition ( ) { 
if ( scoreDefinitionType != ScoreDefinitionType . BENDABLE 
&& scoreDefinitionType != ScoreDefinitionType . BENDABLE_LONG 
&& scoreDefinitionType != ScoreDefinitionType . BENDABLE_BIG_DECIMAL 
&& ( bendableHardLevelsSize != null || bendableSoftLevelsSize != null ) ) { 
if ( ( scoreDefinitionType == ScoreDefinitionType . BENDABLE 
|| scoreDefinitionType == ScoreDefinitionType . BENDABLE_LONG 
|| scoreDefinitionType == ScoreDefinitionType . BENDABLE_BIG_DECIMAL ) 
&& ( bendableHardLevelsSize == null || bendableSoftLevelsSize == null ) ) { 
if ( scoreDefinitionClass != null ) { 
if ( scoreDefinitionType != null ) { 
return ConfigUtils . newInstance ( this , "scoreDefinitionClass" , scoreDefinitionClass ) ; 
switch ( scoreDefinitionType ) { 
return new SimpleScoreDefinition ( ) ; 
case SIMPLE_LONG : 
return new SimpleLongScoreDefinition ( ) ; 
case SIMPLE_DOUBLE : 
return new SimpleDoubleScoreDefinition ( ) ; 
case SIMPLE_BIG_DECIMAL : 
return new SimpleBigDecimalScoreDefinition ( ) ; 
case HARD_SOFT : 
return new HardSoftScoreDefinition ( ) ; 
case HARD_SOFT_LONG : 
return new HardSoftLongScoreDefinition ( ) ; 
case HARD_SOFT_DOUBLE : 
return new HardSoftDoubleScoreDefinition ( ) ; 
case HARD_SOFT_BIG_DECIMAL : 
return new HardSoftBigDecimalScoreDefinition ( ) ; 
case HARD_MEDIUM_SOFT : 
return new HardMediumSoftScoreDefinition ( ) ; 
case HARD_MEDIUM_SOFT_LONG : 
return new HardMediumSoftLongScoreDefinition ( ) ; 
case BENDABLE : 
return new BendableScoreDefinition ( bendableHardLevelsSize , bendableSoftLevelsSize ) ; 
case BENDABLE_LONG : 
return new BendableLongScoreDefinition ( bendableHardLevelsSize , bendableSoftLevelsSize ) ; 
case BENDABLE_BIG_DECIMAL : 
return new BendableBigDecimalScoreDefinition ( bendableHardLevelsSize , bendableSoftLevelsSize ) ; 
} public void buildSolverBenchmark ( SolverConfigContext solverConfigContext , PlannerBenchmarkResult plannerBenchmark , 
Solution_ [ ] extraProblems ) { 
SolverBenchmarkResult solverBenchmarkResult = new SolverBenchmarkResult ( plannerBenchmark ) ; 
solverBenchmarkResult . setName ( name ) ; 
solverBenchmarkResult . setSubSingleCount ( ConfigUtils . inheritOverwritableProperty ( subSingleCount , 1 ) ) ; 
solverBenchmarkResult . setSolverConfig ( solverConfig ) ; 
SolutionDescriptor < Object > solutionDescriptor = solverConfig . buildSolutionDescriptor ( solverConfigContext ) ; 
for ( Solution_ extraProblem : extraProblems ) { 
if ( ! solutionDescriptor . getSolutionClass ( ) . isInstance ( extraProblem ) ) { 
solverBenchmarkResult . setScoreDefinition ( 
solutionDescriptor . getScoreDefinition ( ) ) ; 
solverBenchmarkResult . setSingleBenchmarkResultList ( new ArrayList < > ( ) ) ; 
ProblemBenchmarksConfig problemBenchmarksConfig_ 
= problemBenchmarksConfig == null ? new ProblemBenchmarksConfig ( ) 
: problemBenchmarksConfig ; 
plannerBenchmark . getSolverBenchmarkResultList ( ) . add ( solverBenchmarkResult ) ; 
problemBenchmarksConfig_ . buildProblemBenchmarkList ( solverConfigContext , solverBenchmarkResult , extraProblems ) ; 
protected Collection < ? extends Object > findTabu ( LocalSearchMoveScope moveScope ) { 
return Collections . singletonList ( moveScope . getMove ( ) ) ; 
} protected Solver < NQueens > createSolverByXml ( ) { 
SolverFactory < NQueens > solverFactory = SolverFactory . createFromXmlResource ( SOLVER_CONFIG ) ; 
return solverFactory . buildSolver ( ) ; 
} protected Solver < NQueens > createSolverByApi ( ) { 
SolverFactory < NQueens > solverFactory = SolverFactory . createEmpty ( ) ; 
SolverConfig solverConfig = solverFactory . getSolverConfig ( ) ; 
solverConfig . setSolutionClass ( NQueens . class ) ; 
solverConfig . setEntityClassList ( Collections . < Class < ? > > singletonList ( Queen . class ) ) ; 
ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig ( ) ; 
scoreDirectorFactoryConfig . setScoreDrlList ( 
Arrays . asList ( "org/optaplanner/examples/nqueens/solver/nQueensScoreRules.drl" ) ) ; 
solverConfig . setScoreDirectorFactoryConfig ( scoreDirectorFactoryConfig ) ; 
solverConfig . setTerminationConfig ( new TerminationConfig ( ) . withBestScoreLimit ( "0" ) ) ; 
List < PhaseConfig > phaseConfigList = new ArrayList < > ( ) ; 
ConstructionHeuristicPhaseConfig constructionHeuristicPhaseConfig = new ConstructionHeuristicPhaseConfig ( ) ; 
constructionHeuristicPhaseConfig . setConstructionHeuristicType ( 
ConstructionHeuristicType . FIRST_FIT_DECREASING ) ; 
phaseConfigList . add ( constructionHeuristicPhaseConfig ) ; 
LocalSearchPhaseConfig localSearchPhaseConfig = new LocalSearchPhaseConfig ( ) ; 
ChangeMoveSelectorConfig changeMoveSelectorConfig = new ChangeMoveSelectorConfig ( ) ; 
changeMoveSelectorConfig . setSelectionOrder ( SelectionOrder . ORIGINAL ) ; 
localSearchPhaseConfig . setMoveSelectorConfig ( changeMoveSelectorConfig ) ; 
localSearchPhaseConfig . setAcceptorConfig ( new AcceptorConfig ( ) . withEntityTabuSize ( 5 ) ) ; 
phaseConfigList . add ( localSearchPhaseConfig ) ; 
solverConfig . setPhaseConfigList ( phaseConfigList ) ; 
moveSelector . solvingStarted ( solverScope ) ; 
forager . solvingStarted ( solverScope ) ; 
} public void resetWorkingSolution ( ) { 
for ( VariableListenerNotifiable notifiable : notifiableList ) { 
VariableListener variableListener = notifiable . getVariableListener ( ) ; 
if ( variableListener instanceof StatefulVariableListener ) { 
( ( StatefulVariableListener ) variableListener ) . resetWorkingSolution ( scoreDirector ) ; 
public IncrementalScoreDirector < Solution_ > buildScoreDirector ( 
boolean lookUpEnabled , boolean constraintMatchEnabledPreference ) { 
IncrementalScoreCalculator < Solution_ > incrementalScoreCalculator = ConfigUtils . newInstance ( this , 
"incrementalScoreCalculatorClass" , incrementalScoreCalculatorClass ) ; 
ConfigUtils . applyCustomProperties ( incrementalScoreCalculator , "incrementalScoreCalculatorClass" , 
incrementalScoreCalculatorCustomProperties , "incrementalScoreCalculatorCustomProperties" ) ; 
return new IncrementalScoreDirector < > ( this , 
lookUpEnabled , constraintMatchEnabledPreference , incrementalScoreCalculator ) ; 
EntityDescriptor entityDescriptor = deduceEntityDescriptor ( 
configPolicy . getSolutionDescriptor ( ) , entityClass ) ; 
SubChainSelectorConfig subChainSelectorConfig_ = subChainSelectorConfig == null ? new SubChainSelectorConfig ( ) 
: subChainSelectorConfig ; 
SubChainSelector subChainSelector = subChainSelectorConfig_ . buildSubChainSelector ( configPolicy , 
entityDescriptor , 
ValueSelector valueSelector = valueSelectorConfig_ . buildValueSelector ( configPolicy , 
return new SubChainChangeMoveSelector ( subChainSelector , ( EntityIndependentValueSelector ) valueSelector , 
randomSelection , defaultIfNull ( selectReversingMoveToo , true ) ) ; 
} protected static SubSingleBenchmarkResult createMerge ( 
SingleBenchmarkResult singleBenchmarkResult , SubSingleBenchmarkResult oldResult , 
int subSingleBenchmarkIndex ) { 
SubSingleBenchmarkResult newResult = new SubSingleBenchmarkResult ( singleBenchmarkResult , subSingleBenchmarkIndex ) ; 
newResult . pureSubSingleStatisticList = new ArrayList < > ( oldResult . pureSubSingleStatisticList . size ( ) ) ; 
for ( PureSubSingleStatistic oldSubSingleStatistic : oldResult . pureSubSingleStatisticList ) { 
newResult . pureSubSingleStatisticList . add ( 
oldSubSingleStatistic . getStatisticType ( ) . buildPureSubSingleStatistic ( newResult ) ) ; 
newResult . initSubSingleStatisticMap ( ) ; 
for ( SubSingleStatistic newSubSingleStatistic : newResult . effectiveSubSingleStatisticMap . values ( ) ) { 
SubSingleStatistic oldSubSingleStatistic = oldResult . getSubSingleStatistic ( newSubSingleStatistic . getStatisticType ( ) ) ; 
if ( ! oldSubSingleStatistic . getCsvFile ( ) . exists ( ) ) { 
if ( oldResult . hasAnyFailure ( ) ) { 
newSubSingleStatistic . initPointList ( ) ; 
oldResult , oldSubSingleStatistic ) ; 
oldSubSingleStatistic . unhibernatePointList ( ) ; 
newSubSingleStatistic . setPointList ( oldSubSingleStatistic . getPointList ( ) ) ; 
oldSubSingleStatistic . hibernatePointList ( ) ; 
newResult . succeeded = oldResult . succeeded ; 
newResult . score = oldResult . score ; 
newResult . timeMillisSpent = oldResult . timeMillisSpent ; 
newResult . scoreCalculationCount = oldResult . scoreCalculationCount ; 
singleBenchmarkResult . getSubSingleBenchmarkResultList ( ) . add ( newResult ) ; 
InnerScoreDirectorFactory < Solution_ > scoreDirectorFactory 
= ( InnerScoreDirectorFactory < Solution_ > ) solver . getScoreDirectorFactory ( ) ; 
SolutionDescriptor < Solution_ > solutionDescriptor = scoreDirectorFactory . getSolutionDescriptor ( ) ; 
listener . setMutationCounter ( new MutationCounter < > ( solutionDescriptor ) ) ; 
solver . addEventListener ( listener ) ; 
List < XYPlot > plotList = new ArrayList < > ( BenchmarkReport . CHARTED_SCORE_LEVEL_SIZE ) ; 
List < XYSeries > seriesList = new ArrayList < > ( BenchmarkReport . CHARTED_SCORE_LEVEL_SIZE ) ; 
XYItemRenderer renderer = new XYStepRenderer ( ) ; 
BestScoreSubSingleStatistic subSingleStatistic = ( BestScoreSubSingleStatistic ) 
List < BestScoreStatisticPoint > points = subSingleStatistic . getPointList ( ) ; 
for ( BestScoreStatisticPoint point : points ) { 
if ( ! point . getScore ( ) . isSolutionInitialized ( ) ) { 
double [ ] levelValues = ScoreUtils . extractLevelDoubles ( point . getScore ( ) ) ; 
for ( int i = 0 ; i < levelValues . length && i < BenchmarkReport . CHARTED_SCORE_LEVEL_SIZE ; i ++ ) { 
if ( i >= seriesList . size ( ) ) { 
seriesList . add ( new XYSeries ( 
singleBenchmarkResult . getSolverBenchmarkResult ( ) . getNameWithFavoriteSuffix ( ) ) ) ; 
seriesList . get ( i ) . add ( timeMillisSpent , levelValues [ i ] ) ; 
long timeMillisSpent = singleBenchmarkResult . getTimeMillisSpent ( ) ; 
double [ ] bestScoreLevels = ScoreUtils . extractLevelDoubles ( singleBenchmarkResult . getMedian ( ) . getScore ( ) ) ; 
for ( int i = 0 ; i < bestScoreLevels . length && i < BenchmarkReport . CHARTED_SCORE_LEVEL_SIZE ; i ++ ) { 
seriesList . get ( i ) . add ( timeMillisSpent , bestScoreLevels [ i ] ) ; 
if ( subSingleStatistic . getPointList ( ) . size ( ) <= 1 ) { 
renderer = new StandardXYItemRenderer ( StandardXYItemRenderer . SHAPES_AND_LINES ) ; 
if ( i >= plotList . size ( ) ) { 
plotList . add ( createPlot ( benchmarkReport , i ) ) ; 
plotList . get ( i ) . setDataset ( seriesIndex , new XYSeriesCollection ( seriesList . get ( i ) ) ) ; 
plotList . get ( i ) . setRenderer ( seriesIndex , renderer ) ; 
graphFileList = new ArrayList < > ( plotList . size ( ) ) ; 
for ( int scoreLevelIndex = 0 ; scoreLevelIndex < plotList . size ( ) ; scoreLevelIndex ++ ) { 
String scoreLevelLabel = problemBenchmarkResult . findScoreLevelLabel ( scoreLevelIndex ) ; 
JFreeChart chart = new JFreeChart ( 
JFreeChart . DEFAULT_TITLE_FONT , plotList . get ( scoreLevelIndex ) , true ) ; 
graphFileList . add ( writeChartToImageFile ( chart , 
problemBenchmarkResult . getName ( ) + "BestScoreStatisticLevel" + scoreLevelIndex ) ) ; 
public Termination createChildThreadTermination ( 
if ( childThreadType == ChildThreadType . PART_THREAD ) { 
return solverTermination . createChildThreadTermination ( solverScope , childThreadType ) ; 
public Score calculateScore ( ) { 
variableListenerSupport . assertNotificationQueuesAreEmpty ( ) ; 
Score score = easyScoreCalculator . calculateScore ( workingSolution ) ; 
if ( score == null ) { 
if ( workingInitScore != 0 ) { 
score = score . withInitScore ( workingInitScore ) ; 
setCalculatedScore ( score ) ; 
return score ; 
public Map < Object , Indictment > getIndictmentMap ( ) { 
throw new IllegalStateException ( ConstraintMatch . class . getSimpleName ( ) 
List < Map < String , XYIntervalSeries > > moveTypeToSeriesMapList 
= new ArrayList < > ( BenchmarkReport . CHARTED_SCORE_LEVEL_SIZE ) ; 
List < PickedMoveTypeStepScoreDiffStatisticPoint > points = getPointList ( ) ; 
for ( PickedMoveTypeStepScoreDiffStatisticPoint point : points ) { 
String moveType = point . getMoveType ( ) ; 
double [ ] levelValues = ScoreUtils . extractLevelDoubles ( point . getStepScoreDiff ( ) ) ; 
if ( i >= moveTypeToSeriesMapList . size ( ) ) { 
moveTypeToSeriesMapList . add ( new LinkedHashMap < > ( ) ) ; 
Map < String , XYIntervalSeries > moveTypeToSeriesMap = moveTypeToSeriesMapList . get ( i ) ; 
XYIntervalSeries series = moveTypeToSeriesMap . computeIfAbsent ( moveType , 
k -> new XYIntervalSeries ( moveType ) ) ; 
double yValue = levelValues [ i ] ; 
graphFileList = new ArrayList < > ( moveTypeToSeriesMapList . size ( ) ) ; 
for ( int scoreLevelIndex = 0 ; scoreLevelIndex < moveTypeToSeriesMapList . size ( ) ; scoreLevelIndex ++ ) { 
XYPlot plot = createPlot ( benchmarkReport , scoreLevelIndex ) ; 
plot . setRenderer ( renderer ) ; 
XYIntervalSeriesCollection seriesCollection = new XYIntervalSeriesCollection ( ) ; 
for ( XYIntervalSeries series : moveTypeToSeriesMapList . get ( scoreLevelIndex ) . values ( ) ) { 
seriesCollection . addSeries ( series ) ; 
plot . setDataset ( seriesCollection ) ; 
String scoreLevelLabel = subSingleBenchmarkResult . getSingleBenchmarkResult ( ) . getProblemBenchmarkResult ( ) 
. findScoreLevelLabel ( scoreLevelIndex ) ; 
JFreeChart chart = new JFreeChart ( subSingleBenchmarkResult . getName ( ) 
"PickedMoveTypeStepScoreDiffStatisticLevel" + scoreLevelIndex ) ) ; 
Locale locale = benchmarkReport . getLocale ( ) ; 
xAxis . setNumberFormatOverride ( new MillisecondsSpentNumberFormat ( locale ) ) ; 
yAxis . setNumberFormatOverride ( NumberFormat . getInstance ( locale ) ) ; 
XYPlot plot = new XYPlot ( null , xAxis , yAxis , null ) ; 
plot . setOrientation ( PlotOrientation . VERTICAL ) ; 
XYSeries usedSeries = new XYSeries ( 
XYItemRenderer renderer = new XYLineAndShapeRenderer ( ) ; 
MemoryUseSubSingleStatistic subSingleStatistic = ( MemoryUseSubSingleStatistic ) 
List < MemoryUseStatisticPoint > points = subSingleStatistic . getPointList ( ) ; 
for ( MemoryUseStatisticPoint point : points ) { 
MemoryUseMeasurement memoryUseMeasurement = point . getMemoryUseMeasurement ( ) ; 
usedSeries . add ( timeMillisSpent , memoryUseMeasurement . getUsedMemory ( ) ) ; 
XYSeriesCollection seriesCollection = new XYSeriesCollection ( ) ; 
seriesCollection . addSeries ( usedSeries ) ; 
plot . setDataset ( seriesIndex , seriesCollection ) ; 
graphFile = writeChartToImageFile ( chart , problemBenchmarkResult . getName ( ) + "MemoryUseStatistic" ) ; 
} public static < Solution_ > SolverFactory < Solution_ > createFromKieContainerXmlResource ( 
String solverConfigResource ) { 
KieContainer kieContainer = KieServices . Factory . get ( ) . getKieClasspathContainer ( ) ; 
return new XStreamXmlSolverFactory < Solution_ > ( new SolverConfigContext ( kieContainer ) ) 
. configure ( solverConfigResource ) ; 
} public static < Solution_ > SolverFactory < Solution_ > createFromXmlResource ( String solverConfigResource , ClassLoader classLoader ) { 
return new XStreamXmlSolverFactory < Solution_ > ( new SolverConfigContext ( classLoader ) ) 
} public ScoreDifferencePercentage add ( ScoreDifferencePercentage addend ) { 
if ( percentageLevels . length != addend . getPercentageLevels ( ) . length ) { 
double [ ] newPercentageLevels = new double [ percentageLevels . length ] ; 
for ( int i = 0 ; i < percentageLevels . length ; i ++ ) { 
newPercentageLevels [ i ] = percentageLevels [ i ] + addend . percentageLevels [ i ] ; 
return new ScoreDifferencePercentage ( newPercentageLevels ) ; 
} public EnvironmentMode determineEnvironmentMode ( ) { 
if ( environmentMode == EnvironmentMode . PRODUCTION ) { 
environmentMode = EnvironmentMode . NON_REPRODUCIBLE ; 
return defaultIfNull ( environmentMode , EnvironmentMode . REPRODUCIBLE ) ; 
} public void offerRandomSeedFromSubSingleIndex ( long subSingleIndex ) { 
if ( environmentMode == null || environmentMode . isReproducible ( ) ) { 
if ( randomFactoryClass == null && randomSeed == null ) { 
randomSeed = subSingleIndex ; 
public void configureConstraintWeight ( Rule rule , BendableScore constraintWeight ) { 
BiConsumer < RuleContext , Integer > matchExecutor ; 
if ( constraintWeight . equals ( BendableScore . zero ( hardScores . length , softScores . length ) ) ) { 
matchExecutor = ( RuleContext kcontext , Integer matchWeight ) -> { } ; 
Integer singleLevel = null ; 
Integer singleLevelWeight = null ; 
for ( int i = 0 ; i < constraintWeight . getLevelsSize ( ) ; i ++ ) { 
int levelWeight = constraintWeight . getHardOrSoftScore ( i ) ; 
if ( levelWeight != 0 ) { 
if ( singleLevel != null ) { 
singleLevel = null ; 
singleLevelWeight = null ; 
singleLevel = i ; 
singleLevelWeight = levelWeight ; 
int levelWeight = singleLevelWeight ; 
if ( singleLevel < constraintWeight . getHardLevelsSize ( ) ) { 
int level = singleLevel ; 
matchExecutor = ( RuleContext kcontext , Integer matchWeight ) 
-> addHardConstraintMatch ( kcontext , level , levelWeight * matchWeight ) ; 
int level = singleLevel - constraintWeight . getHardLevelsSize ( ) ; 
-> addSoftConstraintMatch ( kcontext , level , levelWeight * matchWeight ) ; 
matchExecutor = ( RuleContext kcontext , Integer matchWeight ) -> { 
int [ ] hardWeights = new int [ hardScores . length ] ; 
int [ ] softWeights = new int [ softScores . length ] ; 
for ( int i = 0 ; i < hardWeights . length ; i ++ ) { 
hardWeights [ i ] = constraintWeight . getHardScore ( i ) * matchWeight ; 
for ( int i = 0 ; i < softWeights . length ; i ++ ) { 
softWeights [ i ] = constraintWeight . getSoftScore ( i ) * matchWeight ; 
addMultiConstraintMatch ( kcontext , hardWeights , softWeights ) ; 
matchExecutorByScoreMap . put ( rule , ( RuleContext kcontext , BendableScore weightMultiplier ) -> { 
hardWeights [ i ] = constraintWeight . getHardScore ( i ) * weightMultiplier . getHardScore ( i ) ; 
softWeights [ i ] = constraintWeight . getSoftScore ( i ) * weightMultiplier . getSoftScore ( i ) ; 
} public static BendableBigDecimalScore ofUninitialized ( int initScore , BigDecimal [ ] hardScores , BigDecimal [ ] softScores ) { 
return new BendableBigDecimalScore ( initScore , hardScores , softScores ) ; 
} public static BendableBigDecimalScore zero ( int hardLevelsSize , int softLevelsSize ) { 
BigDecimal [ ] hardScores = new BigDecimal [ hardLevelsSize ] ; 
Arrays . fill ( hardScores , BigDecimal . ZERO ) ; 
BigDecimal [ ] softScores = new BigDecimal [ softLevelsSize ] ; 
Arrays . fill ( softScores , BigDecimal . ZERO ) ; 
return new BendableBigDecimalScore ( 0 , hardScores , softScores ) ; 
} public static BendableBigDecimalScore ofHard ( int hardLevelsSize , int softLevelsSize , int hardLevel , BigDecimal hardScore ) { 
} public static BendableBigDecimalScore ofSoft ( int hardLevelsSize , int softLevelsSize , int softLevel , BigDecimal softScore ) { 
public void solve ( DefaultSolverScope < Solution_ > solverScope ) { 
SortedSet < ExhaustiveSearchNode > expandableNodeQueue = new TreeSet < > ( nodeComparator ) ; 
ExhaustiveSearchPhaseScope < Solution_ > phaseScope = new ExhaustiveSearchPhaseScope < > ( solverScope ) ; 
phaseScope . setExpandableNodeQueue ( expandableNodeQueue ) ; 
phaseStarted ( phaseScope ) ; 
while ( ! expandableNodeQueue . isEmpty ( ) && ! termination . isPhaseTerminated ( phaseScope ) ) { 
ExhaustiveSearchStepScope < Solution_ > stepScope = new ExhaustiveSearchStepScope < > ( phaseScope ) ; 
ExhaustiveSearchNode node = expandableNodeQueue . last ( ) ; 
expandableNodeQueue . remove ( node ) ; 
stepScope . setExpandingNode ( node ) ; 
stepStarted ( stepScope ) ; 
restoreWorkingSolution ( stepScope ) ; 
decider . expandNode ( stepScope ) ; 
stepEnded ( stepScope ) ; 
phaseScope . setLastCompletedStepScope ( stepScope ) ; 
phaseEnded ( phaseScope ) ; 
} public LocalSearchForager buildForager ( HeuristicConfigPolicy configPolicy ) { 
if ( foragerClass != null ) { 
if ( pickEarlyType != null || acceptedCountLimit != null || finalistPodiumType != null ) { 
return ConfigUtils . newInstance ( this , "foragerClass" , foragerClass ) ; 
LocalSearchPickEarlyType pickEarlyType_ = defaultIfNull ( pickEarlyType , LocalSearchPickEarlyType . NEVER ) ; 
int acceptedCountLimit_ = defaultIfNull ( acceptedCountLimit , Integer . MAX_VALUE ) ; 
FinalistPodiumType finalistPodiumType_ = defaultIfNull ( finalistPodiumType , FinalistPodiumType . HIGHEST_SCORE ) ; 
boolean breakTieRandomly_ = defaultIfNull ( breakTieRandomly , true ) ; 
return new AcceptedLocalSearchForager ( finalistPodiumType_ . buildFinalistPodium ( ) , pickEarlyType_ , 
acceptedCountLimit_ , breakTieRandomly_ ) ; 
} public void penalize ( RuleContext kcontext , long [ ] hardWeightsMultiplier , long [ ] softWeightsMultiplier ) { 
long [ ] negatedHardWeightsMultiplier = new long [ hardScores . length ] ; 
long [ ] negatedSoftWeightsMultiplier = new long [ softScores . length ] ; 
for ( int i = 0 ; i < negatedHardWeightsMultiplier . length ; i ++ ) { 
negatedHardWeightsMultiplier [ i ] = - hardWeightsMultiplier [ i ] ; 
for ( int i = 0 ; i < negatedSoftWeightsMultiplier . length ; i ++ ) { 
negatedSoftWeightsMultiplier [ i ] = - softWeightsMultiplier [ i ] ; 
reward ( kcontext , negatedHardWeightsMultiplier , negatedSoftWeightsMultiplier ) ; 
} public void reward ( RuleContext kcontext , long [ ] hardWeightsMultiplier , long [ ] softWeightsMultiplier ) { 
BiConsumer < RuleContext , BendableLongScore > matchExecutor = matchExecutorByScoreMap . get ( rule ) ; 
matchExecutor . accept ( kcontext , BendableLongScore . of ( hardWeightsMultiplier , softWeightsMultiplier ) ) ; 
} public void startNextStep ( int stepIndex ) { 
if ( filterStepIndex >= stepIndex ) { 
filterStepIndex = stepIndex ; 
MoveResult < Solution_ > exceptionResult = innerQueue . stream ( ) . filter ( MoveResult :: hasThrownException ) 
if ( exceptionResult != null ) { 
exceptionResult . getThrowable ( ) ) ; 
innerQueue . clear ( ) ; 
nextMoveIndex = 0 ; 
backlog . clear ( ) ; 
} public void addUndoableMove ( int moveThreadIndex , int stepIndex , int moveIndex , Move < Solution_ > move ) { 
MoveResult < Solution_ > result = new MoveResult < > ( moveThreadIndex , stepIndex , moveIndex , move , false , null ) ; 
if ( result . getStepIndex ( ) != filterStepIndex ) { 
innerQueue . add ( result ) ; 
} public void addMove ( int moveThreadIndex , int stepIndex , int moveIndex , Move < Solution_ > move , Score score ) { 
MoveResult < Solution_ > result = new MoveResult < > ( moveThreadIndex , stepIndex , moveIndex , move , true , score ) ; 
} public void addExceptionThrown ( int moveThreadIndex , Throwable throwable ) { 
MoveResult < Solution_ > result = new MoveResult < > ( moveThreadIndex , throwable ) ; 
} public MoveResult < Solution_ > take ( ) throws InterruptedException { 
int moveIndex = nextMoveIndex ; 
nextMoveIndex ++ ; 
if ( ! backlog . isEmpty ( ) ) { 
MoveResult < Solution_ > result = backlog . remove ( moveIndex ) ; 
MoveResult < Solution_ > result = innerQueue . take ( ) ; 
if ( result . hasThrownException ( ) ) { 
result . getThrowable ( ) ) ; 
if ( result . getMoveIndex ( ) == moveIndex ) { 
backlog . put ( result . getMoveIndex ( ) , result ) ; 
yAxis . setAutoRangeIncludesZero ( false ) ; 
XYSeries series = new XYSeries ( singleBenchmarkResult . getSolverBenchmarkResult ( ) . getNameWithFavoriteSuffix ( ) ) ; 
ScoreCalculationSpeedSubSingleStatistic subSingleStatistic = ( ScoreCalculationSpeedSubSingleStatistic ) 
List < ScoreCalculationSpeedStatisticPoint > points = subSingleStatistic . getPointList ( ) ; 
for ( ScoreCalculationSpeedStatisticPoint point : points ) { 
long scoreCalculationSpeed = point . getScoreCalculationSpeed ( ) ; 
series . add ( timeMillisSpent , scoreCalculationSpeed ) ; 
plot . setDataset ( seriesIndex , new XYSeriesCollection ( series ) ) ; 
graphFile = writeChartToImageFile ( chart , problemBenchmarkResult . getName ( ) + "ScoreCalculationSpeedStatistic" ) ; 
public void resetWorkingSolution ( InvestmentSolution solution ) { 
this . solution = solution ; 
squaredStandardDeviationFemtosMaximum = solution . getParametrization ( ) 
. calculateSquaredStandardDeviationFemtosMaximum ( ) ; 
squaredStandardDeviationFemtos = 0L ; 
List < Region > regionList = solution . getRegionList ( ) ; 
regionQuantityTotalMap = new HashMap < > ( ) ; 
for ( Region region : regionList ) { 
regionQuantityTotalMap . put ( region , 0L ) ; 
List < Sector > sectorList = solution . getSectorList ( ) ; 
sectorQuantityTotalMap = new HashMap < > ( sectorList . size ( ) ) ; 
for ( Sector sector : sectorList ) { 
sectorQuantityTotalMap . put ( sector , 0L ) ; 
hardScore = 0L ; 
softScore = 0L ; 
for ( AssetClassAllocation allocation : solution . getAssetClassAllocationList ( ) ) { 
insertQuantityMillis ( allocation , true ) ; 
} private void insertQuantityMillis ( AssetClassAllocation allocation , boolean reset ) { 
if ( squaredStandardDeviationFemtos > squaredStandardDeviationFemtosMaximum ) { 
hardScore += squaredStandardDeviationFemtos - squaredStandardDeviationFemtosMaximum ; 
squaredStandardDeviationFemtos += calculateStandardDeviationSquaredFemtosDelta ( allocation , reset ) ; 
hardScore -= squaredStandardDeviationFemtos - squaredStandardDeviationFemtosMaximum ; 
Long quantityMillis = allocation . getQuantityMillis ( ) ; 
if ( quantityMillis != null ) { 
Region region = allocation . getRegion ( ) ; 
long regionQuantityMaximum = region . getQuantityMillisMaximum ( ) ; 
long oldRegionQuantity = regionQuantityTotalMap . get ( region ) ; 
long oldRegionAvailable = regionQuantityMaximum - oldRegionQuantity ; 
long newRegionQuantity = oldRegionQuantity + quantityMillis ; 
long newRegionAvailable = regionQuantityMaximum - newRegionQuantity ; 
hardScore += Math . min ( newRegionAvailable , 0L ) - Math . min ( oldRegionAvailable , 0L ) ; 
regionQuantityTotalMap . put ( region , newRegionQuantity ) ; 
Sector sector = allocation . getSector ( ) ; 
long sectorQuantityMaximum = sector . getQuantityMillisMaximum ( ) ; 
long oldSectorQuantity = sectorQuantityTotalMap . get ( sector ) ; 
long oldSectorAvailable = sectorQuantityMaximum - oldSectorQuantity ; 
long newSectorQuantity = oldSectorQuantity + quantityMillis ; 
long newSectorAvailable = sectorQuantityMaximum - newSectorQuantity ; 
hardScore += Math . min ( newSectorAvailable , 0L ) - Math . min ( oldSectorAvailable , 0L ) ; 
sectorQuantityTotalMap . put ( sector , newSectorQuantity ) ; 
softScore += allocation . getQuantifiedExpectedReturnMicros ( ) ; 
} public synchronized boolean waitForRestartSolverDecision ( ) { 
if ( ! daemon ) { 
return ! problemFactChangeQueue . isEmpty ( ) && ! terminatedEarly ; 
while ( problemFactChangeQueue . isEmpty ( ) && ! terminatedEarly ) { 
wait ( ) ; 
return ! terminatedEarly ; 
} public synchronized < Solution_ > boolean addProblemFactChange ( ProblemFactChange < Solution_ > problemFactChange ) { 
boolean added = problemFactChangeQueue . add ( problemFactChange ) ; 
notifyAll ( ) ; 
} public synchronized < Solution_ > boolean addProblemFactChanges ( List < ProblemFactChange < Solution_ > > problemFactChangeList ) { 
boolean added = problemFactChangeQueue . addAll ( problemFactChangeList ) ; 
public synchronized boolean isSolverTerminated ( DefaultSolverScope solverScope ) { 
if ( Thread . currentThread ( ) . isInterrupted ( ) 
&& ! terminatedEarly ) { 
terminatedEarly = true ; 
return terminatedEarly || ! problemFactChangeQueue . isEmpty ( ) ; 
public int compareTo ( MrMachineTransientUsage other ) { 
. append ( machineCapacity , other . machineCapacity ) 
. append ( usage , other . usage ) 
public boolean isAccepted ( LocalSearchMoveScope moveScope ) { 
Score moveScore = moveScope . getScore ( ) ; 
Score lastStepScore = moveScope . getStepScope ( ) . getPhaseScope ( ) . getLastCompletedStepScope ( ) . getScore ( ) ; 
return moveScore . compareTo ( lastStepScore ) >= 0 ; 
} public static BendableScore ofHard ( int hardLevelsSize , int softLevelsSize , int hardLevel , int hardScore ) { 
int [ ] hardScores = new int [ hardLevelsSize ] ; 
return new BendableScore ( 0 , hardScores , new int [ softLevelsSize ] ) ; 
} public static BendableScore ofSoft ( int hardLevelsSize , int softLevelsSize , int softLevel , int softScore ) { 
int [ ] softScores = new int [ softLevelsSize ] ; 
return new BendableScore ( 0 , new int [ hardLevelsSize ] , softScores ) ; 
SelectionProbabilityWeightFactory selectorProbabilityWeightFactory ; 
if ( selectorProbabilityWeightFactoryClass != null ) { 
if ( ! randomSelection ) { 
selectorProbabilityWeightFactory = ConfigUtils . newInstance ( this , 
"selectorProbabilityWeightFactoryClass" , selectorProbabilityWeightFactoryClass ) ; 
} else if ( randomSelection ) { 
Map < MoveSelector , Double > fixedProbabilityWeightMap = new HashMap < > ( 
moveSelectorConfigList . size ( ) ) ; 
for ( int i = 0 ; i < moveSelectorConfigList . size ( ) ; i ++ ) { 
MoveSelectorConfig moveSelectorConfig = moveSelectorConfigList . get ( i ) ; 
MoveSelector moveSelector = moveSelectorList . get ( i ) ; 
Double fixedProbabilityWeight = moveSelectorConfig . getFixedProbabilityWeight ( ) ; 
if ( fixedProbabilityWeight == null ) { 
fixedProbabilityWeight = 1.0 ; 
fixedProbabilityWeightMap . put ( moveSelector , fixedProbabilityWeight ) ; 
selectorProbabilityWeightFactory = new FixedSelectorProbabilityWeightFactory ( fixedProbabilityWeightMap ) ; 
selectorProbabilityWeightFactory = null ; 
return new UnionMoveSelector ( moveSelectorList , randomSelection , 
selectorProbabilityWeightFactory ) ; 
LocalSearchPhaseScope < Solution_ > phaseScope = new LocalSearchPhaseScope < > ( solverScope ) ; 
while ( ! termination . isPhaseTerminated ( phaseScope ) ) { 
LocalSearchStepScope < Solution_ > stepScope = new LocalSearchStepScope < > ( phaseScope ) ; 
stepScope . setTimeGradient ( termination . calculatePhaseTimeGradient ( phaseScope ) ) ; 
decider . decideNextStep ( stepScope ) ; 
if ( stepScope . getStep ( ) == null ) { 
if ( termination . isPhaseTerminated ( phaseScope ) ) { 
logIndentation , 
stepScope . getStepIndex ( ) , 
stepScope . getPhaseScope ( ) . calculateSolverTimeMillisSpentUpToNow ( ) ) ; 
} else if ( stepScope . getSelectedMoveCount ( ) == 0L ) { 
+ stepScope . getSelectedMoveCount ( ) 
doStep ( stepScope ) ; 
public SubSingleBenchmarkRunner < Solution_ > call ( ) { 
MDC . put ( NAME_MDC , subSingleBenchmarkResult . getName ( ) ) ; 
Runtime runtime = Runtime . getRuntime ( ) ; 
ProblemBenchmarkResult < Solution_ > problemBenchmarkResult = subSingleBenchmarkResult . getSingleBenchmarkResult ( ) . getProblemBenchmarkResult ( ) ; 
Solution_ problem = problemBenchmarkResult . readProblem ( ) ; 
if ( ! problemBenchmarkResult . getPlannerBenchmarkResult ( ) . hasMultipleParallelBenchmarks ( ) ) { 
runtime . gc ( ) ; 
subSingleBenchmarkResult . setUsedMemoryAfterInputSolution ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) ; 
subSingleBenchmarkResult ) ; 
SolverConfig solverConfig = subSingleBenchmarkResult . getSingleBenchmarkResult ( ) . getSolverBenchmarkResult ( ) . getSolverConfig ( ) ; 
if ( subSingleBenchmarkResult . getSingleBenchmarkResult ( ) . getSubSingleCount ( ) > 1 ) { 
solverConfig = new SolverConfig ( solverConfig ) ; 
solverConfig . offerRandomSeedFromSubSingleIndex ( ( long ) subSingleBenchmarkResult . getSubSingleBenchmarkIndex ( ) ) ; 
Solver < Solution_ > solver = solverConfig . buildSolver ( solverConfigContext ) ; 
for ( SubSingleStatistic subSingleStatistic : subSingleBenchmarkResult . getEffectiveSubSingleStatisticMap ( ) . values ( ) ) { 
subSingleStatistic . open ( solver ) ; 
subSingleStatistic . initPointList ( ) ; 
Solution_ solution = solver . solve ( problem ) ; 
long timeMillisSpent = solver . getTimeMillisSpent ( ) ; 
DefaultSolverScope < Solution_ > solverScope = ( ( DefaultSolver < Solution_ > ) solver ) . getSolverScope ( ) ; 
SolutionDescriptor < Solution_ > solutionDescriptor = solverScope . getSolutionDescriptor ( ) ; 
problemBenchmarkResult . registerScale ( solutionDescriptor . getEntityCount ( solution ) , 
solutionDescriptor . getGenuineVariableCount ( solution ) , 
solutionDescriptor . getMaximumValueCount ( solution ) , 
solutionDescriptor . getProblemScale ( solution ) ) ; 
subSingleBenchmarkResult . setScore ( solutionDescriptor . getScore ( solution ) ) ; 
subSingleBenchmarkResult . setTimeMillisSpent ( timeMillisSpent ) ; 
subSingleBenchmarkResult . setScoreCalculationCount ( solverScope . getScoreCalculationCount ( ) ) ; 
subSingleStatistic . close ( solver ) ; 
subSingleStatistic . hibernatePointList ( ) ; 
if ( ! warmUp ) { 
problemBenchmarkResult . writeSolution ( subSingleBenchmarkResult , solution ) ; 
MDC . remove ( NAME_MDC ) ; 
if ( moveIteratorFactoryClass == null ) { 
MoveIteratorFactory moveIteratorFactory = ConfigUtils . newInstance ( this , 
"moveIteratorFactoryClass" , moveIteratorFactoryClass ) ; 
ConfigUtils . applyCustomProperties ( moveIteratorFactory , "moveIteratorFactoryClass" , 
moveIteratorFactoryCustomProperties , "moveIteratorFactoryCustomProperties" ) ; 
return new MoveIteratorFactoryToMoveSelectorBridge ( moveIteratorFactory , randomSelection ) ; 
public void afterEntityAdded ( EntityDescriptor < Solution_ > entityDescriptor , Object entity ) { 
if ( ! getSolutionDescriptor ( ) . hasEntityDescriptor ( entity . getClass ( ) ) ) { 
if ( kieSession . getFactHandle ( entity ) != null ) { 
kieSession . insert ( entity ) ; 
super . afterEntityAdded ( entityDescriptor , entity ) ; 
public void afterVariableChanged ( VariableDescriptor variableDescriptor , Object entity ) { 
update ( entity , variableDescriptor . getVariableName ( ) ) ; 
super . afterVariableChanged ( variableDescriptor , entity ) ; 
public void afterEntityRemoved ( EntityDescriptor < Solution_ > entityDescriptor , Object entity ) { 
FactHandle factHandle = kieSession . getFactHandle ( entity ) ; 
if ( factHandle == null ) { 
+ getSolutionDescriptor ( ) . getEntityMemberAndEntityCollectionMemberNames ( ) + ")." ) ; 
kieSession . delete ( factHandle ) ; 
super . afterEntityRemoved ( entityDescriptor , entity ) ; 
public void afterProblemFactAdded ( Object problemFact ) { 
if ( kieSession . getFactHandle ( problemFact ) != null ) { 
+ getSolutionDescriptor ( ) . getProblemFactMemberAndProblemFactCollectionMemberNames ( ) + ").\n" 
kieSession . insert ( problemFact ) ; 
super . afterProblemFactAdded ( problemFact ) ; 
public void afterProblemPropertyChanged ( Object problemFactOrEntity ) { 
FactHandle factHandle = kieSession . getFactHandle ( problemFactOrEntity ) ; 
kieSession . update ( factHandle , problemFactOrEntity ) ; 
super . afterProblemPropertyChanged ( problemFactOrEntity ) ; 
public void afterProblemFactRemoved ( Object problemFact ) { 
FactHandle factHandle = kieSession . getFactHandle ( problemFact ) ; 
super . afterProblemFactRemoved ( problemFact ) ; 
} public static PlannerBenchmarkFactory createFromXmlResource ( String benchmarkConfigResource , ClassLoader classLoader ) { 
return new XStreamXmlPlannerBenchmarkFactory ( new SolverConfigContext ( classLoader ) ) 
. configure ( benchmarkConfigResource ) ; 
} public BenchmarkReport buildBenchmarkReport ( PlannerBenchmarkResult plannerBenchmark ) { 
BenchmarkReport benchmarkReport = new BenchmarkReport ( plannerBenchmark ) ; 
benchmarkReport . setLocale ( determineLocale ( ) ) ; 
benchmarkReport . setTimezoneId ( ZoneId . systemDefault ( ) ) ; 
supplySolverRanking ( benchmarkReport ) ; 
return benchmarkReport ; 
public ExhaustiveSearchPhase buildPhase ( int phaseIndex , HeuristicConfigPolicy solverConfigPolicy , 
phaseConfigPolicy . setReinitializeVariableFilterEnabled ( true ) ; 
phaseConfigPolicy . setInitializedChainedValueFilterEnabled ( true ) ; 
ExhaustiveSearchType exhaustiveSearchType_ = exhaustiveSearchType == null 
? ExhaustiveSearchType . BRANCH_AND_BOUND : exhaustiveSearchType ; 
phaseConfigPolicy . setEntitySorterManner ( entitySorterManner != null ? entitySorterManner 
: exhaustiveSearchType_ . getDefaultEntitySorterManner ( ) ) ; 
phaseConfigPolicy . setValueSorterManner ( valueSorterManner != null ? valueSorterManner 
: exhaustiveSearchType_ . getDefaultValueSorterManner ( ) ) ; 
DefaultExhaustiveSearchPhase phase = new DefaultExhaustiveSearchPhase ( 
boolean scoreBounderEnabled = exhaustiveSearchType_ . isScoreBounderEnabled ( ) ; 
NodeExplorationType nodeExplorationType_ ; 
if ( exhaustiveSearchType_ == ExhaustiveSearchType . BRUTE_FORCE ) { 
nodeExplorationType_ = defaultIfNull ( nodeExplorationType , NodeExplorationType . ORIGINAL_ORDER ) ; 
if ( nodeExplorationType_ != NodeExplorationType . ORIGINAL_ORDER ) { 
+ ")." ) ; 
nodeExplorationType_ = defaultIfNull ( nodeExplorationType , NodeExplorationType . DEPTH_FIRST ) ; 
phase . setNodeComparator ( nodeExplorationType_ . buildNodeComparator ( scoreBounderEnabled ) ) ; 
EntitySelectorConfig entitySelectorConfig_ = buildEntitySelectorConfig ( phaseConfigPolicy ) ; 
EntitySelector entitySelector = entitySelectorConfig_ . buildEntitySelector ( phaseConfigPolicy , 
phase . setEntitySelector ( entitySelector ) ; 
phase . setDecider ( buildDecider ( phaseConfigPolicy , entitySelector , bestSolutionRecaller , phase . getTermination ( ) , 
scoreBounderEnabled ) ) ; 
phase . setAssertWorkingSolutionScoreFromScratch ( true ) ; 
phase . setAssertExpectedWorkingSolutionScore ( true ) ; 
} public void processAnnotations ( DescriptorPolicy descriptorPolicy , ScoreDefinition scoreDefinition ) { 
processPackAnnotation ( descriptorPolicy ) ; 
ArrayList < Method > potentiallyOverwritingMethodList = new ArrayList < > ( ) ; 
for ( Class < ? > lineageClass : ConfigUtils . getAllAnnotatedLineageClasses ( constraintConfigurationClass , ConstraintConfiguration . class ) ) { 
List < Member > memberList = ConfigUtils . getDeclaredMembers ( lineageClass ) ; 
if ( member instanceof Method && potentiallyOverwritingMethodList . stream ( ) . anyMatch ( 
m -> member . getName ( ) . equals ( m . getName ( ) ) 
&& ReflectionHelper . isMethodOverwritten ( ( Method ) member , m . getDeclaringClass ( ) ) ) ) { 
processParameterAnnotation ( descriptorPolicy , member , scoreDefinition ) ; 
potentiallyOverwritingMethodList . ensureCapacity ( potentiallyOverwritingMethodList . size ( ) + memberList . size ( ) ) ; 
memberList . stream ( ) . filter ( member -> member instanceof Method ) 
. forEach ( member -> potentiallyOverwritingMethodList . add ( ( Method ) member ) ) ; 
if ( constraintWeightDescriptorMap . isEmpty ( ) ) { 
singleBenchmarkResult . accumulateResults ( benchmarkReport ) ; 
determineTotalsAndAveragesAndRanking ( ) ; 
determineWinningScoreDifference ( ) ; 
for ( ProblemStatistic problemStatistic : problemStatisticList ) { 
problemStatistic . accumulateResults ( benchmarkReport ) ; 
} public void registerScale ( long registeringEntityCount , long registeringVariableCount , 
long registeringMaximumValueCount , long registeringProblemScale ) { 
if ( entityCount == null ) { 
entityCount = registeringEntityCount ; 
} else if ( entityCount . longValue ( ) != registeringEntityCount ) { 
getName ( ) , entityCount , registeringEntityCount ) ; 
entityCount = - 1L ; 
if ( variableCount == null ) { 
variableCount = registeringVariableCount ; 
} else if ( variableCount . longValue ( ) != registeringVariableCount ) { 
getName ( ) , variableCount , registeringVariableCount ) ; 
variableCount = - 1L ; 
if ( maximumValueCount == null ) { 
maximumValueCount = registeringMaximumValueCount ; 
} else if ( maximumValueCount . longValue ( ) != registeringMaximumValueCount ) { 
getName ( ) , maximumValueCount , registeringMaximumValueCount ) ; 
maximumValueCount = - 1L ; 
if ( problemScale == null ) { 
problemScale = registeringProblemScale ; 
} else if ( problemScale . longValue ( ) != registeringProblemScale ) { 
getName ( ) , problemScale , registeringProblemScale ) ; 
problemScale = - 1L ; 
} protected static < Solution_ > Map < ProblemBenchmarkResult , ProblemBenchmarkResult > createMergeMap ( 
Map < ProblemBenchmarkResult , ProblemBenchmarkResult > mergeMap 
Map < ProblemProvider < Solution_ > , ProblemBenchmarkResult > problemProviderToNewResultMap = new HashMap < > ( ) ; 
ProblemBenchmarkResult < Solution_ > oldResult = singleBenchmarkResult . getProblemBenchmarkResult ( ) ; 
ProblemBenchmarkResult < Solution_ > newResult ; 
if ( ! problemProviderToNewResultMap . containsKey ( oldResult . problemProvider ) ) { 
newResult = new ProblemBenchmarkResult < > ( newPlannerBenchmarkResult ) ; 
newResult . problemProvider = oldResult . problemProvider ; 
newResult . problemStatisticList = new ArrayList < > ( oldResult . problemStatisticList . size ( ) ) ; 
for ( ProblemStatistic oldProblemStatistic : oldResult . problemStatisticList ) { 
newResult . problemStatisticList . add ( 
oldProblemStatistic . getProblemStatisticType ( ) . buildProblemStatistic ( newResult ) ) ; 
newResult . entityCount = oldResult . entityCount ; 
newResult . variableCount = oldResult . variableCount ; 
newResult . maximumValueCount = oldResult . maximumValueCount ; 
newResult . problemScale = oldResult . problemScale ; 
problemProviderToNewResultMap . put ( oldResult . problemProvider , newResult ) ; 
newPlannerBenchmarkResult . getUnifiedProblemBenchmarkResultList ( ) . add ( newResult ) ; 
newResult = problemProviderToNewResultMap . get ( oldResult . problemProvider ) ; 
if ( ! Objects . equals ( oldResult . name , newResult . name ) ) { 
+ oldResult . problemProvider + ")." ) ; 
newResult . problemStatisticList . removeIf ( 
newStatistic -> ! oldResult . hasProblemStatisticType ( newStatistic . getProblemStatisticType ( ) ) ) ; 
newResult . entityCount = ConfigUtils . meldProperty ( oldResult . entityCount , newResult . entityCount ) ; 
newResult . variableCount = ConfigUtils . meldProperty ( oldResult . variableCount , newResult . variableCount ) ; 
newResult . maximumValueCount = ConfigUtils . meldProperty ( oldResult . maximumValueCount , newResult . maximumValueCount ) ; 
newResult . problemScale = ConfigUtils . meldProperty ( oldResult . problemScale , newResult . problemScale ) ; 
} public static CountableValueRange < Integer > createIntValueRange ( int from , int to , int incrementUnit ) { 
return new IntValueRange ( from , to , incrementUnit ) ; 
} public static CountableValueRange < Long > createLongValueRange ( long from , long to , long incrementUnit ) { 
return new LongValueRange ( from , to , incrementUnit ) ; 
} public static CountableValueRange < BigInteger > createBigIntegerValueRange ( BigInteger from , BigInteger to ) { 
return new BigIntegerValueRange ( from , to ) ; 
} public static CountableValueRange < BigDecimal > createBigDecimalValueRange ( BigDecimal from , BigDecimal to ) { 
return new BigDecimalValueRange ( from , to ) ; 
} public static CountableValueRange < LocalDate > createLocalDateValueRange ( 
LocalDate from , LocalDate to , long incrementUnitAmount , TemporalUnit incrementUnitType ) { 
return createTemporalValueRange ( from , to , incrementUnitAmount , incrementUnitType ) ; 
} public static CountableValueRange < LocalTime > createLocalTimeValueRange ( 
LocalTime from , LocalTime to , long incrementUnitAmount , TemporalUnit incrementUnitType ) { 
} public static CountableValueRange < LocalDateTime > createLocalDateTimeValueRange ( 
LocalDateTime from , LocalDateTime to , long incrementUnitAmount , TemporalUnit incrementUnitType ) { 
} public static < Temporal_ extends Temporal & Comparable < ? super Temporal_ > > CountableValueRange < Temporal_ > createTemporalValueRange ( 
Temporal_ from , Temporal_ to , long incrementUnitAmount , TemporalUnit incrementUnitType ) { 
return new TemporalValueRange < > ( from , to , incrementUnitAmount , incrementUnitType ) ; 
CustomPhaseScope < Solution_ > phaseScope = new CustomPhaseScope < > ( solverScope ) ; 
CustomStepScope < Solution_ > stepScope = new CustomStepScope < > ( phaseScope ) ; 
for ( CustomPhaseCommand < Solution_ > customPhaseCommand : customPhaseCommandList ) { 
solverScope . checkYielding ( ) ; 
doStep ( stepScope , customPhaseCommand ) ; 
stepScope = new CustomStepScope < > ( phaseScope ) ; 
DrawingSupplier drawingSupplier = new DefaultDrawingSupplier ( ) ; 
XYSeries acceptedSeries = new XYSeries ( 
XYSeries selectedSeries = new XYSeries ( 
XYItemRenderer renderer = new XYLineAndShapeRenderer ( true , false ) ; 
MoveCountPerStepSubSingleStatistic subSingleStatistic = ( MoveCountPerStepSubSingleStatistic ) 
List < MoveCountPerStepStatisticPoint > list = subSingleStatistic . getPointList ( ) ; 
for ( MoveCountPerStepStatisticPoint point : list ) { 
long acceptedMoveCount = point . getMoveCountPerStepMeasurement ( ) . getAcceptedMoveCount ( ) ; 
long selectedMoveCount = point . getMoveCountPerStepMeasurement ( ) . getSelectedMoveCount ( ) ; 
acceptedSeries . add ( timeMillisSpent , acceptedMoveCount ) ; 
selectedSeries . add ( timeMillisSpent , selectedMoveCount ) ; 
seriesCollection . addSeries ( acceptedSeries ) ; 
seriesCollection . addSeries ( selectedSeries ) ; 
renderer . setSeriesStroke ( 1 , new BasicStroke ( 
2.0f , BasicStroke . CAP_ROUND , BasicStroke . JOIN_ROUND , 1.0f , new float [ ] { 2.0f , 6.0f } , 0.0f ) ) ; 
1.0f , BasicStroke . CAP_ROUND , BasicStroke . JOIN_ROUND , 1.0f , new float [ ] { 2.0f , 6.0f } , 0.0f ) ) ; 
Paint linePaint = drawingSupplier . getNextPaint ( ) ; 
renderer . setSeriesPaint ( 0 , linePaint ) ; 
renderer . setSeriesPaint ( 1 , linePaint ) ; 
graphFile = writeChartToImageFile ( chart , problemBenchmarkResult . getName ( ) + "MoveCountPerStepStatistic" ) ; 
public boolean mightContainEntity ( ) { 
SolutionDescriptor < Solution_ > solutionDescriptor 
= variableDescriptor . getEntityDescriptor ( ) . getSolutionDescriptor ( ) ; 
Class < ? > variablePropertyType = variableDescriptor . getVariablePropertyType ( ) ; 
for ( Class < ? > entityClass : solutionDescriptor . getEntityClassSet ( ) ) { 
if ( variablePropertyType . isAssignableFrom ( entityClass ) ) { 
public int compareTo ( MrServiceMovedProcessesCount other ) { 
. append ( service , other . service ) 
. append ( movedProcessesCount , other . movedProcessesCount ) 
} protected static < E > List < E > rebaseList ( List < E > externalObjectList , ScoreDirector < ? > destinationScoreDirector ) { 
List < E > rebasedObjectList = new ArrayList < > ( externalObjectList . size ( ) ) ; 
for ( E entity : externalObjectList ) { 
rebasedObjectList . add ( destinationScoreDirector . lookUpWorkingObject ( entity ) ) ; 
return rebasedObjectList ; 
PartitionedSearchPhaseScope < Solution_ > phaseScope = new PartitionedSearchPhaseScope < > ( solverScope ) ; 
List < Solution_ > partList = solutionPartitioner . splitWorkingSolution ( 
solverScope . getScoreDirector ( ) , runnablePartThreadLimit ) ; 
int partCount = partList . size ( ) ; 
phaseScope . setPartCount ( partCount ) ; 
ExecutorService executor = createThreadPoolExecutor ( partCount ) ; 
ChildThreadPlumbingTermination childThreadPlumbingTermination = new ChildThreadPlumbingTermination ( ) ; 
PartitionQueue < Solution_ > partitionQueue = new PartitionQueue < > ( partCount ) ; 
Semaphore runnablePartThreadSemaphore 
= runnablePartThreadLimit == null ? null : new Semaphore ( runnablePartThreadLimit , true ) ; 
for ( ListIterator < Solution_ > it = partList . listIterator ( ) ; it . hasNext ( ) ; ) { 
int partIndex = it . nextIndex ( ) ; 
Solution_ part = it . next ( ) ; 
PartitionSolver < Solution_ > partitionSolver = buildPartitionSolver ( 
childThreadPlumbingTermination , runnablePartThreadSemaphore , solverScope ) ; 
partitionSolver . addEventListener ( event -> { 
InnerScoreDirector < Solution_ > childScoreDirector = partitionSolver . solverScope . getScoreDirector ( ) ; 
PartitionChangeMove < Solution_ > move = PartitionChangeMove . createMove ( childScoreDirector , partIndex ) ; 
InnerScoreDirector < Solution_ > parentScoreDirector = solverScope . getScoreDirector ( ) ; 
move = move . rebase ( parentScoreDirector ) ; 
partitionQueue . addMove ( partIndex , move ) ; 
executor . submit ( ( ) -> { 
partitionSolver . solve ( part ) ; 
long partCalculationCount = partitionSolver . getScoreCalculationCount ( ) ; 
partitionQueue . addFinish ( partIndex , partCalculationCount ) ; 
logIndentation , partIndex , throwable ) ; 
partitionQueue . addExceptionThrown ( partIndex , throwable ) ; 
for ( PartitionChangeMove < Solution_ > step : partitionQueue ) { 
PartitionedSearchStepScope < Solution_ > stepScope = new PartitionedSearchStepScope < > ( phaseScope ) ; 
stepScope . setStep ( step ) ; 
stepScope . setStepString ( step . toString ( ) ) ; 
phaseScope . addChildThreadsScoreCalculationCount ( partitionQueue . getPartsCalculationCount ( ) ) ; 
childThreadPlumbingTermination . terminateChildren ( ) ; 
} public void checkYielding ( ) { 
if ( runnableThreadSemaphore != null ) { 
runnableThreadSemaphore . release ( ) ; 
runnableThreadSemaphore . acquire ( ) ; 
PillarSelectorConfig pillarSelectorConfig_ = pillarSelectorConfig == null ? new PillarSelectorConfig ( ) 
: pillarSelectorConfig ; 
List < String > variableNameIncludeList = valueSelectorConfig == null ? null 
: valueSelectorConfig . getVariableName ( ) == null ? null 
: Collections . singletonList ( valueSelectorConfig . getVariableName ( ) ) ; 
PillarSelector pillarSelector = pillarSelectorConfig_ . buildPillarSelector ( configPolicy , 
minimumCacheType , SelectionOrder . fromRandomSelectionBoolean ( randomSelection ) , variableNameIncludeList ) ; 
pillarSelector . getEntityDescriptor ( ) , 
return new PillarChangeMoveSelector ( pillarSelector , valueSelector , randomSelection ) ; 
} public boolean isInitialized ( Object entity ) { 
if ( nullable ) { 
Object variable = getValue ( entity ) ; 
return variable != null ; 
} public boolean overlaps ( Flight other ) { 
return departureUTCDateTime . compareTo ( other . arrivalUTCDateTime ) < 0 
&& other . departureUTCDateTime . compareTo ( arrivalUTCDateTime ) < 0 ; 
cachedEntityMap = new TreeMap < > ( ) ; 
ScoreDirector scoreDirector = solverScope . getScoreDirector ( ) ; 
double probabilityWeightOffset = 0L ; 
for ( Object entity : childEntitySelector ) { 
double probabilityWeight = probabilityWeightFactory . createProbabilityWeight ( 
scoreDirector , entity ) ; 
cachedEntityMap . put ( probabilityWeightOffset , entity ) ; 
probabilityWeightOffset += probabilityWeight ; 
probabilityWeightTotal = probabilityWeightOffset ; 
} public void defineColumnHeaderByKey ( HeaderColumnKey xObject ) { 
int x = layout . addColumn ( ) ; 
xMap . put ( xObject , x ) ; 
} public void addCornerHeader ( HeaderColumnKey xObject , HeaderRowKey yObject , JComponent component ) { 
int x = xMap . get ( xObject ) ; 
int y = yMap . get ( yObject ) ; 
add ( component , new TimeTableLayoutConstraints ( x , y , true ) ) ; 
} public int getMissingSkillCount ( ) { 
if ( employee == null ) { 
for ( Skill skill : taskType . getRequiredSkillList ( ) ) { 
if ( ! employee . getSkillSet ( ) . contains ( skill ) ) { 
ConstructionHeuristicPhaseScope < Solution_ > phaseScope = new ConstructionHeuristicPhaseScope < > ( solverScope ) ; 
for ( Placement placement : entityPlacer ) { 
ConstructionHeuristicStepScope < Solution_ > stepScope = new ConstructionHeuristicStepScope < > ( phaseScope ) ; 
decider . decideNextStep ( stepScope , placement ) ; 
public CustomPhase buildPhase ( int phaseIndex , HeuristicConfigPolicy solverConfigPolicy , 
DefaultCustomPhase phase = new DefaultCustomPhase ( 
if ( ConfigUtils . isEmptyCollection ( customPhaseCommandClassList ) ) { 
List < CustomPhaseCommand > customPhaseCommandList = new ArrayList < > ( customPhaseCommandClassList . size ( ) ) ; 
for ( Class < ? extends CustomPhaseCommand > customPhaseCommandClass : customPhaseCommandClassList ) { 
CustomPhaseCommand customPhaseCommand = ConfigUtils . newInstance ( this , 
"customPhaseCommandClass" , customPhaseCommandClass ) ; 
ConfigUtils . applyCustomProperties ( customPhaseCommand , "customPhaseCommandClass" , 
customProperties , "customProperties" ) ; 
customPhaseCommandList . add ( customPhaseCommand ) ; 
phase . setCustomPhaseCommandList ( customPhaseCommandList ) ; 
phase . setForceUpdateBestSolution ( forceUpdateBestSolution == null ? false : forceUpdateBestSolution ) ; 
public void configureConstraintWeight ( Rule rule , HardSoftScore constraintWeight ) { 
if ( constraintWeight . equals ( HardSoftScore . ZERO ) ) { 
} else if ( constraintWeight . getSoftScore ( ) == 0 ) { 
-> addHardConstraintMatch ( kcontext , constraintWeight . getHardScore ( ) * matchWeight ) ; 
} else if ( constraintWeight . getHardScore ( ) == 0 ) { 
-> addSoftConstraintMatch ( kcontext , constraintWeight . getSoftScore ( ) * matchWeight ) ; 
constraintWeight . getHardScore ( ) * matchWeight , 
constraintWeight . getSoftScore ( ) * matchWeight ) ; 
HardSoftScore weightMultiplier ) -> addMultiConstraintMatch ( kcontext , 
constraintWeight . getHardScore ( ) * weightMultiplier . getHardScore ( ) , 
constraintWeight . getSoftScore ( ) * weightMultiplier . getSoftScore ( ) ) ) ; 
} public LookUpStrategy determineLookUpStrategy ( Object object ) { 
Class < ? > objectClass = object . getClass ( ) ; 
return decisionCache . computeIfAbsent ( objectClass , key -> { 
if ( object . getClass ( ) . isEnum ( ) ) { 
return new ImmutableLookUpStrategy ( ) ; 
switch ( lookUpStrategyType ) { 
case PLANNING_ID_OR_NONE : 
MemberAccessor memberAccessor1 = ConfigUtils . findPlanningIdMemberAccessor ( objectClass ) ; 
if ( memberAccessor1 == null ) { 
return new NoneLookUpStrategy ( ) ; 
return new PlanningIdLookUpStrategy ( memberAccessor1 ) ; 
case PLANNING_ID_OR_FAIL_FAST : 
MemberAccessor memberAccessor2 = ConfigUtils . findPlanningIdMemberAccessor ( objectClass ) ; 
if ( memberAccessor2 == null ) { 
+ LookUpStrategyType . class . getSimpleName ( ) + "." ) ; 
return new PlanningIdLookUpStrategy ( memberAccessor2 ) ; 
case EQUALITY : 
Method equalsMethod ; 
Method hashCodeMethod ; 
equalsMethod = object . getClass ( ) . getMethod ( "equals" , Object . class ) ; 
hashCodeMethod = object . getClass ( ) . getMethod ( "hashCode" ) ; 
if ( equalsMethod . getDeclaringClass ( ) . equals ( Object . class ) ) { 
if ( hashCodeMethod . getDeclaringClass ( ) . equals ( Object . class ) ) { 
return new EqualsLookUpStrategy ( ) ; 
public void phaseStarted ( AbstractPhaseScope phaseScope ) { 
super . phaseStarted ( phaseScope ) ; 
InnerScoreDirector scoreDirector = phaseScope . getScoreDirector ( ) ; 
cachedEntityList = entityDescriptor . extractEntities ( scoreDirector . getWorkingSolution ( ) ) ; 
cachedEntityListRevision = scoreDirector . getWorkingEntityListRevision ( ) ; 
cachedEntityListIsDirty = false ; 
this . workingSolution = workingSolution ; 
SolutionDescriptor < Solution_ > solutionDescriptor = getSolutionDescriptor ( ) ; 
workingInitScore = - solutionDescriptor . countUninitializedVariables ( workingSolution ) ; 
if ( lookUpEnabled ) { 
lookUpManager . resetWorkingObjects ( solutionDescriptor . getAllFacts ( workingSolution ) ) ; 
variableListenerSupport . resetWorkingSolution ( ) ; 
setWorkingEntityListDirty ( ) ; 
public final void beforeEntityAdded ( Object entity ) { 
beforeEntityAdded ( getSolutionDescriptor ( ) . findEntityDescriptorOrFail ( entity . getClass ( ) ) , entity ) ; 
public void assertExpectedWorkingScore ( Score expectedWorkingScore , Object completedAction ) { 
Score workingScore = calculateScore ( ) ; 
if ( ! expectedWorkingScore . equals ( workingScore ) ) { 
SubChainSelector leftSubChainSelector = subChainSelectorConfig_ . buildSubChainSelector ( configPolicy , 
SubChainSelectorConfig rightSubChainSelectorConfig = defaultIfNull ( secondarySubChainSelectorConfig , 
subChainSelectorConfig_ ) ; 
SubChainSelector rightSubChainSelector = rightSubChainSelectorConfig . buildSubChainSelector ( configPolicy , 
return new SubChainSwapMoveSelector ( leftSubChainSelector , rightSubChainSelector , randomSelection , 
defaultIfNull ( selectReversingMoveToo , true ) ) ; 
public boolean isCountable ( ) { 
if ( ! entitySelector . isCountable ( ) ) { 
for ( ValueSelector valueSelector : valueSelectors ) { 
if ( ! valueSelector . isCountable ( ) ) { 
public void phaseStarted ( LocalSearchPhaseScope phaseScope ) { 
thresholdScore = phaseScope . getBestScore ( ) ; 
return super . isMoveDoable ( scoreDirector ) 
&& ! Objects . equals ( entity , toPlanningValue ) ; 
} protected void validateCacheTypeVersusSelectionOrder ( 
SelectionCacheType resolvedCacheType , SelectionOrder resolvedSelectionOrder ) { 
switch ( resolvedSelectionOrder ) { 
case INHERIT : 
case ORIGINAL : 
case RANDOM : 
case SORTED : 
case SHUFFLED : 
case PROBABILISTIC : 
if ( resolvedCacheType . isNotCached ( ) ) { 
if ( entitySelectorConfig == null ) { 
EntitySelector entitySelector = entitySelectorConfig . buildEntitySelector ( configPolicy , 
if ( valueSelectorConfig == null ) { 
ValueSelector valueSelector = valueSelectorConfig . buildValueSelector ( configPolicy , 
return new ChangeMoveSelector ( entitySelector , valueSelector , randomSelection ) ; 
if ( Objects . equals ( leftValue , rightValue ) 
|| Objects . equals ( leftEntity , rightValue ) || Objects . equals ( rightEntity , leftValue ) ) { 
if ( rightEntity == null ) { 
if ( leftAnchor == rightAnchor ) { 
if ( rightEntity != null ) { 
ValueRange rightValueRange = valueRangeDescriptor . extractValueRange ( workingSolution , rightEntity ) ; 
if ( ! rightValueRange . contains ( leftValue ) ) { 
ValueRange leftValueRange = valueRangeDescriptor . extractValueRange ( workingSolution , leftEntity ) ; 
if ( ! leftValueRange . contains ( rightValue ) ) { 
InnerScoreDirector scoreDirector = solverScope . getScoreDirector ( ) ; 
GenuineVariableDescriptor variableDescriptor = valueSelector . getVariableDescriptor ( ) ; 
long valueSize = valueSelector . getSize ( ) ; 
if ( valueSize > ( long ) Integer . MAX_VALUE ) { 
List < Object > anchorList = new ArrayList < > ( ) ; 
for ( Object value : valueSelector ) { 
if ( variableDescriptor . isValuePotentialAnchor ( value ) ) { 
anchorList . add ( value ) ; 
int anchorListSize = Math . max ( anchorList . size ( ) , 1 ) ; 
anchorTrailingChainList = new ArrayList < > ( anchorListSize ) ; 
int anchorChainInitialCapacity = ( ( int ) valueSize / anchorListSize ) + 1 ; 
for ( Object anchor : anchorList ) { 
List < Object > anchorChain = new ArrayList < > ( anchorChainInitialCapacity ) ; 
Object trailingEntity = inverseVariableSupply . getInverseSingleton ( anchor ) ; 
while ( trailingEntity != null ) { 
anchorChain . add ( trailingEntity ) ; 
trailingEntity = inverseVariableSupply . getInverseSingleton ( trailingEntity ) ; 
if ( anchorChain . size ( ) >= minimumSubChainSize ) { 
anchorTrailingChainList . add ( new SubChain ( anchorChain ) ) ; 
for ( double startingTemperatureLevel : ScoreUtils . extractLevelDoubles ( startingTemperature ) ) { 
if ( startingTemperatureLevel < 0.0 ) { 
startingTemperatureLevels = ScoreUtils . extractLevelDoubles ( startingTemperature ) ; 
temperatureLevels = startingTemperatureLevels ; 
levelsLength = startingTemperatureLevels . length ; 
cachedValueRange = ( ValueRange < Object > ) 
valueRangeDescriptor . extractValueRange ( scoreDirector . getWorkingSolution ( ) ) ; 
if ( valueRangeMightContainEntity ) { 
} public static double [ ] determineStandardDeviationDoubles ( 
List < ? extends BenchmarkResult > benchmarkResultList , Score averageScore , int successCount ) { 
if ( successCount <= 0 ) { 
if ( averageScore == null ) { 
double [ ] differenceSquaredTotalDoubles = null ; 
for ( BenchmarkResult benchmarkResult : benchmarkResultList ) { 
if ( benchmarkResult . hasAllSuccess ( ) ) { 
Score difference = benchmarkResult . getAverageScore ( ) . subtract ( averageScore ) ; 
double [ ] differenceDoubles = ScoreUtils . extractLevelDoubles ( difference ) ; 
if ( differenceSquaredTotalDoubles == null ) { 
differenceSquaredTotalDoubles = new double [ differenceDoubles . length ] ; 
for ( int i = 0 ; i < differenceDoubles . length ; i ++ ) { 
differenceSquaredTotalDoubles [ i ] += Math . pow ( differenceDoubles [ i ] , 2.0 ) ; 
double [ ] standardDeviationDoubles = new double [ differenceSquaredTotalDoubles . length ] ; 
for ( int i = 0 ; i < differenceSquaredTotalDoubles . length ; i ++ ) { 
standardDeviationDoubles [ i ] = Math . pow ( differenceSquaredTotalDoubles [ i ] / successCount , 0.5 ) ; 
return standardDeviationDoubles ; 
} public static String getStandardDeviationString ( double [ ] standardDeviationDoubles ) { 
if ( standardDeviationDoubles == null ) { 
StringBuilder standardDeviationString = new StringBuilder ( standardDeviationDoubles . length * 9 ) ; 
DecimalFormatSymbols decimalFormatSymbols = new DecimalFormatSymbols ( Locale . US ) ; 
DecimalFormat exponentialFormat = new DecimalFormat ( "0.0#E0" , decimalFormatSymbols ) ; 
DecimalFormat decimalFormat = new DecimalFormat ( "0.0#" , decimalFormatSymbols ) ; 
for ( double standardDeviationDouble : standardDeviationDoubles ) { 
standardDeviationString . append ( "/" ) ; 
String abbreviated ; 
if ( 0.001 <= standardDeviationDouble && standardDeviationDouble <= 10000000.0 ) { 
abbreviated = decimalFormat . format ( standardDeviationDouble ) ; 
abbreviated = exponentialFormat . format ( standardDeviationDouble ) ; 
standardDeviationString . append ( abbreviated ) ; 
return standardDeviationString . toString ( ) ; 
public EasyScoreDirector < Solution_ > buildScoreDirector ( 
return new EasyScoreDirector < > ( this , lookUpEnabled , constraintMatchEnabledPreference , easyScoreCalculator ) ; 
private List < MrServiceDependency > getServiceDependencyList ( ) { 
List < MrServiceDependency > serviceDependencyList = new ArrayList < > ( serviceList . size ( ) * 5 ) ; 
for ( MrService service : serviceList ) { 
for ( MrService toService : service . getToDependencyServiceList ( ) ) { 
MrServiceDependency serviceDependency = new MrServiceDependency ( ) ; 
serviceDependency . setFromService ( service ) ; 
serviceDependency . setToService ( toService ) ; 
serviceDependencyList . add ( serviceDependency ) ; 
return serviceDependencyList ; 
} public Termination buildTermination ( HeuristicConfigPolicy configPolicy , Termination chainedTermination ) { 
Termination termination = buildTermination ( configPolicy ) ; 
if ( termination == null ) { 
return chainedTermination ; 
return new OrCompositeTermination ( chainedTermination , termination ) ; 
} public boolean solutionEquals ( Object o ) { 
if ( this == o ) { 
} else if ( o instanceof Match ) { 
Match other = ( Match ) o ; 
return new EqualsBuilder ( ) 
. append ( homeTeam , other . homeTeam ) 
. append ( awayTeam , other . awayTeam ) 
. append ( day , other . day ) 
. isEquals ( ) ; 
} public int solutionHashCode ( ) { 
return new HashCodeBuilder ( ) 
. append ( id ) 
. append ( homeTeam ) 
. append ( awayTeam ) 
. append ( day ) 
. toHashCode ( ) ; 
public QueuedEntityPlacer buildEntityPlacer ( HeuristicConfigPolicy configPolicy ) { 
EntitySelectorConfig entitySelectorConfig_ = buildEntitySelectorConfig ( configPolicy ) ; 
List < MoveSelectorConfig > moveSelectorConfigList_ ; 
EntityDescriptor entityDescriptor = entitySelector . getEntityDescriptor ( ) ; 
Collection < GenuineVariableDescriptor > variableDescriptors = entityDescriptor . getGenuineVariableDescriptors ( ) ; 
List < MoveSelectorConfig > subMoveSelectorConfigList = new ArrayList < > ( 
variableDescriptors . size ( ) ) ; 
subMoveSelectorConfigList . add ( buildChangeMoveSelectorConfig ( 
configPolicy , entitySelectorConfig_ . getId ( ) , variableDescriptor ) ) ; 
MoveSelectorConfig subMoveSelectorConfig ; 
if ( subMoveSelectorConfigList . size ( ) > 1 ) { 
subMoveSelectorConfig = new CartesianProductMoveSelectorConfig ( subMoveSelectorConfigList ) ; 
subMoveSelectorConfig = subMoveSelectorConfigList . get ( 0 ) ; 
moveSelectorConfigList_ = Collections . singletonList ( subMoveSelectorConfig ) ; 
moveSelectorConfigList_ = moveSelectorConfigList ; 
List < MoveSelector > moveSelectorList = new ArrayList < > ( moveSelectorConfigList_ . size ( ) ) ; 
for ( MoveSelectorConfig moveSelectorConfig : moveSelectorConfigList_ ) { 
moveSelectorList . add ( moveSelectorConfig . buildMoveSelector ( 
configPolicy , SelectionCacheType . JUST_IN_TIME , SelectionOrder . ORIGINAL ) ) ; 
return new QueuedEntityPlacer ( entitySelector , moveSelectorList ) ; 
} public String getRelativePathToBenchmarkReportDirectory ( File file ) { 
String benchmarkReportDirectoryPath = plannerBenchmarkResult . getBenchmarkReportDirectory ( ) . getAbsoluteFile ( ) . toURI ( ) . getPath ( ) ; 
String filePath = file . getAbsoluteFile ( ) . toURI ( ) . getPath ( ) ; 
if ( ! filePath . startsWith ( benchmarkReportDirectoryPath ) ) { 
String relativePath = filePath . substring ( benchmarkReportDirectoryPath . length ( ) ) ; 
if ( relativePath . startsWith ( "/" ) ) { 
relativePath = relativePath . substring ( 1 ) ; 
return relativePath ; 
} public void writeReport ( ) { 
summaryDirectory = new File ( plannerBenchmarkResult . getBenchmarkReportDirectory ( ) , "summary" ) ; 
summaryDirectory . mkdir ( ) ; 
plannerBenchmarkResult . accumulateResults ( this ) ; 
fillWarningList ( ) ; 
writeBestScoreSummaryChart ( ) ; 
writeBestScoreScalabilitySummaryChart ( ) ; 
writeWinningScoreDifferenceSummaryChart ( ) ; 
writeWorstScoreDifferencePercentageSummaryChart ( ) ; 
writeBestScoreDistributionSummaryChart ( ) ; 
writeScoreCalculationSpeedSummaryChart ( ) ; 
writeWorstScoreCalculationSpeedDifferencePercentageSummaryChart ( ) ; 
writeTimeSpentSummaryChart ( ) ; 
writeTimeSpentScalabilitySummaryChart ( ) ; 
writeBestScorePerTimeSpentSummaryChart ( ) ; 
for ( ProblemBenchmarkResult < Object > problemBenchmarkResult : plannerBenchmarkResult . getUnifiedProblemBenchmarkResultList ( ) ) { 
for ( SubSingleBenchmarkResult subSingleBenchmarkResult : singleBenchmarkResult . getSubSingleBenchmarkResultList ( ) ) { 
if ( ! subSingleBenchmarkResult . hasAllSuccess ( ) ) { 
subSingleStatistic . unhibernatePointList ( ) ; 
if ( ! plannerBenchmarkResult . getAggregation ( ) ) { 
if ( problemBenchmarkResult . hasAnySuccess ( ) ) { 
for ( ProblemStatistic problemStatistic : problemBenchmarkResult . getProblemStatisticList ( ) ) { 
problemStatistic . writeGraphFiles ( this ) ; 
for ( PureSubSingleStatistic pureSubSingleStatistic : singleBenchmarkResult . getMedian ( ) . getPureSubSingleStatisticList ( ) ) { 
pureSubSingleStatistic . writeGraphFiles ( this ) ; 
if ( plannerBenchmarkResult . getAggregation ( ) ) { 
subSingleStatistic . setPointList ( null ) ; 
determineDefaultShownScoreLevelIndex ( ) ; 
writeHtmlOverviewFile ( ) ; 
} private CategoryPlot createBarChartPlot ( DefaultCategoryDataset dataset , 
String yAxisLabel , NumberFormat yAxisNumberFormat ) { 
CategoryAxis xAxis = new CategoryAxis ( "Data" ) ; 
xAxis . setCategoryMargin ( 0.40 ) ; 
NumberAxis yAxis = new NumberAxis ( yAxisLabel ) ; 
yAxis . setNumberFormatOverride ( yAxisNumberFormat ) ; 
BarRenderer renderer = createBarChartRenderer ( yAxisNumberFormat ) ; 
CategoryPlot plot = new CategoryPlot ( dataset , xAxis , yAxis , renderer ) ; 
return plot ; 
public ChainedSwapMove < Solution_ > createUndoMove ( ScoreDirector < Solution_ > scoreDirector ) { 
return new ChainedSwapMove < > ( variableDescriptorList , rightEntity , leftEntity , oldLeftTrailingEntityList , oldRightTrailingEntityList ) ; 
double timeGradient = 0.0 ; 
double nextTimeGradient = termination . calculateSolverTimeGradient ( solverScope ) ; 
if ( nextTimeGradient >= 0.0 ) { 
timeGradient = Math . max ( timeGradient , nextTimeGradient ) ; 
return timeGradient ; 
public double calculatePhaseTimeGradient ( AbstractPhaseScope phaseScope ) { 
double nextTimeGradient = termination . calculatePhaseTimeGradient ( phaseScope ) ; 
public OrCompositeTermination createChildThreadTermination ( 
return new OrCompositeTermination ( createChildThreadTerminationList ( solverScope , childThreadType ) ) ; 
public void configureConstraintWeight ( Rule rule , HardMediumSoftScore constraintWeight ) { 
if ( constraintWeight . equals ( HardMediumSoftScore . ZERO ) ) { 
matchExecutor = ( RuleContext kcontext , Integer weightMultiplier ) -> { } ; 
} else if ( constraintWeight . getMediumScore ( ) == 0 && constraintWeight . getSoftScore ( ) == 0 ) { 
matchExecutor = ( RuleContext kcontext , Integer weightMultiplier ) 
-> addHardConstraintMatch ( kcontext , constraintWeight . getHardScore ( ) * weightMultiplier ) ; 
} else if ( constraintWeight . getHardScore ( ) == 0 && constraintWeight . getSoftScore ( ) == 0 ) { 
-> addMediumConstraintMatch ( kcontext , constraintWeight . getMediumScore ( ) * weightMultiplier ) ; 
} else if ( constraintWeight . getHardScore ( ) == 0 && constraintWeight . getMediumScore ( ) == 0 ) { 
-> addSoftConstraintMatch ( kcontext , constraintWeight . getSoftScore ( ) * weightMultiplier ) ; 
constraintWeight . getHardScore ( ) * weightMultiplier , 
constraintWeight . getMediumScore ( ) * weightMultiplier , 
constraintWeight . getSoftScore ( ) * weightMultiplier ) ; 
HardMediumSoftScore weightMultiplier ) -> addMultiConstraintMatch ( kcontext , 
constraintWeight . getMediumScore ( ) * weightMultiplier . getMediumScore ( ) , 
} public void penalize ( RuleContext kcontext , int hardWeightMultiplier , int mediumWeightMultiplier , int softWeightMultiplier ) { 
reward ( kcontext , - hardWeightMultiplier , - mediumWeightMultiplier , - softWeightMultiplier ) ; 
} @ ValueRangeProvider ( id = "startPeriodRange" ) 
public CountableValueRange < Integer > getStartPeriodRange ( ) { 
return ValueRangeFactory . createIntValueRange ( task . getStartPeriodRangeFrom ( ) , task . getStartPeriodRangeTo ( ) ) ; 
public void resetWorkingSolution ( CheapTimeSolution solution ) { 
this . cheapTimeSolution = solution ; 
mediumScore = 0L ; 
if ( solution . getGlobalPeriodRangeFrom ( ) != 0 ) { 
resourceListSize = solution . getResourceList ( ) . size ( ) ; 
globalPeriodRangeTo = solution . getGlobalPeriodRangeTo ( ) ; 
List < Machine > machineList = solution . getMachineList ( ) ; 
List < PeriodPowerPrice > periodPowerPriceList = solution . getPeriodPowerPriceList ( ) ; 
machineToMachinePeriodListMap = new MachinePeriodPart [ machineList . size ( ) ] [ ] ; 
for ( Machine machine : machineList ) { 
MachinePeriodPart [ ] machinePeriodList = new MachinePeriodPart [ globalPeriodRangeTo ] ; 
for ( int period = 0 ; period < globalPeriodRangeTo ; period ++ ) { 
machinePeriodList [ period ] = new MachinePeriodPart ( machine , periodPowerPriceList . get ( period ) ) ; 
machineToMachinePeriodListMap [ machine . getIndex ( ) ] = machinePeriodList ; 
unassignedMachinePeriodList = new MachinePeriodPart [ globalPeriodRangeTo ] ; 
unassignedMachinePeriodList [ period ] = new MachinePeriodPart ( null , periodPowerPriceList . get ( period ) ) ; 
for ( TaskAssignment taskAssignment : solution . getTaskAssignmentList ( ) ) { 
modifyStartPeriod ( taskAssignment , null , taskAssignment . getStartPeriod ( ) ) ; 
} private void modifyMachine ( TaskAssignment taskAssignment , Machine oldMachine , Machine newMachine ) { 
if ( Objects . equals ( oldMachine , newMachine ) ) { 
Integer startPeriod = taskAssignment . getStartPeriod ( ) ; 
if ( startPeriod == null ) { 
Integer endPeriod = taskAssignment . getEndPeriod ( ) ; 
if ( oldMachine != null ) { 
MachinePeriodPart [ ] machinePeriodList = machineToMachinePeriodListMap [ oldMachine . getIndex ( ) ] ; 
retractRange ( taskAssignment , machinePeriodList , startPeriod , endPeriod , false ) ; 
if ( newMachine != null ) { 
MachinePeriodPart [ ] machinePeriodList = machineToMachinePeriodListMap [ newMachine . getIndex ( ) ] ; 
insertRange ( taskAssignment , machinePeriodList , startPeriod , endPeriod , false ) ; 
LocalSearchStepScope lastCompletedStepScope = phaseScope . getLastCompletedStepScope ( ) ; 
workingTabuSize = tabuSizeStrategy == null ? 0 : tabuSizeStrategy . determineTabuSize ( lastCompletedStepScope ) ; 
workingFadingTabuSize = fadingTabuSizeStrategy == null ? 0 : fadingTabuSizeStrategy . determineTabuSize ( lastCompletedStepScope ) ; 
int totalTabuListSize = workingTabuSize + workingFadingTabuSize ; 
tabuToStepIndexMap = new HashMap < > ( totalTabuListSize ) ; 
tabuSequenceDeque = new ArrayDeque < > ( ) ; 
return new TailChainSwapMoveSelector ( entitySelector , valueSelector , randomSelection ) ; 
} public GenuineVariableDescriptor extractVariableDescriptor ( HeuristicConfigPolicy configPolicy , 
EntityDescriptor entityDescriptor ) { 
entityDescriptor = downcastEntityDescriptor ( configPolicy , entityDescriptor ) ; 
if ( variableName != null ) { 
GenuineVariableDescriptor variableDescriptor = entityDescriptor . getGenuineVariableDescriptor ( variableName ) ; 
if ( variableDescriptor == null ) { 
+ entityDescriptor . getEntityClass ( ) + ").\n" 
+ entityDescriptor . buildInvalidVariableNameExceptionMessage ( variableName ) ) ; 
return variableDescriptor ; 
} else if ( mimicSelectorRef != null ) { 
return configPolicy . getValueMimicRecorder ( mimicSelectorRef ) . getVariableDescriptor ( ) ; 
} public < Solution_ > BestSolutionRecaller < Solution_ > buildBestSolutionRecaller ( EnvironmentMode environmentMode ) { 
BestSolutionRecaller < Solution_ > bestSolutionRecaller = new BestSolutionRecaller < > ( ) ; 
bestSolutionRecaller . setAssertInitialScoreFromScratch ( true ) ; 
bestSolutionRecaller . setAssertShadowVariablesAreNotStale ( true ) ; 
bestSolutionRecaller . setAssertBestScoreIsUnmodified ( true ) ; 
return bestSolutionRecaller ; 
protected < C > Constructor < C > retrieveCachedConstructor ( Class < C > clazz ) { 
return ( Constructor < C > ) constructorMemoization . computeIfAbsent ( clazz , key -> { 
Constructor < C > constructor ; 
constructor = clazz . getDeclaredConstructor ( ) ; 
} catch ( ReflectiveOperationException e ) { 
} protected < C > List < Field > retrieveCachedFields ( Class < C > clazz ) { 
return fieldListMemoization . computeIfAbsent ( clazz , key -> { 
Field [ ] fields = clazz . getDeclaredFields ( ) ; 
List < Field > fieldList = new ArrayList < > ( fields . length ) ; 
for ( Field field : fields ) { 
if ( ! Modifier . isStatic ( field . getModifiers ( ) ) ) { 
fieldList . add ( field ) ; 
return fieldList ; 
} protected boolean retrieveDeepCloneDecision ( Field field , Class < ? > fieldInstanceClass , Class < ? > actualValueClass ) { 
Pair < Field , Class < ? > > pair = Pair . of ( field , fieldInstanceClass ) ; 
Boolean deepCloneDecision = fieldDeepClonedMemoization . computeIfAbsent ( pair , 
key -> isFieldDeepCloned ( field , fieldInstanceClass ) ) ; 
return deepCloneDecision || retrieveDeepCloneDecisionForActualValueClass ( actualValueClass ) ; 
} public static ClassLoader [ ] classLoaders ( ClassLoader ... classLoaders ) { 
if ( classLoaders != null && classLoaders . length != 0 ) { 
return classLoaders ; 
ClassLoader contextClassLoader = contextClassLoader ( ) , staticClassLoader = staticClassLoader ( ) ; 
return contextClassLoader != null ? 
staticClassLoader != null && contextClassLoader != staticClassLoader ? 
new ClassLoader [ ] { contextClassLoader , staticClassLoader } : 
new ClassLoader [ ] { contextClassLoader } : 
new ClassLoader [ ] { } ; 
} public static Collection < URL > forPackage ( String name , ClassLoader ... classLoaders ) { 
return forResource ( resourceName ( name ) , classLoaders ) ; 
} public static Collection < URL > forResource ( String resourceName , ClassLoader ... classLoaders ) { 
final List < URL > result = new ArrayList < > ( ) ; 
final ClassLoader [ ] loaders = classLoaders ( classLoaders ) ; 
for ( ClassLoader classLoader : loaders ) { 
final Enumeration < URL > urls = classLoader . getResources ( resourceName ) ; 
while ( urls . hasMoreElements ( ) ) { 
final URL url = urls . nextElement ( ) ; 
int index = url . toExternalForm ( ) . lastIndexOf ( resourceName ) ; 
String newUrlString = url . toExternalForm ( ) . substring ( 0 , index ) ; 
result . add ( new URL ( url , newUrlString ) ) ; 
result . add ( url ) ; 
if ( Reflections . log != null ) { 
return distinctUrls ( result ) ; 
} public static String cleanPath ( final URL url ) { 
String path = url . getPath ( ) ; 
path = URLDecoder . decode ( path , "UTF-8" ) ; 
} catch ( UnsupportedEncodingException e ) { } 
if ( path . startsWith ( "jar:" ) ) { 
path = path . substring ( "jar:" . length ( ) ) ; 
if ( path . startsWith ( "file:" ) ) { 
path = path . substring ( "file:" . length ( ) ) ; 
if ( path . endsWith ( "!/" ) ) { 
path = path . substring ( 0 , path . lastIndexOf ( "!/" ) ) + "/" ; 
} private static Collection < URL > distinctUrls ( Collection < URL > urls ) { 
Map < String , URL > distinct = new HashMap < > ( urls . size ( ) ) ; 
for ( URL url : urls ) { 
distinct . put ( url . toExternalForm ( ) , url ) ; 
return distinct . values ( ) ; 
public void configureConstraintWeight ( Rule rule , Score_ constraintWeight ) { 
if ( constraintWeight . getInitScore ( ) != 0 ) { 
if ( constraintMatchEnabled ) { 
String constraintPackage = rule . getPackageName ( ) ; 
String constraintName = rule . getName ( ) ; 
String constraintId = constraintPackage + "/" + constraintName ; 
constraintMatchTotalMap . put ( constraintId , 
new ConstraintMatchTotal ( constraintPackage , constraintName , constraintWeight , zeroScore ) ) ; 
public Solution_ solve ( Solution_ problem ) { 
solverScope . initializeYielding ( ) ; 
solverScope . setBestSolution ( problem ) ; 
solvingStarted ( solverScope ) ; 
runPhases ( solverScope ) ; 
solvingEnded ( solverScope ) ; 
return solverScope . getBestSolution ( ) ; 
solverScope . destroyYielding ( ) ; 
} public EntityDescriptor extractEntityDescriptor ( HeuristicConfigPolicy configPolicy ) { 
SolutionDescriptor solutionDescriptor = configPolicy . getSolutionDescriptor ( ) ; 
EntityDescriptor entityDescriptor = solutionDescriptor . getEntityDescriptorStrict ( entityClass ) ; 
return configPolicy . getEntityMimicRecorder ( mimicSelectorRef ) . getEntityDescriptor ( ) ; 
} public static < T > T meldProperty ( T a , T b ) { 
if ( a == null && b == null ) { 
} else if ( a == null && b != null ) { 
} else if ( a != null && b == null ) { 
return ConfigUtils . mergeProperty ( a , b ) ; 
} public static int ceilDivide ( int dividend , int divisor ) { 
if ( divisor == 0 ) { 
int correction ; 
if ( dividend % divisor == 0 ) { 
correction = 0 ; 
} else if ( Integer . signum ( dividend ) * Integer . signum ( divisor ) < 0 ) { 
correction = 1 ; 
return ( dividend / divisor ) + correction ; 
} public static List < Class < ? > > getAllAnnotatedLineageClasses ( Class < ? > bottomClass , 
Class < ? extends Annotation > annotation ) { 
if ( ! bottomClass . isAnnotationPresent ( annotation ) ) { 
List < Class < ? > > lineageClassList = new ArrayList < > ( ) ; 
lineageClassList . add ( bottomClass ) ; 
Class < ? > superclass = bottomClass . getSuperclass ( ) ; 
lineageClassList . addAll ( getAllAnnotatedLineageClasses ( superclass , annotation ) ) ; 
for ( Class < ? > superInterface : bottomClass . getInterfaces ( ) ) { 
lineageClassList . addAll ( getAllAnnotatedLineageClasses ( superInterface , annotation ) ) ; 
return lineageClassList ; 
previousScores = new Score [ lateAcceptanceSize ] ; 
Score initialScore = phaseScope . getBestScore ( ) ; 
for ( int i = 0 ; i < previousScores . length ; i ++ ) { 
previousScores [ i ] = initialScore ; 
lateScoreIndex = 0 ; 
} public SolutionDescriptor buildSolutionDescriptor ( SolverConfigContext configContext , ScoreDefinition deprecatedScoreDefinition ) { 
ClassLoader [ ] classLoaders ; 
if ( configContext . getClassLoader ( ) != null ) { 
classLoaders = new ClassLoader [ ] { configContext . getClassLoader ( ) } ; 
} else if ( configContext . getKieContainer ( ) != null ) { 
classLoaders = new ClassLoader [ ] { configContext . getKieContainer ( ) . getClassLoader ( ) } ; 
ReflectionsKieVfsUrlType . register ( configContext . getKieContainer ( ) ) ; 
classLoaders = new ClassLoader [ 0 ] ; 
ConfigurationBuilder builder = new ConfigurationBuilder ( ) ; 
if ( ! ConfigUtils . isEmptyCollection ( packageIncludeList ) ) { 
FilterBuilder filterBuilder = new FilterBuilder ( ) ; 
for ( String packageInclude : packageIncludeList ) { 
if ( StringUtils . isEmpty ( packageInclude ) ) { 
builder . addUrls ( ReflectionsWorkaroundClasspathHelper . forPackage ( packageInclude , classLoaders ) ) ; 
filterBuilder . includePackage ( packageInclude ) ; 
builder . filterInputsBy ( filterBuilder ) ; 
builder . addUrls ( ReflectionsWorkaroundClasspathHelper . forPackage ( "" , classLoaders ) ) ; 
builder . setClassLoaders ( classLoaders ) ; 
Reflections reflections = new Reflections ( builder ) ; 
Class < ? > solutionClass = loadSolutionClass ( reflections ) ; 
List < Class < ? > > entityClassList = loadEntityClassList ( reflections ) ; 
return SolutionDescriptor . buildSolutionDescriptor ( solutionClass , entityClassList , deprecatedScoreDefinition ) ; 
} private void retainOnlyClassesWithDeclaredAnnotation ( Set < Class < ? > > classSet , Class < ? extends Annotation > annotation ) { 
classSet . removeIf ( clazz -> ! clazz . isAnnotationPresent ( annotation ) ) ; 
} public static long nextLong ( Random random , long n ) { 
if ( n <= 0L ) { 
if ( n < Integer . MAX_VALUE ) { 
return ( long ) random . nextInt ( ( int ) n ) ; 
long bits ; 
long val ; 
bits = ( random . nextLong ( ) << 1 ) > > > 1 ; 
val = bits % n ; 
} while ( bits - val + ( n - 1L ) < 0L ) ; 
public final Solution_ solve ( Solution_ problem ) { 
if ( problem == null ) { 
outerSolvingStarted ( solverScope ) ; 
boolean restartSolver = true ; 
while ( restartSolver ) { 
restartSolver = checkProblemFactChanges ( ) ; 
outerSolvingEnded ( solverScope ) ; 
long childSize = childEntitySelector . getSize ( ) ; 
cachedEntityList = new ArrayList < > ( ( int ) childSize ) ; 
childEntitySelector . iterator ( ) . forEachRemaining ( cachedEntityList :: add ) ; 
public ScoreCalculationCountTermination createChildThreadTermination ( 
return new ScoreCalculationCountTermination ( scoreCalculationCountLimit ) ; 
} public long calculateStandardDeviationSquaredFemtos ( ) { 
long totalFemtos = 0L ; 
for ( AssetClassAllocation a : assetClassAllocationList ) { 
for ( AssetClassAllocation b : assetClassAllocationList ) { 
if ( a == b ) { 
totalFemtos += a . getQuantifiedStandardDeviationRiskMicros ( ) * b . getQuantifiedStandardDeviationRiskMicros ( ) 
* 1000L ; 
long correlationMillis = a . getAssetClass ( ) . getCorrelationMillisMap ( ) . get ( b . getAssetClass ( ) ) ; 
* correlationMillis ; 
return totalFemtos ; 
hasRecordingCreated = false ; 
recordingCreated = false ; 
public void configureConstraintWeight ( Rule rule , SimpleScore constraintWeight ) { 
if ( constraintWeight . equals ( SimpleScore . ZERO ) ) { 
-> addConstraintMatch ( kcontext , constraintWeight . getScore ( ) * matchWeight ) ; 
public UnimprovedTimeMillisSpentScoreDifferenceThresholdTermination createChildThreadTermination ( 
return new UnimprovedTimeMillisSpentScoreDifferenceThresholdTermination ( 
unimprovedTimeMillisSpentLimit , unimprovedScoreDifferenceThreshold ) ; 
List < Map < String , XYSeries > > constraintIdToWeightSeriesMapList 
for ( ConstraintMatchTotalBestScoreStatisticPoint point : getPointList ( ) ) { 
double [ ] levelValues = ScoreUtils . extractLevelDoubles ( point . getScoreTotal ( ) ) ; 
if ( i >= constraintIdToWeightSeriesMapList . size ( ) ) { 
constraintIdToWeightSeriesMapList . add ( new LinkedHashMap < > ( ) ) ; 
Map < String , XYSeries > constraintIdToWeightSeriesMap = constraintIdToWeightSeriesMapList . get ( i ) ; 
XYSeries weightSeries = constraintIdToWeightSeriesMap . computeIfAbsent ( point . getConstraintId ( ) , 
if ( levelValues [ i ] != ( ( weightSeries . getItemCount ( ) == 0 ) ? 0.0 
: weightSeries . getY ( weightSeries . getItemCount ( ) - 1 ) . doubleValue ( ) ) ) { 
weightSeries . add ( timeMillisSpent , levelValues [ i ] ) ; 
long timeMillisSpent = subSingleBenchmarkResult . getTimeMillisSpent ( ) ; 
for ( Map < String , XYSeries > constraintIdToWeightSeriesMap : constraintIdToWeightSeriesMapList ) { 
for ( Iterator < Map . Entry < String , XYSeries > > it = constraintIdToWeightSeriesMap . entrySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { 
XYSeries weightSeries = it . next ( ) . getValue ( ) ; 
if ( weightSeries . getItemCount ( ) == 0 ) { 
weightSeries . add ( timeMillisSpent , weightSeries . getY ( weightSeries . getItemCount ( ) - 1 ) . doubleValue ( ) ) ; 
graphFileList = new ArrayList < > ( constraintIdToWeightSeriesMapList . size ( ) ) ; 
for ( int scoreLevelIndex = 0 ; scoreLevelIndex < constraintIdToWeightSeriesMapList . size ( ) ; scoreLevelIndex ++ ) { 
for ( XYSeries series : constraintIdToWeightSeriesMapList . get ( scoreLevelIndex ) . values ( ) ) { 
"ConstraintMatchTotalBestScoreStatisticLevel" + scoreLevelIndex ) ) ; 
terminateChildren = true ; 
return terminateChildren ; 
} public ClassLoader determineActualClassLoader ( ) { 
if ( classLoader != null ) { 
return classLoader ; 
} else if ( kieContainer != null ) { 
return kieContainer . getClassLoader ( ) ; 
return getClass ( ) . getClassLoader ( ) ; 
cachedMoveMap = new TreeMap < > ( ) ; 
for ( Move entity : childMoveSelector ) { 
cachedMoveMap . put ( probabilityWeightOffset , entity ) ; 
Set < String > childMoveTypeDescriptionSet = new TreeSet < > ( ) ; 
for ( Move < Solution_ > move : moves ) { 
childMoveTypeDescriptionSet . add ( move . getSimpleMoveTypeDescription ( ) ) ; 
StringBuilder moveTypeDescription = new StringBuilder ( 20 * ( moves . length + 1 ) ) ; 
for ( String childMoveTypeDescription : childMoveTypeDescriptionSet ) { 
PillarSelector leftPillarSelector = pillarSelectorConfig_ . buildPillarSelector ( configPolicy , 
PillarSelectorConfig rightPillarSelectorConfig = defaultIfNull ( secondaryPillarSelectorConfig , pillarSelectorConfig_ ) ; 
PillarSelector rightPillarSelector = rightPillarSelectorConfig . buildPillarSelector ( configPolicy , 
leftPillarSelector . getEntityDescriptor ( ) , variableNameIncludeList ) ; 
return new PillarSwapMoveSelector ( leftPillarSelector , rightPillarSelector , variableDescriptorList , 
public NoChangePhase buildPhase ( int phaseIndex , HeuristicConfigPolicy solverConfigPolicy , 
return new NoChangePhase ( 
long childSize = childValueSelector . getSize ( ) ; 
cachedValueList = new ArrayList < > ( ( int ) childSize ) ; 
childValueSelector . iterator ( ) . forEachRemaining ( cachedValueList :: add ) ; 
cachedValueList . size ( ) , this ) ; 
public ConstructionHeuristicPhase buildPhase ( int phaseIndex , HeuristicConfigPolicy solverConfigPolicy , 
DefaultConstructionHeuristicPhase phase = new DefaultConstructionHeuristicPhase ( 
phase . setDecider ( buildDecider ( phaseConfigPolicy , phase . getTermination ( ) ) ) ; 
ConstructionHeuristicType constructionHeuristicType_ = defaultIfNull ( 
constructionHeuristicType , ConstructionHeuristicType . ALLOCATE_ENTITY_FROM_QUEUE ) ; 
: constructionHeuristicType_ . getDefaultEntitySorterManner ( ) ) ; 
: constructionHeuristicType_ . getDefaultValueSorterManner ( ) ) ; 
EntityPlacerConfig entityPlacerConfig ; 
if ( ConfigUtils . isEmptyCollection ( entityPlacerConfigList ) ) { 
entityPlacerConfig = buildUnfoldedEntityPlacerConfig ( phaseConfigPolicy , constructionHeuristicType_ ) ; 
} else if ( entityPlacerConfigList . size ( ) == 1 ) { 
entityPlacerConfig = entityPlacerConfigList . get ( 0 ) ; 
if ( constructionHeuristicType != null ) { 
if ( moveSelectorConfigList != null ) { 
EntityPlacer entityPlacer = entityPlacerConfig . buildEntityPlacer ( phaseConfigPolicy ) ; 
phase . setEntityPlacer ( entityPlacer ) ; 
public void configureConstraintWeight ( Rule rule , SimpleBigDecimalScore constraintWeight ) { 
if ( constraintWeight . equals ( SimpleBigDecimalScore . ZERO ) ) { 
-> addConstraintMatch ( kcontext , constraintWeight . getScore ( ) . multiply ( matchWeight ) ) ; 
} public void checkIfProblemFactsExist ( ) { 
if ( problemFactCollectionMemberAccessorMap . isEmpty ( ) && problemFactMemberAccessorMap . isEmpty ( ) ) { 
} public Collection < Object > getAllFacts ( Solution_ solution ) { 
Collection < Object > facts = new ArrayList < > ( ) ; 
Arrays . asList ( entityMemberAccessorMap , problemFactMemberAccessorMap ) 
. forEach ( map -> map . forEach ( ( key , memberAccessor ) -> { 
Object object = extractMemberObject ( memberAccessor , solution ) ; 
facts . add ( object ) ; 
} ) ) ; 
entityCollectionMemberAccessorMap . forEach ( 
( key , memberAccessor ) -> facts . addAll ( extractMemberCollectionOrArray ( memberAccessor , solution , false ) ) ) ; 
problemFactCollectionMemberAccessorMap . forEach ( 
( key , memberAccessor ) -> facts . addAll ( extractMemberCollectionOrArray ( memberAccessor , solution , true ) ) ) ; 
return facts ; 
} public long getProblemScale ( Solution_ solution ) { 
long problemScale = 0L ; 
for ( Iterator < Object > it = extractAllEntitiesIterator ( solution ) ; it . hasNext ( ) ; ) { 
EntityDescriptor < Solution_ > entityDescriptor = findEntityDescriptorOrFail ( entity . getClass ( ) ) ; 
problemScale += entityDescriptor . getProblemScale ( solution , entity ) ; 
return problemScale ; 
boolean movable = false ; 
Object leftValue = variableDescriptor . getValue ( leftPillar . get ( 0 ) ) ; 
Object rightValue = variableDescriptor . getValue ( rightPillar . get ( 0 ) ) ; 
if ( ! Objects . equals ( leftValue , rightValue ) ) { 
movable = true ; 
for ( Object rightEntity : rightPillar ) { 
for ( Object leftEntity : leftPillar ) { 
return movable ; 
} public Object createDBRef ( final String ns , final ObjectId id ) { 
return new BasicBSONObject ( "$ns" , ns ) . append ( "$id" , id ) ; 
public static Class < ? extends BsonValue > getClassForBsonType ( final BsonType bsonType ) { 
return ( Class < ? extends BsonValue > ) DEFAULT_BSON_TYPE_CLASS_MAP . get ( bsonType ) ; 
} public DBCursor getFileList ( final DBObject query , final DBObject sort ) { 
return filesCollection . find ( query ) . sort ( sort ) ; 
} public List < GridFSDBFile > find ( final String filename , final DBObject sort ) { 
return find ( new BasicDBObject ( "filename" , filename ) , sort ) ; 
} public List < GridFSDBFile > find ( final DBObject query , final DBObject sort ) { 
List < GridFSDBFile > files = new ArrayList < GridFSDBFile > ( ) ; 
DBCursor cursor = filesCollection . find ( query ) ; 
if ( sort != null ) { 
cursor . sort ( sort ) ; 
while ( cursor . hasNext ( ) ) { 
files . add ( injectGridFSInstance ( cursor . next ( ) ) ) ; 
cursor . close ( ) ; 
return Collections . unmodifiableList ( files ) ; 
} public void remove ( final ObjectId id ) { 
filesCollection . remove ( new BasicDBObject ( "_id" , id ) ) ; 
chunksCollection . remove ( new BasicDBObject ( "files_id" , id ) ) ; 
} public void remove ( final DBObject query ) { 
for ( final GridFSDBFile f : find ( query ) ) { 
f . remove ( ) ; 
} public GridFSInputFile createFile ( final File file ) throws IOException { 
return createFile ( new FileInputStream ( file ) , file . getName ( ) , true ) ; 
} public GridFSInputFile createFile ( final InputStream in , final String filename , final boolean closeStreamOnPersist ) { 
return new GridFSInputFile ( this , in , filename , closeStreamOnPersist ) ; 
} public static MongoClient create ( final MongoClientSettings settings , @ Nullable final MongoDriverInformation mongoDriverInformation ) { 
MongoDriverInformation . Builder builder = mongoDriverInformation == null ? MongoDriverInformation . builder ( ) 
: MongoDriverInformation . builder ( mongoDriverInformation ) ; 
return new MongoClientImpl ( settings , builder . driverName ( "sync" ) . build ( ) ) ; 
public Object put ( final String key , final Object v ) { 
return put ( _getInt ( key ) , v ) ; 
} public Object put ( final int key , final Object value ) { 
while ( key >= size ( ) ) { 
add ( null ) ; 
set ( key , value ) ; 
} public Object get ( final String key ) { 
int i = _getInt ( key ) ; 
if ( i < 0 ) { 
if ( i >= size ( ) ) { 
return get ( i ) ; 
} public static < T > Builder < T > builder ( final Class < T > type ) { 
return new Builder < T > ( notNull ( "type" , type ) ) ; 
MongoClient mongoClient ; 
mongoClient = MongoClients . create ( ) ; 
mongoClient = MongoClients . create ( args [ 0 ] ) ; 
MongoDatabase database = mongoClient . getDatabase ( "mydb" ) ; 
database . drop ( ) ; 
MongoCollection < Document > collection = database . getCollection ( "test" ) ; 
collection . drop ( ) ; 
for ( String name : mongoClient . listDatabaseNames ( ) ) { 
System . out . println ( name ) ; 
mongoClient . getDatabase ( "databaseToBeDropped" ) . drop ( ) ; 
database . createCollection ( "cappedCollection" , new CreateCollectionOptions ( ) . capped ( true ) . sizeInBytes ( 0x100000 ) ) ; 
for ( String name : database . listCollectionNames ( ) ) { 
collection . createIndex ( Indexes . ascending ( "i" ) ) ; 
for ( final Document index : collection . listIndexes ( ) ) { 
System . out . println ( index . toJson ( ) ) ; 
collection . createIndex ( Indexes . text ( "content" ) ) ; 
matchCount = collection . countDocuments ( textSearch ) ; 
Document projection = new Document ( "score" , new Document ( "$meta" , "textScore" ) ) ; 
Document myDoc = collection . find ( textSearch ) . projection ( projection ) . first ( ) ; 
Document buildInfo = database . runCommand ( new Document ( "buildInfo" , 1 ) ) ; 
System . out . println ( buildInfo ) ; 
mongoClient . close ( ) ; 
} public static void reverseByteArray ( final byte [ ] data , final int start , final int length ) { 
for ( int left = start , right = start + length - 1 ; left < right ; left ++ , right -- ) { 
byte temp = data [ left ] ; 
data [ left ] = data [ right ] ; 
data [ right ] = temp ; 
} public long getMaxTime ( final TimeUnit timeUnit ) { 
notNull ( "timeUnit" , timeUnit ) ; 
return timeUnit . convert ( maxTimeMS , TimeUnit . MILLISECONDS ) ; 
public < T > T getProperty ( final String key , final T defaultValue ) { 
notNull ( "key" , key ) ; 
T value = ( T ) properties . get ( key . toLowerCase ( ) ) ; 
return ( value == null && ! properties . containsKey ( key ) ) ? defaultValue : value ; 
} public < T > T getPropertyNonNull ( final String key , final T defaultValue ) { 
T value = getProperty ( key , defaultValue ) ; 
} public < T > MongoCompressor withProperty ( final String key , final T value ) { 
return new MongoCompressor ( this , key , value ) ; 
List < ServerDescription > any = getClusterDescription ( ) . getAnyPrimaryOrSecondary ( ) ; 
return any . isEmpty ( ) ? null : any . get ( 0 ) . getSetName ( ) ; 
public ServerAddress getMaster ( ) { 
List < ServerDescription > primaries = getClusterDescription ( ) . getPrimaries ( ) ; 
return primaries . isEmpty ( ) ? null : primaries . get ( 0 ) . getAddress ( ) ; 
} public boolean isMaster ( final ServerAddress serverAddress ) { 
ServerAddress masterServerAddress = getMaster ( ) ; 
return masterServerAddress != null && masterServerAddress . equals ( serverAddress ) ; 
public int getMaxBsonObjectSize ( ) { 
return primaries . isEmpty ( ) ? ServerDescription . getDefaultMaxDocumentSize ( ) : primaries . get ( 0 ) . getMaxDocumentSize ( ) ; 
} public QueryBuilder put ( final String key ) { 
_currentKey = key ; 
if ( _query . get ( key ) == null ) { 
_query . put ( _currentKey , new NullObject ( ) ) ; 
} public QueryBuilder withinCenter ( final double x , final double y , final double radius ) { 
addOperand ( QueryOperators . WITHIN , 
new BasicDBObject ( QueryOperators . CENTER , asList ( asList ( x , y ) , radius ) ) ) ; 
} public QueryBuilder near ( final double x , final double y ) { 
addOperand ( QueryOperators . NEAR , 
asList ( x , y ) ) ; 
} public QueryBuilder near ( final double x , final double y , final double maxDistance ) { 
addOperand ( QueryOperators . MAX_DISTANCE , 
maxDistance ) ; 
} public QueryBuilder nearSphere ( final double longitude , final double latitude ) { 
addOperand ( QueryOperators . NEAR_SPHERE , 
asList ( longitude , latitude ) ) ; 
} public QueryBuilder nearSphere ( final double longitude , final double latitude , final double maxDistance ) { 
} public QueryBuilder withinCenterSphere ( final double longitude , final double latitude , final double maxDistance ) { 
new BasicDBObject ( QueryOperators . CENTER_SPHERE , 
asList ( asList ( longitude , latitude ) , maxDistance ) ) ) ; 
public QueryBuilder withinBox ( final double x , final double y , final double x2 , final double y2 ) { 
new BasicDBObject ( QueryOperators . BOX , new Object [ ] { new Double [ ] { x , y } , new Double [ ] { x2 , y2 } } ) ) ; 
} public QueryBuilder withinPolygon ( final List < Double [ ] > points ) { 
notNull ( "points" , points ) ; 
if ( points . isEmpty ( ) || points . size ( ) < 3 ) { 
new BasicDBObject ( QueryOperators . POLYGON , convertToListOfLists ( points ) ) ) ; 
} public QueryBuilder text ( final String search , @ Nullable final String language ) { 
if ( _currentKey != null ) { 
put ( QueryOperators . TEXT ) ; 
addOperand ( QueryOperators . SEARCH , search ) ; 
if ( language != null ) { 
addOperand ( QueryOperators . LANGUAGE , language ) ; 
public QueryBuilder or ( final DBObject ... ors ) { 
List l = ( List ) _query . get ( QueryOperators . OR ) ; 
l = new ArrayList ( ) ; 
_query . put ( QueryOperators . OR , l ) ; 
Collections . addAll ( l , ors ) ; 
public QueryBuilder and ( final DBObject ... ands ) { 
List l = ( List ) _query . get ( QueryOperators . AND ) ; 
_query . put ( QueryOperators . AND , l ) ; 
Collections . addAll ( l , ands ) ; 
} public DBObject get ( ) { 
for ( final String key : _query . keySet ( ) ) { 
if ( _query . get ( key ) instanceof NullObject ) { 
return _query ; 
} public static Logger getLogger ( final String suffix ) { 
notNull ( "suffix" , suffix ) ; 
if ( suffix . startsWith ( "." ) || suffix . endsWith ( "." ) ) { 
String name = PREFIX + "." + suffix ; 
if ( USE_SLF4J ) { 
return new SLF4JLogger ( name ) ; 
return new JULLogger ( name ) ; 
} private void applyMajorityWriteConcernToTransactionOptions ( ) { 
if ( transactionOptions != null ) { 
WriteConcern writeConcern = transactionOptions . getWriteConcern ( ) ; 
if ( writeConcern != null ) { 
transactionOptions = TransactionOptions . merge ( TransactionOptions . builder ( ) 
. writeConcern ( writeConcern . withW ( "majority" ) ) . build ( ) , transactionOptions ) ; 
. writeConcern ( WriteConcern . MAJORITY ) . build ( ) , transactionOptions ) ; 
transactionOptions = TransactionOptions . builder ( ) . writeConcern ( WriteConcern . MAJORITY ) . build ( ) ; 
Document doc = new Document ( "name" , "MongoDB" ) 
. append ( "amount1" , Decimal128 . parse ( ".10" ) ) 
. append ( "amount2" , new Decimal128 ( 42L ) ) 
. append ( "amount3" , new Decimal128 ( new BigDecimal ( ".200" ) ) ) ; 
collection . insertOne ( doc ) ; 
Document first = collection . find ( ) . filter ( Filters . eq ( "amount1" , new Decimal128 ( new BigDecimal ( ".10" ) ) ) ) . first ( ) ; 
Decimal128 amount3 = ( Decimal128 ) first . get ( "amount3" ) ; 
BigDecimal amount2AsBigDecimal = amount3 . bigDecimalValue ( ) ; 
System . out . println ( amount3 . toString ( ) ) ; 
System . out . println ( amount2AsBigDecimal . toString ( ) ) ; 
} public boolean ok ( ) { 
Object okValue = get ( "ok" ) ; 
if ( okValue instanceof Boolean ) { 
return ( Boolean ) okValue ; 
} else if ( okValue instanceof Number ) { 
return ( ( Number ) okValue ) . intValue ( ) == 1 ; 
public String getErrorMessage ( ) { 
Object foo = get ( "errmsg" ) ; 
if ( foo == null ) { 
return foo . toString ( ) ; 
} public PropertyModelBuilder < T > readAnnotations ( final List < Annotation > annotations ) { 
this . readAnnotations = unmodifiableList ( notNull ( "annotations" , annotations ) ) ; 
public PropertyModel < T > build ( ) { 
if ( ! isReadable ( ) && ! isWritable ( ) ) { 
return new PropertyModel ( 
stateNotNull ( "propertyName" , name ) , 
readName , 
writeName , 
stateNotNull ( "typeData" , typeData ) , 
codec , 
stateNotNull ( "propertySerialization" , propertySerialization ) , 
discriminatorEnabled , 
stateNotNull ( "propertyAccessor" , propertyAccessor ) ) ; 
public void encode ( final BsonWriter writer , final Instant value , final EncoderContext encoderContext ) { 
writer . writeDateTime ( value . toEpochMilli ( ) ) ; 
} catch ( ArithmeticException e ) { 
value , e . getMessage ( ) ) , e ) ; 
public void encode ( final BsonWriter writer , final LocalDate value , final EncoderContext encoderContext ) { 
writer . writeDateTime ( value . atStartOfDay ( ZoneOffset . UTC ) . toInstant ( ) . toEpochMilli ( ) ) ; 
} public static List < String > getIndexNames ( final List < IndexModel > indexes , final CodecRegistry codecRegistry ) { 
List < String > indexNames = new ArrayList < String > ( indexes . size ( ) ) ; 
for ( IndexModel index : indexes ) { 
String name = index . getOptions ( ) . getName ( ) ; 
indexNames . add ( name ) ; 
indexNames . add ( IndexHelper . generateIndexName ( index . getKeys ( ) . toBsonDocument ( BsonDocument . class , codecRegistry ) ) ) ; 
return indexNames ; 
} public static String generateIndexName ( final BsonDocument index ) { 
StringBuilder indexName = new StringBuilder ( ) ; 
for ( final String keyNames : index . keySet ( ) ) { 
if ( indexName . length ( ) != 0 ) { 
indexName . append ( '_' ) ; 
indexName . append ( keyNames ) . append ( '_' ) ; 
BsonValue ascOrDescValue = index . get ( keyNames ) ; 
if ( ascOrDescValue instanceof BsonNumber ) { 
indexName . append ( ( ( BsonNumber ) ascOrDescValue ) . intValue ( ) ) ; 
} else if ( ascOrDescValue instanceof BsonString ) { 
return indexName . toString ( ) ; 
public void validate ( ) { 
if ( md5 == null ) { 
DBObject cmd = new BasicDBObject ( "filemd5" , id ) ; 
cmd . put ( "root" , fs . getBucketName ( ) ) ; 
DBObject res = fs . getDB ( ) . command ( cmd ) ; 
if ( res != null && res . containsField ( "md5" ) ) { 
String m = res . get ( "md5" ) . toString ( ) ; 
if ( m . equals ( md5 ) ) { 
} public Codec < ? > get ( final BsonType bsonType ) { 
Codec < ? > codec = codecs [ bsonType . getValue ( ) ] ; 
if ( codec == null ) { 
Class < ? > clazz = bsonTypeClassMap . get ( bsonType ) ; 
return codec ; 
} private int calculateBatchSize ( ) { 
Integer batchSize = mongoIterable . getBatchSize ( ) ; 
if ( batchSize != null ) { 
return batchSize ; 
long requested = getRequested ( ) ; 
if ( requested <= 1 ) { 
} else if ( requested < Integer . MAX_VALUE ) { 
return ( int ) requested ; 
} public CreateIndexOptions maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
this . maxTimeMS = TimeUnit . MILLISECONDS . convert ( maxTime , timeUnit ) ; 
} public static int compare ( final long first , final long second ) { 
return compareLongs ( first + Long . MIN_VALUE , second + Long . MIN_VALUE ) ; 
} public static long parse ( final String string ) { 
if ( string . length ( ) == 0 ) { 
int radix = 10 ; 
int maxSafePos = MAX_SAFE_DIGITS [ radix ] - 1 ; 
long value = 0 ; 
for ( int pos = 0 ; pos < string . length ( ) ; pos ++ ) { 
int digit = Character . digit ( string . charAt ( pos ) , radix ) ; 
if ( digit == - 1 ) { 
throw new NumberFormatException ( string ) ; 
if ( pos > maxSafePos && overflowInParse ( value , digit , radix ) ) { 
value = ( value * radix ) + digit ; 
} private static boolean overflowInParse ( final long current , final int digit , final int radix ) { 
if ( current >= 0 ) { 
if ( current < MAX_VALUE_DIVS [ radix ] ) { 
if ( current > MAX_VALUE_DIVS [ radix ] ) { 
return ( digit > MAX_VALUE_MODS [ radix ] ) ; 
} private static long divide ( final long dividend , final long divisor ) { 
if ( divisor < 0 ) { 
if ( compare ( dividend , divisor ) < 0 ) { 
if ( dividend >= 0 ) { 
return dividend / divisor ; 
long quotient = ( ( dividend > > > 1 ) / divisor ) << 1 ; 
long rem = dividend - quotient * divisor ; 
return quotient + ( compare ( rem , divisor ) >= 0 ? 1 : 0 ) ; 
} private static long remainder ( final long dividend , final long divisor ) { 
return dividend ; 
return dividend - divisor ; 
return dividend % divisor ; 
return rem - ( compare ( rem , divisor ) >= 0 ? divisor : 0 ) ; 
} public < T > T decodeWithChildContext ( final Decoder < T > decoder , final BsonReader reader ) { 
return decoder . decode ( reader , DEFAULT_CONTEXT ) ; 
} public AggregateToCollectionOperation maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
} public ReadOperation < BsonDocument > asExplainableOperation ( final ExplainVerbosity explainVerbosity ) { 
return new AggregateExplainOperation ( namespace , pipeline ) 
. allowDiskUse ( allowDiskUse ) 
. maxTime ( maxTimeMS , TimeUnit . MILLISECONDS ) 
. hint ( hint ) ; 
} protected State getNextState ( ) { 
if ( getContext ( ) . getContextType ( ) == BsonContextType . ARRAY ) { 
return State . VALUE ; 
return State . NAME ; 
} protected boolean checkState ( final State [ ] validStates ) { 
for ( final State cur : validStates ) { 
if ( cur == getState ( ) ) { 
} protected void checkPreconditions ( final String methodName , final State ... validStates ) { 
if ( isClosed ( ) ) { 
if ( ! checkState ( validStates ) ) { 
throwInvalidState ( methodName , validStates ) ; 
} protected void throwInvalidState ( final String methodName , final State ... validStates ) { 
if ( state == State . INITIAL || state == State . SCOPE_DOCUMENT || state == State . DONE ) { 
if ( ! methodName . startsWith ( "end" ) && ! methodName . equals ( "writeName" ) ) { 
String typeName = methodName . substring ( 5 ) ; 
if ( typeName . startsWith ( "start" ) ) { 
typeName = typeName . substring ( 5 ) ; 
String article = "A" ; 
if ( Arrays . asList ( 'A' , 'E' , 'I' , 'O' , 'U' ) . contains ( typeName . charAt ( 0 ) ) ) { 
article = "An" ; 
article , typeName ) ) ; 
methodName , validStatesString , state ) ) ; 
} public void pipe ( final BsonReader reader , final List < BsonElement > extraElements ) { 
notNull ( "reader" , reader ) ; 
notNull ( "extraElements" , extraElements ) ; 
pipeDocument ( reader , extraElements ) ; 
} protected void pipeExtraElements ( final List < BsonElement > extraElements ) { 
for ( BsonElement cur : extraElements ) { 
writeName ( cur . getName ( ) ) ; 
pipeValue ( cur . getValue ( ) ) ; 
} public static String toHex ( final byte [ ] bytes ) { 
for ( final byte b : bytes ) { 
String s = Integer . toHexString ( 0xff & b ) ; 
if ( s . length ( ) < 2 ) { 
sb . append ( "0" ) ; 
sb . append ( s ) ; 
} public static String hexMD5 ( final byte [ ] data ) { 
md5 . reset ( ) ; 
md5 . update ( data ) ; 
byte [ ] digest = md5 . digest ( ) ; 
return toHex ( digest ) ; 
} public static String hexMD5 ( final ByteBuffer buf , final int offset , final int len ) { 
b [ i ] = buf . get ( offset + i ) ; 
return hexMD5 ( b ) ; 
} public static boolean isValid ( final String hexString ) { 
if ( hexString == null ) { 
int len = hexString . length ( ) ; 
if ( len != 24 ) { 
char c = hexString . charAt ( i ) ; 
if ( c >= '0' && c <= '9' ) { 
if ( c >= 'a' && c <= 'f' ) { 
if ( c >= 'A' && c <= 'F' ) { 
} public byte [ ] toByteArray ( ) { 
ByteBuffer buffer = ByteBuffer . allocate ( OBJECT_ID_LENGTH ) ; 
putToByteBuffer ( buffer ) ; 
} public void putToByteBuffer ( final ByteBuffer buffer ) { 
notNull ( "buffer" , buffer ) ; 
buffer . put ( int3 ( timestamp ) ) ; 
buffer . put ( int2 ( timestamp ) ) ; 
buffer . put ( int1 ( timestamp ) ) ; 
buffer . put ( int0 ( timestamp ) ) ; 
buffer . put ( int2 ( randomValue1 ) ) ; 
buffer . put ( int1 ( randomValue1 ) ) ; 
buffer . put ( int0 ( randomValue1 ) ) ; 
buffer . put ( short1 ( randomValue2 ) ) ; 
buffer . put ( short0 ( randomValue2 ) ) ; 
buffer . put ( int2 ( counter ) ) ; 
buffer . put ( int1 ( counter ) ) ; 
buffer . put ( int0 ( counter ) ) ; 
} public String toHexString ( ) { 
char [ ] chars = new char [ OBJECT_ID_LENGTH * 2 ] ; 
for ( byte b : toByteArray ( ) ) { 
chars [ i ++ ] = HEX_CHARS [ b > > 4 & 0xF ] ; 
chars [ i ++ ] = HEX_CHARS [ b & 0xF ] ; 
public static ObjectId createFromLegacyFormat ( final int time , final int machine , final int inc ) { 
return new ObjectId ( time , machine , inc ) ; 
} protected BsonValue readValue ( final BsonReader reader , final DecoderContext decoderContext ) { 
return ( BsonValue ) bsonTypeCodecMap . get ( reader . getCurrentBsonType ( ) ) . decode ( reader , decoderContext ) ; 
} public boolean hasTags ( final TagSet desiredTags ) { 
if ( type == STANDALONE || type == SHARD_ROUTER ) { 
return tagSet . containsAll ( desiredTags ) ; 
} public String getShortDescription ( ) { 
return "{" 
+ "address=" + address 
+ '}' ; 
} public static BasicDBObjectBuilder start ( final String key , final Object val ) { 
return ( new BasicDBObjectBuilder ( ) ) . add ( key , val ) ; 
public static BasicDBObjectBuilder start ( final Map documentAsMap ) { 
BasicDBObjectBuilder builder = new BasicDBObjectBuilder ( ) ; 
Iterator < Map . Entry > i = documentAsMap . entrySet ( ) . iterator ( ) ; 
while ( i . hasNext ( ) ) { 
Map . Entry entry = i . next ( ) ; 
builder . add ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; 
} public BasicDBObjectBuilder append ( final String key , final Object val ) { 
_cur ( ) . put ( key , val ) ; 
} public BasicDBObjectBuilder push ( final String key ) { 
BasicDBObject o = new BasicDBObject ( ) ; 
_cur ( ) . put ( key , o ) ; 
_stack . addLast ( o ) ; 
} public void addResult ( final BulkWriteResult result , final IndexMap indexMap ) { 
insertedCount += result . getInsertedCount ( ) ; 
matchedCount += result . getMatchedCount ( ) ; 
deletedCount += result . getDeletedCount ( ) ; 
modifiedCount += result . getModifiedCount ( ) ; 
mergeUpserts ( result . getUpserts ( ) , indexMap ) ; 
} public void addErrorResult ( final MongoBulkWriteException exception , final IndexMap indexMap ) { 
addResult ( exception . getWriteResult ( ) , indexMap ) ; 
mergeWriteErrors ( exception . getWriteErrors ( ) , indexMap ) ; 
mergeWriteConcernError ( exception . getWriteConcernError ( ) ) ; 
} public void addWriteErrorResult ( final BulkWriteError writeError , final IndexMap indexMap ) { 
notNull ( "writeError" , writeError ) ; 
mergeWriteErrors ( asList ( writeError ) , indexMap ) ; 
} public void addErrorResult ( final List < BulkWriteError > writeErrors , 
final WriteConcernError writeConcernError , final IndexMap indexMap ) { 
mergeWriteErrors ( writeErrors , indexMap ) ; 
mergeWriteConcernError ( writeConcernError ) ; 
} public MongoBulkWriteException getError ( ) { 
return hasErrors ( ) ? new MongoBulkWriteException ( createResult ( ) , 
new ArrayList < BulkWriteError > ( writeErrors ) , 
writeConcernErrors . isEmpty ( ) ? null 
: writeConcernErrors . get ( writeConcernErrors . size ( ) - 1 ) , 
serverAddress ) : null ; 
} private boolean casNext ( Node < E > cmp , Node < E > val ) { 
return compareAndSet ( cmp , val ) ; 
} private Node < E > nextNonmarker ( ) { 
Node < E > f = getNext ( ) ; 
return ( f == null || ! f . isMarker ( ) ) ? f : f . getNext ( ) ; 
} Node < E > successor ( ) { 
Node < E > f = nextNonmarker ( ) ; 
if ( f == null ) 
if ( ! f . isDeleted ( ) ) { 
if ( f . getPrev ( ) != this && ! isDeleted ( ) ) 
f . setPrev ( this ) ; 
Node < E > s = f . nextNonmarker ( ) ; 
if ( f == getNext ( ) ) 
casNext ( f , s ) ; 
f = s ; 
} private Node < E > findPredecessorOf ( Node < E > target ) { 
Node < E > n = this ; 
Node < E > f = n . successor ( ) ; 
if ( f == target ) 
n = f ; 
} Node < E > predecessor ( ) { 
Node < E > b = n . getPrev ( ) ; 
if ( b == null ) 
return n . findPredecessorOf ( this ) ; 
Node < E > s = b . getNext ( ) ; 
if ( s == this ) 
if ( s == null || ! s . isMarker ( ) ) { 
Node < E > p = b . findPredecessorOf ( this ) ; 
if ( p != null ) 
n = b ; 
} Node < E > forward ( ) { 
Node < E > f = successor ( ) ; 
return ( f == null || f . isSpecial ( ) ) ? null : f ; 
} Node < E > back ( ) { 
Node < E > f = predecessor ( ) ; 
} Node < E > append ( E element ) { 
if ( f == null || f . isMarker ( ) ) 
Node < E > x = new Node < E > ( element , f , this ) ; 
if ( casNext ( f , x ) ) { 
f . setPrev ( x ) ; 
} Node < E > prepend ( E element ) { 
Node < E > b = predecessor ( ) ; 
Node < E > x = new Node < E > ( element , this , b ) ; 
if ( b . casNext ( this , x ) ) { 
setPrev ( x ) ; 
} boolean delete ( ) { 
Node < E > b = getPrev ( ) ; 
if ( b != null && f != null && ! f . isMarker ( ) && 
casNext ( f , new Node < E > ( f ) ) ) { 
if ( b . casNext ( this , f ) ) 
f . setPrev ( b ) ; 
} Node < E > replace ( E newElement ) { 
if ( b == null || f == null || f . isMarker ( ) ) 
Node < E > x = new Node < E > ( newElement , f , b ) ; 
if ( casNext ( f , new Node < E > ( x ) ) ) { 
b . successor ( ) ; 
x . successor ( ) ; 
} public JsonToken nextToken ( ) { 
int c = buffer . read ( ) ; 
while ( c != - 1 && Character . isWhitespace ( c ) ) { 
c = buffer . read ( ) ; 
return new JsonToken ( JsonTokenType . END_OF_FILE , "<eof>" ) ; 
case '{' : 
return new JsonToken ( JsonTokenType . BEGIN_OBJECT , "{" ) ; 
case '}' : 
return new JsonToken ( JsonTokenType . END_OBJECT , "}" ) ; 
return new JsonToken ( JsonTokenType . BEGIN_ARRAY , "[" ) ; 
case ']' : 
return new JsonToken ( JsonTokenType . END_ARRAY , "]" ) ; 
return new JsonToken ( JsonTokenType . LEFT_PAREN , "(" ) ; 
case ')' : 
return new JsonToken ( JsonTokenType . RIGHT_PAREN , ")" ) ; 
return new JsonToken ( JsonTokenType . COLON , ":" ) ; 
return new JsonToken ( JsonTokenType . COMMA , "," ) ; 
return scanString ( ( char ) c ) ; 
return scanRegularExpression ( ) ; 
if ( c == '-' || Character . isDigit ( c ) ) { 
return scanNumber ( ( char ) c ) ; 
} else if ( c == '$' || c == '_' || Character . isLetter ( c ) ) { 
return scanUnquotedString ( ( char ) c ) ; 
int position = buffer . getPosition ( ) ; 
buffer . unread ( c ) ; 
} private JsonToken scanRegularExpression ( ) { 
StringBuilder patternBuilder = new StringBuilder ( ) ; 
StringBuilder optionsBuilder = new StringBuilder ( ) ; 
RegularExpressionState state = RegularExpressionState . IN_PATTERN ; 
case IN_PATTERN : 
state = RegularExpressionState . INVALID ; 
state = RegularExpressionState . IN_OPTIONS ; 
state = RegularExpressionState . IN_ESCAPE_SEQUENCE ; 
state = RegularExpressionState . IN_PATTERN ; 
case IN_ESCAPE_SEQUENCE : 
case IN_OPTIONS : 
case 'm' : 
state = RegularExpressionState . DONE ; 
BsonRegularExpression regex 
= new BsonRegularExpression ( patternBuilder . toString ( ) , optionsBuilder . toString ( ) ) ; 
return new JsonToken ( JsonTokenType . REGULAR_EXPRESSION , regex ) ; 
case INVALID : 
if ( c != '/' ) { 
optionsBuilder . append ( ( char ) c ) ; 
patternBuilder . append ( ( char ) c ) ; 
} private JsonToken scanUnquotedString ( final char firstChar ) { 
sb . append ( firstChar ) ; 
while ( c == '$' || c == '_' || Character . isLetterOrDigit ( c ) ) { 
sb . append ( ( char ) c ) ; 
String lexeme = sb . toString ( ) ; 
return new JsonToken ( JsonTokenType . UNQUOTED_STRING , lexeme ) ; 
} private JsonToken scanNumber ( final char firstChar ) { 
int c = firstChar ; 
NumberState state ; 
state = NumberState . SAW_LEADING_MINUS ; 
case '0' : 
state = NumberState . SAW_LEADING_ZERO ; 
state = NumberState . SAW_INTEGER_DIGITS ; 
JsonTokenType type = JsonTokenType . INT64 ; 
case SAW_LEADING_MINUS : 
state = NumberState . SAW_MINUS_I ; 
if ( Character . isDigit ( c ) ) { 
state = NumberState . INVALID ; 
case SAW_LEADING_ZERO : 
case '.' : 
state = NumberState . SAW_DECIMAL_POINT ; 
case 'E' : 
state = NumberState . SAW_EXPONENT_LETTER ; 
state = NumberState . DONE ; 
} else if ( Character . isWhitespace ( c ) ) { 
case SAW_INTEGER_DIGITS : 
case SAW_DECIMAL_POINT : 
type = JsonTokenType . DOUBLE ; 
state = NumberState . SAW_FRACTION_DIGITS ; 
case SAW_FRACTION_DIGITS : 
case SAW_EXPONENT_LETTER : 
case '+' : 
state = NumberState . SAW_EXPONENT_SIGN ; 
state = NumberState . SAW_EXPONENT_DIGITS ; 
case SAW_EXPONENT_SIGN : 
case SAW_EXPONENT_DIGITS : 
case SAW_MINUS_I : 
boolean sawMinusInfinity = true ; 
char [ ] nfinity = new char [ ] { 'n' , 'f' , 'i' , 'n' , 'i' , 't' , 'y' } ; 
for ( int i = 0 ; i < nfinity . length ; i ++ ) { 
if ( c != nfinity [ i ] ) { 
sawMinusInfinity = false ; 
if ( sawMinusInfinity ) { 
if ( type == JsonTokenType . DOUBLE ) { 
return new JsonToken ( JsonTokenType . DOUBLE , Double . parseDouble ( lexeme ) ) ; 
long value = Long . parseLong ( lexeme ) ; 
if ( value < Integer . MIN_VALUE || value > Integer . MAX_VALUE ) { 
return new JsonToken ( JsonTokenType . INT64 , value ) ; 
return new JsonToken ( JsonTokenType . INT32 , ( int ) value ) ; 
} private JsonToken scanString ( final char quoteCharacter ) { 
sb . append ( '\'' ) ; 
sb . append ( '"' ) ; 
sb . append ( '\\' ) ; 
sb . append ( '/' ) ; 
sb . append ( '\b' ) ; 
sb . append ( '\f' ) ; 
sb . append ( '\r' ) ; 
sb . append ( '\t' ) ; 
int u1 = buffer . read ( ) ; 
int u2 = buffer . read ( ) ; 
int u3 = buffer . read ( ) ; 
int u4 = buffer . read ( ) ; 
if ( u4 != - 1 ) { 
String hex = new String ( new char [ ] { ( char ) u1 , ( char ) u2 , ( char ) u3 , ( char ) u4 } ) ; 
sb . append ( ( char ) Integer . parseInt ( hex , 16 ) ) ; 
if ( c == quoteCharacter ) { 
return new JsonToken ( JsonTokenType . STRING , sb . toString ( ) ) ; 
if ( c != - 1 ) { 
public BsonDocument execute ( final WriteBinding binding ) { 
return withConnection ( binding , new CallableWithConnection < BsonDocument > ( ) { 
public BsonDocument call ( final Connection connection ) { 
if ( serverIsAtLeastVersionThreeDotTwo ( connection . getDescription ( ) ) ) { 
return executeCommand ( binding , "admin" , FSYNC_UNLOCK_COMMAND , connection ) ; 
return queryUnlock ( connection ) ; 
} public static void main ( final String [ ] args ) throws InterruptedException { 
final CountDownLatch dropLatch = new CountDownLatch ( 1 ) ; 
collection . drop ( new SingleResultCallback < Void > ( ) { 
public void onResult ( final Void result , final Throwable t ) { 
dropLatch . countDown ( ) ; 
dropLatch . await ( ) ; 
SingleResultCallback < Void > callbackWhenFinished = new SingleResultCallback < Void > ( ) { 
mongoClient . listDatabaseNames ( ) . forEach ( new Block < String > ( ) { 
public void apply ( final String s ) { 
} , callbackWhenFinished ) ; 
mongoClient . getDatabase ( "databaseToBeDropped" ) . drop ( callbackWhenFinished ) ; 
database . createCollection ( "cappedCollection" , new CreateCollectionOptions ( ) . capped ( true ) . sizeInBytes ( 0x100000 ) , 
callbackWhenFinished ) ; 
database . listCollectionNames ( ) . forEach ( new Block < String > ( ) { 
public void apply ( final String databaseName ) { 
System . out . println ( databaseName ) ; 
collection . drop ( callbackWhenFinished ) ; 
collection . createIndex ( Indexes . ascending ( "i" ) , new SingleResultCallback < String > ( ) { 
public void onResult ( final String result , final Throwable t ) { 
Block < Document > printDocumentBlock = new Block < Document > ( ) { 
public void apply ( final Document document ) { 
System . out . println ( document . toJson ( ) ) ; 
collection . listIndexes ( ) . forEach ( printDocumentBlock , callbackWhenFinished ) ; 
collection . createIndex ( Indexes . text ( "content" ) , new SingleResultCallback < String > ( ) { 
public void onResult ( final Long matchCount , final Throwable t ) { 
collection . countDocuments ( textSearch , new SingleResultCallback < Long > ( ) { 
collection . find ( textSearch ) . projection ( projection ) . first ( new SingleResultCallback < Document > ( ) { 
public void onResult ( final Document highest , final Throwable t ) { 
database . runCommand ( new Document ( "buildInfo" , 1 ) , new SingleResultCallback < Document > ( ) { 
public void onResult ( final Document buildInfo , final Throwable t ) { 
database . drop ( callbackWhenFinished ) ; 
} public final List < ServerDescription > choose ( final ClusterDescription clusterDescription ) { 
switch ( clusterDescription . getType ( ) ) { 
case REPLICA_SET : 
return chooseForReplicaSet ( clusterDescription ) ; 
case SHARDED : 
case STANDALONE : 
return chooseForNonReplicaSet ( clusterDescription ) ; 
case UNKNOWN : 
} public static ReadPreference primaryPreferred ( final long maxStaleness , final TimeUnit timeUnit ) { 
return new PrimaryPreferredReadPreference ( Collections . < TagSet > emptyList ( ) , maxStaleness , timeUnit ) ; 
} public static ReadPreference secondary ( final long maxStaleness , final TimeUnit timeUnit ) { 
return new SecondaryReadPreference ( Collections . < TagSet > emptyList ( ) , maxStaleness , timeUnit ) ; 
} public static ReadPreference secondaryPreferred ( final long maxStaleness , final TimeUnit timeUnit ) { 
return new SecondaryPreferredReadPreference ( Collections . < TagSet > emptyList ( ) , maxStaleness , timeUnit ) ; 
} public static ReadPreference nearest ( final long maxStaleness , final TimeUnit timeUnit ) { 
return new NearestReadPreference ( Collections . < TagSet > emptyList ( ) , maxStaleness , timeUnit ) ; 
} public static TaggableReadPreference primaryPreferred ( final TagSet tagSet , 
final long maxStaleness , final TimeUnit timeUnit ) { 
return new PrimaryPreferredReadPreference ( singletonList ( tagSet ) , maxStaleness , timeUnit ) ; 
} public static TaggableReadPreference secondary ( final TagSet tagSet , 
return new SecondaryReadPreference ( singletonList ( tagSet ) , maxStaleness , timeUnit ) ; 
} public static TaggableReadPreference secondaryPreferred ( final TagSet tagSet , 
return new SecondaryPreferredReadPreference ( singletonList ( tagSet ) , maxStaleness , timeUnit ) ; 
} public static TaggableReadPreference nearest ( final TagSet tagSet , 
return new NearestReadPreference ( singletonList ( tagSet ) , maxStaleness , timeUnit ) ; 
} public static TaggableReadPreference primaryPreferred ( final List < TagSet > tagSetList , 
return new PrimaryPreferredReadPreference ( tagSetList , maxStaleness , timeUnit ) ; 
} public static TaggableReadPreference secondary ( final List < TagSet > tagSetList , 
return new SecondaryReadPreference ( tagSetList , maxStaleness , timeUnit ) ; 
} public static TaggableReadPreference secondaryPreferred ( final List < TagSet > tagSetList , 
return new SecondaryPreferredReadPreference ( tagSetList , maxStaleness , timeUnit ) ; 
} public static TaggableReadPreference nearest ( final List < TagSet > tagSetList , 
return new NearestReadPreference ( tagSetList , maxStaleness , timeUnit ) ; 
} public static ReadPreference valueOf ( final String name ) { 
notNull ( "name" , name ) ; 
String nameToCheck = name . toLowerCase ( ) ; 
if ( nameToCheck . equals ( PRIMARY . getName ( ) . toLowerCase ( ) ) ) { 
return PRIMARY ; 
if ( nameToCheck . equals ( SECONDARY . getName ( ) . toLowerCase ( ) ) ) { 
return SECONDARY ; 
if ( nameToCheck . equals ( SECONDARY_PREFERRED . getName ( ) . toLowerCase ( ) ) ) { 
return SECONDARY_PREFERRED ; 
if ( nameToCheck . equals ( PRIMARY_PREFERRED . getName ( ) . toLowerCase ( ) ) ) { 
return PRIMARY_PREFERRED ; 
if ( nameToCheck . equals ( NEAREST . getName ( ) . toLowerCase ( ) ) ) { 
return NEAREST ; 
} public static TaggableReadPreference valueOf ( final String name , final List < TagSet > tagSetList ) { 
return valueOf ( name , tagSetList , null , MILLISECONDS ) ; 
} public static TaggableReadPreference valueOf ( final String name , final List < TagSet > tagSetList , final long maxStaleness , 
final TimeUnit timeUnit ) { 
return valueOf ( name , tagSetList , ( Long ) maxStaleness , timeUnit ) ; 
} public void zeroRemaining ( ) { 
( ( Buffer ) buffer ) . mark ( ) ; 
buffer . put ( ZEROS , 0 , buffer . remaining ( ) ) ; 
( ( Buffer ) buffer ) . reset ( ) ; 
} public void zero ( ) { 
( ( Buffer ) buffer ) . position ( 0 ) ; 
} public static void readFully ( final InputStream inputStream , final byte [ ] buffer ) 
readFully ( inputStream , buffer , buffer . length ) ; 
} public static void readFully ( final InputStream inputStream , final byte [ ] buffer , final int offset , final int length ) 
if ( buffer . length < length + offset ) { 
int arrayOffset = offset ; 
int bytesToRead = length ; 
while ( bytesToRead > 0 ) { 
int bytesRead = inputStream . read ( buffer , arrayOffset , bytesToRead ) ; 
if ( bytesRead < 0 ) { 
bytesToRead -= bytesRead ; 
arrayOffset += bytesRead ; 
} public static int readInt ( final InputStream inputStream , final byte [ ] buffer ) throws IOException { 
readFully ( inputStream , buffer , 4 ) ; 
return readInt ( buffer ) ; 
} public static int readInt ( final byte [ ] buffer , final int offset ) { 
int x = 0 ; 
x |= ( 0xFF & buffer [ offset + 0 ] ) << 0 ; 
x |= ( 0xFF & buffer [ offset + 1 ] ) << 8 ; 
x |= ( 0xFF & buffer [ offset + 2 ] ) << 16 ; 
x |= ( 0xFF & buffer [ offset + 3 ] ) << 24 ; 
} public static int readIntBE ( final byte [ ] buffer , final int offset ) { 
x |= ( 0xFF & buffer [ offset + 0 ] ) << 24 ; 
x |= ( 0xFF & buffer [ offset + 1 ] ) << 16 ; 
x |= ( 0xFF & buffer [ offset + 2 ] ) << 8 ; 
x |= ( 0xFF & buffer [ offset + 3 ] ) << 0 ; 
} public static long readLong ( final InputStream inputStream , final byte [ ] buffer ) throws IOException { 
readFully ( inputStream , buffer , 8 ) ; 
return readLong ( buffer ) ; 
} private Map < String , List < String > > combineOptionsMaps ( final Map < String , List < String > > txtRecordsOptionsMap , 
final Map < String , List < String > > connectionStringOptionsMap ) { 
Map < String , List < String > > combinedOptionsMaps = new HashMap < String , List < String > > ( txtRecordsOptionsMap ) ; 
for ( Map . Entry < String , List < String > > entry : connectionStringOptionsMap . entrySet ( ) ) { 
combinedOptionsMaps . put ( entry . getKey ( ) , entry . getValue ( ) ) ; 
return combinedOptionsMaps ; 
public List < MongoCredential > getCredentialList ( ) { 
return credential != null ? singletonList ( credential ) : Collections . < MongoCredential > emptyList ( ) ; 
} private ClusterableServer getRandomServer ( final List < ServerDescription > serverDescriptions ) { 
while ( ! serverDescriptions . isEmpty ( ) ) { 
int serverPos = getRandom ( ) . nextInt ( serverDescriptions . size ( ) ) ; 
ClusterableServer server = getServer ( serverDescriptions . get ( serverPos ) . getAddress ( ) ) ; 
return server ; 
serverDescriptions . remove ( serverPos ) ; 
} private Random getRandom ( ) { 
Random result = random . get ( ) ; 
result = new Random ( ) ; 
random . set ( result ) ; 
public static MongoClient create ( final MongoClientSettings settings , @ Nullable final MongoDriverInformation mongoDriverInformation ) { 
return create ( settings , mongoDriverInformation , null ) ; 
} public static MongoClient create ( final ConnectionString connectionString , 
@ Nullable final MongoDriverInformation mongoDriverInformation ) { 
return create ( MongoClientSettings . builder ( ) . applyConnectionString ( connectionString ) . build ( ) , 
mongoDriverInformation , connectionString . getStreamType ( ) ) ; 
} public static MongoClient create ( final com . mongodb . MongoClientSettings settings , 
return create ( MongoClientSettings . createFromClientSettings ( settings ) , mongoDriverInformation , null ) ; 
} public Object copy ( ) { 
BasicDBList newobj = new BasicDBList ( ) ; 
for ( int i = 0 ; i < size ( ) ; ++ i ) { 
Object val = get ( i ) ; 
if ( val instanceof BasicDBObject ) { 
val = ( ( BasicDBObject ) val ) . copy ( ) ; 
} else if ( val instanceof BasicDBList ) { 
val = ( ( BasicDBList ) val ) . copy ( ) ; 
newobj . add ( val ) ; 
return newobj ; 
} public static < S > ClassModelBuilder < S > builder ( final Class < S > type ) { 
return new ClassModelBuilder < S > ( type ) ; 
} public PropertyModel < ? > getPropertyModel ( final String propertyName ) { 
for ( PropertyModel < ? > propertyModel : propertyModels ) { 
if ( propertyModel . getName ( ) . equals ( propertyName ) ) { 
return propertyModel ; 
} public FindOneAndReplaceOptions maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
this . maxTimeMS = MILLISECONDS . convert ( maxTime , timeUnit ) ; 
public Object getObjectInstance ( final Object obj , final Name name , final Context nameCtx , final Hashtable < ? , ? > environment ) 
String connectionString = null ; 
if ( environment . get ( CONNECTION_STRING ) instanceof String ) { 
connectionString = ( String ) environment . get ( CONNECTION_STRING ) ; 
if ( connectionString == null || connectionString . isEmpty ( ) ) { 
if ( obj instanceof Reference ) { 
Enumeration < RefAddr > props = ( ( Reference ) obj ) . getAll ( ) ; 
while ( props . hasMoreElements ( ) ) { 
RefAddr addr = props . nextElement ( ) ; 
if ( addr != null ) { 
if ( CONNECTION_STRING . equals ( addr . getType ( ) ) ) { 
if ( addr . getContent ( ) instanceof String ) { 
connectionString = ( String ) addr . getContent ( ) ; 
MongoClientURI uri = new MongoClientURI ( connectionString ) ; 
return new MongoClient ( uri ) ; 
} public DBCollection getCollection ( final String name ) { 
DBCollection collection = collectionCache . get ( name ) ; 
collection = new DBCollection ( name , this , executor ) ; 
if ( mongo . getMongoClientOptions ( ) . getDbDecoderFactory ( ) != DefaultDBDecoder . FACTORY ) { 
collection . setDBDecoderFactory ( mongo . getMongoClientOptions ( ) . getDbDecoderFactory ( ) ) ; 
if ( mongo . getMongoClientOptions ( ) . getDbEncoderFactory ( ) != DefaultDBEncoder . FACTORY ) { 
collection . setDBEncoderFactory ( mongo . getMongoClientOptions ( ) . getDbEncoderFactory ( ) ) ; 
DBCollection old = collectionCache . putIfAbsent ( name , collection ) ; 
return old != null ? old : collection ; 
} public void dropDatabase ( ) { 
getExecutor ( ) . execute ( new DropDatabaseOperation ( getName ( ) , getWriteConcern ( ) ) , getReadConcern ( ) ) ; 
} catch ( MongoWriteConcernException e ) { 
throw createWriteConcernException ( e ) ; 
} public Set < String > getCollectionNames ( ) { 
List < String > collectionNames = 
new MongoIterableImpl < DBObject > ( null , executor , ReadConcern . DEFAULT , primary ( ) , 
mongo . getMongoClientOptions ( ) . getRetryReads ( ) ) { 
public ReadOperation < BatchCursor < DBObject > > asReadOperation ( ) { 
return new ListCollectionsOperation < DBObject > ( name , commandCodec ) 
. nameOnly ( true ) ; 
} . map ( new Function < DBObject , String > ( ) { 
public String apply ( final DBObject result ) { 
return ( String ) result . get ( "name" ) ; 
} ) . into ( new ArrayList < String > ( ) ) ; 
Collections . sort ( collectionNames ) ; 
return new LinkedHashSet < String > ( collectionNames ) ; 
} public DBCollection createCollection ( final String collectionName , @ Nullable final DBObject options ) { 
if ( options != null ) { 
executor . execute ( getCreateCollectionOperation ( collectionName , options ) , getReadConcern ( ) ) ; 
return getCollection ( collectionName ) ; 
} public DBCollection createView ( final String viewName , final String viewOn , final List < ? extends DBObject > pipeline ) { 
return createView ( viewName , viewOn , pipeline , new DBCreateViewOptions ( ) ) ; 
} public DBCollection createView ( final String viewName , final String viewOn , final List < ? extends DBObject > pipeline , 
final DBCreateViewOptions options ) { 
notNull ( "options" , options ) ; 
DBCollection view = getCollection ( viewName ) ; 
executor . execute ( new CreateViewOperation ( name , viewName , viewOn , view . preparePipeline ( pipeline ) , writeConcern ) 
. collation ( options . getCollation ( ) ) , getReadConcern ( ) ) ; 
} public CommandResult command ( final String command ) { 
return command ( new BasicDBObject ( command , Boolean . TRUE ) , getReadPreference ( ) ) ; 
} public CommandResult command ( final DBObject command , final DBEncoder encoder ) { 
return command ( command , getReadPreference ( ) , encoder ) ; 
} public CommandResult command ( final DBObject command , final ReadPreference readPreference , @ Nullable final DBEncoder encoder ) { 
return executeCommand ( wrap ( command , encoder ) , getCommandReadPreference ( command , readPreference ) ) ; 
} catch ( MongoCommandException ex ) { 
return new CommandResult ( ex . getResponse ( ) , ex . getServerAddress ( ) ) ; 
} public CommandResult command ( final DBObject command , final ReadPreference readPreference ) { 
return command ( command , readPreference , null ) ; 
} public CommandResult command ( final String command , final ReadPreference readPreference ) { 
return command ( new BasicDBObject ( command , true ) , readPreference ) ; 
} public boolean collectionExists ( final String collectionName ) { 
Set < String > collectionNames = getCollectionNames ( ) ; 
for ( final String name : collectionNames ) { 
if ( name . equalsIgnoreCase ( collectionName ) ) { 
public CommandResult doEval ( final String code , final Object ... args ) { 
DBObject commandDocument = new BasicDBObject ( "$eval" , code ) . append ( "args" , asList ( args ) ) ; 
return executeCommand ( wrap ( commandDocument ) ) ; 
public Object eval ( final String code , final Object ... args ) { 
CommandResult result = doEval ( code , args ) ; 
result . throwOnError ( ) ; 
return result . get ( "retval" ) ; 
public CommandResult getStats ( ) { 
BsonDocument commandDocument = new BsonDocument ( "dbStats" , new BsonInt32 ( 1 ) ) . append ( "scale" , new BsonInt32 ( 1 ) ) ; 
return executeCommand ( commandDocument ) ; 
public WriteResult addUser ( final String userName , final char [ ] password ) { 
return addUser ( userName , password , false ) ; 
public WriteResult addUser ( final String userName , final char [ ] password , final boolean readOnly ) { 
MongoCredential credential = createCredential ( userName , getName ( ) , password ) ; 
boolean userExists = false ; 
userExists = executor . execute ( new com . mongodb . operation . UserExistsOperation ( getName ( ) , userName ) , primary ( ) , getReadConcern ( ) ) ; 
} catch ( MongoCommandException e ) { 
if ( e . getCode ( ) != 13 ) { 
if ( userExists ) { 
executor . execute ( new com . mongodb . operation . UpdateUserOperation ( credential , readOnly , getWriteConcern ( ) ) , getReadConcern ( ) ) ; 
return new WriteResult ( 1 , true , null ) ; 
executor . execute ( new com . mongodb . operation . CreateUserOperation ( credential , readOnly , getWriteConcern ( ) ) , getReadConcern ( ) ) ; 
return new WriteResult ( 1 , false , null ) ; 
public WriteResult removeUser ( final String userName ) { 
executor . execute ( new com . mongodb . operation . DropUserOperation ( getName ( ) , userName , getWriteConcern ( ) ) , getReadConcern ( ) ) ; 
} ReadPreference getCommandReadPreference ( final DBObject command , @ Nullable final ReadPreference requestedPreference ) { 
String comString = command . keySet ( ) . iterator ( ) . next ( ) . toLowerCase ( ) ; 
boolean primaryRequired = ! OBEDIENT_COMMANDS . contains ( comString ) ; 
if ( primaryRequired ) { 
return ReadPreference . primary ( ) ; 
} else if ( requestedPreference == null ) { 
return requestedPreference ; 
} public static void main ( final String [ ] args ) throws FileNotFoundException , IOException { 
GridFSBucket gridFSBucket = GridFSBuckets . create ( database ) ; 
GridFSUploadOptions options = new GridFSUploadOptions ( ) 
. chunkSizeBytes ( 1024 ) 
. metadata ( new Document ( "type" , "presentation" ) ) ; 
ObjectId fileId = gridFSBucket . uploadFromStream ( "mongodb-tutorial" , streamToUploadFrom , options ) ; 
streamToUploadFrom . close ( ) ; 
GridFSUploadStream uploadStream = gridFSBucket . openUploadStream ( "sampleData" ) ; 
uploadStream . write ( data ) ; 
uploadStream . close ( ) ; 
gridFSBucket . find ( ) . forEach ( new Block < GridFSFile > ( ) { 
public void apply ( final GridFSFile gridFSFile ) { 
System . out . println ( gridFSFile . getFilename ( ) ) ; 
gridFSBucket . find ( eq ( "metadata.contentType" , "image/png" ) ) . forEach ( 
new Block < GridFSFile > ( ) { 
FileOutputStream streamToDownloadTo = new FileOutputStream ( "/tmp/mongodb-tutorial.txt" ) ; 
gridFSBucket . downloadToStream ( fileId , streamToDownloadTo ) ; 
streamToDownloadTo . close ( ) ; 
streamToDownloadTo = new FileOutputStream ( "/tmp/mongodb-tutorial.txt" ) ; 
GridFSDownloadOptions downloadOptions = new GridFSDownloadOptions ( ) . revision ( 0 ) ; 
gridFSBucket . downloadToStream ( "mongodb-tutorial" , streamToDownloadTo , downloadOptions ) ; 
GridFSDownloadStream downloadStream = gridFSBucket . openDownloadStream ( fileId ) ; 
int fileLength = ( int ) downloadStream . getGridFSFile ( ) . getLength ( ) ; 
byte [ ] bytesToWriteTo = new byte [ fileLength ] ; 
downloadStream . read ( bytesToWriteTo ) ; 
downloadStream . close ( ) ; 
System . out . println ( new String ( bytesToWriteTo , StandardCharsets . UTF_8 ) ) ; 
downloadStream = gridFSBucket . openDownloadStream ( "sampleData" ) ; 
fileLength = ( int ) downloadStream . getGridFSFile ( ) . getLength ( ) ; 
bytesToWriteTo = new byte [ fileLength ] ; 
gridFSBucket . rename ( fileId , "mongodbTutorial" ) ; 
gridFSBucket . delete ( fileId ) ; 
} public static CodecRegistry fromRegistries ( final List < ? extends CodecRegistry > registries ) { 
List < CodecProvider > providers = new ArrayList < CodecProvider > ( ) ; 
for ( CodecRegistry registry : registries ) { 
providers . add ( providerFromRegistry ( registry ) ) ; 
return new ProvidersCodecRegistry ( providers ) ; 
} public < U > Codec < U > get ( final Class < U > clazz ) { 
if ( hasCycles ( clazz ) ) { 
return new LazyCodec < U > ( registry , clazz ) ; 
return registry . get ( new ChildCodecRegistry < U > ( this , clazz ) ) ; 
} public WriteResult insert ( final DBObject document , final WriteConcern writeConcern ) { 
return insert ( asList ( document ) , writeConcern ) ; 
} public WriteResult insert ( final DBObject [ ] documents , final WriteConcern writeConcern ) { 
return insert ( asList ( documents ) , writeConcern ) ; 
} public WriteResult insert ( final List < ? extends DBObject > documents , final WriteConcern aWriteConcern ) { 
return insert ( documents , aWriteConcern , null ) ; 
} public WriteResult insert ( final DBObject [ ] documents , final WriteConcern aWriteConcern , final DBEncoder encoder ) { 
return insert ( asList ( documents ) , aWriteConcern , encoder ) ; 
} public WriteResult insert ( final List < ? extends DBObject > documents , final WriteConcern aWriteConcern , 
@ Nullable final DBEncoder dbEncoder ) { 
return insert ( documents , new InsertOptions ( ) . writeConcern ( aWriteConcern ) . dbEncoder ( dbEncoder ) ) ; 
} public WriteResult insert ( final List < ? extends DBObject > documents , final InsertOptions insertOptions ) { 
WriteConcern writeConcern = insertOptions . getWriteConcern ( ) != null ? insertOptions . getWriteConcern ( ) : getWriteConcern ( ) ; 
Encoder < DBObject > encoder = toEncoder ( insertOptions . getDbEncoder ( ) ) ; 
List < InsertRequest > insertRequestList = new ArrayList < InsertRequest > ( documents . size ( ) ) ; 
for ( DBObject cur : documents ) { 
if ( cur . get ( ID_FIELD_NAME ) == null ) { 
cur . put ( ID_FIELD_NAME , new ObjectId ( ) ) ; 
insertRequestList . add ( new InsertRequest ( new BsonDocumentWrapper < DBObject > ( cur , encoder ) ) ) ; 
return insert ( insertRequestList , writeConcern , insertOptions . isContinueOnError ( ) , insertOptions . getBypassDocumentValidation ( ) ) ; 
} public WriteResult save ( final DBObject document , final WriteConcern writeConcern ) { 
Object id = document . get ( ID_FIELD_NAME ) ; 
return insert ( document , writeConcern ) ; 
return replaceOrInsert ( document , id , writeConcern ) ; 
} public WriteResult update ( final DBObject query , final DBObject update , final boolean upsert , final boolean multi , 
final WriteConcern aWriteConcern ) { 
return update ( query , update , upsert , multi , aWriteConcern , null ) ; 
final WriteConcern concern , @ Nullable final DBEncoder encoder ) { 
return update ( query , update , upsert , multi , concern , null , encoder ) ; 
final WriteConcern concern , @ Nullable final Boolean bypassDocumentValidation , 
@ Nullable final DBEncoder encoder ) { 
return update ( query , update , new DBCollectionUpdateOptions ( ) . upsert ( upsert ) . multi ( multi ) 
. writeConcern ( concern ) . bypassDocumentValidation ( bypassDocumentValidation ) . encoder ( encoder ) ) ; 
} public WriteResult update ( final DBObject query , final DBObject update , final boolean upsert , final boolean multi ) { 
return update ( query , update , upsert , multi , getWriteConcern ( ) ) ; 
} public WriteResult update ( final DBObject query , final DBObject update ) { 
return update ( query , update , false , false ) ; 
} public WriteResult updateMulti ( final DBObject query , final DBObject update ) { 
return update ( query , update , false , true ) ; 
} public WriteResult update ( final DBObject query , final DBObject update , final DBCollectionUpdateOptions options ) { 
notNull ( "query" , query ) ; 
notNull ( "update" , update ) ; 
WriteConcern writeConcern = options . getWriteConcern ( ) != null ? options . getWriteConcern ( ) : getWriteConcern ( ) ; 
com . mongodb . bulk . WriteRequest . Type updateType = ! update . keySet ( ) . isEmpty ( ) && update . keySet ( ) . iterator ( ) . next ( ) . startsWith ( "$" ) 
? com . mongodb . bulk . WriteRequest . Type . UPDATE 
: com . mongodb . bulk . WriteRequest . Type . REPLACE ; 
UpdateRequest updateRequest = new UpdateRequest ( wrap ( query ) , wrap ( update , options . getEncoder ( ) ) , updateType ) 
. upsert ( options . isUpsert ( ) ) . multi ( options . isMulti ( ) ) 
. collation ( options . getCollation ( ) ) 
. arrayFilters ( wrapAllowNull ( options . getArrayFilters ( ) , options . getEncoder ( ) ) ) ; 
return executeWriteOperation ( new UpdateOperation ( getNamespace ( ) , true , writeConcern , retryWrites , 
singletonList ( updateRequest ) ) . bypassDocumentValidation ( options . getBypassDocumentValidation ( ) ) ) ; 
} public WriteResult remove ( final DBObject query , final WriteConcern writeConcern ) { 
return remove ( query , new DBCollectionRemoveOptions ( ) . writeConcern ( writeConcern ) ) ; 
} public WriteResult remove ( final DBObject query , final WriteConcern writeConcern , final DBEncoder encoder ) { 
return remove ( query , new DBCollectionRemoveOptions ( ) . writeConcern ( writeConcern ) . encoder ( encoder ) ) ; 
} public WriteResult remove ( final DBObject query , final DBCollectionRemoveOptions options ) { 
DeleteRequest deleteRequest = new DeleteRequest ( wrap ( query , options . getEncoder ( ) ) ) . collation ( options . getCollation ( ) ) ; 
return executeWriteOperation ( new DeleteOperation ( getNamespace ( ) , false , writeConcern , retryWrites , 
singletonList ( deleteRequest ) ) ) ; 
public DBCursor find ( final DBObject query , final DBObject projection , final int numToSkip , final int batchSize ) { 
return new DBCursor ( this , query , projection , getReadPreference ( ) ) . batchSize ( batchSize ) . skip ( numToSkip ) ; 
} public DBCursor find ( final DBObject query , final DBObject projection ) { 
return new DBCursor ( this , query , projection , getReadPreference ( ) ) ; 
} public DBCursor find ( @ Nullable final DBObject query , final DBCollectionFindOptions options ) { 
return new DBCursor ( this , query , options ) ; 
public DBObject findOne ( final DBObject query ) { 
return findOne ( query , null , null , getReadPreference ( ) ) ; 
public DBObject findOne ( final DBObject query , final DBObject projection ) { 
return findOne ( query , projection , null , getReadPreference ( ) ) ; 
public DBObject findOne ( final DBObject query , final DBObject projection , final DBObject sort ) { 
return findOne ( query , projection , sort , getReadPreference ( ) ) ; 
public DBObject findOne ( final DBObject query , final DBObject projection , final ReadPreference readPreference ) { 
return findOne ( query , projection , null , readPreference ) ; 
public DBObject findOne ( @ Nullable final DBObject query , @ Nullable final DBObject projection , @ Nullable final DBObject sort , 
final ReadPreference readPreference ) { 
return findOne ( query != null ? query : new BasicDBObject ( ) , 
new DBCollectionFindOptions ( ) . projection ( projection ) . sort ( sort ) . readPreference ( readPreference ) ) ; 
public DBObject findOne ( final Object id , final DBObject projection ) { 
return findOne ( new BasicDBObject ( "_id" , id ) , new DBCollectionFindOptions ( ) . projection ( projection ) ) ; 
public DBObject findOne ( @ Nullable final DBObject query , final DBCollectionFindOptions findOptions ) { 
return find ( query , findOptions ) . one ( ) ; 
} public long count ( @ Nullable final DBObject query , final ReadPreference readPreference ) { 
return getCount ( query , null , readPreference ) ; 
public long getCount ( @ Nullable final DBObject query , final DBObject projection ) { 
return getCount ( query , projection , 0 , 0 ) ; 
public long getCount ( @ Nullable final DBObject query , @ Nullable final DBObject projection , final ReadPreference readPreference ) { 
return getCount ( query , projection , 0 , 0 , readPreference ) ; 
public long getCount ( @ Nullable final DBObject query , @ Nullable final DBObject projection , final long limit , final long skip ) { 
return getCount ( query , projection , limit , skip , getReadPreference ( ) ) ; 
public long getCount ( @ Nullable final DBObject query , @ Nullable final DBObject projection , final long limit , final long skip , 
return getCount ( query , new DBCollectionCountOptions ( ) . limit ( limit ) . skip ( skip ) . readPreference ( readPreference ) ) ; 
} public long getCount ( @ Nullable final DBObject query , final DBCollectionCountOptions options ) { 
notNull ( "countOptions" , options ) ; 
CountOperation operation = new CountOperation ( getNamespace ( ) ) 
. skip ( options . getSkip ( ) ) 
. limit ( options . getLimit ( ) ) 
. maxTime ( options . getMaxTime ( MILLISECONDS ) , MILLISECONDS ) 
. retryReads ( retryReads ) ; 
operation . filter ( wrap ( query ) ) ; 
DBObject hint = options . getHint ( ) ; 
if ( hint != null ) { 
operation . hint ( wrap ( hint ) ) ; 
String hintString = options . getHintString ( ) ; 
if ( hintString != null ) { 
operation . hint ( new BsonString ( hintString ) ) ; 
ReadPreference optionsReadPreference = options . getReadPreference ( ) ; 
ReadConcern optionsReadConcern = options . getReadConcern ( ) ; 
return executor . execute ( operation , optionsReadPreference != null ? optionsReadPreference : getReadPreference ( ) , 
optionsReadConcern != null ? optionsReadConcern : getReadConcern ( ) ) ; 
} public DBCollection rename ( final String newName , final boolean dropTarget ) { 
executor . execute ( new RenameCollectionOperation ( getNamespace ( ) , 
new MongoNamespace ( getNamespace ( ) . getDatabaseName ( ) , newName ) , getWriteConcern ( ) ) 
. dropTarget ( dropTarget ) , getReadConcern ( ) ) ; 
return getDB ( ) . getCollection ( newName ) ; 
public DBObject group ( final DBObject key , final DBObject cond , final DBObject initial , final String reduce ) { 
return group ( key , cond , initial , reduce , null ) ; 
public DBObject group ( final DBObject key , final DBObject cond , final DBObject initial , final String reduce , 
@ Nullable final String finalize ) { 
return group ( key , cond , initial , reduce , finalize , getReadPreference ( ) ) ; 
@ Nullable final String finalize , final ReadPreference readPreference ) { 
return group ( new GroupCommand ( this , key , cond , initial , reduce , finalize ) , readPreference ) ; 
public DBObject group ( final GroupCommand cmd , final ReadPreference readPreference ) { 
return toDBList ( executor . execute ( cmd . toOperation ( getNamespace ( ) , getDefaultDBObjectCodec ( ) , retryReads ) , readPreference , 
getReadConcern ( ) ) ) ; 
} public List distinct ( final String fieldName , final ReadPreference readPreference ) { 
return distinct ( fieldName , new BasicDBObject ( ) , readPreference ) ; 
} public List distinct ( final String fieldName , final DBObject query ) { 
return distinct ( fieldName , query , getReadPreference ( ) ) ; 
} public List distinct ( final String fieldName , final DBObject query , final ReadPreference readPreference ) { 
return distinct ( fieldName , new DBCollectionDistinctOptions ( ) . filter ( query ) . readPreference ( readPreference ) ) ; 
public List distinct ( final String fieldName , final DBCollectionDistinctOptions options ) { 
notNull ( "fieldName" , fieldName ) ; 
return new MongoIterableImpl < BsonValue > ( null , executor , 
options . getReadConcern ( ) != null ? options . getReadConcern ( ) : getReadConcern ( ) , 
options . getReadPreference ( ) != null ? options . getReadPreference ( ) : getReadPreference ( ) , 
retryReads ) { 
public ReadOperation < BatchCursor < BsonValue > > asReadOperation ( ) { 
return new DistinctOperation < BsonValue > ( getNamespace ( ) , fieldName , new BsonValueCodec ( ) ) 
. filter ( wrapAllowNull ( options . getFilter ( ) ) ) 
} . map ( new Function < BsonValue , Object > ( ) { 
public Object apply ( final BsonValue bsonValue ) { 
if ( bsonValue == null ) { 
BsonDocument document = new BsonDocument ( "value" , bsonValue ) ; 
DBObject obj = getDefaultDBObjectCodec ( ) . decode ( new BsonDocumentReader ( document ) , DecoderContext . builder ( ) . build ( ) ) ; 
return obj . get ( "value" ) ; 
} ) . into ( new ArrayList < Object > ( ) ) ; 
} public MapReduceOutput mapReduce ( final String map , final String reduce , final String outputTarget , 
final MapReduceCommand . OutputType outputType , final DBObject query , 
MapReduceCommand command = new MapReduceCommand ( this , map , reduce , outputTarget , outputType , query ) ; 
command . setReadPreference ( readPreference ) ; 
return mapReduce ( command ) ; 
} public MapReduceOutput mapReduce ( final MapReduceCommand command ) { 
ReadPreference readPreference = command . getReadPreference ( ) == null ? getReadPreference ( ) : command . getReadPreference ( ) ; 
Map < String , Object > scope = command . getScope ( ) ; 
Boolean jsMode = command . getJsMode ( ) ; 
if ( command . getOutputType ( ) == MapReduceCommand . OutputType . INLINE ) { 
MapReduceWithInlineResultsOperation < DBObject > operation = 
new MapReduceWithInlineResultsOperation < DBObject > ( getNamespace ( ) , new BsonJavaScript ( command . getMap ( ) ) , 
new BsonJavaScript ( command . getReduce ( ) ) , getDefaultDBObjectCodec ( ) ) 
. filter ( wrapAllowNull ( command . getQuery ( ) ) ) 
. limit ( command . getLimit ( ) ) 
. maxTime ( command . getMaxTime ( MILLISECONDS ) , MILLISECONDS ) 
. jsMode ( jsMode == null ? false : jsMode ) 
. sort ( wrapAllowNull ( command . getSort ( ) ) ) 
. verbose ( command . isVerbose ( ) ) 
. collation ( command . getCollation ( ) ) ; 
if ( scope != null ) { 
operation . scope ( wrap ( new BasicDBObject ( scope ) ) ) ; 
if ( command . getFinalize ( ) != null ) { 
operation . finalizeFunction ( new BsonJavaScript ( command . getFinalize ( ) ) ) ; 
MapReduceBatchCursor < DBObject > executionResult = executor . execute ( operation , readPreference , getReadConcern ( ) ) ; 
return new MapReduceOutput ( command . toDBObject ( ) , executionResult ) ; 
String action ; 
switch ( command . getOutputType ( ) ) { 
case REPLACE : 
action = "replace" ; 
case MERGE : 
action = "merge" ; 
case REDUCE : 
action = "reduce" ; 
MapReduceToCollectionOperation operation = 
new MapReduceToCollectionOperation ( getNamespace ( ) , 
new BsonJavaScript ( command . getMap ( ) ) , 
new BsonJavaScript ( command . getReduce ( ) ) , 
command . getOutputTarget ( ) , 
getWriteConcern ( ) ) 
. action ( action ) 
. databaseName ( command . getOutputDB ( ) ) 
. bypassDocumentValidation ( command . getBypassDocumentValidation ( ) ) 
MapReduceStatistics mapReduceStatistics = executor . execute ( operation , getReadConcern ( ) ) ; 
DBCollection mapReduceOutputCollection = getMapReduceOutputCollection ( command ) ; 
DBCursor executionResult = mapReduceOutputCollection . find ( ) ; 
return new MapReduceOutput ( command . toDBObject ( ) , executionResult , mapReduceStatistics , mapReduceOutputCollection ) ; 
public AggregationOutput aggregate ( final DBObject firstOp , final DBObject ... additionalOps ) { 
List < DBObject > pipeline = new ArrayList < DBObject > ( ) ; 
pipeline . add ( firstOp ) ; 
Collections . addAll ( pipeline , additionalOps ) ; 
return aggregate ( pipeline ) ; 
public AggregationOutput aggregate ( final List < ? extends DBObject > pipeline , final ReadPreference readPreference ) { 
Cursor cursor = aggregate ( pipeline , AggregationOptions . builder ( ) . build ( ) , readPreference , false ) ; 
if ( cursor == null ) { 
return new AggregationOutput ( Collections . < DBObject > emptyList ( ) ) ; 
List < DBObject > results = new ArrayList < DBObject > ( ) ; 
results . add ( cursor . next ( ) ) ; 
return new AggregationOutput ( results ) ; 
} public Cursor aggregate ( final List < ? extends DBObject > pipeline , final AggregationOptions options ) { 
return aggregate ( pipeline , options , getReadPreference ( ) ) ; 
} public Cursor aggregate ( final List < ? extends DBObject > pipeline , final AggregationOptions options , 
Cursor cursor = aggregate ( pipeline , options , readPreference , true ) ; 
} public CommandResult explainAggregate ( final List < ? extends DBObject > pipeline , final AggregationOptions options ) { 
AggregateOperation < BsonDocument > operation = new AggregateOperation < BsonDocument > ( getNamespace ( ) , preparePipeline ( pipeline ) , 
new BsonDocumentCodec ( ) ) 
. allowDiskUse ( options . getAllowDiskUse ( ) ) 
return new CommandResult ( executor . execute ( operation . asExplainableOperation ( ExplainVerbosity . QUERY_PLANNER ) , primaryPreferred ( ) , 
public List < Cursor > parallelScan ( final ParallelScanOptions options ) { 
List < Cursor > cursors = new ArrayList < Cursor > ( ) ; 
ParallelCollectionScanOperation < DBObject > operation = new ParallelCollectionScanOperation < DBObject > ( getNamespace ( ) , 
options . getNumCursors ( ) , 
objectCodec ) 
. batchSize ( options . getBatchSize ( ) ) . retryReads ( retryReads ) ; 
ReadPreference readPreferenceFromOptions = options . getReadPreference ( ) ; 
List < BatchCursor < DBObject > > mongoCursors = executor . execute ( operation , 
readPreferenceFromOptions != null ? readPreferenceFromOptions 
: getReadPreference ( ) , 
getReadConcern ( ) ) ; 
for ( BatchCursor < DBObject > mongoCursor : mongoCursors ) { 
cursors . add ( new MongoCursorAdapter ( new MongoBatchCursorAdapter < DBObject > ( mongoCursor ) ) ) ; 
return cursors ; 
} public void createIndex ( final DBObject keys , @ Nullable final String name , final boolean unique ) { 
DBObject options = new BasicDBObject ( ) ; 
if ( name != null && name . length ( ) > 0 ) { 
options . put ( "name" , name ) ; 
if ( unique ) { 
options . put ( "unique" , Boolean . TRUE ) ; 
createIndex ( keys , options ) ; 
} public void createIndex ( final DBObject keys , final DBObject options ) { 
executor . execute ( createIndexOperation ( keys , options ) , getReadConcern ( ) ) ; 
public DBObject findAndModify ( @ Nullable final DBObject query , @ Nullable final DBObject sort , final DBObject update ) { 
return findAndModify ( query , null , sort , false , update , false , false ) ; 
public DBObject findAndRemove ( @ Nullable final DBObject query ) { 
return findAndModify ( query , null , null , true , null , false , false ) ; 
public DBObject findAndModify ( @ Nullable final DBObject query , @ Nullable final DBObject fields , @ Nullable final DBObject sort , 
final boolean remove , @ Nullable final DBObject update , 
final boolean returnNew , final boolean upsert ) { 
return findAndModify ( query , fields , sort , remove , update , returnNew , upsert , 0L , MILLISECONDS ) ; 
final boolean returnNew , final boolean upsert , 
final long maxTime , final TimeUnit maxTimeUnit ) { 
return findAndModify ( query , fields , sort , remove , update , returnNew , upsert , maxTime , maxTimeUnit , getWriteConcern ( ) ) ; 
final long maxTime , final TimeUnit maxTimeUnit , 
final WriteConcern writeConcern ) { 
return findAndModify ( query != null ? query : new BasicDBObject ( ) , new DBCollectionFindAndModifyOptions ( ) 
. projection ( fields ) 
. sort ( sort ) 
. remove ( remove ) 
. update ( update ) 
. returnNew ( returnNew ) 
. upsert ( upsert ) 
. maxTime ( maxTime , maxTimeUnit ) 
. writeConcern ( writeConcern ) ) ; 
} public DBObject findAndModify ( final DBObject query , final DBCollectionFindAndModifyOptions options ) { 
WriteConcern optionsWriteConcern = options . getWriteConcern ( ) ; 
WriteConcern writeConcern = optionsWriteConcern != null ? optionsWriteConcern : getWriteConcern ( ) ; 
WriteOperation < DBObject > operation ; 
if ( options . isRemove ( ) ) { 
operation = new FindAndDeleteOperation < DBObject > ( getNamespace ( ) , writeConcern , retryWrites , objectCodec ) 
. filter ( wrapAllowNull ( query ) ) 
. projection ( wrapAllowNull ( options . getProjection ( ) ) ) 
. sort ( wrapAllowNull ( options . getSort ( ) ) ) 
. collation ( options . getCollation ( ) ) ; 
DBObject update = options . getUpdate ( ) ; 
if ( update == null ) { 
if ( ! update . keySet ( ) . isEmpty ( ) && update . keySet ( ) . iterator ( ) . next ( ) . charAt ( 0 ) == '$' ) { 
operation = new FindAndUpdateOperation < DBObject > ( getNamespace ( ) , writeConcern , retryWrites , objectCodec , 
wrap ( update ) ) 
. filter ( wrap ( query ) ) 
. returnOriginal ( ! options . returnNew ( ) ) 
. upsert ( options . isUpsert ( ) ) 
. bypassDocumentValidation ( options . getBypassDocumentValidation ( ) ) 
. arrayFilters ( wrapAllowNull ( options . getArrayFilters ( ) , ( Encoder < DBObject > ) null ) ) ; 
operation = new FindAndReplaceOperation < DBObject > ( getNamespace ( ) , writeConcern , retryWrites , objectCodec , 
return executor . execute ( operation , getReadConcern ( ) ) ; 
} public void drop ( ) { 
executor . execute ( new DropCollectionOperation ( getNamespace ( ) , getWriteConcern ( ) ) , getReadConcern ( ) ) ; 
} public synchronized void setDBDecoderFactory ( @ Nullable final DBDecoderFactory factory ) { 
this . decoderFactory = factory ; 
Decoder < DBObject > decoder = ( factory == null || factory == DefaultDBDecoder . FACTORY ) 
? getDefaultDBObjectCodec ( ) 
: new DBDecoderAdapter ( factory . create ( ) , this , getBufferPool ( ) ) ; 
this . objectCodec = new CompoundDBObjectCodec ( objectCodec . getEncoder ( ) , decoder ) ; 
} public synchronized void setDBEncoderFactory ( @ Nullable final DBEncoderFactory factory ) { 
this . encoderFactory = factory ; 
Encoder < DBObject > encoder = ( factory == null || factory == DefaultDBEncoder . FACTORY ) 
: new DBEncoderFactoryAdapter ( encoderFactory ) ; 
this . objectCodec = new CompoundDBObjectCodec ( encoder , objectCodec . getDecoder ( ) ) ; 
} public List < DBObject > getIndexInfo ( ) { 
return new MongoIterableImpl < DBObject > ( null , executor , ReadConcern . DEFAULT , primary ( ) , retryReads ) { 
return new ListIndexesOperation < DBObject > ( getNamespace ( ) , getDefaultDBObjectCodec ( ) ) . retryReads ( retryReads ) ; 
} . into ( new ArrayList < DBObject > ( ) ) ; 
} public void dropIndex ( final DBObject index ) { 
executor . execute ( new DropIndexOperation ( getNamespace ( ) , wrap ( index ) , getWriteConcern ( ) ) , getReadConcern ( ) ) ; 
executor . execute ( new DropIndexOperation ( getNamespace ( ) , indexName , getWriteConcern ( ) ) , getReadConcern ( ) ) ; 
} public boolean isCapped ( ) { 
CommandResult commandResult = getStats ( ) ; 
Object cappedField = commandResult . get ( "capped" ) ; 
return cappedField != null && ( cappedField . equals ( 1 ) || cappedField . equals ( true ) ) ; 
} public void setInternalClass ( final String path , final Class < ? extends DBObject > aClass ) { 
setObjectFactory ( objectFactory . update ( aClass , asList ( path . split ( "\\." ) ) ) ) ; 
} protected Class < ? extends DBObject > getInternalClass ( final String path ) { 
return objectFactory . getClassForPath ( asList ( path . split ( "\\." ) ) ) ; 
} public static AsyncInputStream toAsyncInputStream ( final ByteBuffer srcByteBuffer ) { 
notNull ( "srcByteBuffer" , srcByteBuffer ) ; 
return new AsyncInputStream ( ) { 
public void read ( final ByteBuffer dstByteBuffer , final SingleResultCallback < Integer > callback ) { 
transferDataFromByteBuffers ( srcByteBuffer , dstByteBuffer , callback ) ; 
public void skip ( final long bytesToSkip , final SingleResultCallback < Long > callback ) { 
notNull ( "callback" , callback ) ; 
callback . onResult ( 0L , null ) ; 
public void close ( final SingleResultCallback < Void > callback ) { 
callback . onResult ( null , null ) ; 
} public static AsyncOutputStream toAsyncOutputStream ( final ByteBuffer dstByteBuffer ) { 
notNull ( "dstByteBuffer" , dstByteBuffer ) ; 
return new AsyncOutputStream ( ) { 
public void write ( final ByteBuffer srcByteBuffer , final SingleResultCallback < Integer > callback ) { 
} public static AsyncInputStream toAsyncInputStream ( final InputStream inputStream ) { 
notNull ( "inputStream" , inputStream ) ; 
notNull ( "dst" , dstByteBuffer ) ; 
if ( ! dstByteBuffer . hasRemaining ( ) ) { 
callback . onResult ( - 1 , null ) ; 
int maxAmount = dstByteBuffer . remaining ( ) ; 
byte [ ] bytes = new byte [ maxAmount ] ; 
int amountRead ; 
amountRead = inputStream . read ( bytes ) ; 
if ( amountRead > 0 ) { 
if ( amountRead < maxAmount ) { 
byte [ ] dataRead = new byte [ amountRead ] ; 
System . arraycopy ( bytes , 0 , dataRead , 0 , amountRead ) ; 
dstByteBuffer . put ( dataRead ) ; 
dstByteBuffer . put ( bytes ) ; 
callback . onResult ( amountRead , null ) ; 
long skipped = inputStream . skip ( bytesToSkip ) ; 
callback . onResult ( skipped , null ) ; 
callback . onResult ( null , t ) ; 
} public static AsyncOutputStream toAsyncOutputStream ( final OutputStream outputStream ) { 
notNull ( "outputStream" , outputStream ) ; 
notNull ( "src" , srcByteBuffer ) ; 
if ( ! srcByteBuffer . hasRemaining ( ) ) { 
int amount = srcByteBuffer . remaining ( ) ; 
byte [ ] bytes = new byte [ amount ] ; 
srcByteBuffer . get ( bytes ) ; 
outputStream . write ( bytes ) ; 
callback . onResult ( amount , null ) ; 
outputStream . close ( ) ; 
CodecRegistry pojoCodecRegistry = fromRegistries ( MongoClients . getDefaultCodecRegistry ( ) , 
fromProviders ( PojoCodecProvider . builder ( ) . automatic ( true ) . build ( ) ) ) ; 
MongoDatabase database = mongoClient . getDatabase ( "mydb" ) . withCodecRegistry ( pojoCodecRegistry ) ; 
final MongoCollection < Person > collection = database . getCollection ( "people" , Person . class ) ; 
collection . insertOne ( ada , new SingleResultCallback < Void > ( ) { 
System . out . println ( "Inserted!" ) ; 
SingleResultCallback < Person > printCallback = new SingleResultCallback < Person > ( ) { 
public void onResult ( final Person person , final Throwable t ) { 
System . out . println ( person ) ; 
collection . find ( ) . first ( printCallback ) ; 
List < Person > people = asList ( 
final CountDownLatch countLatch = new CountDownLatch ( 1 ) ; 
collection . insertMany ( people , new SingleResultCallback < Void > ( ) { 
collection . countDocuments ( new SingleResultCallback < Long > ( ) { 
public void onResult ( final Long count , final Throwable t ) { 
countLatch . countDown ( ) ; 
countLatch . await ( ) ; 
Block < Person > printBlock = new Block < Person > ( ) { 
public void apply ( final Person person ) { 
collection . find ( ) . forEach ( printBlock , callbackWhenFinished ) ; 
collection . find ( eq ( "address.city" , "Wimborne" ) ) . first ( printCallback ) ; 
collection . find ( gt ( "age" , 30 ) ) . forEach ( printBlock , callbackWhenFinished ) ; 
SingleResultCallback < UpdateResult > printModifiedCount = new SingleResultCallback < UpdateResult > ( ) { 
public void onResult ( final UpdateResult result , final Throwable t ) { 
System . out . println ( result . getModifiedCount ( ) ) ; 
printModifiedCount ) ; 
collection . updateMany ( not ( eq ( "zip" , null ) ) , set ( "zip" , null ) , 
SingleResultCallback < DeleteResult > printDeletedCount = new SingleResultCallback < DeleteResult > ( ) { 
public void onResult ( final DeleteResult result , final Throwable t ) { 
System . out . println ( result . getDeletedCount ( ) ) ; 
collection . deleteOne ( eq ( "address.city" , "Wimborne" ) , printDeletedCount ) ; 
collection . deleteMany ( eq ( "address.city" , "London" ) , printDeletedCount ) ; 
final CountDownLatch deleteLatch = new CountDownLatch ( 1 ) ; 
database . drop ( new SingleResultCallback < Void > ( ) { 
deleteLatch . countDown ( ) ; 
deleteLatch . await ( ) ; 
} public static < TItem > Bson set ( final String fieldName , @ Nullable final TItem value ) { 
return new SimpleUpdate < TItem > ( fieldName , value , "$set" ) ; 
} public static < TItem > Bson setOnInsert ( final String fieldName , @ Nullable final TItem value ) { 
return new SimpleUpdate < TItem > ( fieldName , value , "$setOnInsert" ) ; 
} public static Bson rename ( final String fieldName , final String newFieldName ) { 
notNull ( "newFieldName" , newFieldName ) ; 
return new SimpleUpdate < String > ( fieldName , newFieldName , "$rename" ) ; 
} public static Bson inc ( final String fieldName , final Number number ) { 
notNull ( "number" , number ) ; 
return new SimpleUpdate < Number > ( fieldName , number , "$inc" ) ; 
} public static Bson mul ( final String fieldName , final Number number ) { 
return new SimpleUpdate < Number > ( fieldName , number , "$mul" ) ; 
} public static < TItem > Bson min ( final String fieldName , final TItem value ) { 
return new SimpleUpdate < TItem > ( fieldName , value , "$min" ) ; 
} public static < TItem > Bson max ( final String fieldName , final TItem value ) { 
return new SimpleUpdate < TItem > ( fieldName , value , "$max" ) ; 
} public static < TItem > Bson addToSet ( final String fieldName , @ Nullable final TItem value ) { 
return new SimpleUpdate < TItem > ( fieldName , value , "$addToSet" ) ; 
} public static < TItem > Bson addEachToSet ( final String fieldName , final List < TItem > values ) { 
return new WithEachUpdate < TItem > ( fieldName , values , "$addToSet" ) ; 
} public static < TItem > Bson push ( final String fieldName , @ Nullable final TItem value ) { 
return new SimpleUpdate < TItem > ( fieldName , value , "$push" ) ; 
} public static < TItem > Bson pushEach ( final String fieldName , final List < TItem > values ) { 
return new PushUpdate < TItem > ( fieldName , values , new PushOptions ( ) ) ; 
} public static < TItem > Bson pull ( final String fieldName , @ Nullable final TItem value ) { 
return new SimpleUpdate < TItem > ( fieldName , value , "$pull" ) ; 
} public static Bson pullByFilter ( final Bson filter ) { 
return new Bson ( ) { 
public < TDocument > BsonDocument toBsonDocument ( final Class < TDocument > tDocumentClass , final CodecRegistry codecRegistry ) { 
BsonDocumentWriter writer = new BsonDocumentWriter ( new BsonDocument ( ) ) ; 
writer . writeStartDocument ( ) ; 
writer . writeName ( "$pull" ) ; 
encodeValue ( writer , filter , codecRegistry ) ; 
writer . writeEndDocument ( ) ; 
return writer . getDocument ( ) ; 
} public static < TItem > Bson pullAll ( final String fieldName , final List < TItem > values ) { 
return new PullAllUpdate < TItem > ( fieldName , values ) ; 
} protected void writeQueryPrologue ( final BsonOutput bsonOutput ) { 
bsonOutput . writeInt32 ( getCursorFlag ( ) ) ; 
bsonOutput . writeCString ( getCollectionName ( ) ) ; 
bsonOutput . writeInt32 ( skip ) ; 
bsonOutput . writeInt32 ( numberToReturn ) ; 
} public static void checkDatabaseNameValidity ( final String databaseName ) { 
notNull ( "databaseName" , databaseName ) ; 
for ( int i = 0 ; i < databaseName . length ( ) ; i ++ ) { 
! PROHIBITED_CHARACTERS_IN_DATABASE_NAME . contains ( databaseName . charAt ( i ) ) ) ; 
} private void incrementGenerationOnSocketException ( final InternalConnection connection , final Throwable t ) { 
if ( t instanceof MongoSocketException && ! ( t instanceof MongoSocketReadTimeoutException ) ) { 
if ( LOGGER . isWarnEnabled ( ) ) { 
getId ( connection ) , serverId . getAddress ( ) , serverId . getAddress ( ) ) ) ; 
mongoClient = new MongoClient ( ) ; 
mongoClient = new MongoClient ( new MongoClientURI ( args [ 0 ] ) ) ; 
DB database = mongoClient . getDB ( "mydb" ) ; 
DBCollection collection = database . getCollection ( "test" ) ; 
BasicDBObject doc = new BasicDBObject ( "name" , "MongoDB" ) 
collection . insert ( doc ) ; 
DBObject first = collection . findOne ( QueryBuilder . start ( "amount1" ) . is ( new Decimal128 ( new BigDecimal ( ".10" ) ) ) . get ( ) ) ; 
} public FindAndUpdateOperation < T > maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
} public static < T > List < Class < ? > > getAncestry ( final Class < T > clazz ) { 
return ClassAncestry . getAncestry ( clazz ) ; 
} public T put ( final Class < ? > key , final T value ) { 
return map . put ( key , value ) ; 
} public static < TExpression > Bson computed ( final String fieldName , final TExpression expression ) { 
return new SimpleExpression < TExpression > ( fieldName , expression ) ; 
} public static Bson slice ( final String fieldName , final int limit ) { 
return new BsonDocument ( fieldName , new BsonDocument ( "$slice" , new BsonInt32 ( limit ) ) ) ; 
} public static Bson slice ( final String fieldName , final int skip , final int limit ) { 
return new BsonDocument ( fieldName , new BsonDocument ( "$slice" , new BsonArray ( asList ( new BsonInt32 ( skip ) , new BsonInt32 ( limit ) ) ) ) ) ; 
public List < String > resolveHostFromSrvRecords ( final String srvHost ) { 
String srvHostDomain = srvHost . substring ( srvHost . indexOf ( '.' ) + 1 ) ; 
List < String > srvHostDomainParts = asList ( srvHostDomain . split ( "\\." ) ) ; 
List < String > hosts = new ArrayList < String > ( ) ; 
InitialDirContext dirContext = createDnsDirContext ( ) ; 
Attributes attributes = dirContext . getAttributes ( "_mongodb._tcp." + srvHost , new String [ ] { "SRV" } ) ; 
Attribute attribute = attributes . get ( "SRV" ) ; 
if ( attribute == null ) { 
NamingEnumeration < ? > srvRecordEnumeration = attribute . getAll ( ) ; 
while ( srvRecordEnumeration . hasMore ( ) ) { 
String srvRecord = ( String ) srvRecordEnumeration . next ( ) ; 
String resolvedHost = split [ 3 ] . endsWith ( "." ) ? split [ 3 ] . substring ( 0 , split [ 3 ] . length ( ) - 1 ) : split [ 3 ] ; 
String resolvedHostDomain = resolvedHost . substring ( resolvedHost . indexOf ( '.' ) + 1 ) ; 
if ( ! sameParentDomain ( srvHostDomainParts , resolvedHostDomain ) ) { 
throw new MongoConfigurationException ( 
srvHost , resolvedHost ) ) ; 
hosts . add ( resolvedHost + ":" + split [ 2 ] ) ; 
if ( hosts . isEmpty ( ) ) { 
} catch ( NamingException e ) { 
dirContext . close ( ) ; 
return hosts ; 
public String resolveAdditionalQueryParametersFromTxtRecords ( final String host ) { 
String additionalQueryParameters = "" ; 
Attributes attributes = dirContext . getAttributes ( host , new String [ ] { "TXT" } ) ; 
Attribute attribute = attributes . get ( "TXT" ) ; 
NamingEnumeration < ? > txtRecordEnumeration = attribute . getAll ( ) ; 
if ( txtRecordEnumeration . hasMore ( ) ) { 
additionalQueryParameters = ( ( String ) txtRecordEnumeration . next ( ) ) . replaceAll ( "\\s" , "" ) ; 
host ) ) ; 
return additionalQueryParameters ; 
} private static InitialDirContext createDnsDirContext ( ) { 
Hashtable < String , String > envProps = new Hashtable < String , String > ( ) ; 
envProps . put ( Context . INITIAL_CONTEXT_FACTORY , "com.sun.jndi.dns.DnsContextFactory" ) ; 
return new InitialDirContext ( envProps ) ; 
} public DBCollectionCountOptions maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
public static ReplaceOptions createReplaceOptions ( final UpdateOptions updateOptions ) { 
notNull ( "updateOptions" , updateOptions ) ; 
List < ? extends Bson > arrayFilters = updateOptions . getArrayFilters ( ) ; 
return new ReplaceOptions ( ) 
. bypassDocumentValidation ( updateOptions . getBypassDocumentValidation ( ) ) 
. collation ( updateOptions . getCollation ( ) ) 
. upsert ( updateOptions . isUpsert ( ) ) ; 
} public static byte [ ] decode ( final String s ) { 
int delta = s . endsWith ( "==" ) ? 2 : s . endsWith ( "=" ) ? 1 : 0 ; 
byte [ ] buffer = new byte [ s . length ( ) * BYTES_PER_UNENCODED_BLOCK / BYTES_PER_ENCODED_BLOCK - delta ] ; 
int mask = 0xFF ; 
for ( int i = 0 ; i < s . length ( ) ; i += BYTES_PER_ENCODED_BLOCK ) { 
int c0 = DECODE_TABLE [ s . charAt ( i ) ] ; 
int c1 = DECODE_TABLE [ s . charAt ( i + 1 ) ] ; 
buffer [ pos ++ ] = ( byte ) ( ( ( c0 << 2 ) | ( c1 > > 4 ) ) & mask ) ; 
if ( pos >= buffer . length ) { 
int c2 = DECODE_TABLE [ s . charAt ( i + 2 ) ] ; 
buffer [ pos ++ ] = ( byte ) ( ( ( c1 << 4 ) | ( c2 > > 2 ) ) & mask ) ; 
int c3 = DECODE_TABLE [ s . charAt ( i + 3 ) ] ; 
buffer [ pos ++ ] = ( byte ) ( ( ( c2 << 6 ) | c3 ) & mask ) ; 
} public static String encode ( final byte [ ] in ) { 
int modulus = 0 ; 
int bitWorkArea = 0 ; 
int numEncodedBytes = ( in . length / BYTES_PER_UNENCODED_BLOCK ) * BYTES_PER_ENCODED_BLOCK 
+ ( ( in . length % BYTES_PER_UNENCODED_BLOCK == 0 ) ? 0 : 4 ) ; 
byte [ ] buffer = new byte [ numEncodedBytes ] ; 
for ( int b : in ) { 
modulus = ( modulus + 1 ) % BYTES_PER_UNENCODED_BLOCK ; 
if ( b < 0 ) { 
b += 256 ; 
bitWorkArea = ( bitWorkArea << 8 ) + b ; 
if ( 0 == modulus ) { 
buffer [ pos ++ ] = ENCODE_TABLE [ ( bitWorkArea > > 18 ) & SIX_BIT_MASK ] ; 
buffer [ pos ++ ] = ENCODE_TABLE [ ( bitWorkArea > > 12 ) & SIX_BIT_MASK ] ; 
buffer [ pos ++ ] = ENCODE_TABLE [ ( bitWorkArea > > 6 ) & SIX_BIT_MASK ] ; 
buffer [ pos ++ ] = ENCODE_TABLE [ bitWorkArea & SIX_BIT_MASK ] ; 
switch ( modulus ) { 
buffer [ pos ++ ] = ENCODE_TABLE [ ( bitWorkArea > > 2 ) & SIX_BIT_MASK ] ; 
buffer [ pos ++ ] = ENCODE_TABLE [ ( bitWorkArea << 4 ) & SIX_BIT_MASK ] ; 
buffer [ pos ++ ] = PAD ; 
buffer [ pos ] = PAD ; 
buffer [ pos ++ ] = ENCODE_TABLE [ ( bitWorkArea > > 10 ) & SIX_BIT_MASK ] ; 
buffer [ pos ++ ] = ENCODE_TABLE [ ( bitWorkArea > > 4 ) & SIX_BIT_MASK ] ; 
buffer [ pos ++ ] = ENCODE_TABLE [ ( bitWorkArea << 2 ) & SIX_BIT_MASK ] ; 
return byteArrayToString ( buffer ) ; 
public ServerAddress getAddress ( ) { 
ClusterDescription description = getClusterDescription ( ) ; 
if ( description . getPrimaries ( ) . isEmpty ( ) ) { 
return description . getPrimaries ( ) . get ( 0 ) . getAddress ( ) ; 
public ReplicaSetStatus getReplicaSetStatus ( ) { 
ClusterDescription clusterDescription = getClusterDescription ( ) ; 
return clusterDescription . getType ( ) == REPLICA_SET && clusterDescription . getConnectionMode ( ) == MULTIPLE 
? new ReplicaSetStatus ( delegate . getCluster ( ) ) : null ; 
public List < String > getDatabaseNames ( ) { 
return new MongoIterableImpl < DBObject > ( null , createOperationExecutor ( ) , ReadConcern . DEFAULT , primary ( ) , 
options . getRetryReads ( ) ) { 
return new ListDatabasesOperation < DBObject > ( MongoClient . getCommandCodec ( ) ) ; 
public DB getDB ( final String dbName ) { 
DB db = dbCache . get ( dbName ) ; 
db = new DB ( this , dbName , createOperationExecutor ( ) ) ; 
DB temp = dbCache . putIfAbsent ( dbName , db ) ; 
public CommandResult fsync ( final boolean async ) { 
DBObject command = new BasicDBObject ( "fsync" , 1 ) ; 
if ( async ) { 
command . put ( "async" , 1 ) ; 
return getDB ( ADMIN_DATABASE_NAME ) . command ( command ) ; 
public CommandResult fsyncAndLock ( ) { 
command . put ( "lock" , 1 ) ; 
public DBObject unlock ( ) { 
return DBObjects . toDBObject ( createOperationExecutor ( ) . execute ( new FsyncUnlockOperation ( ) , readPreference , readConcern ) ) ; 
public boolean isLocked ( ) { 
return createOperationExecutor ( ) . execute ( new CurrentOpOperation ( ) , ReadPreference . primary ( ) , readConcern ) 
. getBoolean ( "fsyncLock" , BsonBoolean . FALSE ) . getValue ( ) ; 
public String getConnectPoint ( ) { 
ServerAddress master = getAddress ( ) ; 
return master != null ? String . format ( "%s:%d" , master . getHost ( ) , master . getPort ( ) ) : null ; 
if ( transactionState == TransactionState . IN ) { 
abortTransaction ( new SingleResultCallback < Void > ( ) { 
ClientSessionImpl . super . close ( ) ; 
} public BsonNumber asNumber ( ) { 
if ( getBsonType ( ) != BsonType . INT32 && getBsonType ( ) != BsonType . INT64 && getBsonType ( ) != BsonType . DOUBLE ) { 
getBsonType ( ) ) ) ; 
return ( BsonNumber ) this ; 
} public ConnectionId withServerValue ( final int serverValue ) { 
return new ConnectionId ( serverId , localValue , serverValue ) ; 
} public static < T > List < Class < ? > > getAncestry ( final Class < T > c ) { 
ConcurrentMap < Class < ? > , List < Class < ? > > > cache = getClassAncestryCache ( ) ; 
List < Class < ? > > cachedResult = cache . get ( c ) ; 
return cachedResult ; 
cache . putIfAbsent ( c , computeAncestry ( c ) ) ; 
} private static List < Class < ? > > computeAncestry ( final Class < ? > c ) { 
List < Class < ? > > result = new ArrayList < Class < ? > > ( ) ; 
result . add ( Object . class ) ; 
computeAncestry ( c , result ) ; 
Collections . reverse ( result ) ; 
return unmodifiableList ( new ArrayList < Class < ? > > ( result ) ) ; 
} @ SuppressWarnings ( { "unchecked" , "rawtypes" , "deprecation" } ) 
public String toJson ( ) { 
StringWriter stringWriter = new StringWriter ( ) ; 
JsonWriter writer = new JsonWriter ( stringWriter , new JsonWriterSettings ( ) ) ; 
Codec codec = getRegistry ( ) . get ( getClass ( ) ) ; 
codec . encode ( writer , this , EncoderContext . builder ( ) . build ( ) ) ; 
return stringWriter . toString ( ) ; 
public MapReduceBatchCursor < T > execute ( final ReadBinding binding ) { 
return executeCommand ( binding , namespace . getDatabaseName ( ) , getCommandCreator ( binding . getSessionContext ( ) ) , 
CommandResultDocumentCodec . create ( decoder , "results" ) , transformer ( ) , false ) ; 
public Long getExpireAfter ( final TimeUnit timeUnit ) { 
if ( expireAfterSeconds == null ) { 
return timeUnit . convert ( expireAfterSeconds , TimeUnit . SECONDS ) ; 
} public IndexOptions expireAfter ( @ Nullable final Long expireAfter , final TimeUnit timeUnit ) { 
if ( expireAfter == null ) { 
this . expireAfterSeconds = null ; 
this . expireAfterSeconds = TimeUnit . SECONDS . convert ( expireAfter , timeUnit ) ; 
} public DBObject toDBObject ( ) { 
DBObject args = new BasicDBObject ( "ns" , collectionName ) . append ( "cond" , condition ) 
. append ( "$reduce" , reduce ) 
. append ( "initial" , initial ) ; 
if ( keys != null ) { 
args . put ( "key" , keys ) ; 
if ( keyf != null ) { 
args . put ( "$keyf" , keyf ) ; 
if ( finalize != null ) { 
args . put ( "finalize" , finalize ) ; 
return new BasicDBObject ( "group" , args ) ; 
} public Integer getLogicalSessionTimeoutMinutes ( ) { 
Integer retVal = null ; 
for ( ServerDescription cur : getServersByPredicate ( new Predicate ( ) { 
public boolean apply ( final ServerDescription serverDescription ) { 
return serverDescription . isPrimary ( ) || serverDescription . isSecondary ( ) ; 
if ( cur . getLogicalSessionTimeoutMinutes ( ) == null ) { 
retVal = cur . getLogicalSessionTimeoutMinutes ( ) ; 
retVal = Math . min ( retVal , cur . getLogicalSessionTimeoutMinutes ( ) ) ; 
public Set < ServerDescription > getAll ( ) { 
Set < ServerDescription > serverDescriptionSet = new TreeSet < ServerDescription > ( new Comparator < ServerDescription > ( ) { 
public int compare ( final ServerDescription o1 , final ServerDescription o2 ) { 
int val = o1 . getAddress ( ) . getHost ( ) . compareTo ( o2 . getAddress ( ) . getHost ( ) ) ; 
if ( val != 0 ) { 
return integerCompare ( o1 . getAddress ( ) . getPort ( ) , o2 . getAddress ( ) . getPort ( ) ) ; 
private int integerCompare ( final int p1 , final int p2 ) { 
return ( p1 < p2 ) ? - 1 : ( ( p1 == p2 ) ? 0 : 1 ) ; 
serverDescriptionSet . addAll ( serverDescriptions ) ; 
return Collections . unmodifiableSet ( serverDescriptionSet ) ; 
public ServerDescription getByServerAddress ( final ServerAddress serverAddress ) { 
for ( final ServerDescription cur : serverDescriptions ) { 
if ( cur . isOk ( ) && cur . getAddress ( ) . equals ( serverAddress ) ) { 
return cur ; 
public List < ServerDescription > getPrimaries ( ) { 
return getServersByPredicate ( new Predicate ( ) { 
return serverDescription . isPrimary ( ) ; 
public List < ServerDescription > getSecondaries ( ) { 
return serverDescription . isSecondary ( ) ; 
public List < ServerDescription > getSecondaries ( final TagSet tagSet ) { 
return serverDescription . isSecondary ( ) && serverDescription . hasTags ( tagSet ) ; 
public List < ServerDescription > getAny ( ) { 
return serverDescription . isOk ( ) ; 
public List < ServerDescription > getAnyPrimaryOrSecondary ( ) { 
public List < ServerDescription > getAnyPrimaryOrSecondary ( final TagSet tagSet ) { 
return ( serverDescription . isPrimary ( ) || serverDescription . isSecondary ( ) ) && serverDescription . hasTags ( tagSet ) ; 
StringBuilder serverDescriptions = new StringBuilder ( ) ; 
for ( final ServerDescription cur : this . serverDescriptions ) { 
serverDescriptions . append ( delimiter ) . append ( cur . getShortDescription ( ) ) ; 
if ( srvResolutionException == null ) { 
} public static MongoCredential createCredential ( final String userName , final String database , final char [ ] password ) { 
return new MongoCredential ( null , userName , database , password ) ; 
} public static MongoCredential createScramSha1Credential ( final String userName , final String source , final char [ ] password ) { 
return new MongoCredential ( SCRAM_SHA_1 , userName , source , password ) ; 
} public static MongoCredential createScramSha256Credential ( final String userName , final String source , final char [ ] password ) { 
return new MongoCredential ( SCRAM_SHA_256 , userName , source , password ) ; 
public static MongoCredential createMongoCRCredential ( final String userName , final String database , final char [ ] password ) { 
return new MongoCredential ( MONGODB_CR , userName , database , password ) ; 
} public static MongoCredential createPlainCredential ( final String userName , final String source , final char [ ] password ) { 
return new MongoCredential ( PLAIN , userName , source , password ) ; 
} public < T > MongoCredential withMechanismProperty ( final String key , final T value ) { 
return new MongoCredential ( this , key , value ) ; 
} public MongoCredential withMechanism ( final AuthenticationMechanism mechanism ) { 
if ( this . mechanism != null ) { 
return new MongoCredential ( mechanism , userName , source , password , mechanismProperties ) ; 
public < T > T getMechanismProperty ( final String key , @ Nullable final T defaultValue ) { 
T value = ( T ) mechanismProperties . get ( key . toLowerCase ( ) ) ; 
return ( value == null ) ? defaultValue : value ; 
ByteArrayOutputStream bout = new ByteArrayOutputStream ( size ( ) ) ; 
pipe ( bout ) ; 
} public static BsonArray parse ( final String json ) { 
return new BsonArrayCodec ( ) . decode ( new JsonReader ( json ) , DecoderContext . builder ( ) . build ( ) ) ; 
void addObjectSerializer ( final Class c , final ObjectSerializer serializer ) { 
_serializers . put ( c , serializer ) ; 
public Cluster create ( final ClusterSettings settings , final ServerSettings serverSettings , 
final ConnectionPoolSettings connectionPoolSettings , final StreamFactory streamFactory , 
final StreamFactory heartbeatStreamFactory , 
final List < MongoCredential > credentialList , 
final ClusterListener clusterListener , 
final ConnectionPoolListener connectionPoolListener , 
final com . mongodb . event . ConnectionListener connectionListener , 
final CommandListener commandListener ) { 
return createCluster ( getClusterSettings ( settings , clusterListener ) , serverSettings , 
getConnectionPoolSettings ( connectionPoolSettings , connectionPoolListener ) , streamFactory , heartbeatStreamFactory , 
credentialList , commandListener , null , null , Collections . < MongoCompressor > emptyList ( ) ) ; 
public Cluster createCluster ( final ClusterSettings clusterSettings , final ServerSettings serverSettings , 
final StreamFactory heartbeatStreamFactory , final List < MongoCredential > credentialList , 
final CommandListener commandListener , final String applicationName , 
final MongoDriverInformation mongoDriverInformation ) { 
return createCluster ( clusterSettings , serverSettings , connectionPoolSettings , streamFactory , heartbeatStreamFactory , credentialList , 
commandListener , applicationName , mongoDriverInformation , Collections . < MongoCompressor > emptyList ( ) ) ; 
} public Cluster createCluster ( final ClusterSettings clusterSettings , final ServerSettings serverSettings , 
final MongoDriverInformation mongoDriverInformation , 
final List < MongoCompressor > compressorList ) { 
ClusterId clusterId = new ClusterId ( clusterSettings . getDescription ( ) ) ; 
ClusterableServerFactory serverFactory = new DefaultClusterableServerFactory ( clusterId , clusterSettings , serverSettings , 
connectionPoolSettings , streamFactory , heartbeatStreamFactory , credentialList , commandListener , applicationName , 
mongoDriverInformation != null ? mongoDriverInformation : MongoDriverInformation . builder ( ) . build ( ) , compressorList ) ; 
DnsSrvRecordMonitorFactory dnsSrvRecordMonitorFactory = new DefaultDnsSrvRecordMonitorFactory ( clusterId , serverSettings ) ; 
if ( clusterSettings . getMode ( ) == ClusterConnectionMode . SINGLE ) { 
return new SingleServerCluster ( clusterId , clusterSettings , serverFactory ) ; 
} else if ( clusterSettings . getMode ( ) == ClusterConnectionMode . MULTIPLE ) { 
if ( clusterSettings . getSrvHost ( ) == null ) { 
return new MultiServerCluster ( clusterId , clusterSettings , serverFactory ) ; 
return new DnsMultiServerCluster ( clusterId , clusterSettings , serverFactory , dnsSrvRecordMonitorFactory ) ; 
} public UpdateRequest multi ( final boolean isMulti ) { 
if ( isMulti && updateType == Type . REPLACE ) { 
this . isMulti = isMulti ; 
} public void encode ( final BsonOutput bsonOutput , final SessionContext sessionContext ) { 
notNull ( "sessionContext" , sessionContext ) ; 
int messageStartPosition = bsonOutput . getPosition ( ) ; 
writeMessagePrologue ( bsonOutput ) ; 
EncodingMetadata encodingMetadata = encodeMessageBodyWithMetadata ( bsonOutput , sessionContext ) ; 
backpatchMessageLength ( messageStartPosition , bsonOutput ) ; 
this . encodingMetadata = encodingMetadata ; 
} protected void writeMessagePrologue ( final BsonOutput bsonOutput ) { 
bsonOutput . writeInt32 ( 0 ) ; 
bsonOutput . writeInt32 ( id ) ; 
bsonOutput . writeInt32 ( opCode . getValue ( ) ) ; 
} protected void addDocument ( final BsonDocument document , final BsonOutput bsonOutput , 
final FieldNameValidator validator ) { 
addDocument ( document , getCodec ( document ) , EncoderContext . builder ( ) . build ( ) , bsonOutput , validator , 
settings . getMaxDocumentSize ( ) + DOCUMENT_HEADROOM , null ) ; 
} protected void addCollectibleDocument ( final BsonDocument document , final BsonOutput bsonOutput , final FieldNameValidator validator ) { 
addDocument ( document , getCodec ( document ) , EncoderContext . builder ( ) . isEncodingCollectibleDocument ( true ) . build ( ) , bsonOutput , 
validator , settings . getMaxDocumentSize ( ) , null ) ; 
} protected void backpatchMessageLength ( final int startPosition , final BsonOutput bsonOutput ) { 
int messageLength = bsonOutput . getPosition ( ) - startPosition ; 
bsonOutput . writeInt32 ( bsonOutput . getPosition ( ) - messageLength , messageLength ) ; 
} static BsonDocument executeCommand ( final ReadBinding binding , final String database , final CommandCreator commandCreator , 
final boolean retryReads ) { 
return executeCommand ( binding , database , commandCreator , new BsonDocumentCodec ( ) , retryReads ) ; 
} static BsonDocument executeCommand ( final WriteBinding binding , final String database , final BsonDocument command ) { 
return executeCommand ( binding , database , command , new IdentityWriteTransformer < BsonDocument > ( ) ) ; 
} private static < T > T executeCommand ( final String database , final BsonDocument command , 
final FieldNameValidator fieldNameValidator , final Decoder < T > decoder , 
final ConnectionSource source , final Connection connection , 
return executeCommand ( database , command , fieldNameValidator , decoder , source , connection , 
readPreference , new IdentityReadTransformer < T > ( ) , source . getSessionContext ( ) ) ; 
} private static < D , T > T executeCommand ( final String database , final BsonDocument command , 
final Decoder < D > decoder , final ConnectionSource source , final Connection connection , 
final ReadPreference readPreference , 
final CommandReadTransformer < D , T > transformer , final SessionContext sessionContext ) { 
return executeCommand ( database , command , new NoOpFieldNameValidator ( ) , decoder , source , connection , 
readPreference , transformer , sessionContext ) ; 
} private static < T > T executeWriteCommand ( final String database , final BsonDocument command , 
final Decoder < T > decoder , final Connection connection , 
final ReadPreference readPreference , final SessionContext sessionContext ) { 
return executeWriteCommand ( database , command , new NoOpFieldNameValidator ( ) , decoder , connection , 
readPreference , new IdentityWriteTransformer < T > ( ) , sessionContext ) ; 
} static void executeCommandAsync ( final AsyncReadBinding binding , 
final String database , 
final CommandCreator commandCreator , 
final boolean retryReads , 
final SingleResultCallback < BsonDocument > callback ) { 
executeCommandAsync ( binding , database , commandCreator , new BsonDocumentCodec ( ) , retryReads , callback ) ; 
} static void executeCommandAsync ( final AsyncWriteBinding binding , 
final BsonDocument command , 
executeCommandAsync ( binding , database , command , new BsonDocumentCodec ( ) , callback ) ; 
} private static < D , T > void executeCommandAsync ( final String database , final BsonDocument command , 
final Decoder < D > decoder , final AsyncConnection connection , 
final CommandWriteTransformerAsync < D , T > transformer , 
final SessionContext sessionContext , 
final SingleResultCallback < T > callback ) { 
connection . commandAsync ( database , command , new NoOpFieldNameValidator ( ) , readPreference , decoder , sessionContext , 
new SingleResultCallback < D > ( ) { 
public void onResult ( final D result , final Throwable t ) { 
T transformedResult = transformer . apply ( result , connection ) ; 
callback . onResult ( transformedResult , null ) ; 
callback . onResult ( null , e ) ; 
} static < T , R > R executeRetryableCommand ( final WriteBinding binding , final String database , final ReadPreference readPreference , 
final FieldNameValidator fieldNameValidator , final Decoder < T > commandResultDecoder , 
final CommandCreator commandCreator , final CommandWriteTransformer < T , R > transformer ) { 
return executeRetryableCommand ( binding , database , readPreference , fieldNameValidator , commandResultDecoder , commandCreator , 
transformer , noOpRetryCommandModifier ( ) ) ; 
} public void save ( final long chunkSize ) { 
if ( outputStream != null ) { 
if ( ! savedChunks ) { 
saveChunks ( chunkSize ) ; 
super . save ( ) ; 
} public int saveChunks ( final long chunkSize ) throws IOException { 
if ( savedChunks ) { 
if ( chunkSize <= 0 ) { 
if ( this . chunkSize != chunkSize ) { 
this . chunkSize = chunkSize ; 
buffer = new byte [ ( int ) this . chunkSize ] ; 
while ( bytesRead >= 0 ) { 
currentBufferPosition = 0 ; 
bytesRead = _readStream2Buffer ( ) ; 
dumpBuffer ( true ) ; 
finishData ( ) ; 
return currentChunkNumber ; 
} private void dumpBuffer ( final boolean writePartial ) { 
if ( ( currentBufferPosition < chunkSize ) && ! writePartial ) { 
if ( currentBufferPosition == 0 ) { 
byte [ ] writeBuffer = buffer ; 
if ( currentBufferPosition != chunkSize ) { 
writeBuffer = new byte [ currentBufferPosition ] ; 
System . arraycopy ( buffer , 0 , writeBuffer , 0 , currentBufferPosition ) ; 
DBObject chunk = createChunk ( id , currentChunkNumber , writeBuffer ) ; 
fs . getChunksCollection ( ) . save ( chunk ) ; 
currentChunkNumber ++ ; 
totalBytes += writeBuffer . length ; 
messageDigester . update ( writeBuffer ) ; 
} protected DBObject createChunk ( final Object id , final int currentChunkNumber , final byte [ ] writeBuffer ) { 
return new BasicDBObject ( "files_id" , id ) 
. append ( "n" , currentChunkNumber ) 
. append ( "data" , writeBuffer ) ; 
} private int _readStream2Buffer ( ) throws IOException { 
while ( currentBufferPosition < chunkSize && bytesRead >= 0 ) { 
bytesRead = inputStream . read ( buffer , currentBufferPosition , ( int ) chunkSize - currentBufferPosition ) ; 
if ( bytesRead > 0 ) { 
currentBufferPosition += bytesRead ; 
} else if ( bytesRead == 0 ) { 
return bytesRead ; 
} private void finishData ( ) { 
md5 = Util . toHex ( messageDigester . digest ( ) ) ; 
messageDigester = null ; 
length = totalBytes ; 
savedChunks = true ; 
if ( inputStream != null && closeStreamOnPersist ) { 
} public DBCursor copy ( ) { 
return new DBCursor ( collection , filter , findOptions , executor , decoderFactory , decoder , retryReads ) ; 
if ( closed ) { 
FindOperation < DBObject > operation = getQueryOperation ( decoder ) ; 
if ( operation . getCursorType ( ) == CursorType . Tailable ) { 
operation . cursorType ( CursorType . TailableAwait ) ; 
initializeCursor ( operation ) ; 
boolean hasNext = cursor . hasNext ( ) ; 
setServerCursorOnFinalizer ( cursor . getServerCursor ( ) ) ; 
return hasNext ; 
public DBObject tryNext ( ) { 
if ( ! operation . getCursorType ( ) . isTailable ( ) ) { 
DBObject next = cursor . tryNext ( ) ; 
return currentObject ( next ) ; 
public DBCursor setOptions ( final int options ) { 
if ( ( options & Bytes . QUERYOPTION_EXHAUST ) != 0 ) { 
this . options = options ; 
public DBCursor addSpecial ( @ Nullable final String name , @ Nullable final Object value ) { 
if ( name == null || value == null ) { 
if ( "$comment" . equals ( name ) ) { 
comment ( value . toString ( ) ) ; 
} else if ( "$explain" . equals ( name ) ) { 
findOptions . getModifiers ( ) . put ( "$explain" , true ) ; 
} else if ( "$hint" . equals ( name ) ) { 
hint ( ( String ) value ) ; 
hint ( ( DBObject ) value ) ; 
} else if ( "$maxScan" . equals ( name ) ) { 
maxScan ( ( ( Number ) value ) . intValue ( ) ) ; 
} else if ( "$maxTimeMS" . equals ( name ) ) { 
maxTime ( ( ( Number ) value ) . longValue ( ) , MILLISECONDS ) ; 
} else if ( "$max" . equals ( name ) ) { 
max ( ( DBObject ) value ) ; 
} else if ( "$min" . equals ( name ) ) { 
min ( ( DBObject ) value ) ; 
} else if ( "$orderby" . equals ( name ) ) { 
sort ( ( DBObject ) value ) ; 
} else if ( "$returnKey" . equals ( name ) ) { 
returnKey ( ) ; 
} else if ( "$showDiskLoc" . equals ( name ) ) { 
showDiskLoc ( ) ; 
} else if ( "$snapshot" . equals ( name ) ) { 
snapshot ( ) ; 
} else if ( "$natural" . equals ( name ) ) { 
sort ( new BasicDBObject ( "$natural" , ( ( Number ) value ) . intValue ( ) ) ) ; 
} public DBObject explain ( ) { 
return toDBObject ( executor . execute ( getQueryOperation ( collection . getObjectCodec ( ) ) 
. asExplainableOperation ( ExplainVerbosity . QUERY_PLANNER ) , 
getReadPreference ( ) , getReadConcern ( ) ) ) ; 
} public List < DBObject > toArray ( final int max ) { 
checkIteratorOrArray ( IteratorOrArray . ARRAY ) ; 
fillArray ( max - 1 ) ; 
public DBObject one ( ) { 
DBCursor findOneCursor = copy ( ) . limit ( - 1 ) ; 
return findOneCursor . hasNext ( ) ? findOneCursor . next ( ) : null ; 
findOneCursor . close ( ) ; 
DBCollectionCountOptions countOptions = getDbCollectionCountOptions ( ) . skip ( findOptions . getSkip ( ) ) . limit ( findOptions . getLimit ( ) ) ; 
return ( int ) collection . getCount ( getQuery ( ) , countOptions ) ; 
} public ReadPreference getReadPreference ( ) { 
ReadPreference readPreference = findOptions . getReadPreference ( ) ; 
if ( readPreference != null ) { 
return readPreference ; 
return collection . getReadPreference ( ) ; 
} ReadConcern getReadConcern ( ) { 
ReadConcern readConcern = findOptions . getReadConcern ( ) ; 
if ( readConcern != null ) { 
return readConcern ; 
return collection . getReadConcern ( ) ; 
} public DBCursor setDecoderFactory ( final DBDecoderFactory factory ) { 
this . decoder = new DBDecoderAdapter ( factory . create ( ) , collection , getCollection ( ) . getBufferPool ( ) ) ; 
} protected void _put ( final String name , final Object value ) { 
cur ( ) . put ( name , ! BSON . hasDecodeHooks ( ) ? value : BSON . applyDecodingHooks ( value ) ) ; 
} protected void putDBRef ( final String name , final DBRef ref ) { 
BasicDBObject dbRefDocument = new BasicDBObject ( "$ref" , ref . getCollectionName ( ) ) . append ( "$id" , ref . getId ( ) ) ; 
if ( ref . getDatabaseName ( ) != null ) { 
dbRefDocument . put ( "$db" , ref . getDatabaseName ( ) ) ; 
putObject ( name , dbRefDocument ) ; 
CodecRegistry pojoCodecRegistry = fromRegistries ( MongoClientSettings . getDefaultCodecRegistry ( ) , 
MongoCollection < Person > collection = database . getCollection ( "people" , Person . class ) ; 
collection . insertOne ( ada ) ; 
Person somebody = collection . find ( ) . first ( ) ; 
System . out . println ( somebody ) ; 
collection . insertMany ( people ) ; 
collection . find ( ) . forEach ( printBlock ) ; 
somebody = collection . find ( eq ( "address.city" , "Wimborne" ) ) . first ( ) ; 
collection . find ( gt ( "age" , 30 ) ) . forEach ( printBlock ) ; 
UpdateResult updateResult = collection . updateMany ( not ( eq ( "zip" , null ) ) , set ( "zip" , null ) ) ; 
System . out . println ( updateResult . getModifiedCount ( ) ) ; 
collection . deleteOne ( eq ( "address.city" , "Wimborne" ) ) ; 
DeleteResult deleteResult = collection . deleteMany ( eq ( "address.city" , "London" ) ) ; 
System . out . println ( deleteResult . getDeletedCount ( ) ) ; 
} public static BulkWriteResult acknowledged ( final WriteRequest . Type type , final int count , final List < BulkWriteUpsert > upserts ) { 
return acknowledged ( type , count , 0 , upserts ) ; 
} public static BulkWriteResult acknowledged ( final WriteRequest . Type type , final int count , final Integer modifiedCount , 
final List < BulkWriteUpsert > upserts ) { 
return acknowledged ( type == WriteRequest . Type . INSERT ? count : 0 , 
( type == WriteRequest . Type . UPDATE || type == WriteRequest . Type . REPLACE ) ? count : 0 , 
type == WriteRequest . Type . DELETE ? count : 0 , 
modifiedCount , upserts ) ; 
} public static BulkWriteResult acknowledged ( final int insertedCount , final int matchedCount , final int removedCount , 
final Integer modifiedCount , final List < BulkWriteUpsert > upserts ) { 
return new BulkWriteResult ( ) { 
public boolean wasAcknowledged ( ) { 
public int getInsertedCount ( ) { 
return insertedCount ; 
public int getMatchedCount ( ) { 
return matchedCount ; 
public int getDeletedCount ( ) { 
return removedCount ; 
public boolean isModifiedCountAvailable ( ) { 
public int getModifiedCount ( ) { 
return modifiedCount ; 
public List < BulkWriteUpsert > getUpserts ( ) { 
return upserts ; 
public boolean equals ( final Object o ) { 
if ( o == null || getClass ( ) != o . getClass ( ) ) { 
BulkWriteResult that = ( BulkWriteResult ) o ; 
if ( ! that . wasAcknowledged ( ) ) { 
if ( insertedCount != that . getInsertedCount ( ) ) { 
if ( modifiedCount != null && ! modifiedCount . equals ( that . getModifiedCount ( ) ) ) { 
if ( removedCount != that . getDeletedCount ( ) ) { 
if ( matchedCount != that . getMatchedCount ( ) ) { 
if ( ! upserts . equals ( that . getUpserts ( ) ) ) { 
int result = upserts . hashCode ( ) ; 
result = 31 * result + insertedCount ; 
result = 31 * result + matchedCount ; 
result = 31 * result + removedCount ; 
result = 31 * result + ( modifiedCount != null ? modifiedCount . hashCode ( ) : 0 ) ; 
return "AcknowledgedBulkWriteResult{" 
+ "insertedCount=" + insertedCount 
} public static BulkWriteResult unacknowledged ( ) { 
throw getUnacknowledgedWriteException ( ) ; 
return ! that . wasAcknowledged ( ) ; 
return "UnacknowledgedBulkWriteResult{}" ; 
private UnsupportedOperationException getUnacknowledgedWriteException ( ) { 
} public AggregateOperation < T > maxAwaitTime ( final long maxAwaitTime , final TimeUnit timeUnit ) { 
wrapped . maxAwaitTime ( maxAwaitTime , timeUnit ) ; 
} public AggregateOperation < T > maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
wrapped . maxTime ( maxTime , timeUnit ) ; 
} public BsonDocument getHint ( ) { 
BsonValue hint = wrapped . getHint ( ) ; 
if ( hint == null ) { 
if ( ! hint . isDocument ( ) ) { 
return hint . asDocument ( ) ; 
return new AggregateExplainOperation ( getNamespace ( ) , getPipeline ( ) ) 
. allowDiskUse ( getAllowDiskUse ( ) ) 
. maxTime ( getMaxAwaitTime ( TimeUnit . MILLISECONDS ) , TimeUnit . MILLISECONDS ) 
. hint ( wrapped . getHint ( ) ) 
. retryReads ( getRetryReads ( ) ) ; 
} public InetSocketAddress getSocketAddress ( ) { 
return new InetSocketAddress ( InetAddress . getByName ( host ) , port ) ; 
throw new MongoSocketException ( e . getMessage ( ) , this , e ) ; 
} public List < InetSocketAddress > getSocketAddresses ( ) { 
InetAddress [ ] inetAddresses = InetAddress . getAllByName ( host ) ; 
List < InetSocketAddress > inetSocketAddressList = new ArrayList < InetSocketAddress > ( ) ; 
for ( InetAddress inetAddress : inetAddresses ) { 
inetSocketAddressList . add ( new InetSocketAddress ( inetAddress , port ) ) ; 
return inetSocketAddressList ; 
} public FindOneAndDeleteOptions maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
} public static < TItem > Bson eq ( final String fieldName , @ Nullable final TItem value ) { 
return new SimpleEncodingFilter < TItem > ( fieldName , value ) ; 
} public static < TItem > Bson ne ( final String fieldName , @ Nullable final TItem value ) { 
return new OperatorFilter < TItem > ( "$ne" , fieldName , value ) ; 
} public static < TItem > Bson gt ( final String fieldName , final TItem value ) { 
return new OperatorFilter < TItem > ( "$gt" , fieldName , value ) ; 
} public static < TItem > Bson lt ( final String fieldName , final TItem value ) { 
return new OperatorFilter < TItem > ( "$lt" , fieldName , value ) ; 
} public static < TItem > Bson gte ( final String fieldName , final TItem value ) { 
return new OperatorFilter < TItem > ( "$gte" , fieldName , value ) ; 
} public static < TItem > Bson lte ( final String fieldName , final TItem value ) { 
return new OperatorFilter < TItem > ( "$lte" , fieldName , value ) ; 
} public static < TItem > Bson in ( final String fieldName , final TItem ... values ) { 
return in ( fieldName , asList ( values ) ) ; 
} public static < TItem > Bson in ( final String fieldName , final Iterable < TItem > values ) { 
return new IterableOperatorFilter < TItem > ( fieldName , "$in" , values ) ; 
} public static < TItem > Bson nin ( final String fieldName , final TItem ... values ) { 
return nin ( fieldName , asList ( values ) ) ; 
} public static < TItem > Bson nin ( final String fieldName , final Iterable < TItem > values ) { 
return new IterableOperatorFilter < TItem > ( fieldName , "$nin" , values ) ; 
} public static Bson or ( final Iterable < Bson > filters ) { 
return new OrNorFilter ( OrNorFilter . Operator . OR , filters ) ; 
} public static Bson nor ( final Iterable < Bson > filters ) { 
return new OrNorFilter ( OrNorFilter . Operator . NOR , filters ) ; 
} public static Bson exists ( final String fieldName , final boolean exists ) { 
return new OperatorFilter < BsonBoolean > ( "$exists" , fieldName , BsonBoolean . valueOf ( exists ) ) ; 
} public static Bson type ( final String fieldName , final BsonType type ) { 
return new OperatorFilter < BsonInt32 > ( "$type" , fieldName , new BsonInt32 ( type . getValue ( ) ) ) ; 
} public static Bson type ( final String fieldName , final String type ) { 
return new OperatorFilter < BsonString > ( "$type" , fieldName , new BsonString ( type ) ) ; 
} public static Bson mod ( final String fieldName , final long divisor , final long remainder ) { 
return new OperatorFilter < BsonArray > ( "$mod" , fieldName , new BsonArray ( asList ( new BsonInt64 ( divisor ) , new BsonInt64 ( remainder ) ) ) ) ; 
} public static Bson regex ( final String fieldName , final String pattern ) { 
return regex ( fieldName , pattern , null ) ; 
} public static Bson regex ( final String fieldName , final String pattern , @ Nullable final String options ) { 
notNull ( "pattern" , pattern ) ; 
return new SimpleFilter ( fieldName , new BsonRegularExpression ( pattern , options ) ) ; 
} public static Bson regex ( final String fieldName , final Pattern pattern ) { 
return new SimpleEncodingFilter < Pattern > ( fieldName , pattern ) ; 
public static Bson text ( final String search , final String language ) { 
notNull ( "search" , search ) ; 
return text ( search , new TextSearchOptions ( ) . language ( language ) ) ; 
} public static Bson text ( final String search , final TextSearchOptions textSearchOptions ) { 
notNull ( "textSearchOptions" , textSearchOptions ) ; 
return new TextFilter ( search , textSearchOptions ) ; 
} public static < TItem > Bson all ( final String fieldName , final TItem ... values ) { 
return all ( fieldName , asList ( values ) ) ; 
} public static < TItem > Bson all ( final String fieldName , final Iterable < TItem > values ) { 
return new IterableOperatorFilter < TItem > ( fieldName , "$all" , values ) ; 
} public static Bson elemMatch ( final String fieldName , final Bson filter ) { 
public < TDocument > BsonDocument toBsonDocument ( final Class < TDocument > documentClass , final CodecRegistry codecRegistry ) { 
return new BsonDocument ( fieldName , new BsonDocument ( "$elemMatch" , filter . toBsonDocument ( documentClass , codecRegistry ) ) ) ; 
} public static Bson geoWithin ( final String fieldName , final Geometry geometry ) { 
return new GeometryOperatorFilter < Geometry > ( "$geoWithin" , fieldName , geometry ) ; 
} public static Bson geoWithin ( final String fieldName , final Bson geometry ) { 
return new GeometryOperatorFilter < Bson > ( "$geoWithin" , fieldName , geometry ) ; 
} public static Bson geoWithinBox ( final String fieldName , final double lowerLeftX , final double lowerLeftY , final double upperRightX , 
final double upperRightY ) { 
BsonDocument box = new BsonDocument ( "$box" , 
new BsonArray ( asList ( new BsonArray ( asList ( new BsonDouble ( lowerLeftX ) , 
new BsonDouble ( lowerLeftY ) ) ) , 
new BsonArray ( asList ( new BsonDouble ( upperRightX ) , 
new BsonDouble ( upperRightY ) ) ) ) ) ) ; 
return new OperatorFilter < BsonDocument > ( "$geoWithin" , fieldName , box ) ; 
} public static Bson geoWithinPolygon ( final String fieldName , final List < List < Double > > points ) { 
BsonArray pointsArray = new BsonArray ( ) ; 
for ( List < Double > point : points ) { 
pointsArray . add ( new BsonArray ( asList ( new BsonDouble ( point . get ( 0 ) ) , new BsonDouble ( point . get ( 1 ) ) ) ) ) ; 
BsonDocument polygon = new BsonDocument ( "$polygon" , pointsArray ) ; 
return new OperatorFilter < BsonDocument > ( "$geoWithin" , fieldName , polygon ) ; 
} public static Bson geoWithinCenter ( final String fieldName , final double x , final double y , final double radius ) { 
BsonDocument center = new BsonDocument ( "$center" , 
new BsonArray ( Arrays . < BsonValue > asList ( new BsonArray ( asList ( new BsonDouble ( x ) , 
new BsonDouble ( y ) ) ) , 
new BsonDouble ( radius ) ) ) ) ; 
return new OperatorFilter < BsonDocument > ( "$geoWithin" , fieldName , center ) ; 
} public static Bson geoWithinCenterSphere ( final String fieldName , final double x , final double y , final double radius ) { 
BsonDocument centerSphere = new BsonDocument ( "$centerSphere" , 
return new OperatorFilter < BsonDocument > ( "$geoWithin" , fieldName , centerSphere ) ; 
} public static Bson geoIntersects ( final String fieldName , final Bson geometry ) { 
return new GeometryOperatorFilter < Bson > ( "$geoIntersects" , fieldName , geometry ) ; 
} public static Bson geoIntersects ( final String fieldName , final Geometry geometry ) { 
return new GeometryOperatorFilter < Geometry > ( "$geoIntersects" , fieldName , geometry ) ; 
} public static Bson near ( final String fieldName , final Point geometry , @ Nullable final Double maxDistance , 
@ Nullable final Double minDistance ) { 
return new GeometryOperatorFilter < Point > ( "$near" , fieldName , geometry , maxDistance , minDistance ) ; 
} public static Bson near ( final String fieldName , final double x , final double y , @ Nullable final Double maxDistance , 
return createNearFilterDocument ( fieldName , x , y , maxDistance , minDistance , "$near" ) ; 
public SocketFactory getSocketFactory ( ) { 
if ( socketFactory != null ) { 
} else if ( getSslSettings ( ) . isEnabled ( ) ) { 
return sslContext == null ? DEFAULT_SSL_SOCKET_FACTORY : sslContext . getSocketFactory ( ) ; 
return DEFAULT_SOCKET_FACTORY ; 
} public CountOperation maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
if ( countStrategy . equals ( CountStrategy . COMMAND ) ) { 
return createExplainableOperation ( explainVerbosity ) ; 
return getAggregateOperation ( ) . asExplainableOperation ( explainVerbosity ) ; 
} public AsyncReadOperation < BsonDocument > asExplainableOperationAsync ( final ExplainVerbosity explainVerbosity ) { 
return getAggregateOperation ( ) . asExplainableOperationAsync ( explainVerbosity ) ; 
return codecRegistry . get ( BsonValueCodecProvider . getClassForBsonType ( reader . getCurrentBsonType ( ) ) ) . decode ( reader , decoderContext ) ; 
} public static void addEncodingHook ( final Class < ? > clazz , final Transformer transformer ) { 
encodeHooks = true ; 
List < Transformer > transformersForClass = encodingHooks . get ( clazz ) ; 
if ( transformersForClass == null ) { 
transformersForClass = new CopyOnWriteArrayList < Transformer > ( ) ; 
encodingHooks . put ( clazz , transformersForClass ) ; 
transformersForClass . add ( transformer ) ; 
} public static void addDecodingHook ( final Class < ? > clazz , final Transformer transformer ) { 
decodeHooks = true ; 
List < Transformer > transformersForClass = decodingHooks . get ( clazz ) ; 
decodingHooks . put ( clazz , transformersForClass ) ; 
} public static Object applyEncodingHooks ( final Object objectToEncode ) { 
Object transformedObject = objectToEncode ; 
if ( ! hasEncodeHooks ( ) || objectToEncode == null || encodingHooks . size ( ) == 0 ) { 
return transformedObject ; 
List < Transformer > transformersForObject = encodingHooks . get ( objectToEncode . getClass ( ) ) ; 
if ( transformersForObject != null ) { 
for ( final Transformer transformer : transformersForObject ) { 
transformedObject = transformer . transform ( objectToEncode ) ; 
} public static Object applyDecodingHooks ( final Object objectToDecode ) { 
Object transformedObject = objectToDecode ; 
if ( ! hasDecodeHooks ( ) || objectToDecode == null || decodingHooks . size ( ) == 0 ) { 
List < Transformer > transformersForObject = decodingHooks . get ( objectToDecode . getClass ( ) ) ; 
transformedObject = transformer . transform ( objectToDecode ) ; 
} public static int regexFlags ( final String s ) { 
int flags = 0 ; 
return flags ; 
for ( final char f : s . toLowerCase ( ) . toCharArray ( ) ) { 
flags |= regexFlag ( f ) ; 
} public static int regexFlag ( final char c ) { 
int flag = FLAG_LOOKUP [ c ] ; 
if ( flag == 0 ) { 
} public static String regexFlags ( final int flags ) { 
int processedFlags = flags ; 
for ( int i = 0 ; i < FLAG_LOOKUP . length ; i ++ ) { 
if ( ( processedFlags & FLAG_LOOKUP [ i ] ) > 0 ) { 
buf . append ( ( char ) i ) ; 
processedFlags -= FLAG_LOOKUP [ i ] ; 
if ( processedFlags > 0 ) { 
} public static int toInt ( final Object number ) { 
if ( number == null ) { 
if ( number instanceof Number ) { 
return ( ( Number ) number ) . intValue ( ) ; 
if ( number instanceof Boolean ) { 
return ( ( Boolean ) number ) ? 1 : 0 ; 
} public IndexRequest expireAfter ( final Long expireAfter , final TimeUnit timeUnit ) { 
} public IndexRequest textVersion ( final Integer textVersion ) { 
if ( textVersion != null ) { 
this . textVersion = textVersion ; 
} public IndexRequest sphereVersion ( final Integer sphereVersion ) { 
if ( sphereVersion != null ) { 
this . sphereVersion = sphereVersion ; 
} public DBCollectionFindOptions copy ( ) { 
DBCollectionFindOptions copiedOptions = new DBCollectionFindOptions ( ) ; 
copiedOptions . batchSize ( batchSize ) ; 
copiedOptions . limit ( limit ) ; 
copiedOptions . modifiers ( modifiers ) ; 
copiedOptions . projection ( projection ) ; 
copiedOptions . maxTime ( maxTimeMS , TimeUnit . MILLISECONDS ) ; 
copiedOptions . maxAwaitTime ( maxAwaitTimeMS , TimeUnit . MILLISECONDS ) ; 
copiedOptions . skip ( skip ) ; 
copiedOptions . sort ( sort ) ; 
copiedOptions . cursorType ( cursorType ) ; 
copiedOptions . noCursorTimeout ( noCursorTimeout ) ; 
copiedOptions . oplogReplay ( oplogReplay ) ; 
copiedOptions . partial ( partial ) ; 
copiedOptions . readPreference ( readPreference ) ; 
copiedOptions . readConcern ( readConcern ) ; 
copiedOptions . collation ( collation ) ; 
copiedOptions . comment ( comment ) ; 
copiedOptions . hint ( hint ) ; 
copiedOptions . max ( max ) ; 
copiedOptions . min ( min ) ; 
copiedOptions . returnKey ( returnKey ) ; 
copiedOptions . showRecordId ( showRecordId ) ; 
return copiedOptions ; 
} public DBCollectionFindOptions maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
return HexUtils . hexMD5 ( buf , offset , len ) ; 
} public static < T > T isTrueArgument ( final String name , final T value , final boolean condition ) { 
if ( ! condition ) { 
public static < T > T convertToType ( final Class < T > clazz , final Object value , final String errorMessage ) { 
if ( ! clazz . isAssignableFrom ( value . getClass ( ) ) ) { 
throw new IllegalArgumentException ( errorMessage ) ; 
} public static < TExpression > BsonField sum ( final String fieldName , final TExpression expression ) { 
return accumulator ( "$sum" , fieldName , expression ) ; 
} public static < TExpression > BsonField avg ( final String fieldName , final TExpression expression ) { 
return accumulator ( "$avg" , fieldName , expression ) ; 
} public static < TExpression > BsonField first ( final String fieldName , final TExpression expression ) { 
return accumulator ( "$first" , fieldName , expression ) ; 
} public static < TExpression > BsonField last ( final String fieldName , final TExpression expression ) { 
return accumulator ( "$last" , fieldName , expression ) ; 
} public static < TExpression > BsonField max ( final String fieldName , final TExpression expression ) { 
return accumulator ( "$max" , fieldName , expression ) ; 
} public static < TExpression > BsonField min ( final String fieldName , final TExpression expression ) { 
return accumulator ( "$min" , fieldName , expression ) ; 
} public static < TExpression > BsonField push ( final String fieldName , final TExpression expression ) { 
return accumulator ( "$push" , fieldName , expression ) ; 
} public static < TExpression > BsonField addToSet ( final String fieldName , final TExpression expression ) { 
return accumulator ( "$addToSet" , fieldName , expression ) ; 
} public static < TExpression > BsonField stdDevPop ( final String fieldName , final TExpression expression ) { 
return accumulator ( "$stdDevPop" , fieldName , expression ) ; 
} public static < TExpression > BsonField stdDevSamp ( final String fieldName , final TExpression expression ) { 
return accumulator ( "$stdDevSamp" , fieldName , expression ) ; 
public void encode ( final BsonWriter writer , final DBObject document , final EncoderContext encoderContext ) { 
BasicOutputBuffer buffer = new BasicOutputBuffer ( ) ; 
encoder . writeObject ( buffer , document ) ; 
BsonBinaryReader reader = new BsonBinaryReader ( new ByteBufferBsonInput ( new ByteBufNIO ( wrap ( buffer . toByteArray ( ) ) ) ) ) ; 
writer . pipe ( reader ) ; 
buffer . close ( ) ; 
public BulkWriteResult execute ( final WriteBinding binding ) { 
return withReleasableConnection ( binding , new CallableWithConnectionAndSource < BulkWriteResult > ( ) { 
public BulkWriteResult call ( final ConnectionSource connectionSource , final Connection connection ) { 
validateWriteRequestsAndReleaseConnectionIfError ( connection ) ; 
if ( getWriteConcern ( ) . isAcknowledged ( ) || serverIsAtLeastVersionThreeDotSix ( connection . getDescription ( ) ) ) { 
BulkWriteBatch bulkWriteBatch = BulkWriteBatch . createBulkWriteBatch ( namespace , connectionSource . getServerDescription ( ) , 
connection . getDescription ( ) , ordered , writeConcern , bypassDocumentValidation , retryWrites , writeRequests , 
binding . getSessionContext ( ) ) ; 
return executeBulkWriteBatch ( binding , connection , bulkWriteBatch ) ; 
return executeLegacyBatches ( connection ) ; 
setupDatabase ( ) ; 
MongoClient client = MongoClients . create ( ) ; 
ClientSession session1 = client . startSession ( ClientSessionOptions . builder ( ) . causallyConsistent ( true ) . build ( ) ) ; 
Date currentDate = new Date ( ) ; 
MongoCollection < Document > items = client . getDatabase ( "test" ) 
. withReadConcern ( ReadConcern . MAJORITY ) 
. withWriteConcern ( WriteConcern . MAJORITY . withWTimeout ( 1000 , TimeUnit . MILLISECONDS ) ) 
. getCollection ( "test" ) ; 
items . updateOne ( session1 , eq ( "sku" , "111" ) , set ( "end" , currentDate ) ) ; 
Document document = new Document ( "sku" , "nuts-111" ) 
. append ( "name" , "Pecans" ) 
. append ( "start" , currentDate ) ; 
items . insertOne ( session1 , document ) ; 
ClientSession session2 = client . startSession ( ClientSessionOptions . builder ( ) . causallyConsistent ( true ) . build ( ) ) ; 
session2 . advanceClusterTime ( session1 . getClusterTime ( ) ) ; 
session2 . advanceOperationTime ( session1 . getOperationTime ( ) ) ; 
items = client . getDatabase ( "test" ) 
. withReadPreference ( ReadPreference . secondary ( ) ) 
. getCollection ( "items" ) ; 
for ( Document item : items . find ( session2 , eq ( "end" , BsonNull . VALUE ) ) ) { 
System . out . println ( item ) ; 
} public void replaceOne ( final DBObject document ) { 
new BulkUpdateRequestBuilder ( bulkWriteOperation , query , false , codec , replacementCodec , collation , null ) . replaceOne ( document ) ; 
} public void update ( final DBObject update ) { 
new BulkUpdateRequestBuilder ( bulkWriteOperation , query , false , codec , replacementCodec , collation , null ) . update ( update ) ; 
} public BulkUpdateRequestBuilder upsert ( ) { 
return new BulkUpdateRequestBuilder ( bulkWriteOperation , query , true , codec , replacementCodec , collation , null ) ; 
} public BulkUpdateRequestBuilder arrayFilters ( final List < ? extends DBObject > arrayFilters ) { 
return new BulkUpdateRequestBuilder ( bulkWriteOperation , query , false , codec , replacementCodec , collation , arrayFilters ) ; 
} public MapReduceToCollectionOperation maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
} public MapReduceToCollectionOperation action ( final String action ) { 
notNull ( "action" , action ) ; 
public MapReduceStatistics execute ( final WriteBinding binding ) { 
return withConnection ( binding , new OperationHelper . CallableWithConnection < MapReduceStatistics > ( ) { 
public MapReduceStatistics call ( final Connection connection ) { 
validateCollation ( connection , collation ) ; 
return executeCommand ( binding , namespace . getDatabaseName ( ) , getCommand ( connection . getDescription ( ) ) , 
connection , transformer ( ) ) ; 
} public DropIndexOptions maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
} public static synchronized void init ( final MongoEmbeddedSettings mongoEmbeddedSettings ) { 
if ( mongoEmbeddedLibrary != null ) { 
mongoEmbeddedLibrary = MongoEmbeddedCAPI . create ( mongoEmbeddedSettings . getYamlConfig ( ) , 
mongoEmbeddedSettings . getLogLevel ( ) . toCapiLogLevel ( ) , mongoEmbeddedSettings . getLibraryPath ( ) ) ; 
} public static synchronized MongoClient create ( final MongoClientSettings mongoClientSettings ) { 
if ( mongoEmbeddedLibrary == null ) { 
Cluster cluster = new EmbeddedCluster ( mongoEmbeddedLibrary , mongoClientSettings ) ; 
return new MongoClientImpl ( cluster , mongoClientSettings . getWrappedMongoClientSettings ( ) , null ) ; 
} public static synchronized void close ( ) { 
mongoEmbeddedLibrary . close ( ) ; 
mongoEmbeddedLibrary = null ; 
} public static void enableSni ( final String host , final SSLParameters sslParameters ) { 
if ( SNI_SSL_HELPER != null ) { 
SNI_SSL_HELPER . enableSni ( host , sslParameters ) ; 
} public static String createAuthenticationHash ( final String userName , final char [ ] password ) { 
ByteArrayOutputStream bout = new ByteArrayOutputStream ( userName . length ( ) + 20 + password . length ) ; 
bout . write ( userName . getBytes ( UTF_8_CHARSET ) ) ; 
bout . write ( ":mongo:" . getBytes ( UTF_8_CHARSET ) ) ; 
bout . write ( new String ( password ) . getBytes ( UTF_8_CHARSET ) ) ; 
throw new RuntimeException ( "impossible" , ioe ) ; 
return hexMD5 ( bout . toByteArray ( ) ) ; 
public static byte getType ( final Object object ) { 
return NULL ; 
if ( object instanceof Integer 
|| object instanceof Short 
|| object instanceof Byte 
|| object instanceof AtomicInteger ) { 
return NUMBER_INT ; 
if ( object instanceof Long || object instanceof AtomicLong ) { 
return NUMBER_LONG ; 
if ( object instanceof Number ) { 
return NUMBER ; 
if ( object instanceof String ) { 
if ( object instanceof java . util . List ) { 
return ARRAY ; 
if ( object instanceof byte [ ] ) { 
return BINARY ; 
if ( object instanceof ObjectId ) { 
return OID ; 
if ( object instanceof Boolean ) { 
return BOOLEAN ; 
if ( object instanceof java . util . Date ) { 
return DATE ; 
if ( object instanceof BSONTimestamp ) { 
return TIMESTAMP ; 
if ( object instanceof java . util . regex . Pattern ) { 
return REGEX ; 
if ( object instanceof DBObject || object instanceof DBRef ) { 
return OBJECT ; 
if ( object instanceof CodeWScope ) { 
return CODE_W_SCOPE ; 
if ( object instanceof Code ) { 
return CODE ; 
BasicDBObject cmd = new BasicDBObject ( ) ; 
cmd . put ( "mapreduce" , mapReduce ) ; 
cmd . put ( "map" , map ) ; 
cmd . put ( "reduce" , reduce ) ; 
if ( verbose != null ) { 
cmd . put ( "verbose" , verbose ) ; 
BasicDBObject out = new BasicDBObject ( ) ; 
switch ( outputType ) { 
case INLINE : 
out . put ( "inline" , 1 ) ; 
out . put ( "replace" , outputCollection ) ; 
out . put ( "merge" , outputCollection ) ; 
out . put ( "reduce" , outputCollection ) ; 
if ( outputDB != null ) { 
out . put ( "db" , outputDB ) ; 
cmd . put ( "out" , out ) ; 
cmd . put ( "query" , query ) ; 
cmd . put ( "finalize" , finalize ) ; 
cmd . put ( "sort" , sort ) ; 
cmd . put ( "limit" , limit ) ; 
cmd . put ( "scope" , scope ) ; 
if ( jsMode != null ) { 
cmd . put ( "jsMode" , jsMode ) ; 
if ( maxTimeMS != 0 ) { 
cmd . put ( "maxTimeMS" , maxTimeMS ) ; 
return cmd ; 
} public static int extractErrorCode ( final BsonDocument response ) { 
String errorMessage = extractErrorMessage ( response ) ; 
if ( errorMessage != null ) { 
if ( response . containsKey ( "err" ) ) { 
return 11000 ; 
if ( ! response . containsKey ( "code" ) && response . containsKey ( "errObjects" ) ) { 
for ( BsonValue curErrorDocument : response . getArray ( "errObjects" ) ) { 
if ( errorMessage . equals ( extractErrorMessage ( curErrorDocument . asDocument ( ) ) ) ) { 
return curErrorDocument . asDocument ( ) . getNumber ( "code" ) . intValue ( ) ; 
return response . getNumber ( "code" , new BsonInt32 ( - 1 ) ) . intValue ( ) ; 
public static String extractErrorMessage ( final BsonDocument response ) { 
if ( response . isString ( "err" ) ) { 
return response . getString ( "err" ) . getValue ( ) ; 
} else if ( response . isString ( "errmsg" ) ) { 
return response . getString ( "errmsg" ) . getValue ( ) ; 
} public long read ( final ByteBufferSet dest ) throws IOException { 
checkReadBuffer ( dest ) ; 
if ( ! dest . hasRemaining ( ) ) { 
handshake ( ) ; 
readLock . lock ( ) ; 
if ( invalid || shutdownSent ) { 
throw new ClosedChannelException ( ) ; 
HandshakeStatus handshakeStatus = engine . getHandshakeStatus ( ) ; 
int bytesToReturn = inPlain . nullOrEmpty ( ) ? 0 : inPlain . buffer . position ( ) ; 
if ( bytesToReturn > 0 ) { 
if ( inPlain . nullOrEmpty ( ) ) { 
return bytesToReturn ; 
return transferPendingPlain ( dest ) ; 
if ( shutdownReceived ) { 
Util . assertTrue ( inPlain . nullOrEmpty ( ) ) ; 
switch ( handshakeStatus ) { 
case NEED_UNWRAP : 
case NEED_WRAP : 
bytesToReturn = handshake ( Optional . of ( dest ) , Optional . of ( handshakeStatus ) ) ; 
handshakeStatus = NOT_HANDSHAKING ; 
case NOT_HANDSHAKING : 
case FINISHED : 
UnwrapResult res = readAndUnwrap ( Optional . of ( dest ) , NOT_HANDSHAKING , 
if ( res . wasClosed ) { 
bytesToReturn = res . bytesProduced ; 
handshakeStatus = res . lastHandshakeStatus ; 
case NEED_TASK : 
handleTask ( ) ; 
handshakeStatus = engine . getHandshakeStatus ( ) ; 
} catch ( EofException e ) { 
readLock . unlock ( ) ; 
} public long write ( final ByteBufferSet source ) throws IOException { 
writeLock . lock ( ) ; 
return wrapAndWrite ( source ) ; 
writeLock . unlock ( ) ; 
+ ( hosts . isEmpty ( ) ? "" : "hosts=" + hosts ) 
} public static UpdateResult acknowledged ( final long matchedCount , @ Nullable final Long modifiedCount , 
@ Nullable final BsonValue upsertedId ) { 
return new AcknowledgedUpdateResult ( matchedCount , modifiedCount , upsertedId ) ; 
public String getContentType ( ) { 
if ( extraElements != null && extraElements . containsKey ( "contentType" ) ) { 
return extraElements . getString ( "contentType" ) ; 
public List < String > getAliases ( ) { 
if ( extraElements != null && extraElements . containsKey ( "aliases" ) ) { 
return ( List < String > ) extraElements . get ( "aliases" ) ; 
} public String getFirstKey ( ) { 
return findInDocument ( new Finder < String > ( ) { 
public String find ( final BsonReader bsonReader ) { 
return bsonReader . readName ( ) ; 
public String notFound ( ) { 
} public static Bson ascending ( final List < String > fieldNames ) { 
notNull ( "fieldNames" , fieldNames ) ; 
return orderBy ( fieldNames , new BsonInt32 ( 1 ) ) ; 
} public static Bson descending ( final List < String > fieldNames ) { 
return orderBy ( fieldNames , new BsonInt32 ( - 1 ) ) ; 
} public < T > void encodeWithChildContext ( final Encoder < T > encoder , final BsonWriter writer , final T value ) { 
encoder . encode ( writer , value , DEFAULT_CONTEXT ) ; 
} public static ObjectSerializer getLegacy ( ) { 
ClassMapBasedObjectSerializer serializer = addCommonSerializers ( ) ; 
serializer . addObjectSerializer ( Date . class , new LegacyDateSerializer ( serializer ) ) ; 
serializer . addObjectSerializer ( BSONTimestamp . class , new LegacyBSONTimestampSerializer ( serializer ) ) ; 
serializer . addObjectSerializer ( Binary . class , new LegacyBinarySerializer ( ) ) ; 
serializer . addObjectSerializer ( byte [ ] . class , new LegacyBinarySerializer ( ) ) ; 
} public static ObjectSerializer getStrict ( ) { 
serializer . addObjectSerializer ( Date . class , new DateSerializer ( serializer ) ) ; 
serializer . addObjectSerializer ( BSONTimestamp . class , new BSONTimestampSerializer ( serializer ) ) ; 
serializer . addObjectSerializer ( Binary . class , new BinarySerializer ( serializer ) ) ; 
serializer . addObjectSerializer ( byte [ ] . class , new ByteArraySerializer ( serializer ) ) ; 
} public BsonDocument asDocument ( ) { 
BsonDocument readConcern = new BsonDocument ( ) ; 
if ( level != null ) { 
readConcern . put ( "level" , new BsonString ( level . getValue ( ) ) ) ; 
} private static com . mongodb . Mongo getMongo ( ) throws Exception { 
if ( mongo == null ) { 
mongo = new MongoClient ( host ) ; 
return mongo ; 
printUsage ( ) ; 
String s = args [ i ] ; 
if ( s . equals ( "--db" ) ) { 
db = args [ i + 1 ] ; 
if ( s . equals ( "--host" ) ) { 
if ( s . equals ( "help" ) ) { 
if ( s . equals ( "list" ) ) { 
GridFS fs = getGridFS ( ) ; 
DBCursor fileListCursor = fs . getFileList ( ) ; 
while ( fileListCursor . hasNext ( ) ) { 
DBObject o = fileListCursor . next ( ) ; 
fileListCursor . close ( ) ; 
if ( s . equals ( "get" ) ) { 
String fn = args [ i + 1 ] ; 
GridFSDBFile f = fs . findOne ( fn ) ; 
f . writeTo ( f . getFilename ( ) ) ; 
if ( s . equals ( "put" ) ) { 
GridFSInputFile f = fs . createFile ( new File ( fn ) ) ; 
f . validate ( ) ; 
if ( s . equals ( "md5" ) ) { 
DigestInputStream is = new DigestInputStream ( f . getInputStream ( ) , md5 ) ; 
while ( is . read ( ) >= 0 ) { 
int r = is . read ( new byte [ 17 ] ) ; 
if ( r < 0 ) { 
read += r ; 
public void compress ( final List < ByteBuf > source , final BsonOutput target ) { 
int uncompressedSize = getUncompressedSize ( source ) ; 
byte [ ] singleByteArraySource = new byte [ uncompressedSize ] ; 
copy ( source , singleByteArraySource ) ; 
byte [ ] out = new byte [ Snappy . maxCompressedLength ( uncompressedSize ) ] ; 
int compressedSize = Snappy . compress ( singleByteArraySource , 0 , singleByteArraySource . length , out , 0 ) ; 
target . writeBytes ( out , 0 , compressedSize ) ; 
} static int getNumberToReturn ( final int limit , final int batchSize , final int numReturnedSoFar ) { 
int numberToReturn ; 
if ( Math . abs ( limit ) != 0 ) { 
numberToReturn = Math . abs ( limit ) - numReturnedSoFar ; 
if ( batchSize != 0 && numberToReturn > Math . abs ( batchSize ) ) { 
numberToReturn = batchSize ; 
return numberToReturn ; 
} public int getInt ( final String key ) { 
Object o = get ( key ) ; 
return toInt ( o ) ; 
} public int getInt ( final String key , final int def ) { 
Object foo = get ( key ) ; 
return toInt ( foo ) ; 
} public long getLong ( final String key ) { 
return ( ( Number ) foo ) . longValue ( ) ; 
} public double getDouble ( final String key ) { 
return ( ( Number ) foo ) . doubleValue ( ) ; 
} public String getString ( final String key ) { 
} public boolean getBoolean ( final String key , final boolean def ) { 
if ( foo instanceof Number ) { 
return ( ( Number ) foo ) . intValue ( ) > 0 ; 
if ( foo instanceof Boolean ) { 
return ( Boolean ) foo ; 
} public ObjectId getObjectId ( final String field , final ObjectId def ) { 
Object foo = get ( field ) ; 
return ( foo != null ) ? ( ObjectId ) foo : def ; 
} public Date getDate ( final String field , final Date def ) { 
return ( foo != null ) ? ( Date ) foo : def ; 
private static Object canonicalize ( final Object from ) { 
if ( from instanceof BSONObject && ! ( from instanceof BasicBSONList ) ) { 
return canonicalizeBSONObject ( ( BSONObject ) from ) ; 
} else if ( from instanceof List ) { 
return canonicalizeList ( ( List < Object > ) from ) ; 
} else if ( from instanceof Map ) { 
return canonicalizeMap ( ( Map < String , Object > ) from ) ; 
return from ; 
} public FindOneAndUpdateOptions maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
public MongoCredential getCredential ( ) { 
if ( getCredentialsList ( ) . size ( ) > 1 ) { 
} else if ( getCredentialsList ( ) . isEmpty ( ) ) { 
return getCredentialsList ( ) . get ( 0 ) ; 
} public < T > ListDatabasesIterable < T > listDatabases ( final Class < T > clazz ) { 
return createListDatabasesIterable ( null , clazz ) ; 
} public < T > ListDatabasesIterable < T > listDatabases ( final ClientSession clientSession , final Class < T > clazz ) { 
notNull ( "clientSession" , clientSession ) ; 
return createListDatabasesIterable ( clientSession , clazz ) ; 
} public ClientSession startSession ( final ClientSessionOptions options ) { 
ClientSession clientSession = createClientSession ( notNull ( "options" , options ) ) ; 
if ( clientSession == null ) { 
return clientSession ; 
} public static < TResult > Observable < TResult > observe ( final MongoIterable < TResult > mongoIterable ) { 
return new Observable < TResult > ( ) { 
public void subscribe ( final Observer < ? super TResult > observer ) { 
new MongoIterableSubscription < TResult > ( mongoIterable , observer ) ; 
} public static < TResult > Observable < TResult > observe ( final Block < SingleResultCallback < TResult > > operation ) { 
new SingleResultCallbackSubscription < TResult > ( operation , observer ) ; 
} public static < TResult > Observable < TResult > observeAndFlatten ( final Block < SingleResultCallback < List < TResult > > > operation ) { 
new FlatteningSingleResultCallbackSubscription < TResult > ( operation , observer ) ; 
public BsonType readBsonType ( ) { 
if ( getState ( ) == State . INITIAL || getState ( ) == State . DONE || getState ( ) == State . SCOPE_DOCUMENT ) { 
setState ( State . TYPE ) ; 
if ( getState ( ) != State . TYPE ) { 
throwInvalidState ( "readBSONType" , State . TYPE ) ; 
if ( getContext ( ) . getContextType ( ) == BsonContextType . DOCUMENT ) { 
JsonToken nameToken = popToken ( ) ; 
switch ( nameToken . getType ( ) ) { 
case UNQUOTED_STRING : 
setCurrentName ( nameToken . getValue ( String . class ) ) ; 
case END_OBJECT : 
setState ( State . END_OF_DOCUMENT ) ; 
return BsonType . END_OF_DOCUMENT ; 
JsonToken colonToken = popToken ( ) ; 
if ( colonToken . getType ( ) != JsonTokenType . COLON ) { 
JsonToken token = popToken ( ) ; 
if ( getContext ( ) . getContextType ( ) == BsonContextType . ARRAY && token . getType ( ) == JsonTokenType . END_ARRAY ) { 
setState ( State . END_OF_ARRAY ) ; 
boolean noValueFound = false ; 
switch ( token . getType ( ) ) { 
case BEGIN_ARRAY : 
setCurrentBsonType ( BsonType . ARRAY ) ; 
case BEGIN_OBJECT : 
visitExtendedJSON ( ) ; 
setCurrentBsonType ( BsonType . DOUBLE ) ; 
currentValue = token . getValue ( ) ; 
case END_OF_FILE : 
setCurrentBsonType ( BsonType . END_OF_DOCUMENT ) ; 
setCurrentBsonType ( BsonType . INT32 ) ; 
case INT64 : 
setCurrentBsonType ( BsonType . INT64 ) ; 
case REGULAR_EXPRESSION : 
setCurrentBsonType ( BsonType . REGULAR_EXPRESSION ) ; 
setCurrentBsonType ( BsonType . STRING ) ; 
String value = token . getValue ( String . class ) ; 
if ( "false" . equals ( value ) || "true" . equals ( value ) ) { 
setCurrentBsonType ( BsonType . BOOLEAN ) ; 
currentValue = Boolean . parseBoolean ( value ) ; 
} else if ( "Infinity" . equals ( value ) ) { 
currentValue = Double . POSITIVE_INFINITY ; 
} else if ( "NaN" . equals ( value ) ) { 
currentValue = Double . NaN ; 
} else if ( "null" . equals ( value ) ) { 
setCurrentBsonType ( BsonType . NULL ) ; 
} else if ( "undefined" . equals ( value ) ) { 
setCurrentBsonType ( BsonType . UNDEFINED ) ; 
} else if ( "MinKey" . equals ( value ) ) { 
visitEmptyConstructor ( ) ; 
setCurrentBsonType ( BsonType . MIN_KEY ) ; 
currentValue = new MinKey ( ) ; 
} else if ( "MaxKey" . equals ( value ) ) { 
setCurrentBsonType ( BsonType . MAX_KEY ) ; 
currentValue = new MaxKey ( ) ; 
} else if ( "BinData" . equals ( value ) ) { 
setCurrentBsonType ( BsonType . BINARY ) ; 
currentValue = visitBinDataConstructor ( ) ; 
} else if ( "Date" . equals ( value ) ) { 
currentValue = visitDateTimeConstructorWithOutNew ( ) ; 
} else if ( "HexData" . equals ( value ) ) { 
currentValue = visitHexDataConstructor ( ) ; 
} else if ( "ISODate" . equals ( value ) ) { 
setCurrentBsonType ( BsonType . DATE_TIME ) ; 
currentValue = visitISODateTimeConstructor ( ) ; 
} else if ( "NumberInt" . equals ( value ) ) { 
currentValue = visitNumberIntConstructor ( ) ; 
} else if ( "NumberLong" . equals ( value ) ) { 
currentValue = visitNumberLongConstructor ( ) ; 
} else if ( "NumberDecimal" . equals ( value ) ) { 
setCurrentBsonType ( BsonType . DECIMAL128 ) ; 
currentValue = visitNumberDecimalConstructor ( ) ; 
} else if ( "ObjectId" . equals ( value ) ) { 
setCurrentBsonType ( BsonType . OBJECT_ID ) ; 
currentValue = visitObjectIdConstructor ( ) ; 
} else if ( "Timestamp" . equals ( value ) ) { 
setCurrentBsonType ( BsonType . TIMESTAMP ) ; 
currentValue = visitTimestampConstructor ( ) ; 
} else if ( "RegExp" . equals ( value ) ) { 
currentValue = visitRegularExpressionConstructor ( ) ; 
} else if ( "DBPointer" . equals ( value ) ) { 
setCurrentBsonType ( BsonType . DB_POINTER ) ; 
currentValue = visitDBPointerConstructor ( ) ; 
} else if ( "UUID" . equals ( value ) 
|| "GUID" . equals ( value ) 
|| "CSUUID" . equals ( value ) 
|| "CSGUID" . equals ( value ) 
|| "JUUID" . equals ( value ) 
|| "JGUID" . equals ( value ) 
|| "PYUUID" . equals ( value ) 
|| "PYGUID" . equals ( value ) ) { 
currentValue = visitUUIDConstructor ( value ) ; 
} else if ( "new" . equals ( value ) ) { 
visitNew ( ) ; 
noValueFound = true ; 
if ( noValueFound ) { 
if ( getContext ( ) . getContextType ( ) == BsonContextType . ARRAY || getContext ( ) . getContextType ( ) == BsonContextType . DOCUMENT ) { 
JsonToken commaToken = popToken ( ) ; 
if ( commaToken . getType ( ) != JsonTokenType . COMMA ) { 
pushToken ( commaToken ) ; 
switch ( getContext ( ) . getContextType ( ) ) { 
case DOCUMENT : 
case SCOPE_DOCUMENT : 
setState ( State . NAME ) ; 
case JAVASCRIPT_WITH_SCOPE : 
case TOP_LEVEL : 
setState ( State . VALUE ) ; 
return getCurrentBsonType ( ) ; 
public Integer getWTimeout ( final TimeUnit timeUnit ) { 
return wTimeoutMS == null ? null : ( int ) timeUnit . convert ( wTimeoutMS , TimeUnit . MILLISECONDS ) ; 
BsonDocument document = new BsonDocument ( ) ; 
addW ( document ) ; 
addWTimeout ( document ) ; 
addFSync ( document ) ; 
addJ ( document ) ; 
} public boolean isAcknowledged ( ) { 
if ( w instanceof Integer ) { 
return ( Integer ) w > 0 || ( journal != null && journal ) || ( fsync != null && fsync ) ; 
} public WriteConcern withW ( final int w ) { 
return new WriteConcern ( Integer . valueOf ( w ) , wTimeoutMS , fsync , journal ) ; 
} public WriteConcern withW ( final String w ) { 
notNull ( "w" , w ) ; 
return new WriteConcern ( w , wTimeoutMS , fsync , journal ) ; 
} public WriteConcern withWTimeout ( final long wTimeout , final TimeUnit timeUnit ) { 
long newWTimeOutMS = TimeUnit . MILLISECONDS . convert ( wTimeout , timeUnit ) ; 
return new WriteConcern ( w , ( int ) newWTimeOutMS , fsync , journal ) ; 
public static Majority majorityWriteConcern ( final int wtimeout , final boolean fsync , final boolean j ) { 
return new Majority ( wtimeout , fsync , j ) ; 
} public void insert ( final DBObject document ) { 
if ( document . get ( ID_FIELD_NAME ) == null ) { 
document . put ( ID_FIELD_NAME , new ObjectId ( ) ) ; 
addRequest ( new InsertRequest ( document , collection . getObjectCodec ( ) ) ) ; 
} public BulkWriteRequestBuilder find ( final DBObject query ) { 
return new BulkWriteRequestBuilder ( this , query , collection . getDefaultDBObjectCodec ( ) , collection . getObjectCodec ( ) ) ; 
} public BulkWriteResult execute ( ) { 
return collection . executeBulkWriteOperation ( ordered , bypassDocumentValidation , requests ) ; 
} public static BasicDBObject parse ( final String json ) { 
return parse ( json , DBObjectCodec . getDefaultRegistry ( ) . get ( BasicDBObject . class ) ) ; 
} public static BasicDBObject parse ( final String json , final Decoder < BasicDBObject > decoder ) { 
return decoder . decode ( new JsonReader ( json ) , DecoderContext . builder ( ) . build ( ) ) ; 
public BasicDBObject append ( final String key , final Object val ) { 
put ( key , val ) ; 
} public String toJson ( final JsonWriterSettings writerSettings ) { 
return toJson ( writerSettings , DBObjectCodec . getDefaultRegistry ( ) . get ( BasicDBObject . class ) ) ; 
BasicDBObject newCopy = new BasicDBObject ( this . toMap ( ) ) ; 
for ( final String field : keySet ( ) ) { 
Object val = get ( field ) ; 
newCopy . put ( field , ( ( BasicDBObject ) val ) . copy ( ) ) ; 
newCopy . put ( field , ( ( BasicDBList ) val ) . copy ( ) ) ; 
return newCopy ; 
return compoundIndex ( fieldNames , new BsonInt32 ( 1 ) ) ; 
return compoundIndex ( fieldNames , new BsonInt32 ( - 1 ) ) ; 
} public static Bson geo2dsphere ( final List < String > fieldNames ) { 
return compoundIndex ( fieldNames , new BsonString ( "2dsphere" ) ) ; 
} public static Bson geoHaystack ( final String fieldName , final Bson additional ) { 
return compoundIndex ( new BsonDocument ( fieldName , new BsonString ( "geoHaystack" ) ) , additional ) ; 
} public List < String > getIndexNames ( ) { 
List < String > indexNames = new ArrayList < String > ( requests . size ( ) ) ; 
for ( IndexRequest request : requests ) { 
if ( request . getName ( ) != null ) { 
indexNames . add ( request . getName ( ) ) ; 
indexNames . add ( IndexHelper . generateIndexName ( request . getKeys ( ) ) ) ; 
} public FindOptions maxAwaitTime ( final long maxAwaitTime , final TimeUnit timeUnit ) { 
this . maxAwaitTimeMS = TimeUnit . MILLISECONDS . convert ( maxAwaitTime , timeUnit ) ; 
} public static BsonDocument parse ( final String json ) { 
return new BsonDocumentCodec ( ) . decode ( new JsonReader ( json ) , DecoderContext . builder ( ) . build ( ) ) ; 
} public BsonValue get ( final Object key , final BsonValue defaultValue ) { 
BsonValue value = get ( key ) ; 
return value != null ? value : defaultValue ; 
} public BsonDocument getDocument ( final Object key , final BsonDocument defaultValue ) { 
if ( ! containsKey ( key ) ) { 
return get ( key ) . asDocument ( ) ; 
} public BsonArray getArray ( final Object key , final BsonArray defaultValue ) { 
return get ( key ) . asArray ( ) ; 
} public BsonNumber getNumber ( final Object key , final BsonNumber defaultValue ) { 
return get ( key ) . asNumber ( ) ; 
} public BsonInt32 getInt32 ( final Object key , final BsonInt32 defaultValue ) { 
return get ( key ) . asInt32 ( ) ; 
} public BsonInt64 getInt64 ( final Object key , final BsonInt64 defaultValue ) { 
return get ( key ) . asInt64 ( ) ; 
} public BsonDecimal128 getDecimal128 ( final Object key , final BsonDecimal128 defaultValue ) { 
return get ( key ) . asDecimal128 ( ) ; 
} public BsonDouble getDouble ( final Object key , final BsonDouble defaultValue ) { 
return get ( key ) . asDouble ( ) ; 
} public BsonBoolean getBoolean ( final Object key , final BsonBoolean defaultValue ) { 
return get ( key ) . asBoolean ( ) ; 
} public BsonString getString ( final Object key , final BsonString defaultValue ) { 
return get ( key ) . asString ( ) ; 
} public BsonDateTime getDateTime ( final Object key , final BsonDateTime defaultValue ) { 
return get ( key ) . asDateTime ( ) ; 
} public BsonTimestamp getTimestamp ( final Object key , final BsonTimestamp defaultValue ) { 
return get ( key ) . asTimestamp ( ) ; 
} public BsonObjectId getObjectId ( final Object key , final BsonObjectId defaultValue ) { 
return get ( key ) . asObjectId ( ) ; 
} public BsonBinary getBinary ( final Object key , final BsonBinary defaultValue ) { 
return get ( key ) . asBinary ( ) ; 
} public BsonRegularExpression getRegularExpression ( final Object key , final BsonRegularExpression defaultValue ) { 
return get ( key ) . asRegularExpression ( ) ; 
} public String toJson ( final JsonWriterSettings settings ) { 
new BsonDocumentCodec ( ) . encode ( new JsonWriter ( writer , settings ) , this , EncoderContext . builder ( ) . build ( ) ) ; 
} private void writeHandlingTasks ( final RegisteredSocket socket , final WriteOperation op ) throws IOException { 
socket . tlsChannel . write ( op . bufferSet . array , op . bufferSet . offset , op . bufferSet . length ) ; 
} catch ( NeedsTaskException e ) { 
warnAboutNeedTask ( ) ; 
e . getTask ( ) . run ( ) ; 
} public ChangeStreamOperation < T > maxAwaitTime ( final long maxAwaitTime , final TimeUnit timeUnit ) { 
public static BsonDocument asBsonDocument ( final Object document , final CodecRegistry codecRegistry ) { 
if ( document instanceof BsonDocument ) { 
return ( BsonDocument ) document ; 
return new BsonDocumentWrapper ( document , codecRegistry . get ( document . getClass ( ) ) ) ; 
} public static void main ( final String [ ] args ) throws FileNotFoundException , InterruptedException , IOException { 
final AtomicReference < ObjectId > fileIdRef = new AtomicReference < ObjectId > ( ) ; 
final CountDownLatch uploadLatch = new CountDownLatch ( 1 ) ; 
gridFSBucket . uploadFromStream ( "mongodb-tutorial" , streamToUploadFrom , options , new SingleResultCallback < ObjectId > ( ) { 
public void onResult ( final ObjectId result , final Throwable t ) { 
fileIdRef . set ( result ) ; 
streamToUploadFrom . close ( new SingleResultCallback < Void > ( ) { 
uploadLatch . countDown ( ) ; 
uploadLatch . await ( ) ; 
ObjectId fileId = fileIdRef . get ( ) ; 
final CountDownLatch uploadLatch2 = new CountDownLatch ( 2 ) ; 
final GridFSUploadStream uploadStream = gridFSBucket . openUploadStream ( "sampleData" ) ; 
uploadStream . write ( data , new SingleResultCallback < Integer > ( ) { 
public void onResult ( final Integer result , final Throwable t ) { 
uploadLatch2 . countDown ( ) ; 
uploadStream . close ( new SingleResultCallback < Void > ( ) { 
uploadLatch2 . await ( ) ; 
final CountDownLatch findLatch = new CountDownLatch ( 1 ) ; 
} , new SingleResultCallback < Void > ( ) { 
findLatch . countDown ( ) ; 
findLatch . await ( ) ; 
final CountDownLatch findLatch2 = new CountDownLatch ( 1 ) ; 
} , 
new SingleResultCallback < Void > ( ) { 
findLatch2 . countDown ( ) ; 
findLatch2 . await ( ) ; 
Path outputPath = Paths . get ( "/tmp/mongodb-tutorial.txt" ) ; 
AsynchronousFileChannel streamToDownloadTo = AsynchronousFileChannel . open ( outputPath , StandardOpenOption . CREATE_NEW , 
StandardOpenOption . WRITE , StandardOpenOption . DELETE_ON_CLOSE ) ; 
final CountDownLatch downloadLatch = new CountDownLatch ( 1 ) ; 
gridFSBucket . downloadToStream ( fileId , channelToOutputStream ( streamToDownloadTo ) , new SingleResultCallback < Long > ( ) { 
public void onResult ( final Long result , final Throwable t ) { 
downloadLatch . countDown ( ) ; 
downloadLatch . await ( ) ; 
final CountDownLatch downloadLatch2 = new CountDownLatch ( 1 ) ; 
streamToDownloadTo = AsynchronousFileChannel . open ( outputPath , StandardOpenOption . CREATE_NEW , StandardOpenOption . WRITE , 
StandardOpenOption . DELETE_ON_CLOSE ) ; 
gridFSBucket . downloadToStream ( "mongodb-tutorial" , channelToOutputStream ( streamToDownloadTo ) , downloadOptions , 
new SingleResultCallback < Long > ( ) { 
downloadLatch2 . countDown ( ) ; 
downloadLatch2 . await ( ) ; 
final CountDownLatch downloadLatch3 = new CountDownLatch ( 1 ) ; 
final ByteBuffer dstByteBuffer = ByteBuffer . allocate ( 1024 * 1024 ) ; 
final GridFSDownloadStream downloadStream = gridFSBucket . openDownloadStream ( fileId ) ; 
downloadStream . read ( dstByteBuffer , new SingleResultCallback < Integer > ( ) { 
dstByteBuffer . flip ( ) ; 
byte [ ] bytes = new byte [ result ] ; 
dstByteBuffer . get ( bytes ) ; 
System . out . println ( new String ( bytes , StandardCharsets . UTF_8 ) ) ; 
downloadStream . close ( new SingleResultCallback < Void > ( ) { 
downloadLatch3 . countDown ( ) ; 
downloadLatch3 . await ( ) ; 
System . out . println ( "ByName" ) ; 
dstByteBuffer . clear ( ) ; 
final CountDownLatch downloadLatch4 = new CountDownLatch ( 1 ) ; 
final GridFSDownloadStream downloadStreamByName = gridFSBucket . openDownloadStream ( "sampleData" ) ; 
downloadStreamByName . read ( dstByteBuffer , new SingleResultCallback < Integer > ( ) { 
downloadStreamByName . close ( new SingleResultCallback < Void > ( ) { 
downloadLatch4 . countDown ( ) ; 
downloadLatch4 . await ( ) ; 
final CountDownLatch renameLatch = new CountDownLatch ( 1 ) ; 
gridFSBucket . rename ( fileId , "mongodbTutorial" , new SingleResultCallback < Void > ( ) { 
renameLatch . countDown ( ) ; 
renameLatch . await ( ) ; 
gridFSBucket . delete ( fileId , new SingleResultCallback < Void > ( ) { 
final CountDownLatch dropLatch2 = new CountDownLatch ( 1 ) ; 
dropLatch2 . countDown ( ) ; 
dropLatch2 . await ( ) ; 
System . out . println ( "Finished" ) ; 
} public static < T > T notNull ( final String name , final T value , final SingleResultCallback < ? > callback ) { 
callback . onResult ( null , exception ) ; 
} public static void isTrue ( final String name , final boolean condition , final SingleResultCallback < ? > callback ) { 
} public PropertyModelBuilder < ? > getProperty ( final String propertyName ) { 
notNull ( "propertyName" , propertyName ) ; 
for ( PropertyModelBuilder < ? > propertyModelBuilder : propertyModelBuilders ) { 
if ( propertyModelBuilder . getName ( ) . equals ( propertyName ) ) { 
return propertyModelBuilder ; 
} public ClassModel < T > build ( ) { 
List < PropertyModel < ? > > propertyModels = new ArrayList < PropertyModel < ? > > ( ) ; 
PropertyModel < ? > idPropertyModel = null ; 
stateNotNull ( "type" , type ) ; 
for ( Convention convention : conventions ) { 
convention . apply ( this ) ; 
stateNotNull ( "instanceCreatorFactory" , instanceCreatorFactory ) ; 
if ( discriminatorEnabled ) { 
stateNotNull ( "discriminatorKey" , discriminatorKey ) ; 
stateNotNull ( "discriminator" , discriminator ) ; 
boolean isIdProperty = propertyModelBuilder . getName ( ) . equals ( idPropertyName ) ; 
if ( isIdProperty ) { 
propertyModelBuilder . readName ( ID_PROPERTY_NAME ) . writeName ( ID_PROPERTY_NAME ) ; 
PropertyModel < ? > model = propertyModelBuilder . build ( ) ; 
propertyModels . add ( model ) ; 
idPropertyModel = model ; 
validatePropertyModels ( type . getSimpleName ( ) , propertyModels ) ; 
return new ClassModel < T > ( type , propertyNameToTypeParameterMap , instanceCreatorFactory , discriminatorEnabled , discriminatorKey , 
discriminator , IdPropertyModelHolder . create ( type , idPropertyModel , idGenerator ) , unmodifiableList ( propertyModels ) ) ; 
public UpdateOptions getOptions ( ) { 
return new UpdateOptions ( ) 
. upsert ( options . isUpsert ( ) ) ; 
mongoClient = MongoClients . create ( "mongodb://localhost:27017,localhost:27018,localhost:27019" ) ; 
MongoDatabase database = mongoClient . getDatabase ( "testChangeStreams" ) ; 
sleep ( ) ; 
MongoCollection < Document > collection = database . getCollection ( "documents" ) ; 
MongoCursor < ChangeStreamDocument < Document > > cursor = collection . watch ( ) . iterator ( ) ; 
ChangeStreamDocument < Document > next = cursor . next ( ) ; 
System . out . println ( next ) ; 
cursor = collection . watch ( ) . fullDocument ( FullDocument . UPDATE_LOOKUP ) . iterator ( ) ; 
next = cursor . next ( ) ; 
List < Bson > pipeline = singletonList ( 
Aggregates . match ( 
Filters . or ( 
Filters . in ( "operationType" , asList ( "update" , "replace" , "delete" ) ) 
cursor = collection . watch ( pipeline ) . fullDocument ( FullDocument . UPDATE_LOOKUP ) . iterator ( ) ; 
next = cursor . tryNext ( ) ; 
collection . updateOne ( Filters . eq ( "updateMe" , 1 ) , Updates . set ( "updated" , true ) ) ; 
collection . deleteOne ( Filters . eq ( "username" , "alice123" ) ) ; 
BsonDocument resumeToken = next . getResumeToken ( ) ; 
System . out . println ( resumeToken ) ; 
cursor = collection . watch ( ) . resumeAfter ( resumeToken ) . iterator ( ) ; 
public static MongoException fromThrowable ( @ Nullable final Throwable t ) { 
return fromThrowableNonNull ( t ) ; 
} public static MongoException fromThrowableNonNull ( final Throwable t ) { 
if ( t instanceof MongoException ) { 
return ( MongoException ) t ; 
return new MongoException ( t . getMessage ( ) , t ) ; 
} public FindOperation < T > maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
} public FindOperation < T > maxAwaitTime ( final long maxAwaitTime , final TimeUnit timeUnit ) { 
notNull ( "explainVerbosity" , explainVerbosity ) ; 
return new ReadOperation < BsonDocument > ( ) { 
public BsonDocument execute ( final ReadBinding binding ) { 
return withConnection ( binding , new CallableWithConnectionAndSource < BsonDocument > ( ) { 
public BsonDocument call ( final ConnectionSource connectionSource , final Connection connection ) { 
ReadBinding singleConnectionBinding = new SingleConnectionReadBinding ( binding . getReadPreference ( ) , 
connectionSource . getServerDescription ( ) , 
connection ) ; 
return new CommandReadOperation < BsonDocument > ( getNamespace ( ) . getDatabaseName ( ) , 
new BsonDocument ( "explain" , 
getCommand ( binding . getSessionContext ( ) ) ) , 
new BsonDocumentCodec ( ) ) . execute ( singleConnectionBinding ) ; 
throw new MongoQueryException ( e ) ; 
BatchCursor < BsonDocument > cursor = createExplainableQueryOperation ( ) . execute ( singleConnectionBinding ) ; 
return cursor . next ( ) . iterator ( ) . next ( ) ; 
singleConnectionBinding . release ( ) ; 
return new AsyncReadOperation < BsonDocument > ( ) { 
public void executeAsync ( final AsyncReadBinding binding , final SingleResultCallback < BsonDocument > callback ) { 
withConnection ( binding , new AsyncCallableWithConnectionAndSource ( ) { 
public void call ( final AsyncConnectionSource connectionSource , final AsyncConnection connection , final Throwable t ) { 
SingleResultCallback < BsonDocument > errHandlingCallback = errorHandlingCallback ( callback , LOGGER ) ; 
errHandlingCallback . onResult ( null , t ) ; 
AsyncReadBinding singleConnectionReadBinding = 
new AsyncSingleConnectionReadBinding ( binding . getReadPreference ( ) , connectionSource . getServerDescription ( ) , 
new CommandReadOperation < BsonDocument > ( namespace . getDatabaseName ( ) , 
new BsonDocument ( "explain" , getCommand ( binding . getSessionContext ( ) ) ) , 
. executeAsync ( singleConnectionReadBinding , 
releasingCallback ( exceptionTransformingCallback ( errHandlingCallback ) , 
singleConnectionReadBinding , connectionSource , connection ) ) ; 
createExplainableQueryOperation ( ) 
releasingCallback ( new ExplainResultCallback ( errHandlingCallback ) , 
public static JavaWrapper getWrapperIfReflectionObject ( final Class c ) { 
if ( ReflectionDBObject . class . isAssignableFrom ( c ) ) { 
return getWrapper ( c ) ; 
} public static JavaWrapper getWrapper ( final Class c ) { 
JavaWrapper w = _wrappers . get ( c ) ; 
if ( w == null ) { 
w = new JavaWrapper ( c ) ; 
_wrappers . put ( c , w ) ; 
return w ; 
} public CountOptions maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
} public UUID asUuid ( ) { 
if ( ! BsonBinarySubType . isUuid ( type ) ) { 
if ( type != BsonBinarySubType . UUID_STANDARD . getValue ( ) ) { 
return UuidHelper . decodeBinaryToUuid ( this . data . clone ( ) , this . type , UuidRepresentation . STANDARD ) ; 
} public UUID asUuid ( final UuidRepresentation uuidRepresentation ) { 
Assertions . notNull ( "uuidRepresentation" , uuidRepresentation ) ; 
final byte uuidType = uuidRepresentation == UuidRepresentation . STANDARD 
? BsonBinarySubType . UUID_STANDARD . getValue ( ) 
: BsonBinarySubType . UUID_LEGACY . getValue ( ) ; 
if ( type != uuidType ) { 
return UuidHelper . decodeBinaryToUuid ( data . clone ( ) , type , uuidRepresentation ) ; 
} public static RawBsonDocument parse ( final String json ) { 
notNull ( "json" , json ) ; 
return new RawBsonDocumentCodec ( ) . decode ( new JsonReader ( json ) , DecoderContext . builder ( ) . build ( ) ) ; 
} public ByteBuf getByteBuffer ( ) { 
ByteBuffer buffer = ByteBuffer . wrap ( bytes , offset , length ) ; 
buffer . order ( ByteOrder . LITTLE_ENDIAN ) ; 
return new ByteBufNIO ( buffer ) ; 
} public < T > T decode ( final Codec < T > codec ) { 
return decode ( ( Decoder < T > ) codec ) ; 
} public < T > T decode ( final Decoder < T > decoder ) { 
BsonBinaryReader reader = createReader ( ) ; 
return decoder . decode ( reader , DecoderContext . builder ( ) . build ( ) ) ; 
} public static String serialize ( final Object object ) { 
serialize ( object , buf ) ; 
} public static void serialize ( final Object object , final StringBuilder buf ) { 
JSONSerializers . getLegacy ( ) . serialize ( object , buf ) ; 
} public static Object parse ( final String s , final BSONCallback c ) { 
if ( s == null || ( s . trim ( ) ) . equals ( "" ) ) { 
JSONParser p = new JSONParser ( s , c ) ; 
return p . parse ( ) ; 
} protected Object parse ( final String name ) { 
char current = get ( ) ; 
switch ( current ) { 
read ( 'n' ) ; 
read ( 'u' ) ; 
read ( 'l' ) ; 
read ( 'N' ) ; 
read ( 'a' ) ; 
value = Double . NaN ; 
read ( 't' ) ; 
read ( 'r' ) ; 
read ( 'e' ) ; 
value = true ; 
read ( 'f' ) ; 
read ( 's' ) ; 
value = false ; 
value = parseString ( true ) ; 
case '1' : 
case '2' : 
case '3' : 
case '4' : 
case '5' : 
case '6' : 
case '7' : 
case '8' : 
case '9' : 
value = parseNumber ( ) ; 
value = parseArray ( name ) ; 
value = parseObject ( name ) ; 
throw new JSONParseException ( s , pos ) ; 
} protected Object parseObject ( final String name ) { 
_callback . objectStart ( name ) ; 
_callback . objectStart ( ) ; 
read ( '{' ) ; 
while ( get ( ) != '}' ) { 
String key = parseString ( false ) ; 
read ( ':' ) ; 
Object value = parse ( key ) ; 
doCallback ( key , value ) ; 
if ( ( current = get ( ) ) == ',' ) { 
read ( ',' ) ; 
read ( '}' ) ; 
return _callback . objectDone ( ) ; 
} public void readHex ( ) { 
if ( pos < s . length ( ) 
&& ( ( s . charAt ( pos ) >= '0' && s . charAt ( pos ) <= '9' ) 
|| ( s . charAt ( pos ) >= 'A' && s . charAt ( pos ) <= 'F' ) 
|| ( s . charAt ( pos ) >= 'a' && s . charAt ( pos ) <= 'f' ) ) ) { 
} public void skipWS ( ) { 
while ( pos < s . length ( ) && Character . isWhitespace ( s . charAt ( pos ) ) ) { 
} public String parseString ( final boolean needQuote ) { 
char quot = 0 ; 
if ( check ( '\'' ) ) { 
quot = '\'' ; 
} else if ( check ( '\"' ) ) { 
quot = '\"' ; 
} else if ( needQuote ) { 
char current ; 
if ( quot > 0 ) { 
read ( quot ) ; 
while ( pos < s . length ( ) ) { 
current = s . charAt ( pos ) ; 
if ( current == quot ) { 
if ( current == '\\' ) { 
char x = get ( ) ; 
char special = 0 ; 
switch ( x ) { 
buf . append ( s . substring ( start , pos - 1 ) ) ; 
int tempPos = pos ; 
readHex ( ) ; 
int codePoint = Integer . parseInt ( s . substring ( tempPos , tempPos + 4 ) , 16 ) ; 
buf . append ( ( char ) codePoint ) ; 
start = pos ; 
special = '\n' ; 
special = '\r' ; 
special = '\t' ; 
special = '\b' ; 
special = '\"' ; 
special = '\\' ; 
if ( special != 0 ) { 
buf . append ( special ) ; 
buf . append ( s . substring ( start , pos ) ) ; 
} public Number parseNumber ( ) { 
get ( ) ; 
int start = this . pos ; 
boolean isDouble = false ; 
if ( check ( '-' ) || check ( '+' ) ) { 
outer : 
switch ( s . charAt ( pos ) ) { 
isDouble = true ; 
parseFraction ( ) ; 
parseExponent ( ) ; 
break outer ; 
if ( isDouble ) { 
return Double . valueOf ( s . substring ( start , pos ) ) ; 
Long val = Long . valueOf ( s . substring ( start , pos ) ) ; 
if ( val <= Integer . MAX_VALUE && val >= Integer . MIN_VALUE ) { 
return val . intValue ( ) ; 
throw new JSONParseException ( s , start , e ) ; 
} public void parseFraction ( ) { 
} public void parseExponent ( ) { 
} protected Object parseArray ( final String name ) { 
_callback . arrayStart ( name ) ; 
_callback . arrayStart ( ) ; 
read ( '[' ) ; 
while ( current != ']' ) { 
String elemName = String . valueOf ( i ++ ) ; 
Object elem = parse ( elemName ) ; 
doCallback ( elemName , elem ) ; 
} else if ( current == ']' ) { 
read ( ']' ) ; 
return _callback . arrayDone ( ) ; 
bulkWriteOperation . addRequest ( new ReplaceRequest ( query , document , upsert , queryCodec , replacementCodec , collation ) ) ; 
bulkWriteOperation . addRequest ( new UpdateRequest ( query , update , true , upsert , queryCodec , collation , arrayFilters ) ) ; 
} public void updateOne ( final DBObject update ) { 
bulkWriteOperation . addRequest ( new UpdateRequest ( query , update , false , upsert , queryCodec , collation , arrayFilters ) ) ; 
} public ConnectionDescription withConnectionId ( final ConnectionId connectionId ) { 
notNull ( "connectionId" , connectionId ) ; 
return new ConnectionDescription ( connectionId , serverVersion , maxWireVersion , serverType , maxBatchCount , maxDocumentSize , 
maxMessageSize , compressors ) ; 
} public static WriteConcernResult acknowledged ( final int count , final boolean isUpdateOfExisting , @ Nullable final BsonValue upsertedId ) { 
return new WriteConcernResult ( ) { 
public int getCount ( ) { 
public boolean isUpdateOfExisting ( ) { 
return isUpdateOfExisting ; 
public BsonValue getUpsertedId ( ) { 
return upsertedId ; 
WriteConcernResult that = ( WriteConcernResult ) o ; 
if ( count != that . getCount ( ) ) { 
if ( isUpdateOfExisting != that . isUpdateOfExisting ( ) ) { 
if ( upsertedId != null ? ! upsertedId . equals ( that . getUpsertedId ( ) ) : that . getUpsertedId ( ) != null ) { 
int result = count ; 
result = 31 * result + ( isUpdateOfExisting ? 1 : 0 ) ; 
result = 31 * result + ( upsertedId != null ? upsertedId . hashCode ( ) : 0 ) ; 
return "AcknowledgedWriteResult{" 
+ "count=" + count 
} public static WriteConcernResult unacknowledged ( ) { 
return "UnacknowledgedWriteResult{}" ; 
} public static Document parse ( final String json , final Decoder < Document > decoder ) { 
notNull ( "codec" , decoder ) ; 
JsonReader bsonReader = new JsonReader ( json ) ; 
return decoder . decode ( bsonReader , DecoderContext . builder ( ) . build ( ) ) ; 
} public Document append ( final String key , final Object value ) { 
documentAsMap . put ( key , value ) ; 
} public < T > T get ( final Object key , final Class < T > clazz ) { 
notNull ( "clazz" , clazz ) ; 
return clazz . cast ( documentAsMap . get ( key ) ) ; 
public < T > T get ( final Object key , final T defaultValue ) { 
notNull ( "defaultValue" , defaultValue ) ; 
Object value = documentAsMap . get ( key ) ; 
return value == null ? defaultValue : ( T ) value ; 
} public < T > T getEmbedded ( final List < ? > keys , final Class < T > clazz ) { 
notNull ( "keys" , keys ) ; 
isTrue ( "keys" , ! keys . isEmpty ( ) ) ; 
return getEmbeddedValue ( keys , clazz , null ) ; 
} public < T > T getEmbedded ( final List < ? > keys , final T defaultValue ) { 
return getEmbeddedValue ( keys , null , defaultValue ) ; 
private < T > T getEmbeddedValue ( final List < ? > keys , final Class < T > clazz , final T defaultValue ) { 
Object value = this ; 
Iterator < ? > keyIterator = keys . iterator ( ) ; 
while ( keyIterator . hasNext ( ) ) { 
Object key = keyIterator . next ( ) ; 
value = ( ( Document ) value ) . get ( key ) ; 
if ( ! ( value instanceof Document ) ) { 
} else if ( keyIterator . hasNext ( ) ) { 
key , value . getClass ( ) . getName ( ) ) ) ; 
return clazz != null ? clazz . cast ( value ) : ( T ) value ; 
} public < T > List < T > getList ( final Object key , final Class < T > clazz ) { 
return constructValuesList ( key , clazz , null ) ; 
} public < T > List < T > getList ( final Object key , final Class < T > clazz , final List < T > defaultValue ) { 
return constructValuesList ( key , clazz , defaultValue ) ; 
private < T > List < T > constructValuesList ( final Object key , final Class < T > clazz , final List < T > defaultValue ) { 
List < ? > value = get ( key , List . class ) ; 
for ( Object item : value ) { 
if ( ! clazz . isAssignableFrom ( item . getClass ( ) ) ) { 
return ( List < T > ) value ; 
} public String toJson ( final JsonWriterSettings writerSettings , final Encoder < Document > encoder ) { 
JsonWriter writer = new JsonWriter ( new StringWriter ( ) , writerSettings ) ; 
encoder . encode ( writer , this , EncoderContext . builder ( ) . isEncodingCollectibleDocument ( true ) . build ( ) ) ; 
return writer . getWriter ( ) . toString ( ) ; 
} public static TransactionOptions merge ( final TransactionOptions options , final TransactionOptions defaultOptions ) { 
notNull ( "defaultOptions" , defaultOptions ) ; 
return TransactionOptions . builder ( ) 
. writeConcern ( options . getWriteConcern ( ) == null 
? defaultOptions . getWriteConcern ( ) : options . getWriteConcern ( ) ) 
. readConcern ( options . getReadConcern ( ) == null 
? defaultOptions . getReadConcern ( ) : options . getReadConcern ( ) ) 
. readPreference ( options . getReadPreference ( ) == null 
? defaultOptions . getReadPreference ( ) : options . getReadPreference ( ) ) 
final MongoCollection < Document > collection = database . getCollection ( "test" ) ; 
. append ( "type" , "database" ) 
. append ( "count" , 1 ) 
. append ( "info" , new Document ( "x" , 203 ) . append ( "y" , 102 ) ) ; 
collection . insertOne ( doc , new SingleResultCallback < Void > ( ) { 
collection . find ( ) . first ( new SingleResultCallback < Document > ( ) { 
public void onResult ( final Document document , final Throwable t ) { 
List < Document > documents = new ArrayList < Document > ( ) ; 
for ( int i = 0 ; i < 100 ; i ++ ) { 
documents . add ( new Document ( "i" , i ) ) ; 
collection . insertMany ( documents , new SingleResultCallback < Void > ( ) { 
SingleResultCallback < Document > printDocument = new SingleResultCallback < Document > ( ) { 
collection . find ( ) . first ( printDocument ) ; 
collection . find ( ) . forEach ( printDocumentBlock , callbackWhenFinished ) ; 
collection . find ( eq ( "i" , 71 ) ) . first ( printDocument ) ; 
collection . find ( gt ( "i" , 50 ) ) . forEach ( printDocumentBlock , callbackWhenFinished ) ; 
collection . find ( and ( gt ( "i" , 50 ) , lte ( "i" , 100 ) ) ) . forEach ( printDocumentBlock , callbackWhenFinished ) ; 
collection . find ( exists ( "i" ) ) . sort ( descending ( "i" ) ) . first ( printDocument ) ; 
collection . find ( ) . projection ( excludeId ( ) ) . first ( printDocument ) ; 
collection . aggregate ( asList ( 
match ( gt ( "i" , 0 ) ) , 
) . forEach ( printDocumentBlock , callbackWhenFinished ) ; 
collection . aggregate ( singletonList ( group ( null , sum ( "total" , "$i" ) ) ) ) . first ( printDocument ) ; 
collection . updateOne ( eq ( "i" , 10 ) , set ( "i" , 110 ) , 
new SingleResultCallback < UpdateResult > ( ) { 
collection . updateMany ( lt ( "i" , 100 ) , inc ( "i" , 100 ) , 
collection . deleteOne ( eq ( "i" , 110 ) , new SingleResultCallback < DeleteResult > ( ) { 
collection . deleteMany ( gte ( "i" , 100 ) , new SingleResultCallback < DeleteResult > ( ) { 
List < WriteModel < Document > > writes = new ArrayList < WriteModel < Document > > ( ) ; 
writes . add ( new InsertOneModel < Document > ( new Document ( "_id" , 4 ) ) ) ; 
writes . add ( new InsertOneModel < Document > ( new Document ( "_id" , 5 ) ) ) ; 
writes . add ( new InsertOneModel < Document > ( new Document ( "_id" , 6 ) ) ) ; 
writes . add ( new UpdateOneModel < Document > ( new Document ( "_id" , 1 ) , new Document ( "$set" , new Document ( "x" , 2 ) ) ) ) ; 
writes . add ( new DeleteOneModel < Document > ( new Document ( "_id" , 2 ) ) ) ; 
writes . add ( new ReplaceOneModel < Document > ( new Document ( "_id" , 3 ) , new Document ( "_id" , 3 ) . append ( "x" , 4 ) ) ) ; 
SingleResultCallback < BulkWriteResult > printBatchResult = new SingleResultCallback < BulkWriteResult > ( ) { 
public void onResult ( final BulkWriteResult result , final Throwable t ) { 
System . out . println ( result ) ; 
collection . bulkWrite ( writes , printBatchResult ) ; 
final CountDownLatch dropLatch3 = new CountDownLatch ( 1 ) ; 
dropLatch3 . countDown ( ) ; 
dropLatch3 . await ( ) ; 
collection . bulkWrite ( writes , new BulkWriteOptions ( ) . ordered ( false ) , printBatchResult ) ; 
final CountDownLatch dropLatch4 = new CountDownLatch ( 1 ) ; 
dropLatch4 . countDown ( ) ; 
dropLatch4 . await ( ) ; 
} static boolean prohibited ( final int codepoint ) { 
return nonAsciiSpace ( ( char ) codepoint ) 
|| asciiControl ( ( char ) codepoint ) 
|| nonAsciiControl ( codepoint ) 
|| privateUse ( codepoint ) 
|| nonCharacterCodePoint ( codepoint ) 
|| surrogateCodePoint ( codepoint ) 
|| inappropriateForPlainText ( codepoint ) 
|| inappropriateForCanonical ( codepoint ) 
|| changeDisplayProperties ( codepoint ) 
|| tagging ( codepoint ) ; 
} private static boolean changeDisplayProperties ( final int codepoint ) { 
return codepoint == 0x0340 
|| codepoint == 0x0341 
|| codepoint == 0x200E 
|| codepoint == 0x200F 
|| codepoint == 0x202A 
|| codepoint == 0x202B 
|| codepoint == 0x202C 
|| codepoint == 0x202D 
|| codepoint == 0x202E 
|| codepoint == 0x206A 
|| codepoint == 0x206B 
|| codepoint == 0x206C 
|| codepoint == 0x206D 
|| codepoint == 0x206E 
|| codepoint == 0x206F ; 
} private static boolean nonCharacterCodePoint ( final int codepoint ) { 
return 0xFDD0 <= codepoint && codepoint <= 0xFDEF 
|| 0xFFFE <= codepoint && codepoint <= 0xFFFF 
|| 0x1FFFE <= codepoint && codepoint <= 0x1FFFF 
|| 0x2FFFE <= codepoint && codepoint <= 0x2FFFF 
|| 0x3FFFE <= codepoint && codepoint <= 0x3FFFF 
|| 0x4FFFE <= codepoint && codepoint <= 0x4FFFF 
|| 0x5FFFE <= codepoint && codepoint <= 0x5FFFF 
|| 0x6FFFE <= codepoint && codepoint <= 0x6FFFF 
|| 0x7FFFE <= codepoint && codepoint <= 0x7FFFF 
|| 0x8FFFE <= codepoint && codepoint <= 0x8FFFF 
|| 0x9FFFE <= codepoint && codepoint <= 0x9FFFF 
|| 0xAFFFE <= codepoint && codepoint <= 0xAFFFF 
|| 0xBFFFE <= codepoint && codepoint <= 0xBFFFF 
|| 0xCFFFE <= codepoint && codepoint <= 0xCFFFF 
|| 0xDFFFE <= codepoint && codepoint <= 0xDFFFF 
|| 0xEFFFE <= codepoint && codepoint <= 0xEFFFF 
|| 0xFFFFE <= codepoint && codepoint <= 0xFFFFF 
|| 0x10FFFE <= codepoint && codepoint <= 0x10FFFF ; 
} private static boolean nonAsciiControl ( final int codepoint ) { 
return 0x0080 <= codepoint && codepoint <= 0x009F 
|| codepoint == 0x06DD 
|| codepoint == 0x070F 
|| codepoint == 0x180E 
|| codepoint == 0x200C 
|| codepoint == 0x200D 
|| codepoint == 0x2028 
|| codepoint == 0x2029 
|| codepoint == 0x2060 
|| codepoint == 0x2061 
|| codepoint == 0x2062 
|| codepoint == 0x2063 
|| 0x206A <= codepoint && codepoint <= 0x206F 
|| codepoint == 0xFEFF 
|| 0xFFF9 <= codepoint && codepoint <= 0xFFFC 
|| 0x1D173 <= codepoint && codepoint <= 0x1D17A ; 
} private static boolean mappedToNothing ( final char ch ) { 
return ch == '' 
|| ch == '' 
|| ch == '' 
|| ch == '' 
|| ch == '' 
|| ch == '' 
|| ch == '' 
|| ch == '' 
|| ch == '' 
|| ch == '' 
|| '' <= ch && ch <= '' 
|| ch == '' ; 
public void release ( final T t , final boolean prune ) { 
close ( t ) ; 
if ( prune ) { 
available . addLast ( t ) ; 
releasePermit ( ) ; 
public T get ( final long timeout , final TimeUnit timeUnit ) { 
if ( ! acquirePermit ( timeout , timeUnit ) ) { 
T t = available . pollLast ( ) ; 
t = createNewAndReleasePermitIfFailure ( false ) ; 
Iterator < T > iter = available . iterator ( ) ; 
T t = iter . next ( ) ; 
} public static < TExpression , Boundary > Bson bucket ( final TExpression groupBy , final List < Boundary > boundaries ) { 
return bucket ( groupBy , boundaries , new BucketOptions ( ) ) ; 
} public static < TExpression , TBoundary > Bson bucket ( final TExpression groupBy , final List < TBoundary > boundaries , 
final BucketOptions options ) { 
return new BucketStage < TExpression , TBoundary > ( groupBy , boundaries , options ) ; 
} public static < TExpression > Bson bucketAuto ( final TExpression groupBy , final int buckets ) { 
return bucketAuto ( groupBy , buckets , new BucketAutoOptions ( ) ) ; 
} public static < TExpression > Bson bucketAuto ( final TExpression groupBy , final int buckets , final BucketAutoOptions options ) { 
return new BucketAutoStage < TExpression > ( groupBy , buckets , options ) ; 
} public static Bson lookup ( final String from , final String localField , final String foreignField , final String as ) { 
return new BsonDocument ( "$lookup" , new BsonDocument ( "from" , new BsonString ( from ) ) 
. append ( "localField" , new BsonString ( localField ) ) 
. append ( "foreignField" , new BsonString ( foreignField ) ) 
. append ( "as" , new BsonString ( as ) ) ) ; 
} public static Bson lookup ( final String from , final List < ? extends Bson > pipeline , final String as ) { 
return lookup ( from , null , pipeline , as ) ; 
} public static < TExpression > Bson lookup ( final String from , @ Nullable final List < Variable < TExpression > > let , 
final List < ? extends Bson > pipeline , final String as ) { 
return new LookupStage < TExpression > ( from , let , pipeline , as ) ; 
} public static < TExpression > Bson graphLookup ( final String from , final TExpression startWith , final String connectFromField , 
final String connectToField , final String as ) { 
return graphLookup ( from , startWith , connectFromField , connectToField , as , new GraphLookupOptions ( ) ) ; 
final String connectToField , final String as , final GraphLookupOptions options ) { 
return new GraphLookupStage < TExpression > ( from , startWith , connectFromField , connectToField , as , options ) ; 
} public static < TExpression > Bson group ( @ Nullable final TExpression id , final BsonField ... fieldAccumulators ) { 
return group ( id , asList ( fieldAccumulators ) ) ; 
} public static < TExpression > Bson group ( @ Nullable final TExpression id , final List < BsonField > fieldAccumulators ) { 
return new GroupStage < TExpression > ( id , fieldAccumulators ) ; 
} public static Bson unwind ( final String fieldName , final UnwindOptions unwindOptions ) { 
notNull ( "unwindOptions" , unwindOptions ) ; 
BsonDocument options = new BsonDocument ( "path" , new BsonString ( fieldName ) ) ; 
Boolean preserveNullAndEmptyArrays = unwindOptions . isPreserveNullAndEmptyArrays ( ) ; 
if ( preserveNullAndEmptyArrays != null ) { 
options . append ( "preserveNullAndEmptyArrays" , BsonBoolean . valueOf ( preserveNullAndEmptyArrays ) ) ; 
String includeArrayIndex = unwindOptions . getIncludeArrayIndex ( ) ; 
if ( includeArrayIndex != null ) { 
options . append ( "includeArrayIndex" , new BsonString ( includeArrayIndex ) ) ; 
return new BsonDocument ( "$unwind" , options ) ; 
} public static Bson out ( final String collectionName , final AggregateOutStageOptions options ) { 
notNull ( "collectionName" , collectionName ) ; 
return new OutStage ( collectionName , options ) ; 
} public int pipe ( final OutputStream os ) throws IOException { 
WritableByteChannel channel = Channels . newChannel ( os ) ; 
return channel . write ( getBufferForInternalBytes ( ) ) ; 
} public Set < Map . Entry < String , Object > > entrySet ( ) { 
final List < Map . Entry < String , Object > > entries = new ArrayList < Map . Entry < String , Object > > ( ) ; 
BsonBinaryReader reader = getBsonReader ( ) ; 
reader . readStartDocument ( ) ; 
while ( reader . readBsonType ( ) != BsonType . END_OF_DOCUMENT ) { 
entries . add ( new AbstractMap . SimpleImmutableEntry < String , Object > ( reader . readName ( ) , readValue ( reader ) ) ) ; 
reader . readEndDocument ( ) ; 
return new Set < Map . Entry < String , Object > > ( ) { 
return entries . size ( ) ; 
public boolean isEmpty ( ) { 
return entries . isEmpty ( ) ; 
public Iterator < Map . Entry < String , Object > > iterator ( ) { 
return entries . iterator ( ) ; 
public Object [ ] toArray ( ) { 
return entries . toArray ( ) ; 
public < T > T [ ] toArray ( final T [ ] a ) { 
return entries . toArray ( a ) ; 
public boolean contains ( final Object o ) { 
return entries . contains ( o ) ; 
public boolean containsAll ( final Collection < ? > c ) { 
return entries . containsAll ( c ) ; 
public boolean add ( final Map . Entry < String , Object > stringObjectEntry ) { 
public boolean remove ( final Object o ) { 
public boolean addAll ( final Collection < ? extends Map . Entry < String , Object > > c ) { 
public boolean retainAll ( final Collection < ? > c ) { 
public boolean removeAll ( final Collection < ? > c ) { 
} public static AsyncInputStream channelToInputStream ( final AsynchronousByteChannel asynchronousByteChannel ) { 
notNull ( "asynchronousByteChannel" , asynchronousByteChannel ) ; 
public void read ( final ByteBuffer dst , final SingleResultCallback < Integer > callback ) { 
asynchronousByteChannel . read ( dst , null , new CompletionHandler < Integer , Object > ( ) { 
public void completed ( final Integer result , final Object attachment ) { 
callback . onResult ( result , null ) ; 
public void failed ( final Throwable exc , final Object attachment ) { 
callback . onResult ( null , exc ) ; 
asynchronousByteChannel . close ( ) ; 
} public static AsyncOutputStream channelToOutputStream ( final AsynchronousFileChannel asynchronousFileChannel ) { 
notNull ( "asynchronousByteChannel" , asynchronousFileChannel ) ; 
private int position = 0 ; 
public void write ( final ByteBuffer src , final SingleResultCallback < Integer > callback ) { 
asynchronousFileChannel . write ( src , position , null , new CompletionHandler < Integer , Object > ( ) { 
position += result ; 
asynchronousFileChannel . close ( ) ; 
} public static < K , V > CopyOnWriteMap < K , V > newHashMap ( ) { 
Builder < K , V > builder = builder ( ) ; 
return builder . newHashMap ( ) ; 
} public static < K , V > CopyOnWriteMap < K , V > newHashMap ( final Map < ? extends K , ? extends V > map ) { 
return builder . addAll ( map ) . newHashMap ( ) ; 
} public static < K , V > CopyOnWriteMap < K , V > newLinkedMap ( ) { 
return builder . newLinkedMap ( ) ; 
} protected void throwInvalidContextType ( final String methodName , final BsonContextType actualContextType , 
final BsonContextType ... validContextTypes ) { 
methodName , validContextTypesString , actualContextType ) ; 
throw new BsonInvalidOperationException ( message ) ; 
methodName , validStatesString , state ) ; 
} protected void verifyBSONType ( final String methodName , final BsonType requiredBsonType ) { 
if ( state == State . INITIAL || state == State . SCOPE_DOCUMENT || state == State . TYPE ) { 
readBsonType ( ) ; 
if ( state == State . NAME ) { 
skipName ( ) ; 
if ( state != State . VALUE ) { 
throwInvalidState ( methodName , State . VALUE ) ; 
if ( currentBsonType != requiredBsonType ) { 
methodName , requiredBsonType , currentBsonType ) ) ; 
} protected void verifyName ( final String expectedName ) { 
String actualName = readName ( ) ; 
if ( ! actualName . equals ( expectedName ) ) { 
expectedName , actualName ) ) ; 
} protected void checkPreconditions ( final String methodName , final BsonType type ) { 
verifyBSONType ( methodName , type ) ; 
switch ( context . getContextType ( ) ) { 
return State . TYPE ; 
return State . DONE ; 
} public static Decimal128 parse ( final String value ) { 
String lowerCasedValue = value . toLowerCase ( ) ; 
if ( NaN_STRINGS . contains ( lowerCasedValue ) ) { 
return NaN ; 
if ( NEGATIVE_NaN_STRINGS . contains ( lowerCasedValue ) ) { 
return NEGATIVE_NaN ; 
if ( POSITIVE_INFINITY_STRINGS . contains ( lowerCasedValue ) ) { 
return POSITIVE_INFINITY ; 
if ( NEGATIVE_INFINITY_STRINGS . contains ( lowerCasedValue ) ) { 
return NEGATIVE_INFINITY ; 
return new Decimal128 ( new BigDecimal ( value ) , value . charAt ( 0 ) == '-' ) ; 
} public BigDecimal bigDecimalValue ( ) { 
if ( isNaN ( ) ) { 
if ( isInfinite ( ) ) { 
BigDecimal bigDecimal = bigDecimalValueNoNegativeZeroCheck ( ) ; 
if ( isNegative ( ) && bigDecimal . signum ( ) == 0 ) { 
return bigDecimal ; 
} private byte [ ] getBytes ( ) { 
byte [ ] bytes = new byte [ 15 ] ; 
long mask = 0x00000000000000ff ; 
for ( int i = 14 ; i >= 7 ; i -- ) { 
bytes [ i ] = ( byte ) ( ( low & mask ) > > > ( ( 14 - i ) << 3 ) ) ; 
mask = mask << 8 ; 
mask = 0x00000000000000ff ; 
for ( int i = 6 ; i >= 1 ; i -- ) { 
bytes [ i ] = ( byte ) ( ( high & mask ) > > > ( ( 6 - i ) << 3 ) ) ; 
mask = 0x0001000000000000L ; 
bytes [ 0 ] = ( byte ) ( ( high & mask ) > > > 48 ) ; 
public double doubleValue ( ) { 
if ( isNegative ( ) ) { 
return Double . NEGATIVE_INFINITY ; 
return Double . POSITIVE_INFINITY ; 
if ( hasDifferentSign ( bigDecimal ) ) { 
return - 0.0d ; 
return bigDecimal . doubleValue ( ) ; 
} public AggregateExplainOperation maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
} public AggregateExplainOperation hint ( final BsonValue hint ) { 
this . hint = hint ; 
BsonDocument collation = new BsonDocument ( ) ; 
if ( locale != null ) { 
collation . put ( "locale" , new BsonString ( locale ) ) ; 
if ( caseLevel != null ) { 
collation . put ( "caseLevel" , new BsonBoolean ( caseLevel ) ) ; 
if ( caseFirst != null ) { 
collation . put ( "caseFirst" , new BsonString ( caseFirst . getValue ( ) ) ) ; 
if ( strength != null ) { 
collation . put ( "strength" , new BsonInt32 ( strength . getIntRepresentation ( ) ) ) ; 
if ( numericOrdering != null ) { 
collation . put ( "numericOrdering" , new BsonBoolean ( numericOrdering ) ) ; 
if ( alternate != null ) { 
collation . put ( "alternate" , new BsonString ( alternate . getValue ( ) ) ) ; 
if ( maxVariable != null ) { 
collation . put ( "maxVariable" , new BsonString ( maxVariable . getValue ( ) ) ) ; 
if ( normalization != null ) { 
collation . put ( "normalization" , new BsonBoolean ( normalization ) ) ; 
if ( backwards != null ) { 
collation . put ( "backwards" , new BsonBoolean ( backwards ) ) ; 
return collation ; 
} public MongoClientOptions getOptions ( ) { 
ReadPreference readPreference = proxied . getReadPreference ( ) ; 
builder . readPreference ( readPreference ) ; 
ReadConcern readConcern = proxied . getReadConcern ( ) ; 
builder . readConcern ( readConcern ) ; 
WriteConcern writeConcern = proxied . getWriteConcern ( ) ; 
builder . writeConcern ( writeConcern ) ; 
if ( proxied . getRetryWritesValue ( ) != null ) { 
builder . retryWrites ( proxied . getRetryWritesValue ( ) ) ; 
if ( proxied . getRetryReads ( ) != null ) { 
builder . retryReads ( proxied . getRetryReads ( ) ) ; 
Integer maxConnectionPoolSize = proxied . getMaxConnectionPoolSize ( ) ; 
if ( maxConnectionPoolSize != null ) { 
builder . connectionsPerHost ( maxConnectionPoolSize ) ; 
Integer integer = proxied . getMinConnectionPoolSize ( ) ; 
if ( integer != null ) { 
builder . minConnectionsPerHost ( integer ) ; 
Integer maxWaitTime = proxied . getMaxWaitTime ( ) ; 
if ( maxWaitTime != null ) { 
builder . maxWaitTime ( maxWaitTime ) ; 
Integer threadsAllowedToBlockForConnectionMultiplier = proxied . getThreadsAllowedToBlockForConnectionMultiplier ( ) ; 
if ( threadsAllowedToBlockForConnectionMultiplier != null ) { 
builder . threadsAllowedToBlockForConnectionMultiplier ( threadsAllowedToBlockForConnectionMultiplier ) ; 
Integer maxConnectionIdleTime = proxied . getMaxConnectionIdleTime ( ) ; 
if ( maxConnectionIdleTime != null ) { 
builder . maxConnectionIdleTime ( maxConnectionIdleTime ) ; 
Integer maxConnectionLifeTime = proxied . getMaxConnectionLifeTime ( ) ; 
if ( maxConnectionLifeTime != null ) { 
builder . maxConnectionLifeTime ( maxConnectionLifeTime ) ; 
Integer socketTimeout = proxied . getSocketTimeout ( ) ; 
if ( socketTimeout != null ) { 
builder . socketTimeout ( socketTimeout ) ; 
Integer connectTimeout = proxied . getConnectTimeout ( ) ; 
if ( connectTimeout != null ) { 
builder . connectTimeout ( connectTimeout ) ; 
String requiredReplicaSetName = proxied . getRequiredReplicaSetName ( ) ; 
if ( requiredReplicaSetName != null ) { 
builder . requiredReplicaSetName ( requiredReplicaSetName ) ; 
Boolean sslEnabled = proxied . getSslEnabled ( ) ; 
if ( sslEnabled != null ) { 
builder . sslEnabled ( sslEnabled ) ; 
Boolean sslInvalidHostnameAllowed = proxied . getSslInvalidHostnameAllowed ( ) ; 
if ( sslInvalidHostnameAllowed != null ) { 
builder . sslInvalidHostNameAllowed ( sslInvalidHostnameAllowed ) ; 
Integer serverSelectionTimeout = proxied . getServerSelectionTimeout ( ) ; 
if ( serverSelectionTimeout != null ) { 
builder . serverSelectionTimeout ( serverSelectionTimeout ) ; 
Integer localThreshold = proxied . getLocalThreshold ( ) ; 
if ( localThreshold != null ) { 
builder . localThreshold ( localThreshold ) ; 
Integer heartbeatFrequency = proxied . getHeartbeatFrequency ( ) ; 
if ( heartbeatFrequency != null ) { 
builder . heartbeatFrequency ( heartbeatFrequency ) ; 
String applicationName = proxied . getApplicationName ( ) ; 
if ( applicationName != null ) { 
builder . applicationName ( applicationName ) ; 
if ( ! proxied . getCompressorList ( ) . isEmpty ( ) ) { 
builder . compressorList ( proxied . getCompressorList ( ) ) ; 
} public long writeTo ( final File file ) throws IOException { 
out = new FileOutputStream ( file ) ; 
return writeTo ( out ) ; 
} public long writeTo ( final OutputStream out ) throws IOException { 
int nc = numChunks ( ) ; 
out . write ( getChunk ( i ) ) ; 
} void remove ( ) { 
fs . getFilesCollection ( ) . remove ( new BasicDBObject ( "_id" , id ) ) ; 
fs . getChunksCollection ( ) . remove ( new BasicDBObject ( "files_id" , id ) ) ; 
} public PushOptions sort ( @ Nullable final Integer sort ) { 
if ( sortDocument != null ) { 
this . sort = sort ; 
} public PushOptions sortDocument ( @ Nullable final Bson sortDocument ) { 
this . sortDocument = sortDocument ; 
} @ BsonIgnore @ Nullable 
public MongoNamespace getNamespace ( ) { 
if ( namespaceDocument == null ) { 
if ( ! namespaceDocument . containsKey ( "db" ) || ! namespaceDocument . containsKey ( "coll" ) ) { 
return new MongoNamespace ( namespaceDocument . getString ( "db" ) . getValue ( ) , namespaceDocument . getString ( "coll" ) . getValue ( ) ) ; 
public String getDatabaseName ( ) { 
if ( ! namespaceDocument . containsKey ( "db" ) ) { 
return namespaceDocument . getString ( "db" ) . getValue ( ) ; 
} public static < TFullDocument > Codec < ChangeStreamDocument < TFullDocument > > createCodec ( final Class < TFullDocument > fullDocumentClass , 
final CodecRegistry codecRegistry ) { 
return new ChangeStreamDocumentCodec < TFullDocument > ( fullDocumentClass , codecRegistry ) ; 
Document myDoc = collection . find ( ) . first ( ) ; 
System . out . println ( myDoc . toJson ( ) ) ; 
collection . insertMany ( documents ) ; 
myDoc = collection . find ( ) . first ( ) ; 
MongoCursor < Document > cursor = collection . find ( ) . iterator ( ) ; 
System . out . println ( cursor . next ( ) . toJson ( ) ) ; 
for ( Document cur : collection . find ( ) ) { 
System . out . println ( cur . toJson ( ) ) ; 
myDoc = collection . find ( eq ( "i" , 71 ) ) . first ( ) ; 
cursor = collection . find ( gt ( "i" , 50 ) ) . iterator ( ) ; 
cursor = collection . find ( and ( gt ( "i" , 50 ) , lte ( "i" , 100 ) ) ) . iterator ( ) ; 
Block < Document > printBlock = new Block < Document > ( ) { 
collection . find ( gt ( "i" , 50 ) ) . forEach ( printBlock ) ; 
collection . find ( and ( gt ( "i" , 50 ) , lte ( "i" , 100 ) ) ) . forEach ( printBlock ) ; 
myDoc = collection . find ( exists ( "i" ) ) . sort ( descending ( "i" ) ) . first ( ) ; 
myDoc = collection . find ( ) . projection ( excludeId ( ) ) . first ( ) ; 
) . forEach ( printBlock ) ; 
myDoc = collection . aggregate ( singletonList ( group ( null , sum ( "total" , "$i" ) ) ) ) . first ( ) ; 
collection . updateOne ( eq ( "i" , 10 ) , set ( "i" , 110 ) ) ; 
UpdateResult updateResult = collection . updateMany ( lt ( "i" , 100 ) , inc ( "i" , 100 ) ) ; 
collection . deleteOne ( eq ( "i" , 110 ) ) ; 
DeleteResult deleteResult = collection . deleteMany ( gte ( "i" , 100 ) ) ; 
collection . bulkWrite ( writes ) ; 
collection . bulkWrite ( writes , new BulkWriteOptions ( ) . ordered ( false ) ) ; 
} public EstimatedDocumentCountOptions maxTime ( final long maxTime , final TimeUnit timeUnit ) { 
public void encode ( final BsonWriter writer , final LocalTime value , final EncoderContext encoderContext ) { 
writer . writeDateTime ( value . atDate ( LocalDate . ofEpochDay ( 0L ) ) . toInstant ( ZoneOffset . UTC ) . toEpochMilli ( ) ) ; 
} public static Builder builder ( final ClientSessionOptions options ) { 
Builder builder = new Builder ( ) ; 
builder . causallyConsistent = options . isCausallyConsistent ( ) ; 
builder . defaultTransactionOptions = options . getDefaultTransactionOptions ( ) ; 
connectionsPerHost = 10 ; 
threadsAllowedToBlockForConnectionMultiplier = 5 ; 
maxWaitTime = 1000 * 60 * 2 ; 
connectTimeout = 1000 * 10 ; 
socketFactory = SocketFactory . getDefault ( ) ; 
socketTimeout = 0 ; 
socketKeepAlive = false ; 
readPreference = null ; 
writeConcern = null ; 
safe = false ; 
w = 0 ; 
wtimeout = 0 ; 
fsync = false ; 
j = false ; 
dbDecoderFactory = DefaultDBDecoder . FACTORY ; 
dbEncoderFactory = DefaultDBEncoder . FACTORY ; 
description = null ; 
cursorFinalizerEnabled = true ; 
alwaysUseMBeans = false ; 
requiredReplicaSetName = null ; 
} public MongoOptions copy ( ) { 
MongoOptions m = new MongoOptions ( ) ; 
m . connectionsPerHost = connectionsPerHost ; 
m . threadsAllowedToBlockForConnectionMultiplier = threadsAllowedToBlockForConnectionMultiplier ; 
m . maxWaitTime = maxWaitTime ; 
m . connectTimeout = connectTimeout ; 
m . socketFactory = socketFactory ; 
m . socketTimeout = socketTimeout ; 
m . socketKeepAlive = socketKeepAlive ; 
m . readPreference = readPreference ; 
m . writeConcern = writeConcern ; 
m . safe = safe ; 
m . w = w ; 
m . wtimeout = wtimeout ; 
m . fsync = fsync ; 
m . j = j ; 
m . dbDecoderFactory = dbDecoderFactory ; 
m . dbEncoderFactory = dbEncoderFactory ; 
m . description = description ; 
m . cursorFinalizerEnabled = cursorFinalizerEnabled ; 
m . alwaysUseMBeans = alwaysUseMBeans ; 
m . requiredReplicaSetName = requiredReplicaSetName ; 
public WriteConcern getWriteConcern ( ) { 
WriteConcern retVal ; 
retVal = writeConcern ; 
} else if ( w != 0 || wtimeout != 0 || fsync | j ) { 
retVal = WriteConcern . ACKNOWLEDGED ; 
if ( w != 0 ) { 
retVal = retVal . withW ( w ) ; 
if ( wtimeout != 0 ) { 
retVal = retVal . withWTimeout ( wtimeout , TimeUnit . MILLISECONDS ) ; 
if ( fsync ) { 
retVal = retVal . withFsync ( fsync ) ; 
if ( j ) { 
retVal = retVal . withJ ( j ) ; 
} else if ( safe ) { 
retVal = WriteConcern . UNACKNOWLEDGED ; 
public Long getMaxStaleness ( final TimeUnit timeUnit ) { 
if ( maxStalenessMS == null ) { 
return timeUnit . convert ( maxStalenessMS , TimeUnit . MILLISECONDS ) ; 
@ ConditionalOnMissingBean 
public TelemetryConfiguration telemetryConfiguration ( AzureMonitorConfig config ) { 
final TelemetryConfiguration telemetryConfiguration = TelemetryConfiguration . getActive ( ) ; 
if ( StringUtils . isEmpty ( telemetryConfiguration . getInstrumentationKey ( ) ) ) { 
telemetryConfiguration . setInstrumentationKey ( config . instrumentationKey ( ) ) ; 
return telemetryConfiguration ; 
} public static String getUserAgent ( String serviceName , boolean allowTelemetry ) { 
if ( allowTelemetry ) { 
macAddress = GetHashMac . getHashMac ( ) ; 
} private boolean isForgotPasswordAuthorizationRequest ( @ NonNull HttpServletRequest request ) { 
final String error = request . getParameter ( "error" ) ; 
final String description = request . getParameter ( "error_description" ) ; 
if ( "access_denied" . equals ( error ) ) { 
return description . startsWith ( "AADB2C90118:" ) ; 
} @ SuppressFBWarnings ( "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR" ) 
private void populateProperties ( ConfigurableEnvironment environment , VcapPojo [ ] pojos ) { 
final Map < String , Object > map = new HashMap < > ( ) ; 
populateDefaultStorageProperties ( map , 
findPojoForServiceType ( VcapServiceType . AZURE_STORAGE , pojos ) ) ; 
populateDefaultServiceBusProperties ( map , 
findPojoForServiceType ( VcapServiceType . AZURE_SERVICEBUS , pojos ) ) ; 
populateDefaultDocumentDBProperties ( map , 
findPojoForServiceType ( VcapServiceType . AZURE_DOCUMENTDB , pojos ) ) ; 
addOrReplace ( environment . getPropertySources ( ) , map ) ; 
} private boolean isMatchingUserGroupKey ( final JsonNode node ) { 
return node . get ( aadAuthenticationProperties . getUserGroup ( ) . getKey ( ) ) . asText ( ) 
. equals ( aadAuthenticationProperties . getUserGroup ( ) . getValue ( ) ) ; 
} public Set < GrantedAuthority > convertGroupsToGrantedAuthorities ( final List < UserGroup > groups ) { 
final Set < GrantedAuthority > mappedAuthorities = groups . stream ( ) . filter ( this :: isValidUserGroupToGrantAuthority ) 
. map ( userGroup -> new SimpleGrantedAuthority ( DEFAULT_ROLE_PREFIX + userGroup . getDisplayName ( ) ) ) 
. collect ( Collectors . toCollection ( LinkedHashSet :: new ) ) ; 
if ( mappedAuthorities . isEmpty ( ) ) { 
mappedAuthorities . add ( DEFAULT_AUTHORITY ) ; 
return mappedAuthorities ; 
} private boolean isValidUserGroupToGrantAuthority ( final UserGroup group ) { 
return aadAuthenticationProperties . getUserGroup ( ) . getAllowedGroups ( ) . contains ( group . getDisplayName ( ) ) 
|| aadAuthenticationProperties . getActiveDirectoryGroups ( ) . contains ( group . getDisplayName ( ) ) ; 
} public String get ( final String property ) { 
final String secretName = getKeyvaultSecretName ( property ) ; 
if ( System . currentTimeMillis ( ) - this . lastUpdateTime . get ( ) > this . cacheRefreshIntervalInMs ) { 
synchronized ( this . refreshLock ) { 
this . lastUpdateTime . set ( System . currentTimeMillis ( ) ) ; 
fillSecretsHashMap ( ) ; 
if ( this . propertyNamesHashMap . containsKey ( secretName ) ) { 
final SecretBundle secretBundle = this . keyVaultClient . getSecret ( this . vaultUri , secretName ) ; 
return secretBundle . value ( ) ; 
} public ServiceEndpoints getServiceEndpoints ( String environment ) { 
if ( ! endpoints . containsKey ( environment ) ) { 
return endpoints . get ( environment ) ; 
} private void sendQueueMessage ( ) throws ServiceBusException , 
final Message message = new Message ( 
messageBody . getBytes ( StandardCharsets . UTF_8 ) ) ; 
queueClientForSending . send ( message ) ; 
@ Scope ( BeanDefinition . SCOPE_SINGLETON ) 
@ ConditionalOnMissingBean ( AADAuthenticationFilter . class ) 
public AADAuthenticationFilter azureADJwtTokenFilter ( ) { 
return new AADAuthenticationFilter ( aadAuthProps , serviceEndpointsProps , getJWTResourceRetriever ( ) ) ; 
} @ RequestMapping ( value = "/api/todolist/{index}" , 
method = RequestMethod . GET , produces = { MediaType . APPLICATION_JSON_VALUE } ) 
public ResponseEntity < ? > getTodoItem ( @ PathVariable ( "index" ) int index ) { 
if ( index > todoList . size ( ) - 1 ) { 
return new ResponseEntity < > ( todoList . get ( index ) , HttpStatus . OK ) ; 
} @ RequestMapping ( value = "/api/todolist" , method = RequestMethod . GET , produces = { MediaType . APPLICATION_JSON_VALUE } ) 
public ResponseEntity < List < TodoItem > > getAllTodoItems ( ) { 
return new ResponseEntity < > ( todoList , HttpStatus . OK ) ; 
} @ PreAuthorize ( "hasRole('ROLE_group1')" ) 
@ RequestMapping ( value = "/api/todolist" , method = RequestMethod . PUT , consumes = MediaType . APPLICATION_JSON_VALUE ) 
public ResponseEntity < String > updateTodoItem ( @ RequestBody TodoItem item ) { 
final List < TodoItem > find = 
todoList . stream ( ) . filter ( i -> i . getID ( ) == item . getID ( ) ) . collect ( Collectors . toList ( ) ) ; 
if ( ! find . isEmpty ( ) ) { 
todoList . set ( todoList . indexOf ( find . get ( 0 ) ) , item ) ; 
} @ RequestMapping ( value = "/api/todolist/{id}" , method = RequestMethod . DELETE ) 
public ResponseEntity < String > deleteTodoItem ( @ PathVariable ( "id" ) int id , 
PreAuthenticatedAuthenticationToken authToken ) { 
final UserPrincipal current = ( UserPrincipal ) authToken . getPrincipal ( ) ; 
if ( current . isMemberOf ( 
new UserGroup ( "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" , "group1" ) ) ) { 
final List < TodoItem > find = todoList . stream ( ) . filter ( i -> i . getID ( ) == id ) . collect ( Collectors . toList ( ) ) ; 
todoList . remove ( todoList . indexOf ( find . get ( 0 ) ) ) ; 
return new ResponseEntity < > ( "OK" , HttpStatus . OK ) ; 
public void run ( String ... args ) throws Exception { 
final AssetInfo uploadAsset = uploadFileAndCreateAsset ( "video.mp4" ) ; 
} private void sendQueueMessage ( ) throws ServiceBusException , InterruptedException { 
final Message message = new Message ( messageBody . getBytes ( StandardCharsets . UTF_8 ) ) ; 
queueClient . send ( message ) ; 
} public Map < String , Object > toMap ( boolean stacktrace ) { 
Status status = Status . valueOf ( this . status ) ; 
Throwable cause = Optional . ofNullable ( getCause ( ) ) . orElse ( this ) ; 
String message = Optional . ofNullable ( cause . getMessage ( ) ) . orElse ( status . reason ( ) ) ; 
Map < String , Object > err = new LinkedHashMap < > ( ) ; 
err . put ( "message" , message ) ; 
if ( stacktrace ) { 
err . put ( "stacktrace" , Throwables . getStackTraceAsString ( cause ) . replace ( "\r" , "" ) . split ( "\\n" ) ) ; 
err . put ( "status" , status . value ( ) ) ; 
err . put ( "reason" , status . reason ( ) ) ; 
return err ; 
} private static String message ( final Status status , @ Nullable final String tail ) { 
return message ( status . reason ( ) , status . value ( ) , tail ) ; 
} private static String message ( final String reason , final int status , @ Nullable final String tail ) { 
} public LiveReload register ( final Path path , final String ... includes ) { 
if ( Files . exists ( path ) ) { 
paths . add ( new Object [ ] { path , Arrays . asList ( includes ) } ) ; 
} public List < String > assets ( final String name ) { 
return fileset . getOrDefault ( name , Collections . emptyList ( ) ) ; 
} public Set < String > patterns ( ) { 
return patterns ( file -> aggregators . stream ( ) 
. noneMatch ( it -> it . fileset ( ) . contains ( file ) ) ) 
. map ( v -> "/" + v + "/**" ) 
} public List < String > scripts ( final String fileset ) { 
return assets ( fileset ) 
. filter ( scripts ) 
} public List < AssetProcessor > pipeline ( final String dist ) { 
List < AssetProcessor > chain = this . pipeline . get ( dist ) ; 
if ( chain == null ) { 
return Collections . unmodifiableList ( chain ) ; 
} public Map < String , List < File > > build ( final String dist , final File dir ) throws Exception { 
aggregators ( aggregators , conf ) ; 
return buildInternal ( dist , dir ) ; 
} public File buildOne ( String filename , File dir ) throws Exception { 
String dist = "dev" ; 
final MediaType type ; 
AssetWriter writer ; 
if ( scripts . test ( filename ) ) { 
type = MediaType . js ; 
writer = new AssetWriter ( dist , null , dir , ".js" , ";" , charset , this . fileset , scripts ) ; 
} else if ( styles . test ( filename ) ) { 
type = MediaType . css ; 
writer = new AssetWriter ( dist , null , dir , ".css" , "" , charset , this . fileset , styles ) ; 
List < AssetProcessor > pipeline = pipeline ( dist ) ; 
compile ( pipeline , ImmutableList . of ( filename ) . iterator ( ) , type , writer , path -> true , 0 , 0 ) ; 
return new File ( dir , filename ) ; 
} public String summary ( Map < String , List < File > > result , Path outDir , String dist , long duration , 
String ... extraInfo ) { 
StringBuilder buffer = new StringBuilder ( ) ; 
buffer . append ( "Summary:\n" ) ; 
long seconds = Duration . ofMillis ( duration ) . getSeconds ( ) ; 
String took = seconds > 0 ? seconds + "s" : duration + "ms" ; 
Stream . of ( extraInfo ) . forEach ( line -> buffer . append ( line ) . append ( "\n" ) ) ; 
int w1 = result . keySet ( ) . stream ( ) 
. map ( it -> it . length ( ) + 2 ) 
. max ( Integer :: compareTo ) 
. orElse ( 0 ) ; 
int mw1 = Math . max ( w1 , "Fileset" . length ( ) + 2 ) ; 
int w2 = result . values ( ) . stream ( ) 
. flatMap ( List :: stream ) 
. map ( file -> outDir . relativize ( file . toPath ( ) ) . toString ( ) ) 
. map ( String :: length ) 
buffer . append ( format ( w1 , w2 , "Fileset" , "Output" , "Size" ) ) ; 
result . forEach ( ( fileset , files ) -> { 
if ( files . size ( ) > 0 ) { 
files . forEach ( file -> buffer . append ( format ( mw1 , w2 , "" , outDir . relativize ( file . toPath ( ) ) , 
AssetCompiler . humanReadableByteCount ( file . length ( ) ) ) ) ) ; 
} public CaffeineCache < K , V > doWith ( final Callback < K , V , Cache < K , V > > configurer ) { 
this . callback = configurer :: apply ; 
} public CaffeineCache < K , V > doWithAsync ( final AsyncCallback < K , V > configurer ) { 
} private void register ( final Path dir ) throws IOException { 
WatchKey key = dir . register ( watcher , new Kind [ ] { ENTRY_CREATE , ENTRY_DELETE , ENTRY_MODIFY } , HIGH ) ; 
} public GuavaCache < K , V > doWith ( final Callback < K , V , Cache < K , V > > configurer ) { 
public void configure ( Env env , Config config , Binder binder ) { 
GenericObjectPoolConfig poolConfig = poolConfig ( config . getConfig ( "jedis.pool" ) ) ; 
int timeout = ( int ) config . getDuration ( "jedis.timeout" , TimeUnit . MILLISECONDS ) ; 
List < String > hosts = config . getStringList ( "jedis.sentinel.hosts" ) ; 
final Set < String > sentinels = new HashSet < > ( hosts ) ; 
final String MASTER_NAME = config . getString ( "jedis.sentinel.master" ) ; 
final String REDIS_PASSWORD = config . getString ( "jedis.password" ) ; 
JedisSentinelPool pool ; 
if ( REDIS_PASSWORD . length ( ) > 0 ) { 
pool = new JedisSentinelPool ( MASTER_NAME , sentinels , poolConfig , timeout , REDIS_PASSWORD ) ; 
pool = new JedisSentinelPool ( MASTER_NAME , sentinels , poolConfig , timeout ) ; 
RedisProvider provider = new RedisProvider ( pool , null , poolConfig ) ; 
env . onStart ( provider :: start ) ; 
env . onStop ( provider :: stop ) ; 
Env . ServiceKey serviceKey = env . serviceKey ( ) ; 
serviceKey . generate ( JedisSentinelPool . class , "db" , k -> binder . bind ( k ) . toInstance ( pool ) ) ; 
} public RamlType newProperty ( String name , String type , boolean required , String ... values ) { 
properties = new LinkedHashMap < > ( ) ; 
if ( values . length > 0 ) { 
properties . put ( required ? name : name + "?" , ImmutableMap . of ( "enum" , values ) ) ; 
properties . put ( required ? name : name + "?" , type ) ; 
} public static RamlType valueOf ( String name ) { 
switch ( name . toLowerCase ( ) ) { 
case "boolean" : 
case "byte" : 
case "short" : 
case "int" : 
case "integer" : 
case "long" : 
return INTEGER ; 
case "float" : 
case "double" : 
case "char" : 
case "character" : 
case "string" : 
case "file" : 
case "upload" : 
case "path" : 
case "binary" : 
return FILE ; 
case "date" : 
case "datetime" : 
case "localdatetime" : 
return DATE_TIME ; 
return new RamlType ( "object" , name ) ; 
} public FileEventOptions kind ( final WatchEvent . Kind < Path > kind ) { 
kinds . add ( kind ) ; 
} public FileEventOptions includes ( final String expression ) { 
this . matchers . add ( new GlobPathMatcher ( expression ) ) ; 
} public Hbs doWith ( final Consumer < Handlebars > callback ) { 
return doWith ( ( hbs , conf ) -> callback . accept ( hbs ) ) ; 
} public Gzon doWith ( final Consumer < GsonBuilder > configurer ) { 
this . configurer = ( gson , conf ) -> configurer . accept ( gson ) ; 
} public Micrometer doWith ( @ Nonnull final Consumer < CompositeMeterRegistry > configurer ) { 
return doWith ( ( registry , conf ) -> configurer . accept ( registry ) ) ; 
} public Thl doWith ( final Consumer < TemplateEngine > callback ) { 
return doWith ( ( e , c ) -> callback . accept ( e ) ) ; 
} public Auth authorizer ( final String name , final String pattern , 
final Authorizer < ? > authorizer ) { 
authorizer ( authorizer , name , pattern ) ; 
public Auth authorizer ( final String name , final String pattern , 
final Class < ? extends Authorizer > authorizer ) { 
} private void authorizer ( final Object authorizer , final String name , final String pattern ) { 
authorizers . put ( pattern , Maps . immutableEntry ( name , authorizer ) ) ; 
} public Auth form ( final String pattern , 
final Class < ? extends Authenticator < UsernamePasswordCredentials > > authenticator ) { 
bindings . put ( pattern , ( binder , conf ) -> { 
TypeLiteral < Authenticator < UsernamePasswordCredentials > > usernamePasswordAuthenticator = new TypeLiteral < Authenticator < UsernamePasswordCredentials > > ( ) { 
binder . bind ( usernamePasswordAuthenticator . getRawType ( ) ) . to ( authenticator ) ; 
bindProfile ( binder , CommonProfile . class ) ; 
Multibinder . newSetBinder ( binder , Client . class ) 
. addBinding ( ) . toProvider ( FormAuth . class ) ; 
return new FormFilter ( conf . getString ( "auth.form.loginUrl" ) , 
conf . getString ( "application.path" ) + authCallbackPath ( conf ) ) ; 
} public Auth basic ( final String pattern , 
bindings . put ( pattern , ( binder , config ) -> { 
. addBinding ( ) . toProvider ( BasicAuth . class ) ; 
return new AuthFilter ( IndirectBasicAuthClient . class , CommonProfile . class ) ; 
} public < C extends Credentials , U extends CommonProfile > Auth client ( final Client < C , U > client ) { 
return client ( "*" , client ) ; 
} public < C extends Credentials , U extends CommonProfile > Auth client ( final String pattern , 
final Client < C , U > client ) { 
return client ( pattern , config -> client ) ; 
} public < C extends Credentials , U extends CommonProfile > Auth client ( 
final Function < Config , Client < C , U > > provider ) { 
return client ( "*" , provider ) ; 
public < C extends Credentials , U extends CommonProfile > Auth client ( final String pattern , 
Client < C , U > client = provider . apply ( config ) ; 
. addBinding ( ) . toInstance ( client ) ; 
Class clientType = client . getClass ( ) ; 
Class profileType = ClientType . typeOf ( clientType ) ; 
bindProfile ( binder , profileType ) ; 
return new AuthFilter ( clientType , profileType ) ; 
final Class < ? extends Client < C , U > > client ) { 
. addBinding ( ) . to ( client ) ; 
Class profileType = ClientType . typeOf ( client ) ; 
return new AuthFilter ( client , profileType ) ; 
} public < U extends CommonProfile > Auth store ( final Class < ? extends AuthStore < U > > store ) { 
} public Auth logout ( final String logoutUrl , final String redirecTo ) { 
this . logoutUrl = Optional . of ( logoutUrl ) ; 
this . redirecTo = Optional . of ( redirecTo ) ; 
} public Auth logout ( final String logoutUrl ) { 
this . redirecTo = Optional . empty ( ) ; 
public static Route . Mapper < Object > reactor ( final Function < Flux , Flux > flux , 
final Function < Mono , Mono > mono ) { 
return Route . Mapper . create ( "reactor" , value -> { 
if ( value instanceof Flux ) { 
return new Deferred ( deferred -> flux . apply ( ( Flux ) value ) 
. consume ( deferred :: set , deferred :: set ) ) ; 
if ( value instanceof Mono ) { 
return new Deferred ( deferred -> mono . apply ( ( Mono ) value ) 
@ Nonnull 
public Result set ( final Object value ) { 
if ( value instanceof Throwable ) { 
reject ( ( Throwable ) value ) ; 
resolve ( value ) ; 
} public void resolve ( @ Nullable final Object value ) { 
handler . handle ( null , null ) ; 
Result result ; 
if ( value instanceof Result ) { 
super . set ( value ) ; 
result = ( Result ) value ; 
result = clone ( ) ; 
handler . handle ( result , null ) ; 
} public void handler ( final Request req , final Handler handler ) throws Exception { 
if ( initializer != null ) { 
initializer . run ( req , this ) ; 
public static Deferred deferred ( final String executor , final Route . ZeroArgHandler handler ) { 
return deferred ( executor , req -> handler . handle ( ) ) ; 
public static Deferred deferred ( final String executor , final Route . OneArgHandler handler ) { 
return new Deferred ( executor , ( req , deferred ) -> { 
deferred . resolve ( handler . handle ( req ) ) ; 
deferred . reject ( x ) ; 
} public RamlPath path ( String pattern ) { 
RamlPath path = resources . get ( pattern ) ; 
path = new RamlPath ( ) ; 
resources . put ( pattern , path ) ; 
} public RamlType define ( Type javaType , RamlType baseType ) { 
if ( types == null ) { 
types = new LinkedHashMap < > ( ) ; 
String typeName = MoreTypes . getRawType ( javaType ) . getSimpleName ( ) ; 
RamlType ramlType = new RamlType ( baseType . getType ( ) , typeName ) ; 
types . put ( typeName , ramlType ) ; 
return ramlType ; 
} public RamlType define ( Type type ) { 
Type componentType = componentType ( type ) ; 
String typeName = MoreTypes . getRawType ( componentType ) . getSimpleName ( ) ; 
RamlType ramlType = RamlType . valueOf ( typeName ) ; 
if ( ramlType . isObject ( ) ) { 
RamlType existing = types . get ( typeName ) ; 
if ( existing == null ) { 
ModelConverters converter = ModelConverters . getInstance ( ) ; 
Property property = converter . readAsProperty ( componentType ) ; 
Map < PropertyBuilder . PropertyId , Object > args = new EnumMap < > ( 
PropertyBuilder . PropertyId . class ) ; 
for ( Map . Entry < String , Model > entry : converter . readAll ( componentType ) . entrySet ( ) ) { 
define ( entry . getKey ( ) , entry . getValue ( ) ) ; 
ramlType = define ( typeName , PropertyBuilder . toModel ( PropertyBuilder . merge ( property , args ) ) ) ; 
ramlType = existing ; 
return type != componentType ? ramlType . toArray ( ) : ramlType ; 
} public String toYaml ( ) throws IOException { 
YAMLMapper mapper = new YAMLMapper ( ) ; 
mapper . setSerializationInclusion ( JsonInclude . Include . NON_NULL ) ; 
mapper . configure ( YAMLGenerator . Feature . ALWAYS_QUOTE_NUMBERS_AS_STRINGS , false ) ; 
mapper . configure ( YAMLGenerator . Feature . MINIMIZE_QUOTES , true ) ; 
} public static Raml build ( Raml base , List < RouteMethod > routes ) { 
Raml raml = Optional . ofNullable ( base ) . orElseGet ( Raml :: new ) ; 
BiFunction < RamlPath , String , RamlPath > pathFactory = ( path , segment ) -> 
path == null ? raml . path ( segment ) : path . path ( segment ) ; 
BiConsumer < Function < String , RamlParameter > , RouteParameter > parameterFactory = ( factory , parameter ) -> { 
RamlParameter p = factory . apply ( parameter . name ( ) ) ; 
p . setDescription ( parameter . description ( ) 
. map ( Raml :: yamlText ) 
. orElse ( null ) ) ; 
List < String > enums = parameter . enums ( ) ; 
if ( enums . size ( ) > 0 ) { 
p . setType ( RamlType . STRING ) ; 
p . setEnum ( enums ) ; 
p . setType ( raml . define ( parameter . type ( ) ) ) ; 
p . setRequired ( ! parameter . optional ( ) ) ; 
p . setDefault ( parameter . defaultValue ( ) ) ; 
Set < String > alltypes = new LinkedHashSet < > ( ) ; 
Consumer < Function < RouteMethod , List < String > > > mediaTypes = types -> 
routes . stream ( ) . forEach ( r -> types . apply ( r ) . forEach ( alltypes :: add ) ) ; 
mediaTypes . accept ( RouteMethod :: consumes ) ; 
mediaTypes . accept ( RouteMethod :: produces ) ; 
boolean defaultMediaType = false ; 
if ( alltypes . size ( ) == 0 ) { 
raml . setMediaType ( ImmutableList . of ( MediaType . json . name ( ) ) ) ; 
defaultMediaType = true ; 
} else if ( alltypes . size ( ) == 1 ) { 
raml . setMediaType ( ImmutableList . of ( alltypes . iterator ( ) . next ( ) ) ) ; 
for ( RouteMethod route : routes ) { 
List < String > segments = Splitter . on ( "/" ) 
. trimResults ( ) 
. omitEmptyStrings ( ) 
. splitToList ( route . pattern ( ) ) ; 
RamlPath path = null ; 
for ( String segment : segments ) { 
RamlPath newPath = pathFactory . apply ( path , "/" + segment ) ; 
if ( segment . startsWith ( "{" ) && segment . endsWith ( "}" ) ) { 
String pathvar = segment . substring ( 1 , segment . length ( ) - 1 ) ; 
route . parameters ( ) . stream ( ) 
. filter ( it -> it . kind ( ) == RouteParameter . Kind . PATH ) 
. filter ( it -> it . name ( ) . equals ( pathvar ) ) 
. ifPresent ( it -> parameterFactory . accept ( newPath :: uriParameter , it ) ) ; 
path = newPath ; 
path = Optional . ofNullable ( path ) . orElseGet ( ( ) -> raml . path ( "/" ) ) ; 
path . setDescription ( route . summary ( ) 
RamlMethod method = path . method ( route . method ( ) ) ; 
method . setDescription ( route . description ( ) 
List < RouteParameter > files = route . parameters ( ) . stream ( ) 
. filter ( it -> it . kind ( ) == RouteParameter . Kind . FILE ) 
. filter ( it -> it . kind ( ) == RouteParameter . Kind . QUERY ) 
. forEach ( it -> parameterFactory . accept ( method :: formParameter , it ) ) ; 
files . forEach ( it -> { 
parameterFactory . accept ( method :: formParameter , it ) ; 
method . setMediaType ( ImmutableList . of ( MediaType . multipart . name ( ) ) ) ; 
. forEach ( it -> parameterFactory . accept ( method :: queryParameter , it ) ) ; 
List < String > consumes = route . consumes ( ) ; 
if ( consumes . size ( ) == 0 && ! defaultMediaType ) { 
consumes = ImmutableList . of ( MediaType . json . name ( ) ) ; 
method . setMediaType ( consumes ) ; 
. filter ( it -> it . kind ( ) == RouteParameter . Kind . HEADER ) 
. forEach ( it -> parameterFactory . accept ( method :: headerParameter , it ) ) ; 
. filter ( it -> it . kind ( ) == RouteParameter . Kind . BODY ) 
. forEach ( it -> { 
method . setMediaType ( route . consumes ( ) ) ; 
method . setBody ( raml . define ( it . type ( ) ) ) ; 
List < String > produces = route . produces ( ) ; 
if ( produces . size ( ) == 0 ) { 
produces = ImmutableList . of ( MediaType . json . name ( ) ) ; 
RouteResponse returns = route . response ( ) ; 
Map < Integer , String > status = returns . status ( ) ; 
Integer statusCode = returns . statusCode ( ) ; 
RamlResponse response = method . response ( statusCode ) ; 
response . setDescription ( yamlText ( returns . description ( ) . orElseGet ( ( ) -> FriendlyTypeName 
. name ( returns . type ( ) ) ) ) ) ; 
produces . forEach ( type -> response . setMediaType ( type , raml . define ( returns . type ( ) ) ) ) ; 
status . entrySet ( ) . stream ( ) 
. filter ( it -> ! statusCode . equals ( it . getKey ( ) ) ) 
. forEach ( it -> method . response ( it . getKey ( ) ) . setDescription ( it . getValue ( ) ) ) ; 
return raml ; 
} public Map < Integer , String > status ( ) { 
return Optional . ofNullable ( status ) . orElse ( ImmutableMap . of ( ) ) ; 
} public int statusCode ( ) { 
return status ( ) . entrySet ( ) . stream ( ) 
. map ( it -> it . getKey ( ) ) 
. filter ( code -> code >= 200 && code < 400 ) 
. orElseGet ( ( ) -> type ( ) == void . class ? 204 : 200 ) ; 
} public RouteResponse status ( final Map < Integer , String > status ) { 
this . status = new LinkedHashMap < > ( ) ; 
this . status . putAll ( status ) ; 
} public void setMediaType ( final String mediaType , RamlType body ) { 
if ( this . mediaType == null ) { 
this . mediaType = new LinkedHashMap < > ( ) ; 
this . mediaType . put ( mediaType , body ) ; 
} protected static PKCS8EncodedKeySpec generateKeySpec ( final char [ ] password , final byte [ ] key ) 
throws IOException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeySpecException , 
InvalidKeyException , InvalidAlgorithmParameterException { 
if ( password == null || password . length == 0 ) { 
return new PKCS8EncodedKeySpec ( key ) ; 
EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo ( key ) ; 
SecretKeyFactory keyFactory = SecretKeyFactory 
. getInstance ( encryptedPrivateKeyInfo . getAlgName ( ) ) ; 
PBEKeySpec pbeKeySpec = new PBEKeySpec ( password ) ; 
SecretKey pbeKey = keyFactory . generateSecret ( pbeKeySpec ) ; 
Cipher cipher = Cipher . getInstance ( encryptedPrivateKeyInfo . getAlgName ( ) ) ; 
cipher . init ( Cipher . DECRYPT_MODE , pbeKey , encryptedPrivateKeyInfo . getAlgParameters ( ) ) ; 
return encryptedPrivateKeyInfo . getKeySpec ( cipher ) ; 
} static KeyStore buildKeyStore ( final File certChainFile , final File keyFile , 
final char [ ] keyPasswordChars ) 
throws KeyStoreException , NoSuchAlgorithmException , 
NoSuchPaddingException , InvalidKeySpecException , InvalidAlgorithmParameterException , 
CertificateException , KeyException , IOException { 
ByteBuffer encodedKeyBuf = PemReader . readPrivateKey ( keyFile ) ; 
byte [ ] encodedKey = encodedKeyBuf . array ( ) ; 
PKCS8EncodedKeySpec encodedKeySpec = generateKeySpec ( keyPasswordChars , encodedKey ) ; 
PrivateKey key ; 
key = KeyFactory . getInstance ( "RSA" ) . generatePrivate ( encodedKeySpec ) ; 
} catch ( InvalidKeySpecException ignore ) { 
key = KeyFactory . getInstance ( "DSA" ) . generatePrivate ( encodedKeySpec ) ; 
} catch ( InvalidKeySpecException ignore2 ) { 
key = KeyFactory . getInstance ( "EC" ) . generatePrivate ( encodedKeySpec ) ; 
} catch ( InvalidKeySpecException e ) { 
CertificateFactory cf = CertificateFactory . getInstance ( "X.509" ) ; 
List < ByteBuffer > certs = PemReader . readCertificates ( certChainFile ) ; 
List < Certificate > certChain = new ArrayList < Certificate > ( certs . size ( ) ) ; 
for ( ByteBuffer buf : certs ) { 
certChain . add ( cf . generateCertificate ( new ByteArrayInputStream ( buf . array ( ) ) ) ) ; 
KeyStore ks = KeyStore . getInstance ( "JKS" ) ; 
ks . load ( null , null ) ; 
ks . setKeyEntry ( "key" , key , keyPasswordChars , 
certChain . toArray ( new Certificate [ certChain . size ( ) ] ) ) ; 
return ks ; 
} protected static TrustManagerFactory buildTrustManagerFactory ( final File certChainFile , 
TrustManagerFactory trustManagerFactory ) 
throws NoSuchAlgorithmException , CertificateException , KeyStoreException , IOException { 
X509Certificate cert = ( X509Certificate ) cf 
. generateCertificate ( new ByteArrayInputStream ( buf . array ( ) ) ) ; 
X500Principal principal = cert . getSubjectX500Principal ( ) ; 
ks . setCertificateEntry ( principal . getName ( "RFC2253" ) , cert ) ; 
if ( trustManagerFactory == null ) { 
trustManagerFactory = TrustManagerFactory 
. getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; 
trustManagerFactory . init ( ks ) ; 
return trustManagerFactory ; 
} public Jade doWith ( final Consumer < JadeConfiguration > callback ) { 
return doWith ( ( j , c ) -> callback . accept ( j ) ) ; 
} public List < String > enums ( ) { 
return Optional . ofNullable ( MoreTypes . getRawType ( type ) ) 
. map ( Class :: getEnumConstants ) 
. filter ( Objects :: nonNull ) 
. map ( values -> Arrays . asList ( values ) . stream ( ) 
. map ( value -> ( ( Enum ) value ) . name ( ) ) 
. collect ( Collectors . toList ( ) ) 
) . orElse ( Collections . emptyList ( ) ) ; 
public Optional < Object > ifGet ( final List < MediaType > types ) { 
return Optional . ofNullable ( value ) ; 
public < T > T get ( final List < MediaType > types ) { 
public Result header ( final String name , final Object value ) { 
setHeader ( name , value ) ; 
public Result header ( final String name , final Object ... values ) { 
return header ( name , ImmutableList . copyOf ( values ) ) ; 
public Result header ( final String name , final Iterable < Object > values ) { 
setHeader ( name , values ) ; 
} static Throwing . Runnable runEnhancer ( ) { 
return ( ) -> { 
Set < String > packages = PKG . getAndSet ( null ) ; 
if ( packages != null ) { 
EbeanEnhancer . newEnhancer ( ) . run ( packages ) ; 
} public void setMediaType ( final List < String > mediaType ) { 
this . mediaType = mediaType == null ? null : ( mediaType . isEmpty ( ) ? null : mediaType ) ; 
} public RamlParameter queryParameter ( String name ) { 
if ( queryParameters == null ) { 
queryParameters = new LinkedHashMap < > ( ) ; 
RamlParameter param = queryParameters . get ( name ) ; 
param = new RamlParameter ( name ) ; 
queryParameters . put ( name , param ) ; 
} public RamlParameter formParameter ( String name ) { 
if ( formParameters == null ) { 
formParameters = new LinkedHashMap < > ( ) ; 
RamlParameter param = formParameters . get ( name ) ; 
formParameters . put ( name , param ) ; 
} public RamlParameter headerParameter ( String name ) { 
headers = new LinkedHashMap < > ( ) ; 
RamlParameter param = headers . get ( name ) ; 
headers . put ( name , param ) ; 
} public RamlResponse response ( Integer status ) { 
if ( responses == null ) { 
responses = new LinkedHashMap < > ( ) ; 
RamlResponse response = responses . get ( status ) ; 
response = new RamlResponse ( ) ; 
responses . put ( status , response ) ; 
} public RequestLogger dateFormatter ( final DateTimeFormatter formatter ) { 
return dateFormatter ( ts -> formatter . format ( Instant . ofEpochMilli ( ts ) ) ) ; 
} public RequestLogger dateFormatter ( final Function < Long , String > formatter ) { 
this . df = formatter ; 
} public Hbv doWith ( final Consumer < HibernateValidatorConfiguration > configurer ) { 
this . configurer = ( hvc , conf ) -> configurer . accept ( hvc ) ; 
public int read ( final byte [ ] b , int off , int len ) throws IOException { 
if ( encoderOut . position ( ) > 0 ) { 
encoderOut . flip ( ) ; 
int c = Math . min ( encoderOut . remaining ( ) , len ) ; 
encoderOut . get ( b , off , c ) ; 
off += c ; 
len -= c ; 
read += c ; 
encoderOut . compact ( ) ; 
if ( ! endOfInput && ( lastCoderResult == null || lastCoderResult . isUnderflow ( ) ) ) { 
encoderIn . compact ( ) ; 
int position = encoderIn . position ( ) ; 
int c = reader . read ( encoderIn . array ( ) , position , encoderIn . remaining ( ) ) ; 
endOfInput = true ; 
encoderIn . position ( position + c ) ; 
encoderIn . flip ( ) ; 
lastCoderResult = encoder . encode ( encoderIn , encoderOut , endOfInput ) ; 
if ( endOfInput && encoderOut . position ( ) == 0 ) { 
return read == 0 && endOfInput ? - 1 : read ; 
} public FileWatcher register ( final Path path , final Class < ? extends FileEventHandler > handler ) { 
return register ( path , handler , EMPTY ) ; 
} public FileWatcher register ( final Path path , final Class < ? extends FileEventHandler > handler , 
final Consumer < FileEventOptions > configurer ) { 
return register ( c -> path , p -> new FileEventOptions ( p , handler ) , configurer ) ; 
} public FileWatcher register ( final Path path , final FileEventHandler handler ) { 
return register ( c -> path , p -> new FileEventOptions ( p , handler ) , EMPTY ) ; 
} public FileWatcher register ( final String property , final FileEventHandler handler ) { 
return register ( c -> Paths . get ( c . getString ( property ) ) , p -> new FileEventOptions ( p , handler ) , 
EMPTY ) ; 
} public FileWatcher register ( final String property , 
final Class < ? extends FileEventHandler > handler ) { 
return register ( property , handler , EMPTY ) ; 
} public Requery doWith ( final Consumer < ConfigurationBuilder > configurer ) { 
return doWith ( ( c , b ) -> configurer . accept ( b ) ) ; 
} public static Requery reactive ( final String name , final EntityModel model ) { 
return new Requery ( name , ReactiveEntityStore . class , model , 
conf -> ReactiveSupport . toReactiveStore ( new EntityDataStore < > ( conf ) ) ) ; 
} public static Requery reactor ( final String name , final EntityModel model ) { 
return new Requery ( name , ReactorEntityStore . class , model , 
conf -> new ReactorEntityStore < > ( new EntityDataStore < > ( conf ) ) ) ; 
} public static Requery completionStage ( final String name , final EntityModel model ) { 
return new Requery ( name , CompletionStageEntityStore . class , model , 
conf -> new CompletableEntityStore ( new EntityDataStore < > ( conf ) ) ) ; 
} public static Requery kotlin ( final String name , final EntityModel model ) { 
return new Requery ( name , KotlinEntityDataStore . class , model , 
conf -> new KotlinEntityDataStore < > ( conf ) ) ; 
} public XSS js ( final JavaScriptEscapeType type , final JavaScriptEscapeLevel level ) { 
} public XSS html ( final HtmlEscapeType type , final HtmlEscapeLevel level ) { 
} public XSS json ( final JsonEscapeType type , final JsonEscapeLevel level ) { 
} public XSS css ( final CssStringEscapeType type , final CssStringEscapeLevel level ) { 
} public Lambda prefix ( String prefix ) { 
return new Lambda ( declaringClass , owner , desc , implementationName , name , 
Route . normalize ( prefix + "/" + pattern ) , method . orElse ( null ) , tag ) ; 
} public Lambda method ( MethodNode method ) { 
return new Lambda ( declaringClass , owner , desc , implementationName , name , pattern , method , tag ) ; 
} private Map < String , Object > attrs ( final String path , final String ... without ) { 
Map < String , Object > attrs = new LinkedHashMap < > ( get ( path ) ) ; 
Arrays . asList ( without ) . forEach ( attrs :: remove ) ; 
return attrs ; 
} private Tuple < Element , Element > symbol ( final Path file , final String id ) throws IOException { 
Element svg = Jsoup . parse ( file . toFile ( ) , "UTF-8" ) . select ( "svg" ) . first ( ) ; 
Element symbol = new Element ( Tag . valueOf ( "symbol" ) , "" ) 
. attr ( "id" , id ) 
. attr ( "viewBox" , svg . attr ( "viewBox" ) ) ; 
new ArrayList < > ( svg . childNodes ( ) ) . forEach ( symbol :: appendChild ) ; 
return new Tuple ( svg , symbol ) ; 
} private CharSequence css ( final String id , final Element svg ) { 
Throwing . Function < String , Tuple < Tuple < Number , String > , Tuple < Number , String > > > viewBox = Throwing 
. < String , Tuple < Tuple < Number , String > , Tuple < Number , String > > > throwingFunction ( name -> { 
String vbox = svg . attr ( name ) ; 
String [ ] dimension = vbox . split ( "\\s+" ) ; 
return new Tuple ( parse ( dimension [ 2 ] ) , parse ( dimension [ _3 ] ) ) ; 
} ) . memoized ( ) ; 
Tuple < Number , String > w = Optional . ofNullable ( Strings . emptyToNull ( svg . attr ( "width" ) ) ) 
. map ( this :: parse ) 
. orElseGet ( ( ) -> viewBox . apply ( "viewBox" ) . _1 ) ; 
Tuple < Number , String > h = Optional . ofNullable ( Strings . emptyToNull ( svg . attr ( "height" ) ) ) 
. orElseGet ( ( ) -> viewBox . apply ( "viewBox" ) . _2 ) ; 
StringBuilder css = new StringBuilder ( ) ; 
css . append ( get ( "css.prefix" ) . toString ( ) ) . append ( "." ) . append ( id ) 
return css ; 
} private Tuple < Number , String > parse ( final String value ) { 
Matcher matcher = SIZE . matcher ( value ) ; 
String number = matcher . group ( 1 ) ; 
String unit = matcher . group ( _3 ) ; 
boolean round = get ( "css.round" ) ; 
Number num = Double . parseDouble ( number ) ; 
return new Tuple ( round ? Math . round ( num . doubleValue ( ) ) : num , unit ) ; 
} private void write ( final Path path , final List < CharSequence > sequence ) throws IOException { 
path . toFile ( ) . getParentFile ( ) . mkdirs ( ) ; 
Files . write ( path , sequence ) ; 
} public TransactionalRequest handle ( String name ) { 
this . handleKey = Key . get ( Handle . class , Names . named ( name ) ) ; 
} private Model doModel ( Type type , Model model ) { 
Map < String , Property > properties = model . getProperties ( ) ; 
BeanDescription desc = Json . mapper ( ) . getSerializationConfig ( ) 
. introspect ( Json . mapper ( ) . constructType ( type ) ) ; 
for ( BeanPropertyDefinition beanProperty : desc . findProperties ( ) ) { 
Property property = properties . get ( beanProperty . getName ( ) ) ; 
if ( property != null ) { 
property . setRequired ( beanProperty . isRequired ( ) ) ; 
} public static AppModuleLoader build ( final String name , final File ... cp ) throws Exception { 
Map < ModuleIdentifier , ModuleSpec > modules = newModule ( name , 0 , "" , cp ) ; 
return new AppModuleLoader ( modules ) ; 
public < T > Optional < T > lastEventId ( final Class < T > type ) { 
return lastEventId . toOptional ( type ) ; 
public CompletableFuture < Optional < Object > > send ( final Object data , final String type ) { 
return send ( data , MediaType . valueOf ( type ) ) ; 
public CompletableFuture < Optional < Object > > send ( final Object data , final MediaType type ) { 
return event ( data ) . type ( type ) . send ( ) ; 
public CompletableFuture < Optional < Object > > send ( final Object data ) { 
return event ( data ) . send ( ) ; 
public < T > T require ( final Class < T > type ) { 
return require ( Key . get ( type ) ) ; 
public < T > T require ( final String name , final Class < T > type ) { 
return require ( Key . get ( type , Names . named ( name ) ) ) ; 
public < T > T require ( final TypeLiteral < T > type ) { 
public < T > T require ( final Key < T > key ) { 
return injector . getInstance ( key ) ; 
public Sse keepAlive ( final int time , final TimeUnit unit ) { 
return keepAlive ( unit . toMillis ( time ) ) ; 
public Sse keepAlive ( final long millis ) { 
scheduler . schedule ( new KeepAlive ( this , millis ) , millis , TimeUnit . MILLISECONDS ) ; 
public View put ( final String name , final Object value ) { 
model . put ( name , value ) ; 
public View put ( final Map < String , ? > values ) { 
values . forEach ( ( k , v ) -> model . put ( k , v ) ) ; 
} public MongoRx doWith ( final BiConsumer < MongoClientSettings . Builder , Config > configurer ) { 
} public MongoRx doWith ( final Consumer < MongoClientSettings . Builder > configurer ) { 
return doWith ( ( s , c ) -> configurer . accept ( s ) ) ; 
public MongoRx observableAdapter ( final Function < Observable , Observable > adapter ) { 
} private AssetException rewrite ( final AssetException ex ) { 
List < StackTraceElement > stacktrace = Lists . newArrayList ( ex . getStackTrace ( ) ) ; 
List < AssetProblem > problems = ex . getProblems ( ) ; 
AssetProblem head = problems . get ( 0 ) ; 
stacktrace . add ( 0 , 
new StackTraceElement ( head . getFilename ( ) , "" , head . getFilename ( ) , head . getLine ( ) ) ) ; 
ex . setStackTrace ( stacktrace . toArray ( new StackTraceElement [ stacktrace . size ( ) ] ) ) ; 
} public static ClassLoader classLoader ( final ClassLoader parent ) throws IOException { 
return classLoader ( parent , new File ( System . getProperty ( "user.dir" ) ) ) ; 
} public static ClassLoader classLoader ( final ClassLoader parent , File projectDir ) throws IOException { 
File publicDir = new File ( projectDir , "public" ) ; 
if ( publicDir . exists ( ) ) { 
return new URLClassLoader ( new URL [ ] { publicDir . toURI ( ) . toURL ( ) } , parent ) ; 
} public Map < String , Object > attributes ( ) { 
return Optional . ofNullable ( attributes ) . orElse ( ImmutableMap . of ( ) ) ; 
} public RouteMethod attributes ( Map < String , Object > attributes ) { 
if ( attributes != null ) { 
if ( this . attributes == null ) { 
this . attributes = new LinkedHashMap < > ( ) ; 
this . attributes . putAll ( attributes ) ; 
} public RouteMethod attribute ( String name , Object value ) { 
this . attributes . put ( name , value ) ; 
} public RouteMethod param ( String name , Consumer < RouteParameter > customizer ) { 
parameters ( ) . stream ( ) 
. filter ( p -> name . equals ( p . name ( ) ) ) 
. ifPresent ( customizer ) ; 
} public static Route . Mapper < Object > rx ( final Function < Observable , Observable > observable , 
final Function < Single , Single > single ) { 
return rx ( observable , single , Function . identity ( ) ) ; 
public static Route . Mapper < Object > rx ( final Function < Observable , Observable > observable , 
final Function < Single , Single > single , final Function < Completable , Completable > completable ) { 
return Route . Mapper . create ( "rx" , v -> { 
if ( v instanceof Observable ) { 
return new Deferred ( 
deferred -> observable . apply ( ( Observable ) v ) . subscribe ( new DeferredSubscriber ( deferred ) ) ) ; 
} else if ( v instanceof Single ) { 
deferred -> single . apply ( ( Single ) v ) . subscribe ( new DeferredSubscriber ( deferred ) ) ) ; 
} else if ( v instanceof Completable ) { 
return new Deferred ( deferred -> completable . apply ( ( Completable ) v ) 
. subscribe ( new DeferredSubscriber ( deferred ) ) ) ; 
} public < T > T get ( final Class < T > entityClass , final Object id ) { 
return mapper ( entityClass ) . get ( id ) ; 
} public < T > ListenableFuture < T > getAsync ( final Class < T > entityClass , final Object id ) { 
return mapper ( entityClass ) . getAsync ( id ) ; 
} public void delete ( final Class < ? > entityClass , final Object id , final Mapper . Option ... options ) { 
Mapper mapper = mapper ( entityClass ) ; 
mapper . delete ( id , options ) ; 
} public ListenableFuture < Void > deleteAsync ( final Class < ? > entityClass , final Object id , 
final Mapper . Option ... options ) { 
return mapper . deleteAsync ( id , options ) ; 
} public void delete ( final Object entity , final Mapper . Option ... options ) { 
Mapper mapper = mapper ( entity . getClass ( ) ) ; 
mapper . delete ( entity , options ) ; 
} public ListenableFuture < Void > deleteAsync ( final Object entity , final Mapper . Option ... options ) { 
return mapper . deleteAsync ( entity , options ) ; 
} public < T > void save ( final T entity , final Mapper . Option ... options ) { 
Class entityClass = entity . getClass ( ) ; 
mapper . save ( entity , options ) ; 
} public < T > ListenableFuture < Void > saveAsync ( final T entity , final Mapper . Option ... options ) { 
return mapper . saveAsync ( entity , options ) ; 
} public < T > Result < T > query ( final Class < T > entityClass , final String statement , 
final Map < String , Object > values ) { 
return query ( entityClass , new SimpleStatement ( statement , values ) ) ; 
} public < T > Result < T > query ( final Class < T > entityClass , final Statement statement ) { 
Mapper < T > mapper = mapper ( entityClass ) ; 
Session session = mapper . getManager ( ) . getSession ( ) ; 
ResultSet rs = session . execute ( statement ) ; 
return mapper . map ( rs ) ; 
} public < T > ListenableFuture < Result < T > > queryAsync ( final Class < T > entityClass , 
final String statement , final Map < String , Object > values ) { 
return queryAsync ( entityClass , new SimpleStatement ( statement , values ) ) ; 
final Statement statement ) { 
ResultSetFuture rs = session . executeAsync ( statement ) ; 
return Futures . transformAsync ( rs , rs1 -> Futures . immediateFuture ( mapper . map ( rs1 ) ) ) ; 
} public static Status valueOf ( final int statusCode ) { 
Integer key = Integer . valueOf ( statusCode ) ; 
Status status = statusMap . get ( key ) ; 
return status == null ? new Status ( key , key . toString ( ) ) : status ; 
} private void ready ( ) { 
ready . await ( ) ; 
} public Hcast doWith ( final BiConsumer < com . hazelcast . config . Config , Config > configurer ) { 
} public Hcast doWith ( final Consumer < com . hazelcast . config . Config > configurer ) { 
return doWith ( ( config , conf ) -> configurer . accept ( config ) ) ; 
} public Jdbi3 doWith ( Consumer < Jdbi > configurer ) { 
return doWith ( ( jdbi , conf ) -> configurer . accept ( jdbi ) ) ; 
public RewrittenStatement rewrite ( final String sql , final Binding params , 
final StatementContext ctx ) 
final ParsedStatement stmt = new ParsedStatement ( ) ; 
final String parsedSql = parseString ( sql , stmt , params ) ; 
return new MyRewrittenStatement ( parsedSql , stmt , ctx ) ; 
throw new UnableToCreateStatementException ( 
} public AssetHandler maxAge ( final String maxAge ) { 
Try . apply ( ( ) -> Long . parseLong ( maxAge ) ) 
. recover ( x -> ConfigFactory . empty ( ) 
. withValue ( "v" , ConfigValueFactory . fromAnyRef ( maxAge ) ) 
. getDuration ( "v" ) 
. getSeconds ( ) ) 
. onSuccess ( this :: maxAge ) ; 
} protected void send ( final Request req , final Response rsp , final Asset asset ) throws Throwable { 
rsp . send ( asset ) ; 
} public Metrics request ( final String method , final String pattern ) { 
routes . add ( r -> r . use ( method , pattern , new InstrumentedHandler ( ) ) ) ; 
} public Metrics ping ( ) { 
bindings . add ( ( binder , routes , conf ) -> { 
routes . use ( "GET" , this . pattern + "/ping" , new PingHandler ( ) ) ; 
} public Metrics threadDump ( ) { 
routes . use ( "GET" , this . pattern + "/thread-dump" , new ThreadDumpHandler ( ) ) ; 
} public Metrics metric ( final String name , final Metric metric ) { 
MapBinder . newMapBinder ( binder , String . class , Metric . class ) . addBinding ( name ) 
. toInstance ( metric ) ; 
} public < M extends Metric > Metrics metric ( final String name , final Class < M > metric ) { 
. to ( metric ) ; 
} public Metrics healthCheck ( final String name , final HealthCheck check ) { 
MapBinder . newMapBinder ( binder , String . class , HealthCheck . class ) . addBinding ( name ) 
. toInstance ( check ) ; 
} public < H extends HealthCheck > Metrics healthCheck ( final String name , final Class < H > check ) { 
MapBinder . newMapBinder ( binder , String . class , HealthCheck . class ) 
. addBinding ( name ) 
. to ( check ) ; 
} public Metrics reporter ( final BiFunction < MetricRegistry , Config , Reporter > callback ) { 
} public Metrics reporter ( final Function < MetricRegistry , Reporter > callback ) { 
return reporter ( ( registry , conf ) -> callback . apply ( registry ) ) ; 
} public Eh doWith ( final Consumer < Configuration > configurer ) { 
return doWith ( ( ehconf , conf ) -> configurer . accept ( ehconf ) ) ; 
} public static List < MediaType > valueOf ( final String ... types ) throws Err . BadMediaType { 
List < MediaType > result = new ArrayList < > ( ) ; 
for ( String type : types ) { 
result . add ( valueOf ( type ) ) ; 
} public static List < MediaType > parse ( final String value ) throws Err . BadMediaType { 
return cache . computeIfAbsent ( value , MediaType :: parseInternal ) ; 
} public static Optional < MediaType > byFile ( final File file ) { 
return byPath ( file . getName ( ) ) ; 
} public static Optional < MediaType > byPath ( final Path path ) { 
return byPath ( path . toString ( ) ) ; 
} public static Optional < MediaType > byPath ( final String path ) { 
int idx = path . lastIndexOf ( '.' ) ; 
if ( idx != - 1 ) { 
String ext = path . substring ( idx + 1 ) ; 
return byExtension ( ext ) ; 
} public static Optional < MediaType > byExtension ( final String ext ) { 
String key = "mime." + ext ; 
if ( types . hasPath ( key ) ) { 
return Optional . of ( MediaType . valueOf ( types . getString ( "mime." + ext ) ) ) ; 
} public Jdbi doWith ( Consumer < DBI > configurer ) { 
return doWith ( ( dbi , conf ) -> configurer . accept ( dbi ) ) ; 
} public Aws with ( final BiFunction < AWSCredentialsProvider , Config , Object > callback ) { 
callbacks . add ( callback ) ; 
} public Aws with ( final Function < AWSCredentialsProvider , Object > callback ) { 
return with ( ( creds , conf ) -> callback . apply ( creds ) ) ; 
} public < T extends AmazonWebServiceClient > Aws doWith ( 
final BiFunction < T , Config , Object > callback ) { 
after . add ( callback ) ; 
} public < T extends AmazonWebServiceClient > Aws doWith ( final Function < T , Object > callback ) { 
return doWith ( ( s , c ) -> callback . apply ( ( T ) s ) ) ; 
} public jOOQ doWith ( Consumer < Configuration > configurer ) { 
return doWith ( ( configuration , conf ) -> configurer . accept ( configuration ) ) ; 
} public Quartz with ( final JobDetail job , final Trigger trigger ) { 
jobMap . put ( job , trigger ) ; 
} public Quartz with ( final Class < ? extends Job > jobClass , 
final BiConsumer < JobBuilder , TriggerBuilder < Trigger > > configurer ) { 
JobBuilder job = JobBuilder . newJob ( jobClass ) 
. withIdentity ( 
JobKey . jobKey ( jobClass . getSimpleName ( ) , jobClass . getPackage ( ) . getName ( ) ) 
TriggerBuilder < Trigger > trigger = TriggerBuilder . newTrigger ( ) 
TriggerKey . triggerKey ( jobClass . getSimpleName ( ) , jobClass . getPackage ( ) . getName ( ) ) 
configurer . accept ( job , trigger ) ; 
return with ( job . build ( ) , trigger . build ( ) ) ; 
} private void shutdownGracefully ( final Iterator < EventExecutorGroup > iterator ) { 
EventExecutorGroup group = iterator . next ( ) ; 
if ( ! group . isShuttingDown ( ) ) { 
group . shutdownGracefully ( ) . addListener ( future -> { 
shutdownGracefully ( iterator ) ; 
} public Cassandra doWithClusterBuilder ( final BiConsumer < Cluster . Builder , Config > configurer ) { 
} public Cassandra doWithClusterBuilder ( final Consumer < Cluster . Builder > configurer ) { 
return doWithClusterBuilder ( ( b , c ) -> configurer . accept ( b ) ) ; 
} public Cassandra doWithCluster ( final Consumer < Cluster > configurer ) { 
return doWithCluster ( ( cc , c ) -> configurer . accept ( cc ) ) ; 
} public Yasson doWith ( final Consumer < JsonbConfig > configurer ) { 
this . configurer = ( jsonConfig , conf ) -> configurer . accept ( jsonConfig ) ; 
public static Result with ( final Object entity , final Status status ) { 
return new Result ( ) . status ( status ) . set ( entity ) ; 
public static Result with ( final Object entity , final int status ) { 
return with ( entity , Status . valueOf ( status ) ) ; 
public static Result with ( final Status status ) { 
return new Result ( ) . status ( status ) ; 
public static Result when ( final String type , final Supplier < Object > supplier ) { 
return new Result ( ) . when ( type , supplier ) ; 
} private static Result redirect ( final Status status , final String location ) { 
return with ( status ) . header ( "location" , location ) ; 
} public SSIHandler delimiters ( final String start , final String end ) { 
this . startDelimiter = start ; 
this . endDelimiter = end ; 
} public Couchbase environment ( final java . util . function . Supplier < CouchbaseEnvironment > env ) { 
return environment ( c -> env . get ( ) ) ; 
} public Jackson module ( final Module module ) { 
modules . add ( binder -> binder . addBinding ( ) . toInstance ( module ) ) ; 
} public Jackson module ( final Class < ? extends Module > module ) { 
modules . add ( binder -> binder . addBinding ( ) . to ( module ) ) ; 
} public Nodejs overwrite ( final boolean overwrite ) { 
if ( overwrite ) { 
this . coptions = EnumSet . of ( StandardCopyOption . REPLACE_EXISTING ) ; 
this . coptions = Collections . emptySet ( ) ; 
} public void exec ( final String library , final Throwing . Consumer < V8 > callback ) throws Throwable { 
Path basedir = deploy ( library ) ; 
List < String > candidates = Arrays . asList ( 
basedir . getFileName ( ) . toString ( ) + ".js" , 
"main.js" , 
"index.js" ) ; 
Path main = candidates . stream ( ) 
. map ( basedir :: resolve ) 
. filter ( Files :: exists ) 
. orElseThrow ( ( ) -> new FileNotFoundException ( candidates . toString ( ) ) ) ; 
callback . accept ( node . getRuntime ( ) ) ; 
node . exec ( main . toFile ( ) ) ; 
while ( node . isRunning ( ) ) { 
node . handleMessage ( ) ; 
} public static void run ( final Throwing . Consumer < Nodejs > callback ) { 
run ( new File ( System . getProperty ( "java.io.tmpdir" ) ) , callback ) ; 
} public static void run ( final File basedir , final Throwing . Consumer < Nodejs > callback ) { 
Nodejs node = new Nodejs ( basedir ) ; 
Try . run ( ( ) -> callback . accept ( node ) ) 
. onComplete ( node :: release ) 
. throwException ( ) ; 
} public Pebble doWith ( final BiConsumer < PebbleEngine . Builder , Config > callback ) { 
} public Pebble doWith ( final Consumer < PebbleEngine . Builder > callback ) { 
return doWith ( ( p , c ) -> callback . accept ( p ) ) ; 
} public Pac4j doWith ( Consumer < org . pac4j . core . config . Config > configurer ) { 
return doWith ( ( pac4j , conf ) -> configurer . accept ( pac4j ) ) ; 
} public Pac4j doWith ( BiConsumer < org . pac4j . core . config . Config , Config > configurer ) { 
this . configurer = configurer ; 
} public < C extends Credentials , U extends CommonProfile > Pac4j client ( String pattern , 
Authorizer < U > authorizer , Function < Config , Client < C , U > > client ) { 
return clientInternal ( pattern , client , authorizer ) ; 
} public Pac4j unauthenticated ( Supplier < UserProfile > provider ) { 
return unauthenticated ( req -> provider . get ( ) ) ; 
} public Pac4j form ( String pattern ) { 
return clientInternal ( pattern , conf -> { 
showDevLogin = true ; 
return new FormClient ( "/login" , new SimpleTestUsernamePasswordAuthenticator ( ) ) ; 
} , null ) ; 
} protected static KeyManagerFactory buildKeyManagerFactory ( final File certChainFile , 
final File keyFile , final String keyPassword ) 
throws UnrecoverableKeyException , KeyStoreException , NoSuchAlgorithmException , 
String algorithm = Security . getProperty ( "ssl.KeyManagerFactory.algorithm" ) ; 
algorithm = "SunX509" ; 
return buildKeyManagerFactory ( certChainFile , algorithm , keyFile , keyPassword ) ; 
final String keyAlgorithm , final File keyFile , final String keyPassword ) 
throws KeyStoreException , NoSuchAlgorithmException , NoSuchPaddingException , 
InvalidKeySpecException , InvalidAlgorithmParameterException , IOException , 
CertificateException , KeyException , UnrecoverableKeyException { 
char [ ] keyPasswordChars = keyPassword == null ? EMPTY_CHARS : keyPassword . toCharArray ( ) ; 
KeyStore ks = buildKeyStore ( certChainFile , keyFile , keyPasswordChars ) ; 
KeyManagerFactory kmf = KeyManagerFactory . getInstance ( keyAlgorithm ) ; 
kmf . init ( ks , keyPasswordChars ) ; 
return kmf ; 
} public List < RouteMethod > parseFully ( Jooby application ) throws Exception { 
List < RouteMethod > methods = parseFully ( application . getClass ( ) . getName ( ) , 
Jooby . exportRoutes ( application ) ) ; 
} public Path export ( Path outputBaseDir , String application ) throws Exception { 
return new BytecodeRouteParser ( loader , dir ) . export ( outputBaseDir , application ) ; 
} public List < RouteMethod > parse ( String application ) throws Exception { 
return new BytecodeRouteParser ( loader , dir ) . parse ( application ) . stream ( ) 
. filter ( filter ) 
} public List < RouteMethod > parseFully ( String application , List < Route . Definition > routes ) 
List < RouteMethod > methods = parse ( application ) ; 
BiFunction < String , String , OptionalInt > routeIndex = ( verb , pattern ) -> { 
RouteMethod it = new RouteMethod ( verb , pattern , new RouteResponse ( void . class ) ) ; 
return IntStream . range ( 0 , methods . size ( ) ) 
. filter ( i -> methods . get ( i ) . equals ( it ) ) 
List < RouteMethod > result = new ArrayList < > ( routes . size ( ) ) ; 
for ( Route . Definition route : routes ) { 
routeIndex . apply ( route . method ( ) , route . pattern ( ) ) 
. ifPresent ( i -> result . add ( complement ( route , methods . remove ( i ) ) ) ) ; 
customizer . entrySet ( ) . forEach ( it -> 
result . stream ( ) 
. filter ( it . getKey ( ) ) 
. forEach ( it . getValue ( ) ) 
} public ApiParser modify ( final Predicate < RouteMethod > matcher , 
final Consumer < RouteMethod > customizer ) { 
this . customizer . put ( matcher , customizer ) ; 
} public Scanner scan ( final Class < ? > type ) { 
if ( type == Named . class || type == com . google . inject . name . Named . class ) { 
serviceTypes . add ( Named . class ) ; 
serviceTypes . add ( com . google . inject . name . Named . class ) ; 
} else if ( type == Singleton . class || type == com . google . inject . Singleton . class ) { 
serviceTypes . add ( Singleton . class ) ; 
serviceTypes . add ( com . google . inject . Singleton . class ) ; 
serviceTypes . add ( type ) ; 
} public ApiTool swagger ( String path , Consumer < Swagger > swagger ) { 
return swagger ( new Options ( path , options ) , swagger ) ; 
} public ApiTool swagger ( Options options , Consumer < Swagger > swagger ) { 
this . swagger = swagger ; 
} public ApiTool raml ( String path , Consumer < Raml > raml ) { 
return raml ( new Options ( path , options ) , raml ) ; 
} public ApiTool raml ( Options options , Consumer < Raml > raml ) { 
this . raml = raml ; 
} public ApiTool modify ( final Predicate < RouteMethod > matcher , 
} public static GroupByPath from ( final String bucket , final Class < ? > entityClass ) { 
String alias = String . valueOf ( entityClass . getSimpleName ( ) . charAt ( 0 ) ) ; 
return Select . select ( alias + ".*" ) 
. where ( path ( alias , CLASS ) . eq ( s ( entityClass . getName ( ) ) ) ) ; 
} public static String qualifyId ( final Class < ? > entityClass , final Object id ) { 
return qualifyId ( entityClass . getName ( ) , id ) ; 
} public String process ( String filename , String source , Config conf ) throws Exception { 
return process ( filename , source , conf , getClass ( ) . getClassLoader ( ) ) ; 
} public boolean hasProperties ( String ... properties ) { 
for ( String property : properties ) { 
if ( ! hasProperty ( property ) ) { 
} public static Demo . CDemoFileInfo infoForSource ( final Source source ) throws IOException { 
EngineType engineType = source . readEngineType ( ) ; 
source . setPosition ( source . readFixedInt32 ( ) ) ; 
PacketInstance < GeneratedMessage > pi = engineType . getNextPacketInstance ( source ) ; 
return ( Demo . CDemoFileInfo ) pi . parse ( ) ; 
} private static S2DotaMatchMetadata . CDOTAMatchMetadataFile metadataForStream ( InputStream stream ) throws IOException { 
return Packet . parse ( S2DotaMatchMetadata . CDOTAMatchMetadataFile . class , ByteString . readFrom ( stream ) ) ; 
} private byte [ ] readPacket ( Source source ) throws IOException { 
int size = source . readFixedInt32 ( ) ; 
return packetReader . readFromSource ( source , size , false ) ; 
} public int readVarInt32 ( ) throws IOException { 
byte tmp = readByte ( ) ; 
if ( tmp >= 0 ) { 
int result = tmp & 0x7f ; 
if ( ( tmp = readByte ( ) ) >= 0 ) { 
result |= tmp << 7 ; 
result |= ( tmp & 0x7f ) << 7 ; 
result |= tmp << 14 ; 
result |= ( tmp & 0x7f ) << 14 ; 
result |= tmp << 21 ; 
result |= ( tmp & 0x7f ) << 21 ; 
result |= ( tmp = readByte ( ) ) << 28 ; 
if ( tmp < 0 ) { 
} public int readFixedInt32 ( ) throws IOException { 
return ByteBuffer . wrap ( readBytes ( 4 ) ) . order ( ByteOrder . LITTLE_ENDIAN ) . asIntBuffer ( ) . get ( ) ; 
} public EngineType readEngineType ( ) throws IOException { 
engineType = EngineId . typeForMagic ( new String ( readBytes ( 8 ) ) ) ; 
if ( engineType == null ) { 
throw new IOException ( ) ; 
return engineType ; 
} public boolean sendMsgByName ( String name , String msg ) { 
Account account = api . getAccountByName ( name ) ; 
if ( null == account ) { 
return this . api . sendText ( account . getUserName ( ) , msg ) ; 
} public boolean sendImgName ( String name , String imgPath ) { 
return this . api . sendImg ( account . getUserName ( ) , imgPath ) ; 
} public boolean sendFileName ( String name , String filePath ) { 
return this . api . sendFile ( account . getUserName ( ) , filePath ) ; 
this . api = new WeChatApiImpl ( this ) ; 
api . login ( config . autoLogin ( ) ) ; 
Thread msgHandle = new Thread ( new Runnable ( ) { 
if ( hasMessage ( ) ) { 
WeChatMessage weChatMessage = nextMessage ( ) ; 
callBack ( mapping . get ( MsgType . ALL ) , weChatMessage ) ; 
callBack ( mapping . get ( weChatMessage . getMsgType ( ) ) , weChatMessage ) ; 
DateUtils . sleep ( 50 ) ; 
msgHandle . setName ( "message-handle" ) ; 
msgHandle . setDaemon ( true ) ; 
msgHandle . start ( ) ; 
this . other ( ) ; 
} protected void other ( ) { 
Scanner scanner = new Scanner ( System . in ) ; 
if ( scanner . hasNext ( ) ) { 
String text = scanner . next ( ) ; 
if ( "quit" . equals ( text ) || "exit" . equals ( text ) ) { 
api . logout ( ) ; 
DateUtils . sleep ( 100 ) ; 
} private void callBack ( List < Invoke > invokes , WeChatMessage message ) { 
if ( null != invokes && invokes . size ( ) > 0 && null != message ) { 
for ( Invoke invoke : invokes ) { 
invoke . call ( this , message ) ; 
} public void updateLastCheck ( ) { 
this . lastCheckTs = System . currentTimeMillis ( ) ; 
if ( this . config ( ) . autoLogin ( ) ) { 
String file = this . config ( ) . assetsDir ( ) + "/login.json" ; 
WeChatUtils . writeJson ( file , HotReload . build ( this . session ( ) ) ) ; 
log . debug ( "JSON" ) ; 
} public static Config load ( String filePath ) { 
Config config = new Config ( ) ; 
try ( final InputStream stream = Config . class . getResourceAsStream ( filePath ) ) { 
config . props . load ( stream ) ; 
throw new WeChatException ( "" , e ) ; 
} public < T extends WeChatBot > void call ( T bot , WeChatMessage message ) { 
if ( INVOKED_MSG . contains ( message . getId ( ) ) ) { 
if ( message . getMsgType ( ) == MsgType . ADD_FRIEND && bot . config ( ) . autoAddFriend ( ) ) { 
bot . api ( ) . verify ( message . getRecommend ( ) ) ; 
Account account = bot . api ( ) . getAccountById ( message . getFromUserName ( ) ) ; 
INVOKED_MSG . add ( message . getId ( ) ) ; 
method . invoke ( bot , message ) ; 
if ( msgType == MsgType . ALL || msgType == message . getMsgType ( ) ) { 
if ( message . getMsgType ( ) == MsgType . ADD_FRIEND ) { 
if ( accountTypes . contains ( account . getAccountType ( ) ) ) { 
} public static String match ( String reg , String text ) { 
Pattern pattern = Pattern . compile ( reg ) ; 
return m . group ( 1 ) ; 
} public static String formatMsg ( String msg ) { 
msg = msg . replace ( "&lt;" , "<" ) 
. replace ( "&gt;" , ">" ) 
. replace ( "<br/>" , "\n" ) ; 
return emojiParse ( msg ) ; 
} public static String getMimeType ( String fileUrl ) { 
FileNameMap fileNameMap = URLConnection . getFileNameMap ( ) ; 
String type = fileNameMap . getContentTypeFor ( fileUrl ) ; 
} public static void sleep ( long ms ) { 
TimeUnit . MILLISECONDS . sleep ( ms ) ; 
log . error ( "" , e ) ; 
} private void autoLogin ( ) { 
String file = bot . config ( ) . assetsDir ( ) + "/login.json" ; 
HotReload hotReload = WeChatUtils . fromJson ( new FileReader ( file ) , HotReload . class ) ; 
hotReload . reLogin ( bot ) ; 
this . login ( false ) ; 
} private String getUUID ( ) { 
log . info ( "UUID" ) ; 
ApiResponse response = this . client . send ( new StringRequest ( "https://login.weixin.qq.com/jslogin" ) 
. add ( "appid" , "wx782c26e4c19acffb" ) . add ( "fun" , "new" ) ) ; 
Matcher matcher = UUID_PATTERN . matcher ( response . getRawBody ( ) ) ; 
if ( matcher . find ( ) && StateCode . SUCCESS . equals ( matcher . group ( 1 ) ) ) { 
this . uuid = matcher . group ( 2 ) ; 
return this . uuid ; 
} private void getQrImage ( String uuid , boolean terminalShow ) { 
String uid = null != uuid ? uuid : this . uuid ; 
String imgDir = bot . config ( ) . assetsDir ( ) ; 
FileResponse fileResponse = this . client . download ( 
new FileRequest ( String . format ( "%s/qrcode/%s" , Constant . BASE_URL , uid ) ) ) ; 
InputStream inputStream = fileResponse . getInputStream ( ) ; 
File qrCode = WeChatUtils . saveFile ( inputStream , imgDir , "qrcode.png" ) ; 
DateUtils . sleep ( 200 ) ; 
QRCodeUtils . showQrCode ( qrCode , terminalShow ) ; 
this . getQrImage ( uid , terminalShow ) ; 
} private String checkLogin ( String uuid ) { 
String url = String . format ( "%s/cgi-bin/mmwebwx-bin/login" , Constant . BASE_URL ) ; 
Long time = System . currentTimeMillis ( ) ; 
ApiResponse response = this . client . send ( new StringRequest ( url ) 
. add ( "loginicon" , true ) . add ( "uuid" , uid ) 
. add ( "tip" , "1" ) . add ( "_" , time ) 
. add ( "r" , ( int ) ( - time / 1000 ) / 1579 ) 
. timeout ( 30 ) ) ; 
Matcher matcher = CHECK_LOGIN_PATTERN . matcher ( response . getRawBody ( ) ) ; 
if ( StateCode . SUCCESS . equals ( matcher . group ( 1 ) ) ) { 
if ( ! this . processLoginSession ( response . getRawBody ( ) ) ) { 
return StateCode . FAIL ; 
return StateCode . SUCCESS ; 
return matcher . group ( 1 ) ; 
} private boolean processLoginSession ( String loginContent ) { 
LoginSession loginSession = bot . session ( ) ; 
Matcher matcher = PROCESS_LOGIN_PATTERN . matcher ( loginContent ) ; 
loginSession . setUrl ( matcher . group ( 1 ) ) ; 
ApiResponse response = this . client . send ( new StringRequest ( loginSession . getUrl ( ) ) . noRedirect ( ) ) ; 
loginSession . setUrl ( loginSession . getUrl ( ) . substring ( 0 , loginSession . getUrl ( ) . lastIndexOf ( "/" ) ) ) ; 
String body = response . getRawBody ( ) ; 
List < String > fileUrl = new ArrayList < > ( ) ; 
List < String > syncUrl = new ArrayList < > ( ) ; 
for ( int i = 0 ; i < FILE_URL . size ( ) ; i ++ ) { 
fileUrl . add ( String . format ( "https://%s/cgi-bin/mmwebwx-bin" , FILE_URL . get ( i ) ) ) ; 
syncUrl . add ( String . format ( "https://%s/cgi-bin/mmwebwx-bin" , WEB_PUSH_URL . get ( i ) ) ) ; 
String indexUrl = INDEX_URL . get ( i ) ; 
if ( loginSession . getUrl ( ) . contains ( indexUrl ) ) { 
loginSession . setFileUrl ( fileUrl . get ( i ) ) ; 
loginSession . setSyncUrl ( syncUrl . get ( i ) ) ; 
if ( ! flag ) { 
loginSession . setFileUrl ( loginSession . getUrl ( ) ) ; 
loginSession . setSyncUrl ( loginSession . getUrl ( ) ) ; 
loginSession . setDeviceId ( "e" + String . valueOf ( System . currentTimeMillis ( ) ) ) ; 
BaseRequest baseRequest = new BaseRequest ( ) ; 
loginSession . setBaseRequest ( baseRequest ) ; 
loginSession . setSKey ( WeChatUtils . match ( "<skey>(\\S+)</skey>" , body ) ) ; 
loginSession . setWxSid ( WeChatUtils . match ( "<wxsid>(\\S+)</wxsid>" , body ) ) ; 
loginSession . setWxUin ( WeChatUtils . match ( "<wxuin>(\\S+)</wxuin>" , body ) ) ; 
loginSession . setPassTicket ( WeChatUtils . match ( "<pass_ticket>(\\S+)</pass_ticket>" , body ) ) ; 
baseRequest . setSkey ( loginSession . getSKey ( ) ) ; 
baseRequest . setSid ( loginSession . getWxSid ( ) ) ; 
baseRequest . setUin ( loginSession . getWxUin ( ) ) ; 
baseRequest . setDeviceID ( loginSession . getDeviceId ( ) ) ; 
} private String pushLogin ( ) { 
String uin = this . client . cookie ( "wxUin" ) ; 
if ( StringUtils . isEmpty ( uin ) ) { 
String url = String . format ( "%s/cgi-bin/mmwebwx-bin/webwxpushloginurl?uin=%s" , 
Constant . BASE_URL , uin ) ; 
JsonResponse jsonResponse = this . client . send ( new JsonRequest ( url ) ) ; 
return jsonResponse . getString ( "uuid" ) ; 
} private void statusNotify ( ) { 
log . info ( "" ) ; 
String url = String . format ( "%s/webwxstatusnotify?lang=zh_CN&pass_ticket=%s" , 
bot . session ( ) . getUrl ( ) , bot . session ( ) . getPassTicket ( ) ) ; 
this . client . send ( new JsonRequest ( url ) . post ( ) . jsonBody ( ) 
. add ( "BaseRequest" , bot . session ( ) . getBaseRequest ( ) ) 
. add ( "Code" , 3 ) 
. add ( "FromUserName" , bot . session ( ) . getUserName ( ) ) 
. add ( "ToUserName" , bot . session ( ) . getUserName ( ) ) 
. add ( "ClientMsgId" , System . currentTimeMillis ( ) / 1000 ) ) ; 
} private void webInit ( ) { 
log . info ( "..." ) ; 
int r = ( int ) ( - System . currentTimeMillis ( ) / 1000 ) / 1579 ; 
String url = String . format ( "%s/webwxinit?r=%d&pass_ticket=%s" , 
bot . session ( ) . getUrl ( ) , r , bot . session ( ) . getPassTicket ( ) ) ; 
JsonResponse response = this . client . send ( new JsonRequest ( url ) . post ( ) . jsonBody ( ) 
. add ( "BaseRequest" , bot . session ( ) . getBaseRequest ( ) ) ) ; 
WebInitResponse webInitResponse = response . parse ( WebInitResponse . class ) ; 
List < Account > contactList = webInitResponse . getContactList ( ) ; 
this . syncRecentContact ( contactList ) ; 
Account account = webInitResponse . getAccount ( ) ; 
SyncKey syncKey = webInitResponse . getSyncKey ( ) ; 
bot . session ( ) . setInviteStartCount ( webInitResponse . getInviteStartCount ( ) ) ; 
bot . session ( ) . setAccount ( account ) ; 
bot . session ( ) . setUserName ( account . getUserName ( ) ) ; 
bot . session ( ) . setNickName ( account . getNickName ( ) ) ; 
bot . session ( ) . setSyncKey ( syncKey ) ; 
} private void startRevive ( ) { 
bot . setRunning ( true ) ; 
Thread thread = new Thread ( new ChatLoop ( bot ) ) ; 
thread . setName ( "wechat-listener" ) ; 
thread . setDaemon ( true ) ; 
thread . start ( ) ; 
public SyncCheckRet syncCheck ( ) { 
String url = String . format ( "%s/synccheck" , bot . session ( ) . getSyncOrUrl ( ) ) ; 
. add ( "r" , System . currentTimeMillis ( ) ) 
. add ( "skey" , bot . session ( ) . getSKey ( ) ) 
. add ( "sid" , bot . session ( ) . getWxSid ( ) ) 
. add ( "uin" , bot . session ( ) . getWxUin ( ) ) 
. add ( "deviceid" , bot . session ( ) . getDeviceId ( ) ) 
. add ( "synckey" , bot . session ( ) . getSyncKeyStr ( ) ) 
. add ( "_" , System . currentTimeMillis ( ) ) 
. timeout ( 30 ) 
Matcher matcher = SYNC_CHECK_PATTERN . matcher ( response . getRawBody ( ) ) ; 
if ( ! "0" . equals ( matcher . group ( 1 ) ) ) { 
return new SyncCheckRet ( RetCode . parse ( Integer . valueOf ( matcher . group ( 1 ) ) ) , 0 ) ; 
return new SyncCheckRet ( RetCode . parse ( Integer . valueOf ( matcher . group ( 1 ) ) ) , Integer . valueOf ( matcher . group ( 2 ) ) ) ; 
return new SyncCheckRet ( RetCode . UNKNOWN , 0 ) ; 
if ( e instanceof SocketTimeoutException ) { 
log . warn ( "" ) ; 
return syncCheck ( ) ; 
log . error ( "" , e ) ; 
public WebSyncResponse webSync ( ) { 
String url = String . format ( "%s/webwxsync?sid=%s&sKey=%s&passTicket=%s" , 
bot . session ( ) . getUrl ( ) , bot . session ( ) . getWxSid ( ) , 
bot . session ( ) . getSKey ( ) , bot . session ( ) . getPassTicket ( ) ) ; 
. add ( "SyncKey" , bot . session ( ) . getSyncKey ( ) ) 
. add ( "rr" , ~ ( System . currentTimeMillis ( ) / 1000 ) ) ) ; 
WebSyncResponse webSyncResponse = response . parse ( WebSyncResponse . class ) ; 
if ( ! webSyncResponse . success ( ) ) { 
log . warn ( "" ) ; 
return webSyncResponse ; 
bot . session ( ) . setSyncKey ( webSyncResponse . getSyncKey ( ) ) ; 
public void logout ( ) { 
if ( bot . isRunning ( ) ) { 
String url = String . format ( "%s/webwxlogout" , bot . session ( ) . getUrl ( ) ) ; 
this . client . send ( new StringRequest ( url ) 
. add ( "redirect" , 1 ) 
. add ( "type" , 1 ) 
. add ( "sKey" , bot . session ( ) . getSKey ( ) ) ) ; 
bot . setRunning ( false ) ; 
this . logging = false ; 
this . client . cookies ( ) . clear ( ) ; 
new File ( file ) . delete ( ) ; 
public void loadContact ( int seq ) { 
log . info ( "" ) ; 
String url = String . format ( "%s/webwxgetcontact?r=%s&seq=%s&skey=%s" , 
bot . session ( ) . getUrl ( ) , System . currentTimeMillis ( ) , 
seq , bot . session ( ) . getSKey ( ) ) ; 
JsonResponse response = this . client . send ( new JsonRequest ( url ) . jsonBody ( ) ) ; 
JsonObject jsonObject = response . toJsonObject ( ) ; 
seq = jsonObject . get ( "Seq" ) . getAsInt ( ) ; 
this . memberCount += jsonObject . get ( "MemberCount" ) . getAsInt ( ) ; 
List < Account > memberList = WeChatUtils . fromJson ( WeChatUtils . toJson ( jsonObject . getAsJsonArray ( "MemberList" ) ) , new TypeToken < List < Account > > ( ) { } ) ; 
for ( Account account : memberList ) { 
if ( null == account . getUserName ( ) ) { 
accountMap . put ( account . getUserName ( ) , account ) ; 
if ( seq == 0 ) { 
this . contactList = new ArrayList < > ( this . getAccountByType ( AccountType . TYPE_FRIEND ) ) ; 
this . publicUsersList = new ArrayList < > ( this . getAccountByType ( AccountType . TYPE_MP ) ) ; 
this . specialUsersList = new ArrayList < > ( this . getAccountByType ( AccountType . TYPE_SPECIAL ) ) ; 
Set < Account > groupAccounts = this . getAccountByType ( AccountType . TYPE_GROUP ) ; 
for ( Account groupAccount : groupAccounts ) { 
groupUserNames . add ( groupAccount . getUserName ( ) ) ; 
} public void loadGroupList ( ) { 
log . info ( "" ) ; 
List < Map < String , String > > list = new ArrayList < > ( groupUserNames . size ( ) ) ; 
for ( String groupUserName : groupUserNames ) { 
Map < String , String > map = new HashMap < > ( 2 ) ; 
map . put ( "UserName" , groupUserName ) ; 
map . put ( "EncryChatRoomId" , "" ) ; 
list . add ( map ) ; 
String url = String . format ( "%s/webwxbatchgetcontact?type=ex&r=%s&pass_ticket=%s" , 
bot . session ( ) . getUrl ( ) , System . currentTimeMillis ( ) / 1000 , bot . session ( ) . getPassTicket ( ) ) ; 
JsonResponse jsonResponse = this . client . send ( new JsonRequest ( url ) . post ( ) . jsonBody ( ) 
. add ( "Count" , groupUserNames . size ( ) ) 
. add ( "List" , list ) 
this . groupList = WeChatUtils . fromJson ( WeChatUtils . toJson ( jsonResponse . toJsonObject ( ) . getAsJsonArray ( "ContactList" ) ) , new TypeToken < List < Account > > ( ) { } ) ; 
public Account getAccountByName ( String name ) { 
for ( Account account : accountMap . values ( ) ) { 
if ( name . equals ( account . getRemarkName ( ) ) ) { 
return account ; 
if ( name . equals ( account . getNickName ( ) ) ) { 
} public Set < Account > getAccountByType ( AccountType accountType ) { 
Set < Account > accountSet = new HashSet < > ( ) ; 
if ( account . getAccountType ( ) . equals ( accountType ) ) { 
accountSet . add ( account ) ; 
return accountSet ; 
} public void syncRecentContact ( List < Account > contactList ) { 
if ( null != contactList && contactList . size ( ) > 0 ) { 
for ( Account account : contactList ) { 
public List < WeChatMessage > handleMsg ( List < Message > messages ) { 
if ( null != messages && messages . size ( ) > 0 ) { 
List < WeChatMessage > weChatMessages = new ArrayList < > ( messages . size ( ) ) ; 
boolean hashNewMsg = false ; 
for ( Message message : messages ) { 
WeChatMessage weChatMessage = this . processMsg ( message ) ; 
if ( null != weChatMessage ) { 
weChatMessages . add ( weChatMessage ) ; 
hashNewMsg = true ; 
if ( hashNewMsg ) { 
log . info ( "" ) ; 
return weChatMessages ; 
} private String downloadImg ( String msgId ) { 
return this . downloadFile ( 
new DownLoad ( ApiURL . IMAGE , bot . session ( ) . getUrl ( ) , msgId , bot . session ( ) . getSKey ( ) ) 
. msgId ( msgId ) . saveByDay ( ) 
} private String downloadIconImg ( String msgId ) { 
new DownLoad ( ApiURL . ICON , bot . session ( ) . getUrl ( ) , msgId , bot . session ( ) . getSKey ( ) ) 
. msgId ( msgId ) 
} private String downloadHeadImg ( String userName ) { 
new DownLoad ( ApiURL . HEAD_IMG , bot . session ( ) . getUrl ( ) , userName , bot . session ( ) . getSKey ( ) ) 
. msgId ( userName ) 
} private String downloadVideo ( String msgId ) { 
new DownLoad ( ApiURL . VIDEO , bot . session ( ) . getUrl ( ) , msgId , bot . session ( ) . getSKey ( ) ) 
} private String downloadVoice ( String msgId ) { 
new DownLoad ( ApiURL . VOICE , bot . session ( ) . getUrl ( ) , msgId , bot . session ( ) . getSKey ( ) ) 
public MediaResponse uploadMedia ( String toUser , String filePath ) { 
throw new WeChatException ( "[" + filePath + "]" ) ; 
long size = file . length ( ) ; 
String mimeType = WeChatUtils . getMimeType ( filePath ) ; 
String mediatype = "doc" ; 
if ( mediatype . contains ( "image" ) ) { 
mediatype = "pic" ; 
if ( mediatype . contains ( "audio" ) ) { 
mediatype = "audio" ; 
if ( mediatype . contains ( "video" ) ) { 
mediatype = "video" ; 
String url = String . format ( "%s/webwxuploadmedia?f=json" , bot . session ( ) . getFileUrl ( ) ) ; 
String mediaId = System . currentTimeMillis ( ) / 1000 + StringUtils . random ( 6 ) ; 
Map < String , Object > uploadMediaRequest = new HashMap < > ( 10 ) ; 
uploadMediaRequest . put ( "UploadType" , 2 ) ; 
uploadMediaRequest . put ( "BaseRequest" , bot . session ( ) . getBaseRequest ( ) ) ; 
uploadMediaRequest . put ( "ClientMediaId" , mediaId ) ; 
uploadMediaRequest . put ( "TotalLen" , size ) ; 
uploadMediaRequest . put ( "StartPos" , 0 ) ; 
uploadMediaRequest . put ( "DataLen" , size ) ; 
uploadMediaRequest . put ( "MediaType" , 4 ) ; 
uploadMediaRequest . put ( "FromUserName" , bot . session ( ) . getUserName ( ) ) ; 
uploadMediaRequest . put ( "ToUserName" , toUser ) ; 
uploadMediaRequest . put ( "FileMd5" , MD5Checksum . getMD5Checksum ( file . getPath ( ) ) ) ; 
String dataTicket = this . client . cookie ( "webwx_data_ticket" ) ; 
if ( StringUtils . isEmpty ( dataTicket ) ) { 
throw new WeChatException ( "Cookie" ) ; 
ApiResponse response = this . client . send ( new StringRequest ( url ) . post ( ) . multipart ( ) 
. fileName ( file . getName ( ) ) 
. add ( "id" , "WU_FILE_0" ) 
. add ( "name" , filePath ) 
. add ( "type" , mimeType ) 
. add ( "size" , String . valueOf ( size ) ) 
. add ( "mediatype" , mediatype ) 
. add ( "uploadmediarequest" , WeChatUtils . toJson ( uploadMediaRequest ) ) 
. add ( "webwx_data_ticket" , dataTicket ) 
. add ( "pass_ticket" , bot . session ( ) . getPassTicket ( ) ) 
. add ( "filename" , RequestBody . create ( MediaType . parse ( mimeType ) , file ) ) ) ; 
MediaResponse mediaResponse = response . parse ( MediaResponse . class ) ; 
if ( ! mediaResponse . success ( ) ) { 
return mediaResponse ; 
public boolean sendImg ( String toUserName , String filePath ) { 
DateUtils . sendSleep ( ) ; 
String mediaId = this . uploadMedia ( toUserName , filePath ) . getMediaId ( ) ; 
if ( StringUtils . isEmpty ( mediaId ) ) { 
log . warn ( "Media" ) ; 
String url = String . format ( "%s/webwxsendmsgimg?fun=async&f=json&pass_ticket=%s" , 
String msgId = System . currentTimeMillis ( ) / 1000 + StringUtils . random ( 6 ) ; 
Map < String , Object > msg = new HashMap < > ( ) ; 
msg . put ( "Type" , 3 ) ; 
msg . put ( "MediaId" , mediaId ) ; 
msg . put ( "FromUserName" , bot . session ( ) . getUserName ( ) ) ; 
msg . put ( "ToUserName" , toUserName ) ; 
msg . put ( "LocalID" , msgId ) ; 
msg . put ( "ClientMsgId" , msgId ) ; 
. add ( "Msg" , msg ) 
return null != response && response . success ( ) ; 
public boolean sendText ( String toUserName , String msg ) { 
String url = String . format ( "%s/webwxsendmsg?pass_ticket=%s" , bot . session ( ) . getUrl ( ) , bot . session ( ) . getPassTicket ( ) ) ; 
. add ( "Msg" , new SendMessage ( 1 , msg , bot . session ( ) . getUserName ( ) , toUserName , msgId , msgId ) ) 
} public static String getMD5Checksum ( String filename ) { 
byte [ ] b = createChecksum ( filename ) ; 
result += Integer . toString ( ( b [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ; 
} public static void recoverCookie ( Map < String , List < Cookie > > cookieStore ) { 
BotClient . cookieStore . clear ( ) ; 
BotClient . cookieStore = cookieStore ; 
} private OkHttpClient timeout ( ApiRequest request ) { 
int timeoutMillis = request . getTimeout ( ) * 1000 ; 
if ( client . readTimeoutMillis ( ) == 0 || client . readTimeoutMillis ( ) > timeoutMillis ) { 
if ( null != clientWithTimeout && clientWithTimeout . readTimeoutMillis ( ) > timeoutMillis ) { 
return clientWithTimeout ; 
clientWithTimeout = client . newBuilder ( ) . readTimeout ( timeoutMillis + 1000 , TimeUnit . MILLISECONDS ) . build ( ) ; 
} public static void showQrCode ( File qrCode , boolean terminal ) throws WriterException { 
if ( ! terminal ) { 
String os = System . getProperty ( "os.name" ) . toLowerCase ( ) ; 
if ( os . contains ( "mac" ) || os . contains ( "win" ) ) { 
Desktop . getDesktop ( ) . open ( qrCode ) ; 
Map < EncodeHintType , Object > hintMap = new EnumMap < EncodeHintType , Object > ( EncodeHintType . class ) ; 
hintMap . put ( EncodeHintType . CHARACTER_SET , "UTF-8" ) ; 
hintMap . put ( EncodeHintType . MARGIN , 1 ) ; 
hintMap . put ( EncodeHintType . ERROR_CORRECTION , ErrorCorrectionLevel . L ) ; 
String qrContent = QRCodeUtils . readQRCode ( qrCode , hintMap ) ; 
QRCodeWriter qrCodeWriter = new QRCodeWriter ( ) ; 
BitMatrix bitMatrix ; 
bitMatrix = qrCodeWriter . encode ( qrContent , BarcodeFormat . QR_CODE , 10 , 10 , hintMap ) ; 
System . out . println ( toAscii ( bitMatrix ) ) ; 
} private static String toAscii ( BitMatrix bitMatrix ) { 
for ( int rows = 0 ; rows < bitMatrix . getHeight ( ) ; rows ++ ) { 
for ( int cols = 0 ; cols < bitMatrix . getWidth ( ) ; cols ++ ) { 
boolean x = bitMatrix . get ( rows , cols ) ; 
if ( ! x ) { 
sb . append ( "\n" ) ; 
} private static String readQRCode ( File filePath , Map hintMap ) { 
BinaryBitmap binaryBitmap = new BinaryBitmap ( new HybridBinarizer ( 
new BufferedImageLuminanceSource ( ImageIO . read ( new FileInputStream ( filePath ) ) ) ) ) ; 
Result qrCodeResult = new MultiFormatReader ( ) . decode ( binaryBitmap , hintMap ) ; 
return qrCodeResult . getText ( ) ; 
} public static OkHttpClient . Builder configureToIgnoreCertificate ( OkHttpClient . Builder builder ) { 
final TrustManager [ ] trustAllCerts = new TrustManager [ ] { 
new X509TrustManager ( ) { 
public void checkClientTrusted ( java . security . cert . X509Certificate [ ] chain , String authType ) { 
public void checkServerTrusted ( java . security . cert . X509Certificate [ ] chain , String authType ) { 
public java . security . cert . X509Certificate [ ] getAcceptedIssuers ( ) { 
return new java . security . cert . X509Certificate [ ] { } ; 
final SSLContext sslContext = SSLContext . getInstance ( "SSL" ) ; 
sslContext . init ( null , trustAllCerts , new java . security . SecureRandom ( ) ) ; 
final SSLSocketFactory sslSocketFactory = sslContext . getSocketFactory ( ) ; 
builder . sslSocketFactory ( sslSocketFactory , ( X509TrustManager ) trustAllCerts [ 0 ] ) ; 
builder . hostnameVerifier ( new HostnameVerifier ( ) { 
public boolean verify ( String hostname , SSLSession session ) { 
} @ PostDeploy 
public void onDeploymentFinished ( ProcessEngine processEngine ) { 
long processCount = processEngine . getRuntimeService ( ) . createProcessInstanceQuery ( ) . processDefinitionKey ( PROCESS_DEFINITION_KEY ) . count ( ) ; 
if ( processCount == 0 ) { 
Map < String , Object > variables = new HashMap < String , Object > ( ) ; 
variables . put ( "taskAssignee" , "demo" ) ; 
ProcessInstance processInstance = processEngine . getRuntimeService ( ) . startProcessInstanceByKey ( PROCESS_DEFINITION_KEY , "vorgang-27" , variables ) ; 
variables = new HashMap < String , Object > ( ) ; 
variables . put ( "subtaskAssignee" , "demo" ) ; 
processEngine . getRuntimeService ( ) . messageEventReceived ( "SUBTASK_WANTED" , processInstance . getId ( ) , variables ) ; 
} @ StartProcess ( "OrderConfirmation" ) 
public void saveNewOrder ( Order order ) { 
entityManager . persist ( order . getCustomer ( ) ) ; 
entityManager . persist ( order ) ; 
businessProcess . setVariable ( "orderId" , order . getId ( ) ) ; 
Claim claim = new Claim ( ) ; 
claim . setExpenditure ( 1000 ) ; 
processEngine . getRuntimeService ( ) . startProcessInstanceByKey ( BpmConstants . DECISION_FLOW_KEY_mitarbeiterBestimmen , 
Variables . createVariables ( ) 
. putValue ( "claim" , claim ) ) ; 
} public void initFromProcessEngineConfiguration ( ProcessEngineConfigurationImpl processEngineConfiguration , String resourceName ) { 
this . resourceName = resourceName ; 
setDataSource ( processEngineConfiguration . getDataSource ( ) ) ; 
initDataSource ( ) ; 
initCommandContextFactory ( ) ; 
initTransactionFactory ( ) ; 
initTransactionContextFactory ( ) ; 
initCommandExecutors ( ) ; 
initIdentityProviderSessionFactory ( ) ; 
initSqlSessionFactory ( ) ; 
initSessionFactories ( ) ; 
} public void startAccontOpeningProcess ( Map < String , Object > variables ) { 
String businessKey = ( String ) variables . get ( "ordernumber" ) ; 
runtimeService . startProcessInstanceByKey ( PROCESS_KEY , businessKey , variables ) ; 
} public static BoxDeveloperEditionAPIConnection userClient ( String userId ) { 
if ( userId == null ) { 
BoxDeveloperEditionAPIConnection userClient = BoxDeveloperEditionAPIConnection . getAppUserConnection ( 
userId , CLIENT_ID , CLIENT_SECRET , jwtEncryptionPreferences , accessTokenCache ) ; 
return userClient ; 
} catch ( BoxAPIException apiException ) { 
apiException . printStackTrace ( ) ; 
throw apiException ; 
} private void addExecutionListener ( final ActivityImpl activity ) { 
final String guardClass = guardClass ( activity ) ; 
if ( isNotBlank ( guardClass ) ) { 
activity . addExecutionListener ( ExecutionListener . EVENTNAME_START , classDelegateFor ( guardClass ) ) ; 
activity . addExecutionListener ( ExecutionListener . EVENTNAME_END , classDelegateFor ( guardClass ) ) ; 
} public void updateModifiedFieldsFromEntity ( ProcessDefinitionEntity updatingProcessDefinition ) { 
if ( ! this . key . equals ( updatingProcessDefinition . key ) || ! this . deploymentId . equals ( updatingProcessDefinition . deploymentId ) ) { 
this . revision = updatingProcessDefinition . revision ; 
this . suspensionState = updatingProcessDefinition . suspensionState ; 
if ( processEngine . getRuntimeService ( ) . createProcessInstanceQuery ( ) . processDefinitionKey ( PROCESS_DEFINITION_KEY ) . count ( ) == 0 ) { 
Order order = new Order ( ) 
processEngine . getRuntimeService ( ) . startProcessInstanceByKey ( 
PROCESS_DEFINITION_KEY , 
Variables . createVariables ( ) . putValueTyped ( 
ProcessVariables . VAR_NAME_ORDER , 
Variables . objectValue ( order ) . serializationDataFormat ( SerializationDataFormats . JSON ) . create ( ) ) ) ; 
} private void addFourEyesTaskListener ( ActivityImpl activity ) { 
UserTaskActivityBehavior userTaskActivityBehavior = ( UserTaskActivityBehavior ) activity . getActivityBehavior ( ) ; 
boolean listenerAlreadyExists = false ; 
List < TaskListener > existingListeners = userTaskActivityBehavior . getTaskDefinition ( ) . getTaskListeners ( ) . get ( "complete" ) ; 
for ( TaskListener taskListener : existingListeners ) { 
if ( taskListener instanceof ClassDelegate && 
( ( ClassDelegate ) taskListener ) . getClassName ( ) . equals ( TaskCompletionListener . class . getName ( ) ) ) { 
listenerAlreadyExists = true ; 
if ( ! listenerAlreadyExists ) { 
ClassDelegate taskListener = new ClassDelegate ( TaskCompletionListener . class , null ) ; 
userTaskActivityBehavior . getTaskDefinition ( ) . addTaskListener ( "complete" , taskListener ) ; 
public void deployProcessesToTenantEngines ( ) { 
for ( ProcessEngine processEngine : BpmPlatform . getProcessEngineService ( ) . getProcessEngines ( ) ) { 
if ( processEngine != BpmPlatform . getDefaultProcessEngine ( ) ) { 
TenantManager . deployDefaultProcessesToEngine ( processEngine ) ; 
} private void setSharedAttribute ( Task task ) { 
setSharedAttribute ( BRIDGE_TASK_ID , task . getId ( ) ) ; 
setSharedAttribute ( BRIDGE_PROCESS_DEFINITION_ID , null ) ; 
} public String getPortletId ( String portletName , String servletContextName ) { 
String portletId = portletName ; 
if ( Validator . isNotNull ( servletContextName ) ) { 
if ( servletContextName . startsWith ( "/" ) ) { 
servletContextName = servletContextName . substring ( 1 ) ; 
portletId = portletId . concat ( PortletConstants . WAR_SEPARATOR ) . concat ( servletContextName ) ; 
portletId = PortalUtil . getJsSafePortletId ( portletId ) ; 
return portletId ; 
User user = processEngine . getIdentityService ( ) . createUserQuery ( ) . userId ( "niall" ) . singleResult ( ) ; 
createInitialUserInternal ( processEngine ) ; 
} private ProcessEngine startProcessEngine ( String tenant ) { 
ProcessEngineConfigurationImpl configuration = new StandaloneProcessEngineConfiguration ( ) ; 
configuration . setIdGenerator ( new StrongUuidGenerator ( ) ) ; 
configureCustomRetryStrategy ( configuration ) ; 
configuration . setProcessEngineName ( tenant ) ; 
configuration . setJdbcDriver ( "org.h2.Driver" ) ; 
configuration . setJdbcUrl ( "jdbc:h2:./camunda-h2-dbs/process-engine-" + tenant + ";MVCC=TRUE;TRACE_LEVEL_FILE=0;DB_CLOSE_ON_EXIT=FALSE" ) ; 
configuration . setDatabaseSchemaUpdate ( StandaloneProcessEngineConfiguration . DB_SCHEMA_UPDATE_TRUE ) ; 
configuration . setJobExecutorDeploymentAware ( true ) ; 
configuration . setHistory ( StandaloneProcessEngineConfiguration . HISTORY_FULL ) ; 
JobExecutor jobExecutor = getServiceContainer ( ) . getServiceValue ( ServiceTypes . JOB_EXECUTOR , jobAcquisitionName ) ; 
if ( jobExecutor == null ) { 
configuration . setJobExecutor ( jobExecutor ) ; 
ProcessEngine processEngine = configuration . buildProcessEngine ( ) ; 
RuntimeContainerDelegate . INSTANCE . get ( ) . registerProcessEngine ( processEngine ) ; 
return processEngine ; 
} private void checkTaskSelectedViaBridge ( ) { 
String bridgeTaskId = ( String ) getSharedSessionAttribute ( BRIDGE_TASK_ID ) ; 
String selectedTaskId = ( String ) getSharedSessionAttribute ( ASSOCIATED_TASK_ID ) ; 
if ( selectedTaskId == null && bridgeTaskId != null ) { 
switchTaskId ( bridgeTaskId ) ; 
if ( selectedTaskId != null && bridgeTaskId != null && ! selectedTaskId . equals ( bridgeTaskId ) ) { 
} public List < String > getTaskList ( List < String > correlationIds ) { 
ArrayList < String > tasks = new ArrayList < String > ( ) ; 
for ( String id : correlationIds ) { 
List < Task > tasksForCorrelationId = taskService . createTaskQuery ( ) . processVariableValueEquals ( CALLBACK_CORRELATION_ID , id ) . list ( ) ; 
for ( Task task : tasksForCorrelationId ) { 
tasks . add ( task . getName ( ) ) ; 
return tasks ; 
} public static String getServletContextPath ( 
ProcessEngine processEngine , String processDefinitionId ) { 
return getServletContextPath ( getProcessApplicationInfo ( processEngine , processDefinitionId ) ) ; 
} public static String getServletContextPath ( String processDefinitionId ) { 
ProcessApplicationInfo processApplicationInfo = getProcessApplicationInfo ( processDefinitionId ) ; 
if ( processApplicationInfo == null ) { 
return processApplicationInfo . getProperties ( ) . get ( 
ProcessApplicationInfo . PROP_SERVLET_CONTEXT_PATH ) ; 
} public static ProcessApplicationInfo getProcessApplicationInfo ( 
ProcessDefinition processDefinition = processEngine . getRepositoryService ( ) . getProcessDefinition ( processDefinitionId ) ; 
String processApplicationName = processEngine . getManagementService ( ) 
. getProcessApplicationForDeployment ( processDefinition . getDeploymentId ( ) ) ; 
if ( processApplicationName == null ) { 
ProcessApplicationService processApplicationService = BpmPlatform . getProcessApplicationService ( ) ; 
return processApplicationService . getProcessApplicationInfo ( processApplicationName ) ; 
} public static ProcessApplicationInfo getProcessApplicationInfo ( String processDefinitionId ) { 
ProcessEngineService processEngineService = BpmPlatform . getProcessEngineService ( ) ; 
ProcessApplicationService processAppService = BpmPlatform . getProcessApplicationService ( ) ; 
for ( String appName : processAppService . getProcessApplicationNames ( ) ) { 
ProcessApplicationInfo appInfo = processAppService 
. getProcessApplicationInfo ( appName ) ; 
for ( ProcessApplicationDeploymentInfo deploymentInfo : appInfo 
. getDeploymentInfo ( ) ) { 
long count = processEngineService 
. getProcessEngine ( deploymentInfo . getProcessEngineName ( ) ) 
. getRepositoryService ( ) . createProcessDefinitionQuery ( ) 
. deploymentId ( deploymentInfo . getDeploymentId ( ) ) 
. processDefinitionId ( processDefinitionId ) . count ( ) ; 
if ( count > 0 ) { 
return appInfo ; 
} @ PostConstruct 
public void initializeDiscountRules ( ) { 
List < DiscountRuleEntry > rules = rulesDAO . findAllDiscountRuleEntries ( ) ; 
if ( ( rules == null ) || ( rules . size ( ) == 0 ) ) { 
public void startFirstProcess ( ProcessEngine processEngine ) { 
processEngine = BpmPlatform . getProcessEngineService ( ) . getProcessEngine ( "anders" ) ; 
createUsers ( processEngine ) ; 
startProcessInstances ( processEngine , "invoice" , 1 ) ; 
startProcessInstances ( processEngine , "invoice" , null ) ; 
for ( int i = 0 ; i < 1000 ; i ++ ) { 
@ Bean 
public UserDetailsService userDetailsService ( ) { 
InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager ( ) ; 
manager . createUser ( User . withDefaultPasswordEncoder ( ) . username ( "demo" ) . password ( "demo" ) . roles ( "ACTUATOR" , "camunda-admin" ) . build ( ) ) ; 
manager . createUser ( User . withDefaultPasswordEncoder ( ) . username ( "john" ) . password ( "john" ) . roles ( "camunda-user" ) . build ( ) ) ; 
public static final < T extends Serializable > T castValue ( final Object value ) { 
return value != null ? ( T ) value : null ; 
public void init ( ) throws Exception { 
log . info ( "=======================" ) ; 
CamundaBpmComponent component = new CamundaBpmComponent ( processEngine ) ; 
component . setCamelContext ( cdiCamelContext ) ; 
cdiCamelContext . addComponent ( "camunda-bpm" , component ) ; 
cdiCamelContext . addComponent ( "jms" , cdiCamelContext . getComponent ( "seda" , SedaComponent . class ) ) ; 
cdiCamelContext . addRoutes ( openAccountRoute ) ; 
cdiCamelContext . start ( ) ; 
} public static DmnDecisionTableResult evaluate ( String decisionKey , VariableContext variables ) { 
final DmnEngine dmnEngine = Context . getProcessEngineConfiguration ( ) . getDmnEngine ( ) ; 
DeploymentCache deploymentCache = Context . getProcessEngineConfiguration ( ) . getDeploymentCache ( ) ; 
DmnDecision decisionDefinition = ( DmnDecision ) deploymentCache . findDeployedLatestDecisionDefinitionByKey ( decisionKey ) ; 
return dmnEngine . evaluateDecisionTable ( decisionDefinition , variables ) ; 
} protected CriteriaQuery < T > createQuery ( CriteriaBuilder cb ) { 
CriteriaQuery < T > query = cb . createQuery ( getEntityType ( ) ) ; 
Root < T > e = query . from ( getEntityType ( ) ) ; 
query . select ( e ) ; 
if ( sortColumn != null ) { 
Path < Object > sortField = e . get ( sortColumn ) ; 
if ( sortAsc ) { 
query . orderBy ( cb . asc ( sortField ) ) ; 
query . orderBy ( cb . desc ( sortField ) ) ; 
return query ; 
} @ Produces 
@ Named ( "orderProcesses" ) 
public List < OrderProcessDTO > getOrders ( ) { 
ProcessEngineImpl processEngine = ( ProcessEngineImpl ) ProcessEngines . getDefaultProcessEngine ( ) ; 
ProcessEngineConfigurationImpl processEngineConfiguration = processEngine . getProcessEngineConfiguration ( ) ; 
MyBatisQueryCommandExecutor commandExecutor = new MyBatisQueryCommandExecutor ( processEngineConfiguration , "customMappings.xml" ) ; 
return commandExecutor . executeQueryCommand ( new Command < List < OrderProcessDTO > > ( ) { 
public List < OrderProcessDTO > execute ( CommandContext commandContext ) { 
return ( List < OrderProcessDTO > ) commandContext . getDbSqlSession ( ) . selectList ( "selectOrdersWithProcessInformation" , null ) ; 
} public static void checkIsSet ( final DelegateExecution execution , final String variableName ) { 
checkArgument ( variableName != null , VARIABLE_NAME_MUST_BE_NOT_NULL ) ; 
final Object variableLocal = execution . getVariableLocal ( variableName ) ; 
final Object variable = execution . getVariable ( variableName ) ; 
checkState ( variableLocal != null || variable != null , 
} public static void checkIsSetGlobal ( final DelegateExecution execution , final String variableName ) { 
public void execute ( ActivityExecution execution ) throws Exception { 
String processDefinitionKey = this . processDefinitionKey ; 
String binding = this . binding ; 
Integer version = this . version ; 
if ( copy_processDefinitionExpression != null ) { 
processDefinitionKey = ( String ) copy_processDefinitionExpression . getValue ( execution ) ; 
ProcessDefinitionEntity processDefinition = null ; 
if ( binding == null || CalledElementBinding . LATEST . getValue ( ) . equals ( binding ) ) { 
processDefinition = Context . getProcessEngineConfiguration ( ) . getDeploymentCache ( ) . findDeployedLatestProcessDefinitionByKey ( processDefinitionKey ) ; 
} else if ( binding != null && CalledElementBinding . DEPLOYMENT . getValue ( ) . equals ( binding ) ) { 
processDefinition = Context 
. getProcessEngineConfiguration ( ) 
. getDeploymentCache ( ) 
. findDeployedProcessDefinitionByDeploymentAndKey ( Context . getExecutionContext ( ) . getExecution ( ) . getProcessDefinition ( ) . getDeploymentId ( ) , 
processDefinitionKey ) ; 
} else if ( binding != null && CalledElementBinding . VERSION . getValue ( ) . equals ( binding ) && version != null ) { 
processDefinition = Context . getProcessEngineConfiguration ( ) . getDeploymentCache ( ) 
. findDeployedProcessDefinitionByKeyAndVersion ( processDefinitionKey , version ) ; 
String businessKey = null ; 
Map < String , Object > callActivityVariables = new HashMap < String , Object > ( ) ; 
for ( DataAssociation dataInputAssociation : copy_dataInputAssociations ) { 
if ( dataInputAssociation . getBusinessKeyExpression ( ) != null ) { 
businessKey = ( String ) dataInputAssociation . getBusinessKeyExpression ( ) . getValue ( execution ) ; 
} else if ( dataInputAssociation . getVariables ( ) != null ) { 
Map < String , Object > variables = execution . getVariables ( ) ; 
if ( variables != null && ! variables . isEmpty ( ) ) { 
Set < String > variableKeys = variables . keySet ( ) ; 
for ( String variableKey : variableKeys ) { 
callActivityVariables . put ( variableKey , variables . get ( variableKey ) ) ; 
} else if ( dataInputAssociation . getSourceExpression ( ) != null ) { 
value = dataInputAssociation . getSourceExpression ( ) . getValue ( execution ) ; 
value = execution . getVariable ( dataInputAssociation . getSource ( ) ) ; 
callActivityVariables . put ( dataInputAssociation . getTarget ( ) , value ) ; 
String migrationScenario = null ; 
migrationScenario = ( String ) migrationScenarioExpression . getValue ( execution ) ; 
catch ( ProcessEngineException ex ) { 
if ( migrationScenario == null ) { 
PvmProcessInstance subProcessInstance = execution . createSubProcessInstance ( processDefinition , businessKey ) ; 
subProcessInstance . start ( callActivityVariables ) ; 
ActivityImpl startActivity = processDefinition . findActivity ( migrationScenario ) ; 
ExecutionEntity subProcessInstance = ( ExecutionEntity ) processDefinition . createProcessInstance ( businessKey , startActivity ) ; 
subProcessInstance . setSuperExecution ( ( ExecutionEntity ) execution ) ; 
( ( ExecutionEntity ) execution ) . setSubProcessInstance ( subProcessInstance ) ; 
if ( subProcessInstance . getExecutions ( ) . size ( ) == 1 ) { 
healExecution ( subProcessInstance , subProcessInstance . getExecutions ( ) . get ( 0 ) , startActivity ) ; 
else if ( subProcessInstance . getExecutions ( ) . size ( ) > 1 ) { 
} @ Start ( order = 9 ) 
Boolean runMigrations = ninjaProperties . getBoolean ( NinjaConstant . NINJA_MIGRATION_RUN ) ; 
if ( runMigrations != null && runMigrations ) { 
migrationEngineProvider . get ( ) . migrate ( ) ; 
} public static List < String > tokenize ( String arguments , boolean stringify ) { 
LinkedList < String > argList = new LinkedList < > ( ) ; 
StringBuilder currArg = new StringBuilder ( ) ; 
int state = NO_TOKEN_STATE ; 
int len = arguments . length ( ) ; 
char c = arguments . charAt ( i ) ; 
currArg . append ( c ) ; 
case SINGLE_QUOTE_STATE : 
state = NORMAL_TOKEN_STATE ; 
case DOUBLE_QUOTE_STATE : 
char next = arguments . charAt ( i ) ; 
if ( next == '"' || next == '\\' ) { 
currArg . append ( next ) ; 
case NO_TOKEN_STATE : 
case NORMAL_TOKEN_STATE : 
state = SINGLE_QUOTE_STATE ; 
state = DOUBLE_QUOTE_STATE ; 
else if ( state == NORMAL_TOKEN_STATE ) { 
argList . add ( currArg . toString ( ) ) ; 
currArg = new StringBuilder ( ) ; 
state = NO_TOKEN_STATE ; 
currArg . append ( '\\' ) ; 
else if ( state != NO_TOKEN_STATE ) { 
if ( stringify ) { 
for ( int i = 0 ; i < argList . size ( ) ; i ++ ) { 
argList . set ( i , "\"" + _escapeQuotesAndBackslashes ( argList . get ( i ) ) + "\"" ) ; 
return argList ; 
} protected static String _escapeQuotesAndBackslashes ( String s ) { 
final StringBuilder buf = new StringBuilder ( s ) ; 
for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { 
if ( ( c == '\\' ) || ( c == '"' ) ) { 
buf . insert ( i , '\\' ) ; 
else if ( c == '\n' ) { 
buf . insert ( i , "\\n" ) ; 
else if ( c == '\t' ) { 
buf . insert ( i , "\\t" ) ; 
else if ( c == '\r' ) { 
buf . insert ( i , "\\r" ) ; 
else if ( c == '\b' ) { 
buf . insert ( i , "\\b" ) ; 
else if ( c == '\f' ) { 
buf . insert ( i , "\\f" ) ; 
} public static String getCharsetOfContentType ( String rawContentType , String defaultEncoding ) { 
if ( rawContentType . contains ( "charset=" ) ) { 
String charset = rawContentType . split ( "charset=" ) [ 1 ] ; 
return charset ; 
return defaultEncoding ; 
} static public Map < String , RouteParameter > parse ( String path ) { 
Map < String , RouteParameter > params = new LinkedHashMap < > ( ) ; 
Matcher matcher = Route . PATTERN_FOR_VARIABLE_PARTS_OF_ROUTE . matcher ( path ) ; 
RouteParameter param = new RouteParameter ( 
matcher . start ( 0 ) , matcher . group ( 0 ) , matcher . group ( 1 ) , matcher . group ( 3 ) ) ; 
params . put ( param . getName ( ) , param ) ; 
} private void enforceCorrectEncodingOfRequest ( ) { 
String charset = NinjaConstant . UTF_8 ; 
String contentType = getHeader ( CONTENT_TYPE ) ; 
charset = HttpHeaderUtils . getCharsetOfContentTypeOrUtf8 ( contentType ) ; 
httpServletRequest . setCharacterEncoding ( charset ) ; 
} private < T > Map < String , List < T > > toUnmodifiableMap ( Multimap < String , T > multimap ) { 
Map < String , List < T > > map = new HashMap < > ( multimap . size ( ) ) ; 
for ( Entry < String , Collection < T > > entry : multimap . asMap ( ) . entrySet ( ) ) { 
Collection < T > value = entry . getValue ( ) ; 
Collections . emptyList ( ) ; 
} else if ( value instanceof List ) { 
map . put ( entry . getKey ( ) , ( List < T > ) value ) ; 
map . put ( entry . getKey ( ) , new ArrayList < > ( value ) ) ; 
return Collections . unmodifiableMap ( map ) ; 
public Builder with ( ControllerMethod controllerMethod ) { 
LambdaRoute lambdaRoute = LambdaRoute . resolve ( controllerMethod ) ; 
Method method = lambdaRoute . getFunctionalMethod ( ) ; 
return builder ( method . getDeclaringClass ( ) , method . getName ( ) ) ; 
public Injector getInjector ( ) { 
Bootstrap ninjaBootstrapLocal = ninjaBootstrap ; 
if ( ninjaBootstrapLocal == null ) { 
ninjaBootstrapLocal = ninjaBootstrap ; 
if ( ninjaProperties == null ) { 
ninjaProperties 
= new NinjaPropertiesImpl ( 
NinjaModeHelper . determineModeFromSystemPropertiesOrProdIfNotSet ( ) ) ; 
ninjaBootstrap 
= createNinjaBootstrap ( ninjaProperties , contextPath ) ; 
return ninjaBootstrapLocal . getInjector ( ) ; 
} public Result serveStatic ( ) { 
Object renderable = new Renderable ( ) { 
public void render ( Context context , Result result ) { 
String fileName = getFileNameFromPathOrReturnRequestPath ( context ) ; 
URL url = getStaticFileFromAssetsDir ( fileName ) ; 
streamOutUrlEntity ( url , context , result ) ; 
return Results . ok ( ) . render ( renderable ) ; 
} private URL getStaticFileFromAssetsDir ( String fileName ) { 
if ( ninjaProperties . isDev ( ) 
&& new File ( assetsDirInDevModeWithoutTrailingSlash ( ) ) . exists ( ) ) { 
String finalNameWithoutLeadingSlash = assetsControllerHelper . normalizePathWithoutLeadingSlash ( fileName , false ) ; 
File possibleFile = new File ( 
assetsDirInDevModeWithoutTrailingSlash ( ) 
+ File . separator 
+ finalNameWithoutLeadingSlash ) ; 
url = getUrlForFile ( possibleFile ) ; 
String finalNameWithoutLeadingSlash = assetsControllerHelper . normalizePathWithoutLeadingSlash ( fileName , true ) ; 
url = this . getClass ( ) . getClassLoader ( ) 
. getResource ( ASSETS_DIR 
+ "/" 
} private URL getStaticFileFromMetaInfResourcesDir ( String fileName ) { 
String finalNameWithoutLeadingSlash 
= assetsControllerHelper . normalizePathWithoutLeadingSlash ( fileName , true ) ; 
url = this . getClass ( ) . getClassLoader ( ) . getResource ( "META-INF/resources/webjars/" + finalNameWithoutLeadingSlash ) ; 
} private String assetsDirInDevModeWithoutTrailingSlash ( ) { 
String srcDir = System . 
getProperty ( "user.dir" ) 
+ "src" 
+ "main" 
+ "java" ; 
return srcDir + File . separator + ASSETS_DIR ; 
} public static boolean isThisASecureCallbackName ( String callback ) { 
return ! Strings . isNullOrEmpty ( callback ) 
&& ! callback . contains ( ".." ) 
&& CALLBACK_SECURITY_VALIDATION_REGEXP . matcher ( callback ) . matches ( ) ; 
} private PropertiesConfiguration loadLanguageConfiguration ( String fileOrUrl ) { 
PropertiesConfiguration configuration = SwissKnife 
. loadConfigurationInUtf8 ( fileOrUrl ) ; 
if ( configuration != null && ninjaProperties . isDev ( ) ) { 
FileChangedReloadingStrategy strategy = new FileChangedReloadingStrategy ( ) ; 
configuration . setReloadingStrategy ( strategy ) ; 
} private Map < String , Configuration > loadAllMessageFilesForRegisteredLanguages ( ) { 
Map < String , Configuration > langToKeyAndValuesMappingMutable = Maps . newHashMap ( ) ; 
Configuration defaultLanguage = loadLanguageConfiguration ( "conf/messages.properties" ) ; 
if ( defaultLanguage == null ) { 
langToKeyAndValuesMappingMutable . put ( "" , defaultLanguage ) ; 
String [ ] applicationLangs = ninjaProperties 
. getStringArray ( NinjaConstant . applicationLanguages ) ; 
if ( applicationLangs == null ) { 
return ImmutableMap . copyOf ( langToKeyAndValuesMappingMutable ) ; 
for ( String lang : applicationLangs ) { 
Configuration configuration = loadLanguageConfiguration ( String 
. format ( "conf/messages_%s.properties" , lang ) ) ; 
Configuration configurationLangOnly = null ; 
if ( lang . contains ( "-" ) ) { 
String langOnly = lang . split ( "-" ) [ 0 ] ; 
configurationLangOnly = loadLanguageConfiguration ( String 
. format ( "conf/messages_%s.properties" , langOnly ) ) ; 
if ( configuration == null ) { 
logger . info ( 
lang ) ; 
CompositeConfiguration compositeConfiguration = new CompositeConfiguration ( ) ; 
compositeConfiguration . addConfiguration ( configuration ) ; 
if ( configurationLangOnly != null ) { 
compositeConfiguration 
. addConfiguration ( configurationLangOnly ) ; 
compositeConfiguration . addConfiguration ( defaultLanguage ) ; 
langToKeyAndValuesMappingMutable . put ( lang , 
( Configuration ) compositeConfiguration ) ; 
} private Configuration getLanguageConfigurationForLocale ( Optional < String > language ) { 
if ( ! language . isPresent ( ) ) { 
return langToKeyAndValuesMapping . get ( "" ) ; 
String [ ] languages = language . get ( ) . split ( "," ) ; 
for ( String l : languages ) { 
l = l . trim ( ) ; 
if ( l . contains ( ";" ) ) { 
l = l . split ( ";" ) [ 0 ] ; 
Configuration configuration = langToKeyAndValuesMapping . get ( l ) ; 
if ( l . contains ( "-" ) ) { 
String [ ] array = l . split ( "-" ) ; 
String languageWithoutCountry = array [ 0 ] ; 
if ( array . length > 1 ) { 
String country = array [ 1 ] ; 
String languageWithUpperCaseCountry = languageWithoutCountry + "-" + country . toUpperCase ( ) ; 
configuration = langToKeyAndValuesMapping . get ( languageWithUpperCaseCountry ) ; 
configuration = langToKeyAndValuesMapping 
. get ( languageWithoutCountry ) ; 
} protected static URL getUrlForStringFromClasspathAsFileOrUrl ( String logbackConfigurationFile ) { 
url = Resources . getResource ( logbackConfigurationFile ) ; 
File file = new File ( logbackConfigurationFile ) ; 
url = new File ( logbackConfigurationFile ) . toURI ( ) . toURL ( ) ; 
} catch ( MalformedURLException ex ) { 
url = new URL ( logbackConfigurationFile ) ; 
} private Cookie generateNinjaLanguageCookie ( ) { 
Cookie cookie = Cookie . builder ( applicationCookiePrefix 
+ ninja . utils . NinjaConstant . LANG_COOKIE_SUFFIX , "" ) 
. setMaxAge ( TEN_YEARS ) . build ( ) ; 
return cookie ; 
} protected static String generateSecret ( Random random ) { 
String charsetForSecret = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" ; 
StringBuilder stringBuilder = new StringBuilder ( 64 ) ; 
for ( int i = 0 ; i < 64 ; i ++ ) { 
int charToPoPickFromCharset = random . nextInt ( charsetForSecret . length ( ) ) ; 
stringBuilder . append ( charsetForSecret . charAt ( charToPoPickFromCharset ) ) ; 
} protected RunClassInSeparateJvmMachine buildRunClassInSeparateJvmMachine ( 
String name , 
String classNameWithMainToRun , 
List < String > classpath , 
List < String > jvmArguments , 
File mavenBaseDir ) { 
return new RunClassInSeparateJvmMachine ( 
classNameWithMainToRun , 
classpath , 
buildJvmArguments ( ) , 
mavenBaseDir 
} protected List < Artifact > getAllArtifactsComingFromNinjaStandalone ( 
List < Artifact > artifacts ) { 
List < Artifact > resultingArtifacts = new ArrayList < > ( ) ; 
for ( String dependencyTrail : artifact . getDependencyTrail ( ) ) { 
if ( dependencyTrail . contains ( NinjaMavenPluginConstants . NINJA_STANDALONE_ARTIFACT_ID ) ) { 
resultingArtifacts . add ( artifact ) ; 
return resultingArtifacts ; 
} static public Class < ? extends Standalone > resolveStandaloneClass ( ) { 
return resolveStandaloneClass ( 
System . getProperty ( Standalone . KEY_NINJA_STANDALONE_CLASS ) , 
ForwardingServiceLoader . loadWithSystemServiceLoader ( Standalone . class ) , 
Standalone . DEFAULT_STANDALONE_CLASS 
} static Class < ? extends Standalone > resolveStandaloneClass ( String standaloneClassNameSystemProperty , 
ForwardingServiceLoader < Standalone > standaloneServiceLoader , 
String standaloneClassNameDefaultValue ) { 
Class < ? extends Standalone > resolvedStandaloneClass = null ; 
if ( standaloneClassNameSystemProperty != null ) { 
resolvedStandaloneClass 
= ( Class < Standalone > ) Class . forName ( standaloneClassNameSystemProperty ) ; 
if ( resolvedStandaloneClass == null ) { 
Iterator < Standalone > standaloneIterator = standaloneServiceLoader . iterator ( ) ; 
if ( standaloneIterator . hasNext ( ) ) { 
resolvedStandaloneClass = standaloneIterator . next ( ) . getClass ( ) ; 
standaloneServiceLoader . reload ( ) ; 
= ( Class < Standalone > ) Class . forName ( standaloneClassNameDefaultValue ) ; 
return resolvedStandaloneClass ; 
} public String encrypt ( String data ) { 
if ( ! secretKeySpec . isPresent ( ) ) { 
Cipher cipher = Cipher . getInstance ( ALGORITHM ) ; 
cipher . init ( Cipher . ENCRYPT_MODE , secretKeySpec . get ( ) ) ; 
byte [ ] encrypted = cipher . doFinal ( data . getBytes ( StandardCharsets . UTF_8 ) ) ; 
return Base64 . encodeBase64URLSafeString ( encrypted ) ; 
} catch ( InvalidKeyException ex ) { 
logger . error ( getHelperLogMessage ( ) , ex ) ; 
} catch ( GeneralSecurityException ex ) { 
} public String decrypt ( String data ) { 
byte [ ] decoded = Base64 . decodeBase64 ( data ) ; 
cipher . init ( Cipher . DECRYPT_MODE , secretKeySpec . get ( ) ) ; 
byte [ ] decrypted = cipher . doFinal ( decoded ) ; 
return new String ( decrypted , StandardCharsets . UTF_8 ) ; 
public Result onException ( Context context , Exception exception ) { 
return onException ( context , exception , null ) ; 
public Result getInternalServerErrorResult ( Context context , Exception exception ) { 
return getInternalServerErrorResult ( context , exception , null ) ; 
} private final String readNinjaVersion ( ) { 
String LOCATION_OF_NINJA_BUILTIN_PROPERTIES = "ninja/ninja-builtin.properties" ; 
String NINJA_VERSION_PROPERTY_KEY = "ninja.version" ; 
String ninjaVersion ; 
try ( InputStream stream = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( LOCATION_OF_NINJA_BUILTIN_PROPERTIES ) ) { 
Properties prop = new Properties ( ) ; 
prop . load ( stream ) ; 
ninjaVersion = prop . getProperty ( NINJA_VERSION_PROPERTY_KEY ) ; 
return ninjaVersion ; 
} private void register ( Path path ) throws IOException { 
WatchKey watchKey = path . register ( 
watchService , 
new WatchEvent . Kind [ ] { 
StandardWatchEventKinds . ENTRY_CREATE , 
StandardWatchEventKinds . ENTRY_MODIFY , 
StandardWatchEventKinds . ENTRY_DELETE 
SensitivityWatchEventModifier . HIGH ) ; 
mapOfWatchKeysToPaths . put ( watchKey , path ) ; 
} public boolean matches ( String httpMethod , String uri ) { 
if ( this . httpMethod . equalsIgnoreCase ( httpMethod ) ) { 
Matcher matcher = regex . matcher ( uri ) ; 
return matcher . matches ( ) ; 
} public Map < String , String > getPathParametersEncoded ( String uri ) { 
Map < String , String > map = Maps . newHashMap ( ) ; 
Matcher m = regex . matcher ( uri ) ; 
Iterator < String > it = this . parameters . keySet ( ) . iterator ( ) ; 
for ( int i = 1 ; i < m . groupCount ( ) + 1 ; i ++ ) { 
String parameterName = it . next ( ) ; 
map . put ( parameterName , m . group ( i ) ) ; 
} protected static String convertRawUriToRegex ( String rawUri ) { 
Matcher groupMatcher = Pattern . compile ( "\\(([^?].*)\\)" ) . matcher ( rawUri ) ; 
String converted = groupMatcher . replaceAll ( "\\(?:$1\\)" ) ; 
Matcher matcher = PATTERN_FOR_VARIABLE_PARTS_OF_ROUTE . matcher ( converted ) ; 
StringBuffer stringBuffer = new StringBuffer ( ) ; 
String namedVariablePartOfRoute = matcher . group ( 3 ) ; 
String namedVariablePartOfORouteReplacedWithRegex ; 
if ( namedVariablePartOfRoute != null ) { 
namedVariablePartOfORouteReplacedWithRegex 
= "(" + Matcher . quoteReplacement ( namedVariablePartOfRoute ) + ")" ; 
= VARIABLE_ROUTES_DEFAULT_REGEX ; 
matcher . appendReplacement ( stringBuffer , namedVariablePartOfORouteReplacedWithRegex ) ; 
matcher . appendTail ( stringBuffer ) ; 
return stringBuffer . toString ( ) ; 
} public static Optional < NinjaMode > determineModeFromSystemProperties ( ) { 
NinjaMode ninjaMode = null ; 
String modeFromGetSystemProperty = System 
. getProperty ( NinjaConstant . MODE_KEY_NAME ) ; 
if ( modeFromGetSystemProperty != null ) { 
if ( modeFromGetSystemProperty . equals ( NinjaConstant . MODE_TEST ) ) { 
ninjaMode = NinjaMode . test ; 
} else if ( modeFromGetSystemProperty . equals ( NinjaConstant . MODE_DEV ) ) { 
ninjaMode = NinjaMode . dev ; 
} else if ( modeFromGetSystemProperty . equals ( NinjaConstant . MODE_PROD ) ) { 
ninjaMode = NinjaMode . prod ; 
return Optional . ofNullable ( ninjaMode ) ; 
} public static NinjaMode determineModeFromSystemPropertiesOrProdIfNotSet ( ) { 
Optional < NinjaMode > ninjaModeOptional = determineModeFromSystemProperties ( ) ; 
NinjaMode ninjaMode ; 
if ( ! ninjaModeOptional . isPresent ( ) ) { 
ninjaMode = ninjaModeOptional . get ( ) ; 
return ninjaMode ; 
} public String getMimeType ( String filename , String defaultMimeType ) { 
Matcher matcher = extPattern . matcher ( filename . toLowerCase ( ) ) ; 
String ext = "" ; 
ext = matcher . group ( 1 ) ; 
if ( ext . length ( ) > 0 ) { 
String mimeType = mimetypes . getProperty ( ext ) ; 
if ( mimeType == null ) { 
return defaultMimeType ; 
return mimeType ; 
} public boolean isValidMimeType ( String mimeType ) { 
} else if ( mimeType . indexOf ( ";" ) != - 1 ) { 
return mimetypes . contains ( mimeType . split ( ";" ) [ 0 ] ) ; 
return mimetypes . contains ( mimeType ) ; 
} static public Set < String > parseProtocolRequestHeader ( String value ) { 
Set < String > subprotocols = new LinkedHashSet < > ( ) ; 
if ( ! StringUtils . isEmpty ( value ) ) { 
String [ ] values = value . split ( "," ) ; 
for ( String v : values ) { 
subprotocols . add ( v . trim ( ) ) ; 
return subprotocols ; 
} private Method verifyControllerMethod ( Class < ? > controllerClass , 
String controllerMethod ) { 
Method methodFromQueryingClass = null ; 
for ( Method method : controllerClass . getMethods ( ) ) { 
if ( method . getName ( ) . equals ( controllerMethod ) ) { 
if ( methodFromQueryingClass == null ) { 
methodFromQueryingClass = method ; 
if ( Result . class . isAssignableFrom ( methodFromQueryingClass . getReturnType ( ) ) ) { 
return methodFromQueryingClass ; 
log . error ( 
} public Route buildRoute ( Injector injector ) { 
if ( functionalMethod == null ) { 
LinkedList < Class < ? extends Filter > > allFilters = new LinkedList < > ( ) ; 
allFilters . addAll ( calculateGlobalFilters ( this . globalFiltersOptional , injector ) ) ; 
allFilters . addAll ( this . localFilters ) ; 
allFilters . addAll ( calculateFiltersForClass ( functionalMethod . getDeclaringClass ( ) ) ) ; 
FilterWith filterWith = functionalMethod . getAnnotation ( FilterWith . class ) ; 
if ( filterWith != null ) { 
allFilters . addAll ( Arrays . asList ( filterWith . value ( ) ) ) ; 
FilterChain filterChain = buildFilterChain ( injector , allFilters ) ; 
return new Route ( httpMethod , uri , functionalMethod , filterChain ) ; 
} public static SerializedLambda getSerializedLambda ( Object lambda ) { 
Objects . requireNonNull ( lambda ) ; 
if ( ! ( lambda instanceof java . io . Serializable ) ) { 
for ( Class < ? > clazz = lambda . getClass ( ) ; clazz != null ; clazz = clazz . getSuperclass ( ) ) { 
Method replaceMethod = clazz . getDeclaredMethod ( "writeReplace" ) ; 
replaceMethod . setAccessible ( true ) ; 
Object serializedForm = replaceMethod . invoke ( lambda ) ; 
if ( serializedForm instanceof SerializedLambda ) { 
return ( SerializedLambda ) serializedForm ; 
} catch ( NoSuchMethodError e ) { 
} catch ( SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { 
final public void run ( ) { 
Thread . currentThread ( ) . setName ( this . name ) ; 
this . configure ( ) ; 
this . start ( ) ; 
shutdown ( ) ; 
join ( ) ; 
} protected String createServerUrl ( String scheme , String host , Integer port ) { 
sb . append ( scheme ) ; 
sb . append ( "://" ) ; 
sb . append ( ( host != null ? host : "localhost" ) ) ; 
if ( ( "http" . equals ( scheme ) && port != 80 ) || ( "https" . equals ( scheme ) && port != 443 ) ) { 
sb . append ( port ) ; 
public void init ( Router router ) { 
this . router = router ; 
configureReflections ( ) ; 
controllers = Maps . newHashMap ( ) ; 
methods = Sets . newHashSet ( ) ; 
processFoundMethods ( ) ; 
sortMethods ( ) ; 
registerMethods ( ) ; 
} private void registerMethods ( ) { 
final Class < ? > controllerClass = method . getDeclaringClass ( ) ; 
final Path methodPath = method . getAnnotation ( Path . class ) ; 
final Set < String > controllerPaths = controllers 
. get ( controllerClass ) ; 
String [ ] paths = { "/" } ; 
if ( methodPath != null ) { 
paths = methodPath . value ( ) ; 
for ( String controllerPath : controllerPaths ) { 
for ( String methodPathSpec : paths ) { 
final String httpMethod = getHttpMethod ( method ) ; 
final String fullPath = controllerPath + methodPathSpec ; 
final String methodName = method . getName ( ) ; 
router . METHOD ( httpMethod ) . route ( fullPath ) 
. with ( controllerClass , methodName ) ; 
} private void processFoundMethods ( ) { 
for ( Method method : findControllerMethods ( ) ) { 
if ( allowMethod ( method ) ) { 
methods . add ( method ) ; 
if ( ! controllers . containsKey ( controllerClass ) ) { 
Set < String > paths = collectPaths ( controllerClass ) ; 
controllers . put ( controllerClass , paths ) ; 
} private void sortMethods ( ) { 
List < Method > methodList = new ArrayList < > ( methods ) ; 
Collections . sort ( methodList , new Comparator < Method > ( ) { 
public int compare ( Method m1 , Method m2 ) { 
int o1 = Integer . MAX_VALUE ; 
if ( m1 . isAnnotationPresent ( Order . class ) ) { 
Order order = m1 . getAnnotation ( Order . class ) ; 
o1 = order . value ( ) ; 
int o2 = Integer . MAX_VALUE ; 
if ( m2 . isAnnotationPresent ( Order . class ) ) { 
Order order = m2 . getAnnotation ( Order . class ) ; 
o2 = order . value ( ) ; 
if ( o1 == o2 ) { 
String s1 = m1 . getDeclaringClass ( ) . getName ( ) + "." 
+ m1 . getName ( ) ; 
String s2 = m2 . getDeclaringClass ( ) . getName ( ) + "." 
+ m2 . getName ( ) ; 
return s1 . compareTo ( s2 ) ; 
if ( o1 < o2 ) { 
methods = new LinkedHashSet < > ( methodList ) ; 
private Set < Method > findControllerMethods ( ) { 
Set < Method > methods = Sets . newLinkedHashSet ( ) ; 
methods . addAll ( reflections . getMethodsAnnotatedWith ( Path . class ) ) ; 
boolean enableCustomHttpMethods = ninjaProperties . getBooleanWithDefault ( NINJA_CUSTOM_HTTP_METHODS , false ) ; 
if ( enableCustomHttpMethods ) { 
Reflections annotationReflections = new Reflections ( "" , new TypeAnnotationsScanner ( ) , new SubTypesScanner ( ) ) ; 
for ( Class < ? > httpMethod : annotationReflections . getTypesAnnotatedWith ( HttpMethod . class ) ) { 
if ( httpMethod . isAnnotation ( ) ) { 
methods . addAll ( reflections . getMethodsAnnotatedWith ( ( Class < ? extends Annotation > ) httpMethod ) ) ; 
Reflections annotationReflections = new Reflections ( "ninja.jaxy" , new TypeAnnotationsScanner ( ) , new SubTypesScanner ( ) ) ; 
} private void configureReflections ( ) { 
Optional < String > basePackage = Optional . ofNullable ( ninjaProperties . get ( NinjaConstant . APPLICATION_MODULES_BASE_PACKAGE ) ) ; 
if ( basePackage . isPresent ( ) ) { 
reflections = new Reflections ( 
basePackage . get ( ) + "." + NinjaConstant . CONTROLLERS_DIR , 
new MethodAnnotationsScanner ( ) ) ; 
NinjaConstant . CONTROLLERS_DIR , 
} private boolean allowMethod ( Method method ) { 
if ( method . isAnnotationPresent ( Requires . class ) ) { 
String key = method . getAnnotation ( Requires . class ) . value ( ) ; 
String value = ninjaProperties . get ( key ) ; 
Set < NinjaMode > modes = Sets . newTreeSet ( ) ; 
for ( Annotation annotation : method . getAnnotations ( ) ) { 
Class < ? extends Annotation > annotationClass = annotation 
. annotationType ( ) ; 
if ( annotationClass . isAnnotationPresent ( RuntimeMode . class ) ) { 
RuntimeMode mode = annotationClass 
. getAnnotation ( RuntimeMode . class ) ; 
modes . add ( mode . value ( ) ) ; 
return modes . isEmpty ( ) || modes . contains ( runtimeMode ) ; 
} private String getHttpMethod ( Method method ) { 
if ( annotationClass . isAnnotationPresent ( HttpMethod . class ) ) { 
HttpMethod httpMethod = annotationClass 
. getAnnotation ( HttpMethod . class ) ; 
return httpMethod . value ( ) ; 
logger . info ( String 
method . getClass ( ) . getName ( ) , method . getName ( ) ) ) ; 
return HttpMethod . GET ; 
} public static ControllerMethodInvoker build ( 
Method functionalMethod , 
Method implementationMethod , 
Injector injector , 
NinjaProperties ninjaProperties ) { 
final Type [ ] genericParameterTypes = implementationMethod . getGenericParameterTypes ( ) ; 
final MethodParameter [ ] methodParameters = MethodParameter . convertIntoMethodParameters ( genericParameterTypes ) ; 
final Annotation [ ] [ ] paramAnnotations = implementationMethod 
. getParameterAnnotations ( ) ; 
ArgumentExtractor < ? > [ ] argumentExtractors = new ArgumentExtractor < ? > [ methodParameters . length ] ; 
for ( int i = 0 ; i < methodParameters . length ; i ++ ) { 
argumentExtractors [ i ] = getArgumentExtractor ( methodParameters [ i ] , paramAnnotations [ i ] , 
injector ) ; 
} catch ( RoutingException e ) { 
int bodyAsFound = - 1 ; 
for ( int i = 0 ; i < argumentExtractors . length ; i ++ ) { 
if ( argumentExtractors [ i ] == null ) { 
if ( bodyAsFound > - 1 ) { 
+ implementationMethod . getDeclaringClass ( ) . getName ( ) + "." + implementationMethod . getName ( ) + "()\n" 
argumentExtractors [ i ] = new ArgumentExtractors . BodyAsExtractor ( methodParameters [ i ] . parameterClass ) ; 
bodyAsFound = i ; 
argumentExtractors [ i ] = 
validateArgumentWithExtractor ( 
methodParameters [ i ] , 
paramAnnotations [ i ] , 
injector , 
argumentExtractors [ i ] ) ; 
boolean useStrictArgumentExtractors = determineWhetherToUseStrictArgumentExtractorMode ( ninjaProperties ) ; 
return new ControllerMethodInvoker ( functionalMethod , argumentExtractors , useStrictArgumentExtractors ) ; 
} private < T > T invoke ( Context context , Map < String , String [ ] > parameters , Class < T > classOfT , String paramPrefix ) { 
t = classOfT . newInstance ( ) ; 
for ( String declaredField : getAllDeclaredFieldsAsStringSet ( classOfT ) ) { 
Field field = classOfT . getDeclaredField ( declaredField ) ; 
Class < ? > fieldType = field . getType ( ) ; 
if ( parameters . containsKey ( paramPrefix + declaredField ) ) { 
String [ ] values = parameters . get ( paramPrefix + declaredField ) ; 
if ( Collection . class . isAssignableFrom ( fieldType ) || List . class . isAssignableFrom ( fieldType ) ) { 
ListParamParser < ? > parser = ( ListParamParser < ? > ) paramParsers . getListParser ( getGenericType ( field ) ) ; 
if ( parser == null ) { 
field . set ( t , parser . parseParameter ( field . getName ( ) , values , context . getValidation ( ) ) ) ; 
} else if ( fieldType . isArray ( ) ) { 
ArrayParamParser < ? > parser = paramParsers . getArrayParser ( fieldType ) ; 
ParamParser < ? > parser = ( ParamParser < ? > ) paramParsers . getParamParser ( fieldType ) ; 
field . set ( t , parser . parseParameter ( field . getName ( ) , values [ 0 ] , context . getValidation ( ) ) ) ; 
for ( String parameter : parameters . keySet ( ) ) { 
if ( parameter . startsWith ( paramPrefix + declaredField + "." ) ) { 
if ( isEmptyParameter ( parameters . get ( parameter ) ) ) { 
field . set ( t , invoke ( context , parameters , fieldType , paramPrefix + declaredField + "." ) ) ; 
} catch ( NoSuchFieldException 
| SecurityException 
| IllegalArgumentException 
| IllegalAccessException e ) { 
classOfT . getName ( ) , paramPrefix + declaredField , parameters . get ( paramPrefix + declaredField ) , e ) ; 
} public static Result redirect ( String url ) { 
Result result = status ( Result . SC_303_SEE_OTHER ) ; 
result . addHeader ( Result . LOCATION , url ) ; 
result . render ( Result . NO_HTTP_BODY ) ; 
} public static Result redirectTemporary ( String url ) { 
Result result = status ( Result . SC_307_TEMPORARY_REDIRECT ) ; 
public MultiPartEmail createMultiPartEmailWithContent ( Mail mail ) throws EmailException { 
MultiPartEmail multiPartEmail ; 
if ( mail . getBodyHtml ( ) == null || mail . getBodyHtml ( ) . equals ( "" ) ) { 
multiPartEmail = new MultiPartEmail ( ) ; 
multiPartEmail . setMsg ( mail . getBodyText ( ) ) ; 
} else if ( mail . getBodyText ( ) == null || mail . getBodyText ( ) . equals ( "" ) ) { 
multiPartEmail = new HtmlEmail ( ) . setHtmlMsg ( mail . getBodyHtml ( ) ) ; 
multiPartEmail = 
new HtmlEmail ( ) . setHtmlMsg ( mail . getBodyHtml ( ) ) . setTextMsg ( mail . getBodyText ( ) ) ; 
return multiPartEmail ; 
} public static PropertiesConfiguration loadConfigurationInUtf8 ( String fileOrUrlOrClasspathUrl ) { 
PropertiesConfiguration propertiesConfiguration = new PropertiesConfiguration ( ) ; 
propertiesConfiguration . setEncoding ( NinjaConstant . UTF_8 ) ; 
propertiesConfiguration . setDelimiterParsingDisabled ( true ) ; 
propertiesConfiguration . setFileName ( fileOrUrlOrClasspathUrl ) ; 
propertiesConfiguration . getLayout ( ) . setSingleLine ( NinjaConstant . applicationSecret , true ) ; 
propertiesConfiguration . load ( fileOrUrlOrClasspathUrl ) ; 
} catch ( ConfigurationException e ) { 
return propertiesConfiguration ; 
} public static String getRealClassNameLowerCamelCase ( Object object ) { 
return CaseFormat . UPPER_CAMEL . to ( CaseFormat . LOWER_CAMEL , object . getClass ( ) . getSimpleName ( ) ) ; 
} public static boolean doesClassExist ( String nameWithPackage , Object instanceToGetClassloaderFrom ) { 
boolean exists = false ; 
Class . forName ( nameWithPackage , false , instanceToGetClassloaderFrom . getClass ( ) . getClassLoader ( ) ) ; 
exists = true ; 
exists = false ; 
return exists ; 
} static public String getSourceCodeRelativePathForStackTraceElement ( StackTraceElement ste ) { 
String packageName = ste . getClassName ( ) ; 
int pos = packageName . lastIndexOf ( '.' ) ; 
packageName = packageName . substring ( 0 , pos ) ; 
packageName . replace ( "." , File . separator ) 
+ ste . getFileName ( ) ; 
ste . getFileName ( ) ; 
} public void add ( String key , Object value , String expiration ) { 
checkSerializable ( value ) ; 
cache . add ( key , value , TimeUtil . parseDuration ( expiration ) ) ; 
public < T > T get ( String key , Class < T > clazz ) { 
return ( T ) cache . get ( key ) ; 
} void checkSerializable ( Object value ) { 
if ( value != null && ! ( value instanceof Serializable ) ) { 
throw new CacheException ( 
+ value . getClass ( ) . getName ( ) , 
new NotSerializableException ( value . getClass ( ) . getName ( ) ) ) ; 
} public Result render ( Object object ) { 
if ( this . renderable == null ) { 
this . renderable = object ; 
assertObjectNoRenderableOrThrowException ( this . renderable ) ; 
Map < String , Object > map ; 
if ( this . renderable instanceof Map ) { 
map = ( Map ) this . renderable ; 
map = Maps . newHashMap ( ) ; 
map . put ( SwissKnife . getRealClassNameLowerCamelCase ( this . renderable ) , this . renderable ) ; 
this . renderable = map ; 
String key = SwissKnife . getRealClassNameLowerCamelCase ( object ) ; 
key ) ) ; 
map . put ( SwissKnife . getRealClassNameLowerCamelCase ( object ) , object ) ; 
} public Result render ( Entry < String , Object > entry ) { 
Map < String , Object > map = Maps . newHashMap ( ) ; 
map . put ( entry . getKey ( ) , entry . getValue ( ) ) ; 
if ( map . containsKey ( entry . getKey ( ) ) ) { 
entry . getKey ( ) ) ) ; 
map . put ( 
SwissKnife . getRealClassNameLowerCamelCase ( this . renderable ) , 
this . renderable ) ; 
} public Result render ( String key , Object value ) { 
render ( new AbstractMap . SimpleEntry < String , Object > ( key , value ) ) ; 
public Result renderRaw ( final String string ) { 
Renderable renderable = new Renderable ( ) { 
if ( result . getContentType ( ) == null ) { 
result . contentType ( Result . TEXT_PLAIN ) ; 
ResponseStreams resultJsonCustom = context 
. finalizeHeaders ( result ) ; 
try ( Writer writer = resultJsonCustom . getWriter ( ) ) { 
writer . write ( string ) ; 
} catch ( IOException ioException ) { 
ioException ) ; 
render ( renderable ) ; 
} public Result renderRaw ( final byte [ ] bytes ) { 
result . contentType ( Result . APPLICATION_OCTET_STREAM ) ; 
ResponseStreams responseStreams = context 
try ( OutputStream outputStream = responseStreams . getOutputStream ( ) ) { 
throw new InternalServerErrorException ( ioException ) ; 
} public Cookie getCookie ( String cookieName ) { 
for ( Cookie cookie : getCookies ( ) ) { 
if ( cookie . getName ( ) . equals ( cookieName ) ) { 
} public Result redirect ( String url ) { 
status ( Result . SC_303_SEE_OTHER ) ; 
addHeader ( Result . LOCATION , url ) ; 
} public Result redirectTemporary ( String url ) { 
status ( Result . SC_307_TEMPORARY_REDIRECT ) ; 
} public Result doNotCacheContent ( ) { 
addHeader ( CACHE_CONTROL , CACHE_CONTROL_DEFAULT_NOCACHE_VALUE ) ; 
addHeader ( DATE , DateUtil . formatForHttpHeader ( System . currentTimeMillis ( ) ) ) ; 
addHeader ( EXPIRES , DateUtil . formatForHttpHeader ( 0L ) ) ; 
} public static void checkThatApplicationSecretIsSet ( 
boolean isProd , 
String baseDirWithoutTrailingSlash , 
PropertiesConfiguration defaultConfiguration , 
Configuration compositeConfiguration ) { 
String applicationSecret = compositeConfiguration . getString ( NinjaConstant . applicationSecret ) ; 
if ( applicationSecret == null 
|| applicationSecret . isEmpty ( ) ) { 
if ( isProd ) { 
logger . error ( errorMessage ) ; 
String secret = SecretGenerator . generateSecret ( ) ; 
compositeConfiguration . setProperty ( NinjaConstant . applicationSecret , secret ) ; 
defaultConfiguration . setProperty ( NinjaConstant . applicationSecret , secret ) ; 
String pathToApplicationConfInSrcDir = baseDirWithoutTrailingSlash + File . separator + "src" + File . separator + "main" + File . separator + "java" + File . separator + NinjaProperties . CONF_FILE_LOCATION_BY_CONVENTION ; 
Files . createParentDirs ( new File ( pathToApplicationConfInSrcDir ) ) ; 
defaultConfiguration . save ( pathToApplicationConfInSrcDir ) ; 
defaultConfiguration . save ( ) ; 
} public String normalizePathWithoutLeadingSlash ( String fileName , boolean enforceUnixSeparator ) { 
String fileNameNormalized = enforceUnixSeparator 
? FilenameUtils . normalize ( fileName , true ) 
: FilenameUtils . normalize ( fileName ) ; 
return StringUtils . removeStart ( fileNameNormalized , "/" ) ; 
} public boolean isDirectoryURL ( URL url ) { 
return url . getProtocol ( ) . equals ( "file" ) && new File ( url . toURI ( ) ) . isDirectory ( ) ; 
} private void step1 ( ) 
if ( b [ k ] == 's' ) 
if ( ends ( "sses" ) ) k -= 2 ; 
else if ( ends ( "ies" ) ) setto ( "i" ) ; 
else if ( b [ k - 1 ] != 's' ) k -- ; 
if ( ends ( "eed" ) ) 
if ( m ( ) > 0 ) k -- ; 
else if ( ( ends ( "ed" ) || ends ( "ing" ) ) && vowelinstem ( ) ) 
k = j ; 
if ( ends ( "at" ) ) setto ( "ate" ) ; 
else if ( ends ( "bl" ) ) setto ( "ble" ) ; 
else if ( ends ( "iz" ) ) setto ( "ize" ) ; 
else if ( doublec ( k ) ) 
int ch = b [ k -- ] ; 
if ( ch == 'l' || ch == 's' || ch == 'z' ) k ++ ; 
else if ( m ( ) == 1 && cvc ( k ) ) setto ( "e" ) ; 
} private void step3 ( ) 
if ( k == k0 ) return ; 
switch ( b [ k - 1 ] ) 
if ( ends ( "ational" ) ) 
r ( "ate" ) ; 
if ( ends ( "tional" ) ) 
r ( "tion" ) ; 
if ( ends ( "enci" ) ) 
r ( "ence" ) ; 
if ( ends ( "anci" ) ) 
r ( "ance" ) ; 
if ( ends ( "izer" ) ) 
r ( "ize" ) ; 
if ( ends ( "bli" ) ) 
r ( "ble" ) ; 
if ( ends ( "alli" ) ) 
r ( "al" ) ; 
if ( ends ( "entli" ) ) 
r ( "ent" ) ; 
if ( ends ( "eli" ) ) 
r ( "e" ) ; 
if ( ends ( "ousli" ) ) 
r ( "ous" ) ; 
if ( ends ( "ization" ) ) 
if ( ends ( "ation" ) ) 
if ( ends ( "ator" ) ) 
if ( ends ( "alism" ) ) 
if ( ends ( "iveness" ) ) 
r ( "ive" ) ; 
if ( ends ( "fulness" ) ) 
r ( "ful" ) ; 
if ( ends ( "ousness" ) ) 
if ( ends ( "aliti" ) ) 
if ( ends ( "iviti" ) ) 
if ( ends ( "biliti" ) ) 
if ( ends ( "logi" ) ) 
r ( "log" ) ; 
} private void step5 ( ) 
if ( ends ( "al" ) ) break ; 
if ( ends ( "ance" ) ) break ; 
if ( ends ( "ence" ) ) break ; 
if ( ends ( "er" ) ) break ; 
if ( ends ( "ic" ) ) break ; 
if ( ends ( "able" ) ) break ; 
if ( ends ( "ible" ) ) break ; 
if ( ends ( "ant" ) ) break ; 
if ( ends ( "ement" ) ) break ; 
if ( ends ( "ment" ) ) break ; 
if ( ends ( "ent" ) ) break ; 
if ( ends ( "ion" ) && j >= 0 && ( b [ j ] == 's' || b [ j ] == 't' ) ) break ; 
if ( ends ( "ou" ) ) break ; 
if ( ends ( "ism" ) ) break ; 
if ( ends ( "ate" ) ) break ; 
if ( ends ( "iti" ) ) break ; 
if ( ends ( "ous" ) ) break ; 
case 'v' : 
if ( ends ( "ive" ) ) break ; 
case 'z' : 
if ( ends ( "ize" ) ) break ; 
if ( m ( ) > 1 ) k = j ; 
protected TokenStreamComponents createComponents ( String fieldName ) 
Tokenizer tokenizer = new HanLPTokenizer ( HanLP . newSegment ( ) . enableOffset ( true ) , filter , enablePorterStemming ) ; 
return new TokenStreamComponents ( tokenizer ) ; 
} private int [ ] fetchDatabaseNameRangeIndexFromURLForH2FileMode ( String url ) { 
int fileLabelIndex = url . indexOf ( FILE_MODE_FLAG ) ; 
int parameterLabelIndex = url . indexOf ( ";" , fileLabelIndex ) ; 
if ( parameterLabelIndex == - 1 ) { 
parameterLabelIndex = url . length ( ) ; 
if ( fileLabelIndex != - 1 ) { 
return new int [ ] { fileLabelIndex + FILE_MODE_FLAG . length ( ) + 1 , parameterLabelIndex } ; 
} private int [ ] fetchDatabaseNameRangeIndexFromURLForH2MemMode ( String url ) { 
int fileLabelIndex = url . indexOf ( MEMORY_MODE_FLAG ) ; 
return new int [ ] { fileLabelIndex + MEMORY_MODE_FLAG . length ( ) + 1 , parameterLabelIndex } ; 
} public static ConnectionInfo parser ( String url ) { 
if ( null == url ) { 
return ConnectionInfo . UNKNOWN_CONNECTION_INFO ; 
String lowerCaseUrl = url . toLowerCase ( ) ; 
ConnectionURLParser parser = findURLParser ( lowerCaseUrl ) ; 
return parser . parse ( url ) ; 
} public static void registerConnectionParser ( String urlPrefix , ConnectionURLParser parser ) { 
if ( null == urlPrefix || parser == null ) { 
parserRegister . put ( urlPrefix . toLowerCase ( ) , parser ) ; 
} protected String fetchDatabaseHostsFromURL ( String url ) { 
URLLocation hostsLocation = fetchDatabaseHostsIndexRange ( url ) ; 
return url . substring ( hostsLocation . startIndex ( ) , hostsLocation . endIndex ( ) ) ; 
} protected String fetchDatabaseNameFromURL ( String url ) { 
URLLocation hostsLocation = fetchDatabaseNameIndexRange ( url ) ; 
} private static void start ( Context context , Class < ? > daemonClazzName , int interval ) { 
String cmd = context . getDir ( BIN_DIR_NAME , Context . MODE_PRIVATE ) 
. getAbsolutePath ( ) + File . separator + DAEMON_BIN_NAME ; 
StringBuilder cmdBuilder = new StringBuilder ( ) ; 
cmdBuilder . append ( cmd ) ; 
cmdBuilder . append ( context . getPackageName ( ) ) ; 
cmdBuilder . append ( daemonClazzName . getName ( ) ) ; 
cmdBuilder . append ( interval ) ; 
Runtime . getRuntime ( ) . exec ( cmdBuilder . toString ( ) ) . waitFor ( ) ; 
} catch ( IOException | InterruptedException e ) { 
} public static void run ( final Context context , final Class < ? > daemonServiceClazz , 
final int interval ) { 
new Thread ( new Runnable ( ) { 
Command . install ( context , BIN_DIR_NAME , DAEMON_BIN_NAME ) ; 
start ( context , daemonServiceClazz , interval ) ; 
} ) . start ( ) ; 
} private static void copyFile ( File file , InputStream is , String mode ) 
throws IOException , InterruptedException { 
final String abspath = file . getAbsolutePath ( ) ; 
final FileOutputStream out = new FileOutputStream ( file ) ; 
byte buf [ ] = new byte [ 1024 ] ; 
while ( ( len = is . read ( buf ) ) > 0 ) { 
out . write ( buf , 0 , len ) ; 
} public static void copyAssets ( Context context , String assetsFilename , File file , String mode ) 
AssetManager manager = context . getAssets ( ) ; 
final InputStream is = manager . open ( assetsFilename ) ; 
copyFile ( file , is , mode ) ; 
public static boolean install ( Context context , String destDir , String filename ) { 
String binaryDir = "armeabi" ; 
String abi = Build . CPU_ABI ; 
if ( abi . startsWith ( "armeabi-v7a" ) ) { 
binaryDir = "armeabi-v7a" ; 
} else if ( abi . startsWith ( "x86" ) ) { 
binaryDir = "x86" ; 
String assetfilename = binaryDir + File . separator + filename ; 
File f = new File ( context . getDir ( destDir , Context . MODE_PRIVATE ) , filename ) ; 
copyAssets ( context , assetfilename , f , "0755" ) ; 
} public static long parseDuration ( String duration ) { 
if ( duration == null || duration . isEmpty ( ) ) { 
long toAdd = - 1 ; 
if ( days . matcher ( duration ) . matches ( ) ) { 
Matcher matcher = days . matcher ( duration ) ; 
matcher . matches ( ) ; 
toAdd = Long . parseLong ( matcher . group ( 1 ) ) * 60 * 60 * 24 * 1000 ; 
} else if ( hours . matcher ( duration ) . matches ( ) ) { 
Matcher matcher = hours . matcher ( duration ) ; 
toAdd = Long . parseLong ( matcher . group ( 1 ) ) * 60 * 60 * 1000 ; 
} else if ( minutes . matcher ( duration ) . matches ( ) ) { 
Matcher matcher = minutes . matcher ( duration ) ; 
toAdd = Long . parseLong ( matcher . group ( 1 ) ) * 60 * 1000 ; 
} else if ( seconds . matcher ( duration ) . matches ( ) ) { 
Matcher matcher = seconds . matcher ( duration ) ; 
toAdd = Long . parseLong ( matcher . group ( 1 ) ) * 1000 ; 
} else if ( milliseconds . matcher ( duration ) . matches ( ) ) { 
Matcher matcher = milliseconds . matcher ( duration ) ; 
toAdd = Long . parseLong ( matcher . group ( 1 ) ) ; 
if ( toAdd == - 1 ) { 
} protected CronScheduleBuilder createCronScheduleBuilder ( String cronExpr ) { 
int i = cronExpr . indexOf ( "[" ) ; 
int j = cronExpr . indexOf ( "]" ) ; 
TimeZone timezone = defaultTimezone ; 
if ( i > - 1 && j > - 1 ) { 
timezone = TimeZone . getTimeZone ( cronExpr . substring ( i + 1 , j ) ) ; 
cronExpr = cronExpr . substring ( 0 , i ) . trim ( ) ; 
return CronScheduleBuilder . cronSchedule ( cronExpr ) . inTimeZone ( timezone ) ; 
} public static boolean isBeginGroupKey ( RenderingHints . Key key ) { 
return SVGHints . KEY_BEGIN_GROUP . equals ( key ) 
|| beginGroupKeys . contains ( key ) ; 
} public static boolean isEndGroupKey ( RenderingHints . Key key ) { 
return SVGHints . KEY_END_GROUP . equals ( key ) || endGroupKeys . contains ( key ) ; 
} public static boolean isElementTitleKey ( RenderingHints . Key key ) { 
return SVGHints . KEY_ELEMENT_TITLE . equals ( key ) 
|| elementTitleKeys . contains ( key ) ; 
} public static String escapeForXML ( String source ) { 
Args . nullNotPermitted ( source , "source" ) ; 
for ( int i = 0 ; i < source . length ( ) ; i ++ ) { 
char c = source . charAt ( i ) ; 
case '<' : { 
sb . append ( "&lt;" ) ; 
case '>' : { 
sb . append ( "&gt;" ) ; 
case '&' : { 
String next = source . substring ( i , Math . min ( i + 6 , 
source . length ( ) ) ) ; 
if ( next . startsWith ( "&lt;" ) || next . startsWith ( "&gt;" ) 
|| next . startsWith ( "&amp;" ) 
|| next . startsWith ( "&apos;" ) 
|| next . startsWith ( "&quot;" ) ) { 
sb . append ( "&amp;" ) ; 
case '\'' : { 
sb . append ( "&apos;" ) ; 
case '\"' : { 
sb . append ( "&quot;" ) ; 
default : sb . append ( c ) ; 
} public static void writeToSVG ( File file , String svgElement ) 
writeToSVG ( file , svgElement , false ) ; 
} public static void writeToSVG ( File file , String svgElement , boolean zip ) 
BufferedWriter writer = null ; 
OutputStream os = new FileOutputStream ( file ) ; 
if ( zip ) { 
os = new GZIPOutputStream ( os ) ; 
OutputStreamWriter osw = new OutputStreamWriter ( os , "UTF-8" ) ; 
writer = new BufferedWriter ( osw ) ; 
writer . write ( svgElement + "\n" ) ; 
} public static void writeToHTML ( File file , String title , String svgElement ) 
FileOutputStream fos = new FileOutputStream ( file ) ; 
OutputStreamWriter osw = new OutputStreamWriter ( fos , "UTF-8" ) ; 
writer . write ( "<html>\n" ) ; 
writer . write ( "<head>\n" ) ; 
writer . write ( "<title>" + title + "</title>\n" ) ; 
writer . write ( "</head>\n" ) ; 
writer . write ( "<body>\n" ) ; 
writer . write ( "</body>\n" ) ; 
writer . write ( "</html>\n" ) ; 
Logger . getLogger ( SVGUtils . class . getName ( ) ) . log ( Level . SEVERE , 
null , ex ) ; 
} public static Shape copyOf ( Shape shape ) { 
Args . nullNotPermitted ( shape , "shape" ) ; 
if ( shape instanceof Line2D ) { 
Line2D l = ( Line2D ) shape ; 
return new Line2D . Double ( l . getX1 ( ) , l . getY1 ( ) , l . getX2 ( ) , l . getY2 ( ) ) ; 
if ( shape instanceof Rectangle2D ) { 
Rectangle2D r = ( Rectangle2D ) shape ; 
return new Rectangle2D . Double ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , 
r . getHeight ( ) ) ; 
if ( shape instanceof RoundRectangle2D ) { 
RoundRectangle2D rr = ( RoundRectangle2D ) shape ; 
return new RoundRectangle2D . Double ( rr . getX ( ) , rr . getY ( ) , 
rr . getWidth ( ) , rr . getHeight ( ) , rr . getArcWidth ( ) , 
rr . getArcHeight ( ) ) ; 
if ( shape instanceof Arc2D ) { 
Arc2D arc = ( Arc2D ) shape ; 
return new Arc2D . Double ( arc . getX ( ) , arc . getY ( ) , arc . getWidth ( ) , 
arc . getHeight ( ) , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , 
arc . getArcType ( ) ) ; 
if ( shape instanceof Ellipse2D ) { 
Ellipse2D ell = ( Ellipse2D ) shape ; 
return new Ellipse2D . Double ( ell . getX ( ) , ell . getY ( ) , ell . getWidth ( ) , 
ell . getHeight ( ) ) ; 
if ( shape instanceof Polygon ) { 
Polygon p = ( Polygon ) shape ; 
return new Polygon ( p . xpoints , p . ypoints , p . npoints ) ; 
return new Path2D . Double ( shape ) ; 
} public static GeneralPath createPolygon ( int [ ] xPoints , int [ ] yPoints , 
int nPoints , boolean close ) { 
GeneralPath p = new GeneralPath ( ) ; 
p . moveTo ( xPoints [ 0 ] , yPoints [ 0 ] ) ; 
for ( int i = 1 ; i < nPoints ; i ++ ) { 
p . lineTo ( xPoints [ i ] , yPoints [ i ] ) ; 
if ( close ) { 
p . closePath ( ) ; 
public ColorModel getColorModel ( int transparency ) { 
if ( transparency == Transparency . TRANSLUCENT ) { 
return ColorModel . getRGBdefault ( ) ; 
} else if ( transparency == Transparency . OPAQUE ) { 
return new DirectColorModel ( 32 , 0x00ff0000 , 0x0000ff00 , 0x000000ff ) ; 
public BufferedImage createCompatibleImage ( int width , int height ) { 
ColorModel model = getColorModel ( ) ; 
WritableRaster raster = model . createCompatibleWritableRaster ( width , 
height ) ; 
return new BufferedImage ( model , raster , model . isAlphaPremultiplied ( ) , 
public VolatileImage createCompatibleVolatileImage ( int width , int height , 
ImageCapabilities caps , int transparency ) throws AWTException { 
if ( img == null ) { 
img = new BufferedImage ( 1 , 1 , BufferedImage . TYPE_INT_ARGB ) ; 
gc = img . createGraphics ( ) . getDeviceConfiguration ( ) ; 
return gc . createCompatibleVolatileImage ( width , height , caps , 
transparency ) ; 
} public static void arrayMustHaveLength ( int length , boolean [ ] array , 
String ref ) { 
nullNotPermitted ( array , "array" ) ; 
if ( array . length != length ) { 
} public String valueStr ( ) { 
. append ( this . height ) . toString ( ) ; 
} public String get ( String family ) { 
Args . nullNotPermitted ( family , "family" ) ; 
return this . alternates . get ( family ) ; 
} public void put ( String family , String alternate ) { 
this . alternates . put ( family , alternate ) ; 
public String mapFont ( String family ) { 
String alternate = this . alternates . get ( family ) ; 
return alternate ; 
return family ; 
} public void setShapeRendering ( String value ) { 
if ( ! value . equals ( "auto" ) && ! value . equals ( "crispEdges" ) 
&& ! value . equals ( "geometricPrecision" ) 
&& ! value . equals ( "optimizeSpeed" ) ) { 
this . shapeRendering = value ; 
} public void setTextRendering ( String value ) { 
if ( ! value . equals ( "auto" ) && ! value . equals ( "optimizeSpeed" ) 
&& ! value . equals ( "optimizeLegibility" ) 
&& ! value . equals ( "geometricPrecision" ) ) { 
this . textRendering = value ; 
} public void setTransformDP ( int dp ) { 
this . transformDP = dp ; 
if ( dp < 1 || dp > 10 ) { 
this . transformFormat = null ; 
DecimalFormatSymbols dfs = new DecimalFormatSymbols ( ) ; 
dfs . setDecimalSeparator ( '.' ) ; 
this . transformFormat = new DecimalFormat ( "0." 
+ "##########" . substring ( 0 , dp ) , dfs ) ; 
} public void setGeometryDP ( int dp ) { 
this . geometryDP = dp ; 
this . geometryFormat = null ; 
this . geometryFormat = new DecimalFormat ( "0." 
public GraphicsConfiguration getDeviceConfiguration ( ) { 
if ( this . deviceConfiguration == null ) { 
this . deviceConfiguration = new SVGGraphicsConfiguration ( this . width , 
this . height ) ; 
return this . deviceConfiguration ; 
public Graphics create ( ) { 
SVGGraphics2D copy = new SVGGraphics2D ( this ) ; 
copy . setRenderingHints ( getRenderingHints ( ) ) ; 
copy . setTransform ( getTransform ( ) ) ; 
copy . setClip ( getClip ( ) ) ; 
copy . setPaint ( getPaint ( ) ) ; 
copy . setColor ( getColor ( ) ) ; 
copy . setComposite ( getComposite ( ) ) ; 
copy . setStroke ( getStroke ( ) ) ; 
copy . setFont ( getFont ( ) ) ; 
copy . setBackground ( getBackground ( ) ) ; 
copy . setFilePrefix ( getFilePrefix ( ) ) ; 
copy . setFileSuffix ( getFileSuffix ( ) ) ; 
public void setPaint ( Paint paint ) { 
if ( paint == null ) { 
this . paint = paint ; 
this . gradientPaintRef = null ; 
if ( paint instanceof Color ) { 
setColor ( ( Color ) paint ) ; 
} else if ( paint instanceof GradientPaint ) { 
GradientPaint gp = ( GradientPaint ) paint ; 
GradientPaintKey key = new GradientPaintKey ( gp ) ; 
String ref = this . gradientPaints . get ( key ) ; 
int count = this . gradientPaints . keySet ( ) . size ( ) ; 
String id = this . defsKeyPrefix + "gp" + count ; 
this . elementIDs . add ( id ) ; 
this . gradientPaints . put ( key , id ) ; 
this . gradientPaintRef = id ; 
this . gradientPaintRef = ref ; 
} else if ( paint instanceof LinearGradientPaint ) { 
LinearGradientPaint lgp = ( LinearGradientPaint ) paint ; 
LinearGradientPaintKey key = new LinearGradientPaintKey ( lgp ) ; 
String ref = this . linearGradientPaints . get ( key ) ; 
int count = this . linearGradientPaints . keySet ( ) . size ( ) ; 
String id = this . defsKeyPrefix + "lgp" + count ; 
this . linearGradientPaints . put ( key , id ) ; 
} else if ( paint instanceof RadialGradientPaint ) { 
RadialGradientPaint rgp = ( RadialGradientPaint ) paint ; 
RadialGradientPaintKey key = new RadialGradientPaintKey ( rgp ) ; 
String ref = this . radialGradientPaints . get ( key ) ; 
int count = this . radialGradientPaints . keySet ( ) . size ( ) ; 
String id = this . defsKeyPrefix + "rgp" + count ; 
this . radialGradientPaints . put ( key , id ) ; 
this . color = c ; 
this . paint = c ; 
public void setRenderingHint ( RenderingHints . Key hintKey , Object hintValue ) { 
if ( hintKey == null ) { 
if ( SVGHints . isBeginGroupKey ( hintKey ) ) { 
String groupId = null ; 
List < Entry > otherKeysAndValues = null ; 
if ( hintValue instanceof String ) { 
groupId = ( String ) hintValue ; 
} else if ( hintValue instanceof Map ) { 
Map hintValueMap = ( Map ) hintValue ; 
groupId = ( String ) hintValueMap . get ( "id" ) ; 
ref = ( String ) hintValueMap . get ( "ref" ) ; 
for ( final Object obj : hintValueMap . entrySet ( ) ) { 
final Entry e = ( Entry ) obj ; 
final Object key = e . getKey ( ) ; 
if ( "id" . equals ( key ) || "ref" . equals ( key ) ) { 
if ( otherKeysAndValues == null ) { 
otherKeysAndValues = new ArrayList < Entry > ( ) ; 
otherKeysAndValues . add ( e ) ; 
this . sb . append ( "<g" ) ; 
if ( groupId != null ) { 
if ( this . elementIDs . contains ( groupId ) ) { 
this . elementIDs . add ( groupId ) ; 
this . sb . append ( SVGUtils . escapeForXML ( ref ) ) . append ( "\"" ) ; 
if ( otherKeysAndValues != null ) { 
for ( final Entry e : otherKeysAndValues ) { 
this . sb . append ( SVGUtils . escapeForXML ( String . valueOf ( 
e . getValue ( ) ) ) ) . append ( "\"" ) ; 
this . sb . append ( ">" ) ; 
} else if ( SVGHints . isEndGroupKey ( hintKey ) ) { 
this . sb . append ( "</g>\n" ) ; 
} else if ( SVGHints . isElementTitleKey ( hintKey ) && ( hintValue != null ) ) { 
this . sb . append ( "<title>" ) ; 
this . sb . append ( SVGUtils . escapeForXML ( String . valueOf ( hintValue ) ) ) ; 
this . sb . append ( "</title>" ) ; 
this . hints . put ( hintKey , hintValue ) ; 
} private void appendOptionalElementIDFromHint ( StringBuilder sb ) { 
String elementID = ( String ) this . hints . get ( SVGHints . KEY_ELEMENT_ID ) ; 
if ( elementID != null ) { 
this . hints . put ( SVGHints . KEY_ELEMENT_ID , null ) ; 
if ( this . elementIDs . contains ( elementID ) ) { 
this . elementIDs . add ( elementID ) ; 
public void draw ( Shape s ) { 
if ( ! ( this . stroke instanceof BasicStroke ) ) { 
fill ( this . stroke . createStrokedShape ( s ) ) ; 
if ( s instanceof Line2D ) { 
Line2D l = ( Line2D ) s ; 
appendOptionalElementIDFromHint ( this . sb ) ; 
this . sb . append ( "x1=\"" ) . append ( geomDP ( l . getX1 ( ) ) ) 
if ( ! this . transform . isIdentity ( ) ) { 
this . sb . append ( "transform=\"" ) . append ( getSVGTransform ( 
this . sb . append ( getClipPathRef ( ) ) ; 
this . sb . append ( "/>" ) ; 
} else if ( s instanceof Rectangle2D ) { 
Rectangle2D r = ( Rectangle2D ) s ; 
this . sb . append ( "x=\"" ) . append ( geomDP ( r . getX ( ) ) ) 
this . sb . append ( "style=\"" ) . append ( strokeStyle ( ) ) 
} else if ( s instanceof Ellipse2D ) { 
Ellipse2D e = ( Ellipse2D ) s ; 
this . sb . append ( "cx=\"" ) . append ( geomDP ( e . getCenterX ( ) ) ) 
} else if ( s instanceof Path2D ) { 
Path2D path = ( Path2D ) s ; 
this . sb . append ( "</g>" ) ; 
draw ( new GeneralPath ( s ) ) ; 
public void fill ( Shape s ) { 
if ( s instanceof Rectangle2D ) { 
if ( r . isEmpty ( ) ) { 
this . sb . append ( "style=\"" ) . append ( getSVGFillStyle ( ) ) ; 
fill ( new GeneralPath ( s ) ) ; 
} private String getSVGPathData ( Path2D path ) { 
StringBuilder b = new StringBuilder ( "d=\"" ) ; 
PathIterator iterator = path . getPathIterator ( null ) ; 
while ( ! iterator . isDone ( ) ) { 
int type = iterator . currentSegment ( coords ) ; 
if ( ! first ) { 
case ( PathIterator . SEG_MOVETO ) : 
. append ( geomDP ( coords [ 1 ] ) ) ; 
case ( PathIterator . SEG_LINETO ) : 
case ( PathIterator . SEG_QUADTO ) : 
case ( PathIterator . SEG_CUBICTO ) : 
. append ( geomDP ( coords [ 5 ] ) ) ; 
case ( PathIterator . SEG_CLOSE ) : 
iterator . next ( ) ; 
return b . append ( "\"" ) . toString ( ) ; 
} private float getAlpha ( ) { 
float alpha = 1.0f ; 
if ( this . composite instanceof AlphaComposite ) { 
AlphaComposite ac = ( AlphaComposite ) this . composite ; 
alpha = ac . getAlpha ( ) ; 
return alpha ; 
} private String svgColorStr ( ) { 
String result = "black;" ; 
if ( this . paint instanceof Color ) { 
return rgbColorStr ( ( Color ) this . paint ) ; 
} else if ( this . paint instanceof GradientPaint 
|| this . paint instanceof LinearGradientPaint 
|| this . paint instanceof RadialGradientPaint ) { 
return "url(#" + this . gradientPaintRef + ")" ; 
} private String rgbColorStr ( Color c ) { 
StringBuilder b = new StringBuilder ( "rgb(" ) ; 
b . append ( c . getRed ( ) ) . append ( "," ) . append ( c . getGreen ( ) ) . append ( "," ) 
. append ( c . getBlue ( ) ) . append ( ")" ) ; 
} private String rgbaColorStr ( Color c ) { 
StringBuilder b = new StringBuilder ( "rgba(" ) ; 
double alphaPercent = c . getAlpha ( ) / 255.0 ; 
. append ( c . getBlue ( ) ) ; 
b . append ( "," ) . append ( transformDP ( alphaPercent ) ) ; 
b . append ( ")" ) ; 
} private String strokeStyle ( ) { 
double strokeWidth = 1.0f ; 
String strokeCap = DEFAULT_STROKE_CAP ; 
String strokeJoin = DEFAULT_STROKE_JOIN ; 
float miterLimit = DEFAULT_MITER_LIMIT ; 
float [ ] dashArray = new float [ 0 ] ; 
if ( this . stroke instanceof BasicStroke ) { 
BasicStroke bs = ( BasicStroke ) this . stroke ; 
strokeWidth = bs . getLineWidth ( ) > 0.0 ? bs . getLineWidth ( ) 
: this . zeroStrokeWidth ; 
switch ( bs . getEndCap ( ) ) { 
case BasicStroke . CAP_ROUND : 
strokeCap = "round" ; 
case BasicStroke . CAP_SQUARE : 
strokeCap = "square" ; 
case BasicStroke . CAP_BUTT : 
switch ( bs . getLineJoin ( ) ) { 
case BasicStroke . JOIN_BEVEL : 
strokeJoin = "bevel" ; 
case BasicStroke . JOIN_ROUND : 
strokeJoin = "round" ; 
case BasicStroke . JOIN_MITER : 
miterLimit = bs . getMiterLimit ( ) ; 
dashArray = bs . getDashArray ( ) ; 
. append ( ";" ) ; 
if ( ! strokeCap . equals ( DEFAULT_STROKE_CAP ) ) { 
if ( ! strokeJoin . equals ( DEFAULT_STROKE_JOIN ) ) { 
if ( Math . abs ( DEFAULT_MITER_LIMIT - miterLimit ) < 0.001 ) { 
if ( dashArray != null && dashArray . length != 0 ) { 
for ( int i = 0 ; i < dashArray . length ; i ++ ) { 
b . append ( dashArray [ i ] ) ; 
b . append ( ";" ) ; 
if ( this . checkStrokeControlHint ) { 
Object hint = getRenderingHint ( RenderingHints . KEY_STROKE_CONTROL ) ; 
if ( RenderingHints . VALUE_STROKE_NORMALIZE . equals ( hint ) 
&& ! this . shapeRendering . equals ( "crispEdges" ) ) { 
b . append ( "shape-rendering:crispEdges;" ) ; 
if ( RenderingHints . VALUE_STROKE_PURE . equals ( hint ) 
&& ! this . shapeRendering . equals ( "geometricPrecision" ) ) { 
b . append ( "shape-rendering:geometricPrecision;" ) ; 
} private String getSVGFillStyle ( ) { 
} private String getSVGFontStyle ( ) { 
String fontFamily = this . fontMapper . mapFont ( this . font . getFamily ( ) ) ; 
if ( this . font . isBold ( ) ) { 
if ( this . font . isItalic ( ) ) { 
public FontMetrics getFontMetrics ( Font f ) { 
if ( this . fmImage == null ) { 
this . fmImage = new BufferedImage ( 10 , 10 , 
BufferedImage . TYPE_INT_RGB ) ; 
this . fmImageG2D = this . fmImage . createGraphics ( ) ; 
this . fmImageG2D . setRenderingHint ( 
RenderingHints . KEY_FRACTIONALMETRICS , 
RenderingHints . VALUE_FRACTIONALMETRICS_ON ) ; 
return this . fmImageG2D . getFontMetrics ( f ) ; 
public void drawString ( String str , float x , float y ) { 
if ( str . isEmpty ( ) ) { 
if ( ! SVGHints . VALUE_DRAW_STRING_TYPE_VECTOR . equals ( 
this . hints . get ( SVGHints . KEY_DRAW_STRING_TYPE ) ) ) { 
this . transform ) ) . append ( "\"" ) ; 
. append ( "\"" ) ; 
Object hintValue = getRenderingHint ( SVGHints . KEY_TEXT_RENDERING ) ; 
if ( hintValue != null ) { 
String textRenderValue = hintValue . toString ( ) ; 
this . sb . append ( SVGUtils . escapeForXML ( str ) ) . append ( "</text>" ) ; 
AttributedString as = new AttributedString ( str , 
this . font . getAttributes ( ) ) ; 
drawString ( as . getIterator ( ) , x , y ) ; 
public void drawString ( AttributedCharacterIterator iterator , int x , int y ) { 
drawString ( iterator , ( float ) x , ( float ) y ) ; 
public void drawString ( AttributedCharacterIterator iterator , float x , 
float y ) { 
Set < Attribute > s = iterator . getAllAttributeKeys ( ) ; 
if ( ! s . isEmpty ( ) ) { 
TextLayout layout = new TextLayout ( iterator , 
getFontRenderContext ( ) ) ; 
layout . draw ( this , x , y ) ; 
StringBuilder strb = new StringBuilder ( ) ; 
iterator . first ( ) ; 
for ( int i = iterator . getBeginIndex ( ) ; i < iterator . getEndIndex ( ) ; 
i ++ ) { 
strb . append ( iterator . current ( ) ) ; 
drawString ( strb . toString ( ) , x , y ) ; 
public void drawGlyphVector ( GlyphVector g , float x , float y ) { 
fill ( g . getOutline ( x , y ) ) ; 
public void translate ( double tx , double ty ) { 
AffineTransform t = getTransform ( ) ; 
t . translate ( tx , ty ) ; 
setTransform ( t ) ; 
public void rotate ( double theta ) { 
t . rotate ( theta ) ; 
public void rotate ( double theta , double x , double y ) { 
translate ( x , y ) ; 
rotate ( theta ) ; 
translate ( - x , - y ) ; 
public void scale ( double sx , double sy ) { 
t . scale ( sx , sy ) ; 
public void transform ( AffineTransform t ) { 
AffineTransform tx = getTransform ( ) ; 
tx . concatenate ( t ) ; 
setTransform ( tx ) ; 
public void setTransform ( AffineTransform t ) { 
this . transform = new AffineTransform ( ) ; 
this . transform = new AffineTransform ( t ) ; 
this . clipRef = null ; 
public boolean hit ( Rectangle rect , Shape s , boolean onStroke ) { 
Shape ts ; 
if ( onStroke ) { 
ts = this . transform . createTransformedShape ( 
this . stroke . createStrokedShape ( s ) ) ; 
ts = this . transform . createTransformedShape ( s ) ; 
if ( ! rect . getBounds2D ( ) . intersects ( ts . getBounds2D ( ) ) ) { 
Area a1 = new Area ( rect ) ; 
Area a2 = new Area ( ts ) ; 
a1 . intersect ( a2 ) ; 
return ! a1 . isEmpty ( ) ; 
public Shape getClip ( ) { 
if ( this . clip == null ) { 
AffineTransform inv ; 
inv = this . transform . createInverse ( ) ; 
return inv . createTransformedShape ( this . clip ) ; 
} catch ( NoninvertibleTransformException ex ) { 
public void setClip ( Shape shape ) { 
this . clip = this . transform . createTransformedShape ( shape ) ; 
} private String registerClip ( Shape clip ) { 
if ( clip == null ) { 
String pathStr = getSVGPathData ( new Path2D . Double ( clip ) ) ; 
int index = this . clipPaths . indexOf ( pathStr ) ; 
this . clipPaths . add ( pathStr ) ; 
index = this . clipPaths . size ( ) - 1 ; 
return this . defsKeyPrefix + CLIP_KEY_PREFIX + index ; 
public void clip ( Shape s ) { 
s = s . getBounds2D ( ) ; 
setClip ( s ) ; 
Shape ts = this . transform . createTransformedShape ( s ) ; 
if ( ! ts . intersects ( this . clip . getBounds2D ( ) ) ) { 
setClip ( new Rectangle2D . Double ( ) ) ; 
Area a1 = new Area ( ts ) ; 
Area a2 = new Area ( this . clip ) ; 
this . clip = new Path2D . Double ( a1 ) ; 
public void clipRect ( int x , int y , int width , int height ) { 
setRect ( x , y , width , height ) ; 
clip ( this . rect ) ; 
public void setClip ( int x , int y , int width , int height ) { 
setClip ( this . rect ) ; 
public void drawLine ( int x1 , int y1 , int x2 , int y2 ) { 
if ( this . line == null ) { 
this . line = new Line2D . Double ( x1 , y1 , x2 , y2 ) ; 
this . line . setLine ( x1 , y1 , x2 , y2 ) ; 
draw ( this . line ) ; 
public void fillRect ( int x , int y , int width , int height ) { 
fill ( this . rect ) ; 
public void clearRect ( int x , int y , int width , int height ) { 
if ( getBackground ( ) == null ) { 
Paint saved = getPaint ( ) ; 
setPaint ( getBackground ( ) ) ; 
fillRect ( x , y , width , height ) ; 
setPaint ( saved ) ; 
public void drawRoundRect ( int x , int y , int width , int height , 
int arcWidth , int arcHeight ) { 
setRoundRect ( x , y , width , height , arcWidth , arcHeight ) ; 
draw ( this . roundRect ) ; 
public void fillRoundRect ( int x , int y , int width , int height , 
fill ( this . roundRect ) ; 
public void drawOval ( int x , int y , int width , int height ) { 
setOval ( x , y , width , height ) ; 
draw ( this . oval ) ; 
public void fillOval ( int x , int y , int width , int height ) { 
fill ( this . oval ) ; 
public void drawArc ( int x , int y , int width , int height , int startAngle , 
int arcAngle ) { 
setArc ( x , y , width , height , startAngle , arcAngle ) ; 
draw ( this . arc ) ; 
public void fillArc ( int x , int y , int width , int height , int startAngle , 
fill ( this . arc ) ; 
public void drawPolyline ( int [ ] xPoints , int [ ] yPoints , int nPoints ) { 
GeneralPath p = GraphicsUtils . createPolygon ( xPoints , yPoints , nPoints , 
draw ( p ) ; 
public void drawPolygon ( int [ ] xPoints , int [ ] yPoints , int nPoints ) { 
public void fillPolygon ( int [ ] xPoints , int [ ] yPoints , int nPoints ) { 
fill ( p ) ; 
} private byte [ ] getPNGBytes ( Image img ) { 
RenderedImage ri ; 
if ( img instanceof RenderedImage ) { 
ri = ( RenderedImage ) img ; 
BufferedImage bi = new BufferedImage ( img . getWidth ( null ) , 
img . getHeight ( null ) , BufferedImage . TYPE_INT_ARGB ) ; 
Graphics2D g2 = bi . createGraphics ( ) ; 
g2 . drawImage ( img , 0 , 0 , null ) ; 
ri = bi ; 
ImageIO . write ( ri , "png" , baos ) ; 
Logger . getLogger ( SVGGraphics2D . class . getName ( ) ) . log ( Level . SEVERE , 
public boolean drawImage ( Image img , int x , int y , int w , int h , 
ImageObserver observer ) { 
Object hint = getRenderingHint ( SVGHints . KEY_IMAGE_HANDLING ) ; 
if ( SVGHints . VALUE_IMAGE_HANDLING_EMBED . equals ( hint ) ) { 
this . sb . append ( "xlink:href=\"data:image/png;base64," ) ; 
this . sb . append ( Base64 . getEncoder ( ) . encode ( getPNGBytes ( 
img ) ) ) ; 
this . sb . append ( "x=\"" ) . append ( geomDP ( x ) ) 
. append ( geomDP ( h ) ) . append ( "\"/>\n" ) ; 
int count = this . imageElements . size ( ) ; 
String href = ( String ) this . hints . get ( SVGHints . KEY_IMAGE_HREF ) ; 
href = this . filePrefix + count + this . fileSuffix ; 
this . hints . put ( SVGHints . KEY_IMAGE_HREF , null ) ; 
ImageElement imageElement = new ImageElement ( href , img ) ; 
this . imageElements . add ( imageElement ) ; 
this . sb . append ( "xlink:href=\"" ) ; 
public boolean drawImage ( Image img , int x , int y , Color bgcolor , 
int w = img . getWidth ( null ) ; 
if ( w < 0 ) { 
int h = img . getHeight ( null ) ; 
if ( h < 0 ) { 
return drawImage ( img , x , y , w , h , bgcolor , observer ) ; 
Color bgcolor , ImageObserver observer ) { 
setPaint ( bgcolor ) ; 
fillRect ( x , y , w , h ) ; 
return drawImage ( img , x , y , w , h , observer ) ; 
public boolean drawImage ( Image img , int dx1 , int dy1 , int dx2 , int dy2 , 
int sx1 , int sy1 , int sx2 , int sy2 , ImageObserver observer ) { 
int w = dx2 - dx1 ; 
int h = dy2 - dy1 ; 
BufferedImage img2 = new BufferedImage ( w , h , 
BufferedImage . TYPE_INT_ARGB ) ; 
Graphics2D g2 = img2 . createGraphics ( ) ; 
g2 . drawImage ( img , 0 , 0 , w , h , sx1 , sy1 , sx2 , sy2 , null ) ; 
return drawImage ( img2 , dx1 , dy1 , null ) ; 
int sx1 , int sy1 , int sx2 , int sy2 , Color bgcolor , 
fillRect ( dx1 , dy1 , dx2 - dx1 , dy2 - dy1 ) ; 
return drawImage ( img , dx1 , dy1 , dx2 , dy2 , sx1 , sy1 , sx2 , sy2 , observer ) ; 
public void drawRenderedImage ( RenderedImage img , AffineTransform xform ) { 
BufferedImage bi = GraphicsUtils . convertRenderedImage ( img ) ; 
drawImage ( bi , xform , null ) ; 
public void drawRenderableImage ( RenderableImage img , 
AffineTransform xform ) { 
RenderedImage ri = img . createDefaultRendering ( ) ; 
drawRenderedImage ( ri , xform ) ; 
public boolean drawImage ( Image img , AffineTransform xform , 
ImageObserver obs ) { 
AffineTransform savedTransform = getTransform ( ) ; 
if ( xform != null ) { 
transform ( xform ) ; 
boolean result = drawImage ( img , 0 , 0 , obs ) ; 
setTransform ( savedTransform ) ; 
public void drawImage ( BufferedImage img , BufferedImageOp op , int x , int y ) { 
BufferedImage imageToDraw = img ; 
if ( op != null ) { 
imageToDraw = op . filter ( img , null ) ; 
drawImage ( imageToDraw , new AffineTransform ( 1f , 0f , 0f , 1f , x , y ) , null ) ; 
} public String getSVGElement ( String id ) { 
return getSVGElement ( id , true , null , null , null ) ; 
} public String getSVGElement ( String id , boolean includeDimensions , 
ViewBox viewBox , PreserveAspectRatio preserveAspectRatio , 
MeetOrSlice meetOrSlice ) { 
String unitStr = this . units != null ? this . units . toString ( ) : "" ; 
if ( includeDimensions ) { 
svg . append ( "width=\"" ) . append ( this . width ) . append ( unitStr ) 
if ( viewBox != null ) { 
if ( preserveAspectRatio != null ) { 
svg . append ( "preserveAspectRatio=\"" ) 
. append ( preserveAspectRatio . toString ( ) ) ; 
if ( meetOrSlice != null ) { 
svg . append ( "text-rendering=\"" ) . append ( this . textRendering ) 
. append ( "\">\n" ) ; 
StringBuilder defs = new StringBuilder ( "<defs>" ) ; 
for ( GradientPaintKey key : this . gradientPaints . keySet ( ) ) { 
defs . append ( getLinearGradientElement ( this . gradientPaints . get ( key ) , 
key . getPaint ( ) ) ) ; 
defs . append ( "\n" ) ; 
for ( LinearGradientPaintKey key : this . linearGradientPaints . keySet ( ) ) { 
defs . append ( getLinearGradientElement ( 
this . linearGradientPaints . get ( key ) , key . getPaint ( ) ) ) ; 
for ( RadialGradientPaintKey key : this . radialGradientPaints . keySet ( ) ) { 
defs . append ( getRadialGradientElement ( 
this . radialGradientPaints . get ( key ) , key . getPaint ( ) ) ) ; 
for ( int i = 0 ; i < this . clipPaths . size ( ) ; i ++ ) { 
. append ( this . defsKeyPrefix ) . append ( CLIP_KEY_PREFIX ) . append ( i ) 
. append ( "\">" ) ; 
b . append ( "</clipPath>" ) . append ( "\n" ) ; 
defs . append ( b . toString ( ) ) ; 
defs . append ( "</defs>\n" ) ; 
svg . append ( defs ) ; 
svg . append ( this . sb ) ; 
svg . append ( "</svg>" ) ; 
return svg . toString ( ) ; 
} public String getSVGDocument ( ) { 
b . append ( "\"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd\">\n" ) ; 
b . append ( getSVGElement ( ) ) ; 
return b . append ( "\n" ) . toString ( ) ; 
} private String getLinearGradientElement ( String id , GradientPaint paint ) { 
Point2D p1 = paint . getPoint1 ( ) ; 
Point2D p2 = paint . getPoint2 ( ) ; 
b . append ( "gradientUnits=\"userSpaceOnUse\">" ) ; 
Color c1 = paint . getColor1 ( ) ; 
if ( c1 . getAlpha ( ) < 255 ) { 
double alphaPercent = c1 . getAlpha ( ) / 255.0 ; 
b . append ( "/>" ) ; 
Color c2 = paint . getColor2 ( ) ; 
if ( c2 . getAlpha ( ) < 255 ) { 
double alphaPercent = c2 . getAlpha ( ) / 255.0 ; 
return b . append ( "</linearGradient>" ) . toString ( ) ; 
} private String getLinearGradientElement ( String id , 
LinearGradientPaint paint ) { 
Point2D p1 = paint . getStartPoint ( ) ; 
Point2D p2 = paint . getEndPoint ( ) ; 
if ( ! paint . getCycleMethod ( ) . equals ( CycleMethod . NO_CYCLE ) ) { 
String sm = paint . getCycleMethod ( ) . equals ( CycleMethod . REFLECT ) 
? "reflect" : "repeat" ; 
for ( int i = 0 ; i < paint . getFractions ( ) . length ; i ++ ) { 
Color c = paint . getColors ( ) [ i ] ; 
float fraction = paint . getFractions ( ) [ i ] ; 
. append ( rgbColorStr ( c ) ) . append ( "\"" ) ; 
if ( c . getAlpha ( ) < 255 ) { 
} private String getRadialGradientElement ( String id , RadialGradientPaint rgp ) { 
Point2D center = rgp . getCenterPoint ( ) ; 
Point2D focus = rgp . getFocusPoint ( ) ; 
float radius = rgp . getRadius ( ) ; 
b . append ( "fy=\"" ) . append ( geomDP ( focus . getY ( ) ) ) . append ( "\">" ) ; 
Color [ ] colors = rgp . getColors ( ) ; 
float [ ] fractions = rgp . getFractions ( ) ; 
for ( int i = 0 ; i < colors . length ; i ++ ) { 
Color c = colors [ i ] ; 
float f = fractions [ i ] ; 
b . append ( "stop-color=\"" ) . append ( rgbColorStr ( c ) ) . append ( "\"" ) ; 
return b . append ( "</radialGradient>" ) . toString ( ) ; 
} private String getClipPathRef ( ) { 
if ( this . clipRef == null ) { 
this . clipRef = registerClip ( getClip ( ) ) ; 
b . append ( "clip-path=\"url(#" ) . append ( this . clipRef ) . append ( ")\"" ) ; 
} private void setRect ( int x , int y , int width , int height ) { 
if ( this . rect == null ) { 
this . rect = new Rectangle2D . Double ( x , y , width , height ) ; 
this . rect . setRect ( x , y , width , height ) ; 
} private void setRoundRect ( int x , int y , int width , int height , int arcWidth , 
int arcHeight ) { 
if ( this . roundRect == null ) { 
this . roundRect = new RoundRectangle2D . Double ( x , y , width , height , 
arcWidth , arcHeight ) ; 
this . roundRect . setRoundRect ( x , y , width , height , 
} private void setArc ( int x , int y , int width , int height , int startAngle , 
if ( this . arc == null ) { 
this . arc = new Arc2D . Double ( x , y , width , height , startAngle , 
arcAngle , Arc2D . PIE ) ; 
this . arc . setArc ( x , y , width , height , startAngle , arcAngle , 
Arc2D . PIE ) ; 
} private void setOval ( int x , int y , int width , int height ) { 
if ( this . oval == null ) { 
this . oval = new Ellipse2D . Double ( x , y , width , height ) ; 
this . oval . setFrame ( x , y , width , height ) ; 
} private SEVERITY toSeverity ( Integer rank ) { 
if ( rank <= 9 ) { 
return SEVERITY . ERROR ; 
if ( rank <= 14 ) { 
return SEVERITY . WARN ; 
return SEVERITY . INFO ; 
} public static List < String > getParts ( String string , final String ... regexpList ) { 
final List < String > parts = new ArrayList < > ( ) ; 
for ( final String regexp : regexpList ) { 
final Pattern pattern = Pattern . compile ( regexp ) ; 
final Matcher matcher = pattern . matcher ( string ) ; 
final boolean found = matcher . find ( ) ; 
final String part = matcher . group ( 1 ) . trim ( ) ; 
parts . add ( part ) ; 
string = string . replaceFirst ( quote ( matcher . group ( ) ) , "" ) . trim ( ) ; 
return parts ; 
} public void addTrade ( Decimal tradeVolume , Decimal tradePrice ) { 
if ( openPrice == null ) { 
openPrice = tradePrice ; 
closePrice = tradePrice ; 
if ( maxPrice == null ) { 
maxPrice = tradePrice ; 
maxPrice = maxPrice . isLessThan ( tradePrice ) ? tradePrice : maxPrice ; 
if ( minPrice == null ) { 
minPrice = tradePrice ; 
minPrice = minPrice . isGreaterThan ( tradePrice ) ? tradePrice : minPrice ; 
volume = volume . plus ( tradeVolume ) ; 
amount = amount . plus ( tradeVolume . multipliedBy ( tradePrice ) ) ; 
trades ++ ; 
} private void increaseLengthTo ( int index , int maxLength ) { 
if ( highestResultIndex > - 1 ) { 
int newResultsCount = Math . min ( index - highestResultIndex , maxLength ) ; 
if ( newResultsCount == maxLength ) { 
results . clear ( ) ; 
results . addAll ( Collections . < T > nCopies ( maxLength , null ) ) ; 
} else if ( newResultsCount > 0 ) { 
results . addAll ( Collections . < T > nCopies ( newResultsCount , null ) ) ; 
removeExceedingResults ( maxLength ) ; 
results . addAll ( Collections . < T > nCopies ( Math . min ( index + 1 , maxLength ) , null ) ) ; 
} private void removeExceedingResults ( int maximumResultCount ) { 
int resultCount = results . size ( ) ; 
if ( resultCount > maximumResultCount ) { 
final int nbResultsToRemove = resultCount - maximumResultCount ; 
for ( int i = 0 ; i < nbResultsToRemove ; i ++ ) { 
results . remove ( 0 ) ; 
} private Decimal calculateMaximumDrawdown ( TimeSeries series , CashFlow cashFlow ) { 
Decimal maximumDrawdown = Decimal . ZERO ; 
Decimal maxPeak = Decimal . ZERO ; 
if ( ! series . isEmpty ( ) ) { 
for ( int i = series . getBeginIndex ( ) ; i <= series . getEndIndex ( ) ; i ++ ) { 
Decimal value = cashFlow . getValue ( i ) ; 
if ( value . isGreaterThan ( maxPeak ) ) { 
maxPeak = value ; 
Decimal drawdown = maxPeak . minus ( value ) . dividedBy ( maxPeak ) ; 
if ( drawdown . isGreaterThan ( maximumDrawdown ) ) { 
maximumDrawdown = drawdown ; 
return maximumDrawdown ; 
} public Decimal plus ( Decimal augend ) { 
if ( ( this == NaN ) || ( augend == NaN ) ) { 
return new Decimal ( delegate . add ( augend . delegate , MATH_CONTEXT ) ) ; 
} public Decimal minus ( Decimal subtrahend ) { 
if ( ( this == NaN ) || ( subtrahend == NaN ) ) { 
return new Decimal ( delegate . subtract ( subtrahend . delegate , MATH_CONTEXT ) ) ; 
} public Decimal multipliedBy ( Decimal multiplicand ) { 
if ( ( this == NaN ) || ( multiplicand == NaN ) ) { 
return new Decimal ( delegate . multiply ( multiplicand . delegate , MATH_CONTEXT ) ) ; 
} public Decimal dividedBy ( Decimal divisor ) { 
if ( ( this == NaN ) || ( divisor == NaN ) || divisor . isZero ( ) ) { 
return new Decimal ( delegate . divide ( divisor . delegate , MATH_CONTEXT ) ) ; 
} public Decimal remainder ( Decimal divisor ) { 
return new Decimal ( delegate . remainder ( divisor . delegate , MATH_CONTEXT ) ) ; 
} public Decimal pow ( int n ) { 
if ( this == NaN ) { 
return new Decimal ( delegate . pow ( n , MATH_CONTEXT ) ) ; 
} public Decimal min ( Decimal other ) { 
if ( ( this == NaN ) || ( other == NaN ) ) { 
return ( compareTo ( other ) <= 0 ? this : other ) ; 
} public Decimal max ( Decimal other ) { 
return ( compareTo ( other ) >= 0 ? this : other ) ; 
} public double getTotalReturn ( ) { 
Decimal totalProduct = Decimal . ONE ; 
int completeTimeframes = ( getTimeSeries ( ) . getTickCount ( ) / timeFrame ) ; 
for ( int i = 1 ; i <= completeTimeframes ; i ++ ) { 
int index = i * timeFrame ; 
Decimal currentReturn = getValue ( index ) ; 
if ( currentReturn != Decimal . NaN ) { 
currentReturn = currentReturn . plus ( Decimal . ONE ) ; 
totalProduct = totalProduct . multipliedBy ( currentReturn ) ; 
return ( Math . pow ( totalProduct . toDouble ( ) , ( 1.0 / completeTimeframes ) ) ) ; 
} public static List < Integer > getSplitBeginIndexes ( TimeSeries series , Duration splitDuration ) { 
ArrayList < Integer > beginIndexes = new ArrayList < > ( ) ; 
int beginIndex = series . getBeginIndex ( ) ; 
int endIndex = series . getEndIndex ( ) ; 
beginIndexes . add ( beginIndex ) ; 
ZonedDateTime beginInterval = series . getFirstTick ( ) . getEndTime ( ) ; 
ZonedDateTime endInterval = beginInterval . plus ( splitDuration ) ; 
for ( int i = beginIndex ; i <= endIndex ; i ++ ) { 
ZonedDateTime tickTime = series . getTick ( i ) . getEndTime ( ) ; 
if ( tickTime . isBefore ( beginInterval ) || ! tickTime . isBefore ( endInterval ) ) { 
if ( ! endInterval . isAfter ( tickTime ) ) { 
beginIndexes . add ( i ) ; 
beginInterval = endInterval . isBefore ( tickTime ) ? tickTime : endInterval ; 
endInterval = beginInterval . plus ( splitDuration ) ; 
return beginIndexes ; 
} public static TimeSeries subseries ( TimeSeries series , int beginIndex , Duration duration ) { 
ZonedDateTime beginInterval = series . getTick ( beginIndex ) . getEndTime ( ) ; 
ZonedDateTime endInterval = beginInterval . plus ( duration ) ; 
int subseriesNbTicks = 0 ; 
subseriesNbTicks ++ ; 
return new BaseTimeSeries ( series , beginIndex , beginIndex + subseriesNbTicks - 1 ) ; 
} public static List < TimeSeries > splitSeries ( TimeSeries series , Duration splitDuration , Duration sliceDuration ) { 
ArrayList < TimeSeries > subseries = new ArrayList < > ( ) ; 
if ( splitDuration != null && ! splitDuration . isZero ( ) 
&& sliceDuration != null && ! sliceDuration . isZero ( ) ) { 
List < Integer > beginIndexes = getSplitBeginIndexes ( series , splitDuration ) ; 
for ( Integer subseriesBegin : beginIndexes ) { 
subseries . add ( subseries ( series , subseriesBegin , sliceDuration ) ) ; 
return subseries ; 
} private void calculateRegressionLine ( int startIndex , int endIndex ) { 
Decimal sumX = Decimal . ZERO ; 
Decimal sumY = Decimal . ZERO ; 
for ( int i = startIndex ; i <= endIndex ; i ++ ) { 
sumX = sumX . plus ( Decimal . valueOf ( i ) ) ; 
sumY = sumY . plus ( indicator . getValue ( i ) ) ; 
Decimal nbObservations = Decimal . valueOf ( endIndex - startIndex + 1 ) ; 
Decimal xBar = sumX . dividedBy ( nbObservations ) ; 
Decimal yBar = sumY . dividedBy ( nbObservations ) ; 
Decimal xxBar = Decimal . ZERO ; 
Decimal xyBar = Decimal . ZERO ; 
Decimal dX = Decimal . valueOf ( i ) . minus ( xBar ) ; 
Decimal dY = indicator . getValue ( i ) . minus ( yBar ) ; 
xxBar = xxBar . plus ( dX . multipliedBy ( dX ) ) ; 
xyBar = xyBar . plus ( dX . multipliedBy ( dY ) ) ; 
slope = xyBar . dividedBy ( xxBar ) ; 
intercept = yBar . minus ( slope . multipliedBy ( xBar ) ) ; 
} public Order operate ( int index , Decimal price , Decimal amount ) { 
Order order = null ; 
if ( isNew ( ) ) { 
order = new Order ( index , startingType , price , amount ) ; 
entry = order ; 
} else if ( isOpened ( ) ) { 
if ( index < entry . getIndex ( ) ) { 
order = new Order ( index , startingType . complementType ( ) , price , amount ) ; 
exit = order ; 
return order ; 
} private static org . jfree . data . time . TimeSeries buildChartTimeSeries ( TimeSeries tickSeries , Indicator < Decimal > indicator , String name ) { 
org . jfree . data . time . TimeSeries chartTimeSeries = new org . jfree . data . time . TimeSeries ( name ) ; 
for ( int i = 0 ; i < tickSeries . getTickCount ( ) ; i ++ ) { 
Tick tick = tickSeries . getTick ( i ) ; 
chartTimeSeries . add ( new Minute ( Date . from ( tick . getEndTime ( ) . toInstant ( ) ) ) , indicator . getValue ( i ) . toDouble ( ) ) ; 
return chartTimeSeries ; 
} private static void addBuySellSignals ( TimeSeries series , Strategy strategy , XYPlot plot ) { 
TimeSeriesManager seriesManager = new TimeSeriesManager ( series ) ; 
List < Trade > trades = seriesManager . run ( strategy ) . getTrades ( ) ; 
for ( Trade trade : trades ) { 
double buySignalTickTime = new Minute ( Date . from ( series . getTick ( trade . getEntry ( ) . getIndex ( ) ) . getEndTime ( ) . toInstant ( ) ) ) . getFirstMillisecond ( ) ; 
Marker buyMarker = new ValueMarker ( buySignalTickTime ) ; 
buyMarker . setPaint ( Color . GREEN ) ; 
buyMarker . setLabel ( "B" ) ; 
plot . addDomainMarker ( buyMarker ) ; 
double sellSignalTickTime = new Minute ( Date . from ( series . getTick ( trade . getExit ( ) . getIndex ( ) ) . getEndTime ( ) . toInstant ( ) ) ) . getFirstMillisecond ( ) ; 
Marker sellMarker = new ValueMarker ( sellSignalTickTime ) ; 
sellMarker . setPaint ( Color . RED ) ; 
sellMarker . setLabel ( "S" ) ; 
plot . addDomainMarker ( sellMarker ) ; 
} private static TimeSeries initMovingTimeSeries ( int maxTickCount ) { 
TimeSeries series = CsvTradesLoader . loadBitstampSeries ( ) ; 
series . setMaximumTickCount ( maxTickCount ) ; 
LAST_TICK_CLOSE_PRICE = series . getTick ( series . getEndIndex ( ) ) . getClosePrice ( ) ; 
} private static Decimal randDecimal ( Decimal min , Decimal max ) { 
Decimal randomDecimal = null ; 
if ( min != null && max != null && min . isLessThan ( max ) ) { 
randomDecimal = max . minus ( min ) . multipliedBy ( Decimal . valueOf ( Math . random ( ) ) ) . plus ( min ) ; 
return randomDecimal ; 
} private static Tick generateRandomTick ( ) { 
final Decimal maxRange = Decimal . valueOf ( "0.03" ) ; 
Decimal openPrice = LAST_TICK_CLOSE_PRICE ; 
Decimal minPrice = openPrice . minus ( openPrice . multipliedBy ( maxRange . multipliedBy ( Decimal . valueOf ( Math . random ( ) ) ) ) ) ; 
Decimal maxPrice = openPrice . plus ( openPrice . multipliedBy ( maxRange . multipliedBy ( Decimal . valueOf ( Math . random ( ) ) ) ) ) ; 
Decimal closePrice = randDecimal ( minPrice , maxPrice ) ; 
LAST_TICK_CLOSE_PRICE = closePrice ; 
return new BaseTick ( ZonedDateTime . now ( ) , openPrice , maxPrice , minPrice , closePrice , Decimal . ONE ) ; 
} private double calculateProfit ( TimeSeries series , Trade trade ) { 
Decimal profit = Decimal . ONE ; 
if ( trade . isClosed ( ) ) { 
Decimal exitClosePrice = series . getTick ( trade . getExit ( ) . getIndex ( ) ) . getClosePrice ( ) ; 
Decimal entryClosePrice = series . getTick ( trade . getEntry ( ) . getIndex ( ) ) . getClosePrice ( ) ; 
if ( trade . getEntry ( ) . isBuy ( ) ) { 
profit = exitClosePrice . dividedBy ( entryClosePrice ) ; 
profit = entryClosePrice . dividedBy ( exitClosePrice ) ; 
return profit . toDouble ( ) ; 
} private void incrementAcceleration ( ) { 
if ( acceleration . isGreaterThanOrEqual ( ACCELERATION_THRESHOLD ) ) { 
acceleration = MAX_ACCELERATION ; 
acceleration = acceleration . plus ( ACCELERATION_INCREMENT ) ; 
} private Decimal calculateSar ( int index ) { 
Decimal previousSar = getValue ( index - 1 ) ; 
return extremePoint . multipliedBy ( acceleration ) 
. plus ( Decimal . ONE . minus ( acceleration ) . multipliedBy ( previousSar ) ) ; 
} private void calculate ( Trade trade ) { 
final int entryIndex = trade . getEntry ( ) . getIndex ( ) ; 
int begin = entryIndex + 1 ; 
if ( begin > values . size ( ) ) { 
Decimal lastValue = values . get ( values . size ( ) - 1 ) ; 
values . addAll ( Collections . nCopies ( begin - values . size ( ) , lastValue ) ) ; 
int end = trade . getExit ( ) . getIndex ( ) ; 
for ( int i = Math . max ( begin , 1 ) ; i <= end ; i ++ ) { 
Decimal ratio ; 
ratio = timeSeries . getTick ( i ) . getClosePrice ( ) . dividedBy ( timeSeries . getTick ( entryIndex ) . getClosePrice ( ) ) ; 
ratio = timeSeries . getTick ( entryIndex ) . getClosePrice ( ) . dividedBy ( timeSeries . getTick ( i ) . getClosePrice ( ) ) ; 
values . add ( values . get ( entryIndex ) . multipliedBy ( ratio ) ) ; 
} private void fillToTheEnd ( ) { 
if ( timeSeries . getEndIndex ( ) >= values . size ( ) ) { 
values . addAll ( Collections . nCopies ( timeSeries . getEndIndex ( ) - values . size ( ) + 1 , lastValue ) ) ; 
} private static void loadLoggerConfiguration ( ) { 
LoggerContext context = ( LoggerContext ) LoggerFactory . getILoggerFactory ( ) ; 
context . reset ( ) ; 
configurator . setContext ( context ) ; 
configurator . doConfigure ( LOGBACK_CONF_FILE ) ; 
protected Decimal calculate ( int index ) { 
if ( stopLossLimit . isNaN ( ) ) { 
stopLossLimit = indicator . getValue ( 0 ) . minus ( stopLossDistance ) ; 
Decimal currentValue = indicator . getValue ( index ) ; 
Decimal referenceValue = stopLossLimit . plus ( stopLossDistance ) ; 
if ( currentValue . isGreaterThan ( referenceValue ) ) { 
stopLossLimit = currentValue . minus ( stopLossDistance ) ; 
return stopLossLimit ; 
} private void recordOrder ( Order order , boolean isEntry ) { 
if ( order == null ) { 
if ( isEntry ) { 
entryOrders . add ( order ) ; 
exitOrders . add ( order ) ; 
orders . add ( order ) ; 
if ( OrderType . BUY . equals ( order . getType ( ) ) ) { 
buyOrders . add ( order ) ; 
} else if ( OrderType . SELL . equals ( order . getType ( ) ) ) { 
sellOrders . add ( order ) ; 
if ( currentTrade . isClosed ( ) ) { 
trades . add ( currentTrade ) ; 
currentTrade = new Trade ( startingType ) ; 
} public TradingRecord run ( Strategy strategy , OrderType orderType , int startIndex , int finishIndex ) { 
return run ( strategy , orderType , Decimal . NaN , startIndex , finishIndex ) ; 
} public TradingRecord run ( Strategy strategy , OrderType orderType , Decimal amount ) { 
return run ( strategy , orderType , amount , timeSeries . getBeginIndex ( ) , timeSeries . getEndIndex ( ) ) ; 
} public TradingRecord run ( Strategy strategy , OrderType orderType , Decimal amount , int startIndex , int finishIndex ) { 
int runBeginIndex = Math . max ( startIndex , timeSeries . getBeginIndex ( ) ) ; 
int runEndIndex = Math . min ( finishIndex , timeSeries . getEndIndex ( ) ) ; 
TradingRecord tradingRecord = new BaseTradingRecord ( orderType ) ; 
for ( int i = runBeginIndex ; i <= runEndIndex ; i ++ ) { 
if ( strategy . shouldOperate ( i , tradingRecord ) ) { 
tradingRecord . operate ( i , timeSeries . getTick ( i ) . getClosePrice ( ) , amount ) ; 
if ( ! tradingRecord . isClosed ( ) ) { 
int seriesMaxSize = Math . max ( timeSeries . getEndIndex ( ) + 1 , timeSeries . getTickData ( ) . size ( ) ) ; 
for ( int i = runEndIndex + 1 ; i < seriesMaxSize ; i ++ ) { 
return tradingRecord ; 
} private static OHLCDataset createOHLCDataset ( TimeSeries series ) { 
final int nbTicks = series . getTickCount ( ) ; 
Date [ ] dates = new Date [ nbTicks ] ; 
double [ ] opens = new double [ nbTicks ] ; 
double [ ] highs = new double [ nbTicks ] ; 
double [ ] lows = new double [ nbTicks ] ; 
double [ ] closes = new double [ nbTicks ] ; 
double [ ] volumes = new double [ nbTicks ] ; 
for ( int i = 0 ; i < nbTicks ; i ++ ) { 
Tick tick = series . getTick ( i ) ; 
dates [ i ] = new Date ( tick . getEndTime ( ) . toEpochSecond ( ) * 1000 ) ; 
opens [ i ] = tick . getOpenPrice ( ) . toDouble ( ) ; 
highs [ i ] = tick . getMaxPrice ( ) . toDouble ( ) ; 
lows [ i ] = tick . getMinPrice ( ) . toDouble ( ) ; 
closes [ i ] = tick . getClosePrice ( ) . toDouble ( ) ; 
volumes [ i ] = tick . getVolume ( ) . toDouble ( ) ; 
OHLCDataset dataset = new DefaultHighLowDataset ( "btc" , dates , highs , lows , opens , closes , volumes ) ; 
} private static TimeSeriesCollection createAdditionalDataset ( TimeSeries series ) { 
ClosePriceIndicator indicator = new ClosePriceIndicator ( series ) ; 
TimeSeriesCollection dataset = new TimeSeriesCollection ( ) ; 
for ( int i = 0 ; i < series . getTickCount ( ) ; i ++ ) { 
chartTimeSeries . add ( new Second ( new Date ( tick . getEndTime ( ) . toEpochSecond ( ) * 1000 ) ) , indicator . getValue ( i ) . toDouble ( ) ) ; 
dataset . addSeries ( chartTimeSeries ) ; 
} private static void addCashFlowAxis ( XYPlot plot , TimeSeriesCollection dataset ) { 
cashAxis . setAutoRangeIncludesZero ( false ) ; 
plot . setRangeAxis ( 1 , cashAxis ) ; 
plot . setDataset ( 1 , dataset ) ; 
plot . mapDatasetToRangeAxis ( 1 , 1 ) ; 
final StandardXYItemRenderer cashFlowRenderer = new StandardXYItemRenderer ( ) ; 
cashFlowRenderer . setSeriesPaint ( 0 , Color . blue ) ; 
plot . setRenderer ( 1 , cashFlowRenderer ) ; 
} private static void displayChart ( JFreeChart chart ) { 
ChartPanel panel = new ChartPanel ( chart ) ; 
panel . setFillZoomRectangle ( true ) ; 
panel . setMouseWheelEnabled ( true ) ; 
panel . setPreferredSize ( new Dimension ( 1024 , 400 ) ) ; 
frame . setContentPane ( panel ) ; 
RefineryUtilities . centerFrameOnScreen ( frame ) ; 
} private void removeExceedingTicks ( ) { 
int tickCount = ticks . size ( ) ; 
if ( tickCount > maximumTickCount ) { 
int nbTicksToRemove = tickCount - maximumTickCount ; 
for ( int i = 0 ; i < nbTicksToRemove ; i ++ ) { 
ticks . remove ( 0 ) ; 
removedTicksCount += nbTicksToRemove ; 
} private static List < Tick > buildEmptyTicks ( ZonedDateTime beginTime , ZonedDateTime endTime , int duration ) { 
List < Tick > emptyTicks = new ArrayList < > ( ) ; 
Duration tickDuration = Duration . ofSeconds ( duration ) ; 
ZonedDateTime tickEndTime = beginTime ; 
tickEndTime = tickEndTime . plus ( tickDuration ) ; 
emptyTicks . add ( new BaseTick ( tickDuration , tickEndTime ) ) ; 
} while ( tickEndTime . isBefore ( endTime ) ) ; 
return emptyTicks ; 
} private static void removeEmptyTicks ( List < Tick > ticks ) { 
for ( int i = ticks . size ( ) - 1 ; i >= 0 ; i -- ) { 
if ( ticks . get ( i ) . getTrades ( ) == 0 ) { 
ticks . remove ( i ) ; 
} final void signalEvent ( WatchEvent . Kind < Path > kind , Path context ) { 
post ( new Event < > ( kind , 1 , context ) ) ; 
signal ( ) ; 
} public CompletableFuture < Void > watchAsync ( Executor executor ) { 
return CompletableFuture . supplyAsync ( 
( ) -> { 
watch ( ) ; 
executor ) ; 
} public void watch ( ) { 
if ( ! listener . isWatching ( ) ) { 
key = watchService . take ( ) ; 
WatchEvent . Kind < ? > kind = event . kind ( ) ; 
WatchEvent < Path > ev = PathUtils . cast ( event ) ; 
int count = ev . count ( ) ; 
Path eventPath = ev . context ( ) ; 
if ( ! keyRoots . containsKey ( key ) ) { 
Path childPath = eventPath == null ? null : keyRoots . get ( key ) . resolve ( eventPath ) ; 
listener . onEvent ( new DirectoryChangeEvent ( EventType . OVERFLOW , childPath , count ) ) ; 
} else if ( eventPath == null ) { 
} else if ( kind == ENTRY_CREATE ) { 
if ( Files . isDirectory ( childPath , NOFOLLOW_LINKS ) ) { 
if ( ! Boolean . TRUE . equals ( fileTreeSupported ) ) { 
registerAll ( childPath ) ; 
if ( ! isMac ) { 
PathUtils . recursiveVisitFiles ( 
childPath , 
dir -> notifyCreateEvent ( dir , count ) , 
file -> notifyCreateEvent ( file , count ) ) ; 
notifyCreateEvent ( childPath , count ) ; 
} else if ( kind == ENTRY_MODIFY ) { 
if ( fileHasher != null || Files . isDirectory ( childPath ) ) { 
HashCode existingHash = pathHashes . get ( childPath ) ; 
HashCode newHash = PathUtils . hash ( fileHasher , childPath ) ; 
if ( newHash != null && ! newHash . equals ( existingHash ) ) { 
pathHashes . put ( childPath , newHash ) ; 
listener . onEvent ( new DirectoryChangeEvent ( EventType . MODIFY , childPath , count ) ) ; 
} else if ( newHash == null ) { 
} else if ( kind == ENTRY_DELETE ) { 
pathHashes . entrySet ( ) . removeIf ( e -> e . getKey ( ) . startsWith ( childPath ) ) ; 
listener . onEvent ( new DirectoryChangeEvent ( EventType . DELETE , childPath , count ) ) ; 
keyRoots . remove ( key ) ; 
if ( keyRoots . isEmpty ( ) ) { 
} private void register ( Path directory , boolean useFileTreeModifier ) throws IOException { 
Watchable watchable = isMac ? new WatchablePath ( directory ) : directory ; 
WatchEvent . Modifier [ ] modifiers = 
useFileTreeModifier 
? new WatchEvent . Modifier [ ] { ExtendedWatchEventModifier . FILE_TREE } 
: new WatchEvent . Modifier [ ] { } ; 
WatchEvent . Kind < ? > [ ] kinds = 
new WatchEvent . Kind < ? > [ ] { ENTRY_CREATE , ENTRY_DELETE , ENTRY_MODIFY } ; 
WatchKey watchKey = watchable . register ( watchService , kinds , modifiers ) ; 
keyRoots . put ( watchKey , directory ) ; 
} public LocalDate getCalendarServiceRangeStart ( ) { 
int startDate = 0 ; 
for ( Service service : feed . services . values ( ) ) { 
if ( service . calendar == null ) 
if ( startDate == 0 ) 
DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( "yyyyMMdd" ) ; 
return LocalDate . parse ( String . valueOf ( startDate ) , formatter ) ; 
} public int getDailyAverageHeadway ( LocalDate date , LocalTime from , LocalTime to ) { 
OptionalDouble avg = feed . stops . values ( ) . stream ( ) 
. map ( s -> this . stop . getAverageHeadwayForStop ( s . stop_id , date , from , to ) ) 
. mapToDouble ( headway -> headway ) 
. average ( ) ; 
return ( int ) avg . getAsDouble ( ) ; 
} public Rectangle2D getBounds ( ) { 
Rectangle2D ret = null ; 
for ( Stop stop : feed . stops . values ( ) ) { 
if ( ! feed . stopCountByStopTime . containsKey ( stop . stop_id ) ) { 
ret = new Rectangle2D . Double ( stop . stop_lon , stop . stop_lat , 0 , 0 ) ; 
ret . add ( new Point2D . Double ( stop . stop_lon , stop . stop_lat ) ) ; 
} private void checkShapeDistTraveled ( StopTime previous , StopTime current ) { 
if ( 
current . shape_dist_traveled != Entity . DOUBLE_MISSING && 
previous . shape_dist_traveled == Entity . DOUBLE_MISSING || 
current . shape_dist_traveled <= previous . shape_dist_traveled 
registerError ( current , SHAPE_DIST_TRAVELED_NOT_INCREASING , current . shape_dist_traveled ) ; 
} public void complete ( ValidationResult validationResult ) { 
if ( ! allTravelTimesAreRounded ) storeErrors ( travelTimeZeroErrors ) ; 
else registerError ( NewGTFSError . forFeed ( FEED_TRAVEL_TIMES_ROUNDED , null ) ) ; 
} private boolean areTravelTimesRounded ( StopTime stopTime ) { 
boolean bothTravelTimesAreRounded = stopTime . departure_time % 60 == 0 && stopTime . arrival_time % 60 == 0 ; 
if ( ! bothTravelTimesAreRounded ) this . allTravelTimesAreRounded = false ; 
return bothTravelTimesAreRounded ; 
} private boolean checkDistanceAndTime ( double distanceMeters , double travelTimeSeconds , StopTime stopTime ) { 
boolean good = true ; 
if ( distanceMeters == 0 ) { 
registerError ( stopTime , TRAVEL_DISTANCE_ZERO ) ; 
good = false ; 
if ( travelTimeSeconds < 0 ) { 
registerError ( stopTime , TRAVEL_TIME_NEGATIVE , travelTimeSeconds ) ; 
} else if ( travelTimeSeconds == 0 ) { 
if ( ! allTravelTimesAreRounded ) registerError ( stopTime , TRAVEL_TIME_ZERO ) ; 
else travelTimeZeroErrors . add ( createUnregisteredError ( stopTime , TRAVEL_TIME_ZERO ) ) ; 
return good ; 
public void setStatementParameters ( PreparedStatement statement , boolean setDefaultId ) throws SQLException { 
int oneBasedIndex = 1 ; 
if ( ! setDefaultId ) statement . setInt ( oneBasedIndex ++ , id ) ; 
statement . setString ( oneBasedIndex ++ , pattern_id ) ; 
statement . setString ( oneBasedIndex ++ , route_id ) ; 
statement . setString ( oneBasedIndex ++ , name ) ; 
setIntParameter ( statement , oneBasedIndex ++ , direction_id ) ; 
setIntParameter ( statement , oneBasedIndex ++ , INT_MISSING ) ; 
statement . setString ( oneBasedIndex ++ , associatedShapes . iterator ( ) . next ( ) ) ; 
} public FeedLoadResult loadTables ( ) { 
FeedLoadResult result = new FeedLoadResult ( ) ; 
File gtfsFile = new File ( gtfsFilePath ) ; 
this . zip = new ZipFile ( gtfsFilePath ) ; 
this . tablePrefix = randomIdString ( ) ; 
result . filename = gtfsFilePath ; 
result . uniqueIdentifier = tablePrefix ; 
createSchema ( connection , tablePrefix ) ; 
this . errorStorage = new SQLErrorStorage ( connection , tablePrefix + "." , true ) ; 
registerFeed ( gtfsFile ) ; 
this . tablePrefix += "." ; 
result . agency = load ( Table . AGENCY ) ; 
result . calendar = load ( Table . CALENDAR ) ; 
result . calendarDates = load ( Table . CALENDAR_DATES ) ; 
result . routes = load ( Table . ROUTES ) ; 
result . fareAttributes = load ( Table . FARE_ATTRIBUTES ) ; 
result . fareRules = load ( Table . FARE_RULES ) ; 
result . feedInfo = load ( Table . FEED_INFO ) ; 
result . shapes = load ( Table . SHAPES ) ; 
result . stops = load ( Table . STOPS ) ; 
result . transfers = load ( Table . TRANSFERS ) ; 
result . trips = load ( Table . TRIPS ) ; 
result . frequencies = load ( Table . FREQUENCIES ) ; 
result . stopTimes = load ( Table . STOP_TIMES ) ; 
result . errorCount = errorStorage . getErrorCount ( ) ; 
errorStorage . commitAndClose ( ) ; 
zip . close ( ) ; 
result . completionTime = System . currentTimeMillis ( ) ; 
result . loadTimeMillis = result . completionTime - startTime ; 
result . fatalException = ex . toString ( ) ; 
} static void createSchema ( Connection connection , String schemaName ) { 
Statement statement = connection . createStatement ( ) ; 
DbUtils . closeQuietly ( connection ) ; 
} private void registerFeed ( File gtfsFile ) { 
CsvReader csvReader = Table . FEED_INFO . getCsvReader ( zip , errorStorage ) ; 
String feedId = "" , feedVersion = "" ; 
if ( csvReader != null ) { 
csvReader . readRecord ( ) ; 
feedId = csvReader . get ( "feed_id" ) ; 
feedVersion = csvReader . get ( "feed_version" ) ; 
csvReader . close ( ) ; 
HashCode md5 = Files . hash ( gtfsFile , Hashing . md5 ( ) ) ; 
String md5Hex = md5 . toString ( ) ; 
HashCode sha1 = Files . hash ( gtfsFile , Hashing . sha1 ( ) ) ; 
String shaHex = sha1 . toString ( ) ; 
createFeedRegistryIfNotExists ( connection ) ; 
PreparedStatement insertStatement = connection . prepareStatement ( 
insertStatement . setString ( 1 , tablePrefix ) ; 
insertStatement . setString ( 2 , md5Hex ) ; 
insertStatement . setString ( 3 , shaHex ) ; 
insertStatement . setString ( 4 , feedId . isEmpty ( ) ? null : feedId ) ; 
insertStatement . setString ( 5 , feedVersion . isEmpty ( ) ? null : feedVersion ) ; 
insertStatement . setString ( 6 , zip . getName ( ) ) ; 
insertStatement . execute ( ) ; 
connection . commit ( ) ; 
} static void createFeedRegistryIfNotExists ( Connection connection ) throws SQLException { 
} private TableLoadResult load ( Table table ) { 
TableLoadResult tableLoadResult = new TableLoadResult ( ) ; 
int initialErrorCount = errorStorage . getErrorCount ( ) ; 
tableLoadResult . rowCount = loadInternal ( table ) ; 
tableLoadResult . fileSize = getTableSize ( table ) ; 
tableLoadResult . fatalException = ex . toString ( ) ; 
connection . rollback ( ) ; 
if ( tempTextFile != null ) { 
tempTextFile . delete ( ) ; 
int finalErrorCount = errorStorage . getErrorCount ( ) ; 
tableLoadResult . errorCount = finalErrorCount - initialErrorCount ; 
return tableLoadResult ; 
} private int getTableSize ( Table table ) { 
ZipEntry zipEntry = zip . getEntry ( table . name + ".txt" ) ; 
if ( zipEntry == null ) return 0 ; 
return ( int ) zipEntry . getSize ( ) ; 
} private int loadInternal ( Table table ) throws Exception { 
CsvReader csvReader = table . getCsvReader ( zip , errorStorage ) ; 
if ( csvReader == null ) { 
if ( table . isRequired ( ) ) errorStorage . storeError ( NewGTFSError . forTable ( table , MISSING_TABLE ) ) ; 
boolean postgresText = ( connection . getMetaData ( ) . getDatabaseProductName ( ) . equals ( "PostgreSQL" ) ) ; 
Field [ ] fields = table . getFieldsFromFieldHeaders ( csvReader . getHeaders ( ) , errorStorage ) ; 
int keyFieldIndex = table . getKeyFieldIndex ( fields ) ; 
Field [ ] cleanFields = Arrays . stream ( fields ) . filter ( field -> field != null ) . toArray ( Field [ ] :: new ) ; 
if ( cleanFields . length == 0 ) { 
errorStorage . storeError ( NewGTFSError . forTable ( table , TABLE_MISSING_COLUMN_HEADERS ) ) ; 
Table targetTable = new Table ( tablePrefix + table . name , table . entityClass , table . required , cleanFields ) ; 
targetTable . createSqlTable ( connection ) ; 
if ( postgresText ) { 
tempTextFile = File . createTempFile ( targetTable . name , "text" ) ; 
tempTextFileStream = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( tempTextFile ) ) ) ; 
insertStatement = connection . prepareStatement ( targetTable . generateInsertSql ( ) ) ; 
LOG . info ( insertStatement . toString ( ) ) ; 
String [ ] transformedStrings = new String [ cleanFields . length + 1 ] ; 
while ( csvReader . readRecord ( ) ) { 
if ( csvReader . getCurrentRecord ( ) + 2 > Integer . MAX_VALUE ) { 
errorStorage . storeError ( NewGTFSError . forTable ( table , TABLE_TOO_LONG ) ) ; 
int lineNumber = ( ( int ) csvReader . getCurrentRecord ( ) ) + 2 ; 
if ( csvReader . getColumnCount ( ) != fields . length ) { 
errorStorage . storeError ( NewGTFSError . forLine ( table , lineNumber , WRONG_NUMBER_OF_FIELDS , badValues ) ) ; 
String keyValue = csvReader . get ( keyFieldIndex ) ; 
if ( postgresText ) transformedStrings [ 0 ] = Integer . toString ( lineNumber ) ; 
else insertStatement . setInt ( 1 , lineNumber ) ; 
int columnIndex = 0 ; 
for ( int f = 0 ; f < fields . length ; f ++ ) { 
Field field = fields [ f ] ; 
if ( field == null ) continue ; 
String string = csvReader . get ( f ) ; 
Set < NewGTFSError > errors = referenceTracker 
. checkReferencesAndUniqueness ( keyValue , lineNumber , field , string , table ) ; 
table . name . equals ( "calendar_dates" ) && 
"service_id" . equals ( field . name ) && 
"1" . equals ( csvReader . get ( Field . getFieldIndex ( fields , "exception_type" ) ) ) 
for ( NewGTFSError error : errors ) { 
if ( NewGTFSErrorType . REFERENTIAL_INTEGRITY . equals ( error . errorType ) ) { 
LOG . info ( 
keyValue 
errorStorage . storeError ( error ) ; 
errorStorage . storeErrors ( errors ) ; 
setValueForField ( table , columnIndex , lineNumber , field , string , postgresText , transformedStrings ) ; 
columnIndex += 1 ; 
tempTextFileStream . println ( String . join ( "\t" , transformedStrings ) ) ; 
insertStatement . addBatch ( ) ; 
if ( lineNumber % INSERT_BATCH_SIZE == 0 ) insertStatement . executeBatch ( ) ; 
int numberOfRecordsLoaded = ( int ) csvReader . getCurrentRecord ( ) ; 
numberOfRecordsLoaded = numberOfRecordsLoaded + 1 ; 
if ( table . isRequired ( ) && numberOfRecordsLoaded == 0 ) { 
errorStorage . storeError ( NewGTFSError . forTable ( table , REQUIRED_TABLE_EMPTY ) ) ; 
tempTextFileStream . close ( ) ; 
copyFromFile ( connection , tempTextFile , targetTable . name ) ; 
insertStatement . executeBatch ( ) ; 
table . createIndexes ( connection , tablePrefix ) ; 
LOG . info ( "Done." ) ; 
return numberOfRecordsLoaded ; 
} public static void copyFromFile ( Connection connection , File file , String targetTableName ) throws IOException , SQLException { 
InputStream stream = new BufferedInputStream ( new FileInputStream ( file . getAbsolutePath ( ) ) ) ; 
CopyManager copyManager = new CopyManager ( connection . unwrap ( BaseConnection . class ) ) ; 
copyManager . copyIn ( copySql , stream , 1024 * 1024 ) ; 
} public void setValueForField ( Table table , int fieldIndex , int lineNumber , Field field , String string , boolean postgresText , String [ ] transformedStrings ) { 
if ( string . isEmpty ( ) ) { 
if ( field . isRequired ( ) && ! field . isEmptyValuePermitted ( ) && errorStorage != null ) { 
errorStorage . storeError ( NewGTFSError . forLine ( table , lineNumber , MISSING_FIELD , field . name ) ) ; 
setFieldToNull ( postgresText , transformedStrings , fieldIndex , field ) ; 
Set < NewGTFSError > errors ; 
ValidateFieldResult < String > result = field . validateAndConvert ( string ) ; 
if ( result . clean == null ) setFieldToNull ( postgresText , transformedStrings , fieldIndex , field ) ; 
else transformedStrings [ fieldIndex + 1 ] = result . clean ; 
errors = result . errors ; 
errors = field . setParameter ( insertStatement , fieldIndex + 2 , string ) ; 
error . entityType = table . getEntityClass ( ) ; 
error . lineNumber = lineNumber ; 
if ( errorStorage != null ) errorStorage . storeError ( error ) ; 
} catch ( StorageException ex ) { 
if ( errorStorage != null ) { 
errorStorage . storeError ( NewGTFSError . forLine ( table , lineNumber , ex . errorType , ex . badValue ) ) ; 
} private void setFieldToNull ( boolean postgresText , String [ ] transformedStrings , int fieldIndex , Field field ) { 
if ( postgresText ) transformedStrings [ fieldIndex + 1 ] = POSTGRES_NULL_TEXT ; 
else try { 
field . setNull ( insertStatement , fieldIndex + 2 ) ; 
} public static String sanitize ( String string , SQLErrorStorage errorStorage ) { 
String clean = string . replaceAll ( "[^\\p{Alnum}_]" , "" ) ; 
if ( ! clean . equals ( string ) ) { 
if ( errorStorage != null ) errorStorage . storeError ( NewGTFSError . forFeed ( COLUMN_NAME_UNSAFE , string ) ) ; 
return clean ; 
statement . setString ( oneBasedIndex ++ , fare_id ) ; 
statement . setString ( oneBasedIndex ++ , origin_id ) ; 
statement . setString ( oneBasedIndex ++ , destination_id ) ; 
statement . setString ( oneBasedIndex ++ , contains_id ) ; 
} public SnapshotResult copyTables ( ) { 
SnapshotResult result = new SnapshotResult ( ) ; 
registerSnapshot ( ) ; 
result . agency = copy ( Table . AGENCY , true ) ; 
result . calendar = copy ( Table . CALENDAR , true ) ; 
result . calendarDates = copy ( Table . CALENDAR_DATES , true ) ; 
result . fareAttributes = copy ( Table . FARE_ATTRIBUTES , true ) ; 
result . fareRules = copy ( Table . FARE_RULES , true ) ; 
result . feedInfo = copy ( Table . FEED_INFO , true ) ; 
result . frequencies = copy ( Table . FREQUENCIES , true ) ; 
result . routes = copy ( Table . ROUTES , true ) ; 
copy ( Table . PATTERNS , true ) ; 
copy ( Table . PATTERN_STOP , true ) ; 
result . scheduleExceptions = createScheduleExceptionsTable ( ) ; 
result . shapes = copy ( Table . SHAPES , true ) ; 
result . stops = copy ( Table . STOPS , true ) ; 
result . stopTimes = copy ( Table . STOP_TIMES , true ) ; 
result . transfers = copy ( Table . TRANSFERS , true ) ; 
result . trips = copy ( Table . TRIPS , true ) ; 
} private TableLoadResult copy ( Table table , boolean createIndexes ) { 
Table targetTable = new Table ( tablePrefix + table . name , table . entityClass , table . required , table . fields ) ; 
boolean success ; 
if ( feedIdToSnapshot == null ) { 
success = targetTable . createSqlTable ( connection , true ) ; 
String fromTableName = String . format ( "%s.%s" , feedIdToSnapshot , table . name ) ; 
success = targetTable . createSqlTableFrom ( connection , fromTableName ) ; 
if ( success && createIndexes ) { 
addEditorSpecificFields ( connection , tablePrefix , table ) ; 
populateDefaultEditorValues ( connection , tablePrefix , table ) ; 
} private TableLoadResult createScheduleExceptionsTable ( ) { 
boolean scheduleExceptionsTableExists = tableExists ( feedIdToSnapshot , "schedule_exceptions" ) ; 
String scheduleExceptionsTableName = tablePrefix + "schedule_exceptions" ; 
if ( scheduleExceptionsTableExists ) { 
return copy ( Table . SCHEDULE_EXCEPTIONS , true ) ; 
Table . SCHEDULE_EXCEPTIONS . createSqlTable ( 
connection , 
tablePrefix . replace ( "." , "" ) , 
true 
String sql = String . format ( 
scheduleExceptionsTableName 
PreparedStatement scheduleExceptionsStatement = connection . prepareStatement ( sql ) ; 
final BatchTracker scheduleExceptionsTracker = new BatchTracker ( 
"schedule_exceptions" , 
scheduleExceptionsStatement 
JDBCTableReader < CalendarDate > calendarDatesReader = new JDBCTableReader ( 
Table . CALENDAR_DATES , 
dataSource , 
feedIdToSnapshot + "." , 
EntityPopulator . CALENDAR_DATE 
Iterable < CalendarDate > calendarDates = calendarDatesReader . getAll ( ) ; 
Map < String , Calendar > calendarsByServiceId = new HashMap < > ( ) ; 
Multimap < String , String > removedServiceForDate = HashMultimap . create ( ) ; 
Multimap < String , String > addedServiceForDate = HashMultimap . create ( ) ; 
for ( CalendarDate calendarDate : calendarDates ) { 
if ( calendarDate . date == null ) { 
String date = calendarDate . date . format ( DateTimeFormatter . BASIC_ISO_DATE ) ; 
if ( calendarDate . exception_type == 1 ) { 
addedServiceForDate . put ( date , calendarDate . service_id ) ; 
Calendar calendar = calendarsByServiceId . getOrDefault ( calendarDate . service_id , new Calendar ( ) ) ; 
calendar . service_id = calendarDate . service_id ; 
if ( calendar . start_date == null || calendar . start_date . isAfter ( calendarDate . date ) ) { 
calendar . start_date = calendarDate . date ; 
if ( calendar . end_date == null || calendar . end_date . isBefore ( calendarDate . date ) ) { 
calendar . end_date = calendarDate . date ; 
calendarsByServiceId . put ( calendarDate . service_id , calendar ) ; 
removedServiceForDate . put ( date , calendarDate . service_id ) ; 
for ( String date : Sets . union ( removedServiceForDate . keySet ( ) , addedServiceForDate . keySet ( ) ) ) { 
scheduleExceptionsStatement . setString ( 1 , date ) ; 
String [ ] dates = { date } ; 
scheduleExceptionsStatement . setArray ( 2 , connection . createArrayOf ( "text" , dates ) ) ; 
scheduleExceptionsStatement . setInt ( 3 , 9 ) ; 
scheduleExceptionsStatement . setArray ( 
4 , 
connection . createArrayOf ( "text" , addedServiceForDate . get ( date ) . toArray ( ) ) 
5 , 
connection . createArrayOf ( "text" , removedServiceForDate . get ( date ) . toArray ( ) ) 
scheduleExceptionsTracker . addBatch ( ) ; 
scheduleExceptionsTracker . executeRemaining ( ) ; 
feedIdToSnapshot != null && 
! tableExists ( feedIdToSnapshot , "calendar" ) && 
calendarDatesReader . getRowCount ( ) > 0 
sql = String . format ( 
tablePrefix + "calendar" 
PreparedStatement calendarStatement = connection . prepareStatement ( sql ) ; 
final BatchTracker calendarsTracker = new BatchTracker ( 
"calendar" , 
calendarStatement 
for ( Calendar calendar : calendarsByServiceId . values ( ) ) { 
calendarStatement . setString ( 1 , calendar . service_id ) ; 
calendarStatement . setString ( 
2 , 
3 , 
calendar . start_date . format ( DateTimeFormatter . BASIC_ISO_DATE ) 
calendar . end_date . format ( DateTimeFormatter . BASIC_ISO_DATE ) 
calendarsTracker . addBatch ( ) ; 
calendarsTracker . executeRemaining ( ) ; 
tableLoadResult . fatalException = e . toString ( ) ; 
} catch ( SQLException ex ) { 
} private boolean tableExists ( String namespace , String tableName ) { 
if ( namespace == null || tableName == null ) return false ; 
PreparedStatement tableExistsStatement = connection . prepareStatement ( 
tableExistsStatement . setString ( 1 , namespace ) ; 
tableExistsStatement . setString ( 2 , tableName ) ; 
ResultSet resultSet = tableExistsStatement . executeQuery ( ) ; 
resultSet . next ( ) ; 
return resultSet . getBoolean ( 1 ) ; 
} private void addEditorSpecificFields ( Connection connection , String tablePrefix , Table table ) throws SQLException { 
for ( Field field : table . editorFields ( ) ) { 
tablePrefix + table . name , 
field . name , 
field . getSqlTypeName ( ) ) ; 
LOG . info ( addColumnSql ) ; 
statement . execute ( addColumnSql ) ; 
} private void populateDefaultEditorValues ( Connection connection , String tablePrefix , Table table ) throws SQLException { 
if ( Table . ROUTES . name . equals ( table . name ) ) { 
String updateStatusSql = String . format ( 
tablePrefix ) ; 
int updatedRoutes = statement . executeUpdate ( updateStatusSql ) ; 
if ( Table . CALENDAR . name . equals ( table . name ) ) { 
String [ ] daysOfWeek = new String [ ] { "monday" , "tuesday" , "wednesday" , "thursday" , "friday" , "saturday" , "sunday" } ; 
Arrays . stream ( daysOfWeek ) 
. map ( d -> String . format ( 
d , 
d . substring ( 0 , 1 ) . toUpperCase ( ) + d . substring ( 1 , 2 ) ) ) . toArray ( String [ ] :: new ) ) ; 
String updateOtherSql = String . format ( 
tablePrefix , 
concatenatedDaysOfWeek ) ; 
LOG . info ( updateOtherSql ) ; 
int calendarsUpdated = statement . executeUpdate ( updateOtherSql ) ; 
if ( Table . TRIPS . name . equals ( table . name ) ) { 
String updatePatternsSql = String . format ( 
LOG . info ( updatePatternsSql ) ; 
int patternsUpdated = statement . executeUpdate ( updatePatternsSql ) ; 
} private void registerSnapshot ( ) { 
insertStatement . setString ( 2 , feedIdToSnapshot ) ; 
DateField startDateField = ( DateField ) Table . CALENDAR . getFieldForName ( "start_date" ) ; 
DateField endDateField = ( ( DateField ) Table . CALENDAR . getFieldForName ( "end_date" ) ) ; 
statement . setString ( oneBasedIndex ++ , service_id ) ; 
setIntParameter ( statement , oneBasedIndex ++ , monday ) ; 
setIntParameter ( statement , oneBasedIndex ++ , tuesday ) ; 
setIntParameter ( statement , oneBasedIndex ++ , wednesday ) ; 
setIntParameter ( statement , oneBasedIndex ++ , thursday ) ; 
setIntParameter ( statement , oneBasedIndex ++ , friday ) ; 
setIntParameter ( statement , oneBasedIndex ++ , saturday ) ; 
setIntParameter ( statement , oneBasedIndex ++ , sunday ) ; 
startDateField . setParameter ( statement , oneBasedIndex ++ , start_date ) ; 
endDateField . setParameter ( statement , oneBasedIndex ++ , end_date ) ; 
statement . setString ( oneBasedIndex ++ , null ) ; 
} public String getId ( ) { 
sb . append ( trip_id ) ; 
sb . append ( '_' ) ; 
sb . append ( convertToGtfsTime ( start_time ) ) ; 
sb . append ( "_to_" ) ; 
sb . append ( convertToGtfsTime ( end_time ) ) ; 
sb . append ( "_every_" ) ; 
sb . append ( String . format ( "%dm%02ds" , headway_secs / 60 , headway_secs % 60 ) ) ; 
if ( exact_times == 1 ) sb . append ( "_exact" ) ; 
statement . setString ( oneBasedIndex ++ , trip_id ) ; 
setIntParameter ( statement , oneBasedIndex ++ , start_time ) ; 
setIntParameter ( statement , oneBasedIndex ++ , end_time ) ; 
setIntParameter ( statement , oneBasedIndex ++ , headway_secs ) ; 
setIntParameter ( statement , oneBasedIndex ++ , exact_times ) ; 
} public int executeRemaining ( ) throws SQLException { 
if ( currentBatchSize > 0 ) { 
totalRecordsProcessed += currentBatchSize ; 
preparedStatement . executeBatch ( ) ; 
currentBatchSize = 0 ; 
preparedStatement = null ; 
return totalRecordsProcessed ; 
} public static BooleanAsciiGrid forEarthPopulation ( ) { 
InputStream gridStream = BooleanAsciiGrid . class . getResourceAsStream ( "gpwv3-quarter-boolean.asc" ) ; 
return new BooleanAsciiGrid ( gridStream , false ) ; 
} private void validateBlocks ( ) { 
for ( String blockId : blockIntervals . keySet ( ) ) { 
List < BlockInterval > intervals = blockIntervals . get ( blockId ) ; 
intervals . sort ( Comparator . comparingInt ( i -> i . startTime ) ) ; 
for ( int n = 0 ; n < intervals . size ( ) - 1 ; n ++ ) { 
BlockInterval interval1 = intervals . get ( n ) ; 
for ( BlockInterval interval2 : intervals . subList ( n + 1 , intervals . size ( ) ) ) { 
if ( interval1 . lastStop . departure_time <= interval2 . firstStop . arrival_time || interval2 . lastStop . departure_time <= interval1 . firstStop . arrival_time ) { 
if ( interval1 . trip . service_id . equals ( interval2 . trip . service_id ) ) { 
registerError ( interval1 . trip , TRIP_OVERLAP_IN_BLOCK , interval2 . trip . trip_id ) ; 
ServiceValidator . ServiceInfo info1 = serviceInfoForServiceId . get ( interval1 . trip . service_id ) ; 
ServiceValidator . ServiceInfo info2 = serviceInfoForServiceId . get ( interval2 . trip . service_id ) ; 
Set < LocalDate > overlappingDates = new HashSet < > ( info1 . datesActive ) ; 
overlappingDates . retainAll ( info2 . datesActive ) ; 
if ( overlappingDates . size ( ) > 0 ) { 
} public FeedLoadResult exportTables ( ) { 
zipOutputStream = new ZipOutputStream ( new FileOutputStream ( outFile ) ) ; 
if ( ! connection . getMetaData ( ) . getDatabaseProductName ( ) . equals ( "PostgreSQL" ) ) { 
result . agency = export ( Table . AGENCY , connection ) ; 
if ( fromEditor ) { 
result . calendar = export ( 
Table . CALENDAR , 
String . join ( 
Table . CALENDAR . generateSelectSql ( feedIdToExport , Requirement . OPTIONAL ) , 
result . calendar = export ( Table . CALENDAR , connection ) ; 
GTFSFeed feed = new GTFSFeed ( ) ; 
JDBCTableReader < ScheduleException > exceptionsReader = 
new JDBCTableReader ( Table . SCHEDULE_EXCEPTIONS , dataSource , feedIdToExport + "." , 
EntityPopulator . SCHEDULE_EXCEPTION ) ; 
JDBCTableReader < Calendar > calendarsReader = 
new JDBCTableReader ( Table . CALENDAR , dataSource , feedIdToExport + "." , 
EntityPopulator . CALENDAR ) ; 
Iterable < Calendar > calendars = calendarsReader . getAll ( ) ; 
Iterable < ScheduleException > exceptionsIterator = exceptionsReader . getAll ( ) ; 
List < ScheduleException > exceptions = new ArrayList < > ( ) ; 
for ( ScheduleException exception : exceptionsIterator ) { 
exceptions . add ( exception ) ; 
if ( calendarsReader . getRowCount ( ) > 0 ) { 
int calendarDateCount = 0 ; 
for ( Calendar cal : calendars ) { 
Service service = new Service ( cal . service_id ) ; 
service . calendar = cal ; 
for ( ScheduleException ex : exceptions ) { 
if ( ex . exemplar . equals ( ScheduleException . ExemplarServiceDescriptor . SWAP ) && 
( ! ex . addedService . contains ( cal . service_id ) && ! ex . removedService . contains ( cal . service_id ) ) ) { 
for ( LocalDate date : ex . dates ) { 
if ( date . isBefore ( cal . start_date ) || date . isAfter ( cal . end_date ) ) { 
CalendarDate calendarDate = new CalendarDate ( ) ; 
calendarDate . date = date ; 
calendarDate . service_id = cal . service_id ; 
calendarDate . exception_type = ex . serviceRunsOn ( cal ) ? 1 : 2 ; 
if ( service . calendar_dates . containsKey ( date ) ) 
service . calendar_dates . put ( date , calendarDate ) ; 
calendarDateCount += 1 ; 
feed . services . put ( cal . service_id , service ) ; 
if ( calendarDateCount == 0 ) { 
new CalendarDate . Writer ( feed ) . writeTable ( zipOutputStream ) ; 
result . calendarDates = export ( Table . CALENDAR_DATES , connection ) ; 
result . fareAttributes = export ( Table . FARE_ATTRIBUTES , connection ) ; 
result . fareRules = export ( Table . FARE_RULES , connection ) ; 
result . feedInfo = export ( Table . FEED_INFO , connection ) ; 
result . frequencies = export ( 
Table . FREQUENCIES , 
Table . FREQUENCIES . generateSelectSql ( feedIdToExport , Requirement . OPTIONAL ) , 
Table . FREQUENCIES . generateJoinSql ( Table . TRIPS , feedIdToExport ) , 
Table . TRIPS . generateJoinSql ( 
Table . ROUTES , 
feedIdToExport , 
"route_id" , 
) , 
whereRouteIsApproved 
result . frequencies = export ( Table . FREQUENCIES , connection ) ; 
result . routes = export ( 
Table . ROUTES . generateSelectSql ( feedIdToExport , Requirement . OPTIONAL ) , 
result . routes = export ( Table . ROUTES , connection ) ; 
String shapeFieldsToExport = Table . commaSeparatedNames ( 
Table . SHAPES . specFields ( ) , 
String . join ( "." , feedIdToExport , Table . SHAPES . name + "." ) , 
result . shapes = export ( 
Table . SHAPES , 
shapeFieldsToExport , 
feedIdToExport 
result . shapes = export ( Table . SHAPES , connection ) ; 
result . stops = export ( Table . STOPS , connection ) ; 
result . stopTimes = export ( 
Table . STOP_TIMES , 
Table . STOP_TIMES . generateSelectSql ( feedIdToExport , Requirement . OPTIONAL ) , 
Table . STOP_TIMES . generateJoinSql ( Table . TRIPS , feedIdToExport ) , 
result . stopTimes = export ( Table . STOP_TIMES , connection ) ; 
result . transfers = export ( Table . TRANSFERS , connection ) ; 
result . trips = export ( 
Table . TRIPS , 
Table . TRIPS . generateSelectSql ( feedIdToExport , Requirement . OPTIONAL ) , 
result . trips = export ( Table . TRIPS , connection ) ; 
zipOutputStream . close ( ) ; 
cleanUpZipFile ( ) ; 
} private void cleanUpZipFile ( ) { 
Map < String , String > zip_properties = new HashMap < > ( ) ; 
zip_properties . put ( "create" , "false" ) ; 
URI zip_disk = URI . create ( "jar:" + new File ( outFile ) . toURI ( ) ) ; 
try ( FileSystem fileSystem = FileSystems . newFileSystem ( zip_disk , zip_properties ) ) { 
for ( String fileName : emptyTableList ) { 
Path filePath = fileSystem . getPath ( fileName ) ; 
Files . delete ( filePath ) ; 
} private TableLoadResult export ( Table table , String filterSql ) { 
if ( filterSql == null ) { 
filterSql = String . format ( "(%s)" , filterSql ) ; 
String textFileName = table . name + ".txt" ; 
ZipEntry zipEntry = new ZipEntry ( textFileName ) ; 
zipOutputStream . putNextEntry ( zipEntry ) ; 
OutputStream protectedOut = new FilterOutputStream ( zipOutputStream ) ; 
LOG . info ( copySql ) ; 
tableLoadResult . rowCount = ( int ) copyManager . copyOut ( copySql , protectedOut ) ; 
if ( tableLoadResult . rowCount == 0 ) { 
emptyTableList . add ( textFileName ) ; 
zipOutputStream . closeEntry ( ) ; 
} catch ( SQLException | IOException | IllegalArgumentException e ) { 
statement . setString ( oneBasedIndex ++ , trip_headsign ) ; 
statement . setString ( oneBasedIndex ++ , trip_short_name ) ; 
statement . setString ( oneBasedIndex ++ , block_id ) ; 
statement . setString ( oneBasedIndex ++ , shape_id ) ; 
setIntParameter ( statement , oneBasedIndex ++ , wheelchair_accessible ) ; 
setIntParameter ( statement , oneBasedIndex ++ , bikes_allowed ) ; 
setIntParameter ( statement , oneBasedIndex ++ , shape_pt_sequence ) ; 
statement . setDouble ( oneBasedIndex ++ , shape_pt_lat ) ; 
statement . setDouble ( oneBasedIndex ++ , shape_pt_lon ) ; 
statement . setDouble ( oneBasedIndex ++ , shape_dist_traveled ) ; 
statement . setInt ( oneBasedIndex ++ , 0 ) ; 
} public void registerError ( Entity entity , NewGTFSErrorType errorType ) { 
errorStorage . storeError ( NewGTFSError . forEntity ( entity , errorType ) ) ; 
} NewGTFSError createUnregisteredError ( Entity entity , NewGTFSErrorType errorType ) { 
return NewGTFSError . forEntity ( entity , errorType ) ; 
} public void registerError ( Entity entity , NewGTFSErrorType errorType , Object badValue ) { 
errorStorage . storeError ( NewGTFSError . forEntity ( entity , errorType ) . setBadValue ( badValue . toString ( ) ) ) ; 
} public static FeedLoadResult export ( String feedId , String outFile , DataSource dataSource , boolean fromEditor ) { 
JdbcGtfsExporter exporter = new JdbcGtfsExporter ( feedId , outFile , dataSource , fromEditor ) ; 
FeedLoadResult result = exporter . exportTables ( ) ; 
} public static FeedLoadResult load ( String filePath , DataSource dataSource ) { 
JdbcGtfsLoader loader = new JdbcGtfsLoader ( filePath , dataSource ) ; 
FeedLoadResult result = loader . loadTables ( ) ; 
} public static SnapshotResult makeSnapshot ( String feedId , DataSource dataSource ) { 
JdbcGtfsSnapshotter snapshotter = new JdbcGtfsSnapshotter ( feedId , dataSource ) ; 
SnapshotResult result = snapshotter . copyTables ( ) ; 
} public static ValidationResult validate ( String feedId , DataSource dataSource ) { 
Feed feed = new Feed ( dataSource , feedId ) ; 
ValidationResult result = feed . validate ( ) ; 
} public static void delete ( String feedId , DataSource dataSource ) throws SQLException , InvalidNamespaceException { 
ensureValidNamespace ( feedId ) ; 
PreparedStatement deleteFeedStatement = connection . prepareStatement ( deleteFeedEntrySql ) ; 
deleteFeedStatement . setString ( 1 , feedId ) ; 
deleteFeedStatement . executeUpdate ( ) ; 
statement . executeUpdate ( dropSchemaSql ) ; 
} catch ( InvalidNamespaceException | SQLException e ) { 
if ( connection != null ) DbUtils . closeQuietly ( connection ) ; 
} public static DataSource createDataSource ( String url , String username , String password ) { 
String characterEncoding = Charset . defaultCharset ( ) . toString ( ) ; 
if ( ! Charset . defaultCharset ( ) . equals ( StandardCharsets . UTF_8 ) ) { 
ConnectionFactory connectionFactory = new DriverManagerConnectionFactory ( url , username , password ) ; 
PoolableConnectionFactory poolableConnectionFactory = new PoolableConnectionFactory ( connectionFactory , null ) ; 
GenericObjectPool connectionPool = new GenericObjectPool ( poolableConnectionFactory ) ; 
connectionPool . setMaxTotal ( 300 ) ; 
connectionPool . setMaxIdle ( 4 ) ; 
connectionPool . setMinIdle ( 2 ) ; 
poolableConnectionFactory . setPool ( connectionPool ) ; 
poolableConnectionFactory . setDefaultAutoCommit ( false ) ; 
return new PoolingDataSource ( connectionPool ) ; 
Options options = getOptions ( ) ; 
CommandLine cmd ; 
cmd = new DefaultParser ( ) . parse ( options , args ) ; 
printHelp ( options ) ; 
if ( cmd . hasOption ( "help" ) ) { 
if ( ! cmd . getArgList ( ) . isEmpty ( ) ) { 
if ( ! ( cmd . hasOption ( "export" ) || cmd . hasOption ( "snapshot" ) || cmd . hasOption ( "load" ) || cmd . hasOption ( "validate" ) || cmd . hasOption ( "delete" ) ) ) { 
boolean storeResults = cmd . hasOption ( "json" ) ; 
ObjectMapper mapper = null ; 
File directory = null ; 
if ( storeResults ) { 
mapper = new ObjectMapper ( ) ; 
directory = cmd . getOptionValue ( "json" ) != null ? new File ( cmd . getOptionValue ( "json" ) ) : Files . createTempDir ( ) ; 
String databaseUrl = cmd . getOptionValue ( "database" , DEFAULT_DATABASE_URL ) ; 
String databaseUser = cmd . getOptionValue ( "user" ) ; 
String databasePassword = cmd . getOptionValue ( "password" ) ; 
DataSource dataSource = createDataSource ( databaseUrl , databaseUser , databasePassword ) ; 
FeedLoadResult loadResult = null ; 
if ( cmd . hasOption ( "load" ) ) { 
String filePath = cmd . getOptionValue ( "load" ) ; 
loadResult = load ( filePath , dataSource ) ; 
File loadResultFile = new File ( directory , String . format ( "%s-load.json" , loadResult . uniqueIdentifier ) ) ; 
mapper . writerWithDefaultPrettyPrinter ( ) . writeValue ( loadResultFile , loadResult ) ; 
if ( cmd . hasOption ( "validate" ) ) { 
String feedToValidate = cmd . getOptionValue ( "validate" ) ; 
if ( feedToValidate != null && loadResult != null ) { 
feedToValidate , loadResult . uniqueIdentifier ) ; 
if ( feedToValidate == null && loadResult != null ) { 
feedToValidate = loadResult . uniqueIdentifier ; 
if ( feedToValidate != null ) { 
ValidationResult validationResult = validate ( feedToValidate , dataSource ) ; 
File validationResultFile = new File ( directory , String . format ( "%s-validation.json" , feedToValidate ) ) ; 
mapper . writerWithDefaultPrettyPrinter ( ) . writeValue ( validationResultFile , validationResult ) ; 
if ( cmd . hasOption ( "snapshot" ) ) { 
String namespaceToSnapshot = cmd . getOptionValue ( "snapshot" ) ; 
if ( namespaceToSnapshot == null && loadResult != null ) { 
namespaceToSnapshot = loadResult . uniqueIdentifier ; 
if ( namespaceToSnapshot != null ) { 
FeedLoadResult snapshotResult = makeSnapshot ( namespaceToSnapshot , dataSource ) ; 
File snapshotResultFile = new File ( directory , String . format ( "%s-snapshot.json" , snapshotResult . uniqueIdentifier ) ) ; 
mapper . writerWithDefaultPrettyPrinter ( ) . writeValue ( snapshotResultFile , snapshotResult ) ; 
if ( cmd . hasOption ( "export" ) ) { 
String namespaceToExport = cmd . getOptionValue ( "export" ) ; 
String outFile = cmd . getOptionValue ( "outFile" ) ; 
if ( namespaceToExport == null && loadResult != null ) { 
namespaceToExport = loadResult . uniqueIdentifier ; 
if ( namespaceToExport != null ) { 
FeedLoadResult exportResult = export ( namespaceToExport , outFile , dataSource , true ) ; 
if ( cmd . hasOption ( "delete" ) ) { 
String namespaceToDelete = cmd . getOptionValue ( "delete" ) ; 
if ( namespaceToDelete != null ) { 
delete ( namespaceToDelete , dataSource ) ; 
} catch ( SQLException | InvalidNamespaceException e ) { 
} private static Options getOptions ( ) { 
Options options = new Options ( ) ; 
options . addOption ( Option . builder ( ) 
. longOpt ( "export" ) . hasArg ( ) 
. argName ( "namespace" ) 
. longOpt ( "outFile" ) . hasArg ( ) 
. argName ( "file" ) 
. longOpt ( "load" ) . hasArg ( ) 
. longOpt ( "validate" ) . hasArg ( ) . optionalArg ( true ) 
. longOpt ( "snapshot" ) . hasArg ( ) 
options . addOption ( Option . builder ( "d" ) 
. longOpt ( "database" ) . hasArg ( ) 
. argName ( "url" ) 
options . addOption ( Option . builder ( "u" ) . longOpt ( "user" ) . hasArg ( ) 
. argName ( "username" ) 
options . addOption ( Option . builder ( "p" ) 
. longOpt ( "password" ) . hasArg ( ) 
. argName ( "password" ) 
. longOpt ( "delete" ) . hasArg ( ) 
. longOpt ( "json" ) . hasArg ( ) . optionalArg ( true ) 
. argName ( "directory" ) 
return options ; 
} public NewGTFSError addInfo ( String key , String value ) { 
errorInfo . put ( key , value ) ; 
} public static NewGTFSError forLine ( Table table , int lineNumber , NewGTFSErrorType errorType , String badValue ) { 
NewGTFSError error = new NewGTFSError ( table . getEntityClass ( ) , errorType ) ; 
error . badValue = badValue ; 
} public static NewGTFSError forEntity ( Entity entity , NewGTFSErrorType errorType ) { 
NewGTFSError error = new NewGTFSError ( entity . getClass ( ) , errorType ) ; 
error . lineNumber = entity . id ; 
error . entityId = entity . getId ( ) ; 
error . entitySequenceNumber = entity . getSequenceNumber ( ) ; 
} public static NewGTFSError forTable ( Table table , NewGTFSErrorType errorType ) { 
return new NewGTFSError ( table . getEntityClass ( ) , errorType ) ; 
} public static NewGTFSError forFeed ( NewGTFSErrorType errorType , String badValue ) { 
return new NewGTFSError ( null , errorType ) . setBadValue ( badValue ) ; 
} public NewGTFSError setSequence ( String sequenceAsString ) { 
this . entitySequenceNumber = Integer . parseInt ( sequenceAsString ) ; 
this . entitySequenceNumber = null ; 
} public double getPatternSpeed ( String pattern_id , LocalDate date , LocalTime from , LocalTime to ) { 
List < Trip > trips = getTripsForDate ( pattern_id , date ) ; 
return getAverageSpeedForTrips ( trips , from , to ) ; 
} public double getAverageSpeedForTrips ( Collection < Trip > trips , LocalTime from , LocalTime to ) { 
TDoubleList speeds = new TDoubleArrayList ( ) ; 
for ( Trip trip : trips ) { 
StopTime firstStopTime = feed . stop_times . ceilingEntry ( Fun . t2 ( trip . trip_id , null ) ) . getValue ( ) ; 
LocalTime tripBeginTime = LocalTime . ofSecondOfDay ( firstStopTime . departure_time % 86399 ) ; 
if ( tripBeginTime . isAfter ( to ) || tripBeginTime . isBefore ( from ) ) { 
double speed = feed . getTripSpeed ( trip . trip_id , true ) ; 
if ( ! Double . isNaN ( speed ) ) { 
speeds . add ( speed ) ; 
if ( speeds . isEmpty ( ) ) return - 1 ; 
return speeds . sum ( ) / speeds . size ( ) ; 
} public LocalTime getStartTimeForTrips ( Collection < Trip > trips ) { 
int earliestDeparture = Integer . MAX_VALUE ; 
StopTime st = feed . getOrderedStopTimesForTrip ( trip . trip_id ) . iterator ( ) . next ( ) ; 
int dep = st . departure_time ; 
if ( dep > 86399 ) { 
dep = dep % 86399 ; 
if ( dep <= earliestDeparture ) { 
earliestDeparture = dep ; 
return LocalTime . ofSecondOfDay ( earliestDeparture ) ; 
} public LocalTime getEndTimeForTrips ( Collection < Trip > trips ) { 
int latestArrival = Integer . MIN_VALUE ; 
if ( st . arrival_time >= latestArrival ) { 
latestArrival = st . arrival_time ; 
return LocalTime . ofSecondOfDay ( latestArrival % 86399 ) ; 
} public long getTotalRevenueTimeForTrips ( Collection < Trip > trips ) { 
TIntList times = new TIntArrayList ( ) ; 
StopTime first ; 
StopTime last ; 
Spliterator < StopTime > stopTimes = feed . getOrderedStopTimesForTrip ( trip . trip_id ) . spliterator ( ) ; ; 
first = StreamSupport . stream ( stopTimes , false ) 
. orElse ( null ) ; 
last = StreamSupport . stream ( stopTimes , false ) 
. reduce ( ( a , b ) -> b ) 
if ( last != null && first != null ) { 
int time = last . arrival_time - first . departure_time ; 
times . add ( time ) ; 
return times . sum ( ) ; 
} public double getTotalDistanceForTrips ( Collection < Trip > trips ) { 
TDoubleList distances = new TDoubleArrayList ( ) ; 
distances . add ( feed . getTripDistance ( trip . trip_id , false ) ) ; 
return distances . sum ( ) ; 
} public double getPatternDistance ( String pattern_id ) { 
Pattern pattern = feed . patterns . get ( pattern_id ) ; 
return feed . getTripDistance ( pattern . associatedTrips . iterator ( ) . next ( ) , false ) ; 
} public double getAverageStopSpacing ( String pattern_id ) { 
return getPatternDistance ( pattern_id ) / pattern . orderedStops . size ( ) ; 
DateField dateField = ( DateField ) Table . CALENDAR_DATES . getFieldForName ( "date" ) ; 
dateField . setParameter ( statement , oneBasedIndex ++ , date ) ; 
setIntParameter ( statement , oneBasedIndex ++ , exception_type ) ; 
DateField feedStartDateField = ( DateField ) Table . FEED_INFO . getFieldForName ( "feed_start_date" ) ; 
DateField feedEndDateField = ( DateField ) Table . FEED_INFO . getFieldForName ( "feed_end_date" ) ; 
String feedPublisherUrl = feed_publisher_url != null ? feed_publisher_url . toString ( ) : null ; 
statement . setString ( oneBasedIndex ++ , feed_publisher_name ) ; 
statement . setString ( oneBasedIndex ++ , feedPublisherUrl ) ; 
statement . setString ( oneBasedIndex ++ , feed_lang ) ; 
feedStartDateField . setParameter ( statement , oneBasedIndex ++ , feed_start_date ) ; 
feedEndDateField . setParameter ( statement , oneBasedIndex ++ , feed_end_date ) ; 
statement . setString ( oneBasedIndex ++ , feed_version ) ; 
statement . setString ( oneBasedIndex ++ , from_stop_id ) ; 
statement . setString ( oneBasedIndex ++ , to_stop_id ) ; 
setIntParameter ( statement , oneBasedIndex ++ , transfer_type ) ; 
setIntParameter ( statement , oneBasedIndex ++ , min_transfer_time ) ; 
} public Set < NewGTFSError > checkReferencesAndUniqueness ( String keyValue , int lineNumber , 
Field field , String value , Table table ) { 
return checkReferencesAndUniqueness ( keyValue , lineNumber , field , value , table , 
table . getKeyFieldName ( ) , table . getOrderFieldName ( ) ) ; 
Field field , String value , Table table , String keyField , String orderField ) { 
Set < NewGTFSError > errors = new HashSet < > ( ) ; 
String uniqueKeyField = orderField != null ? orderField 
: ! table . hasUniqueKeyField ? null : keyField ; 
String transitId = String . join ( ":" , keyField , keyValue ) ; 
if ( ! field . isRequired ( ) && "" . equals ( value ) ) return Collections . emptySet ( ) ; 
boolean isOrderField = field . name . equals ( orderField ) ; 
if ( field . isForeignReference ( ) ) { 
String referenceField = field . referenceTable . getKeyFieldName ( ) ; 
String referenceTransitId = String . join ( ":" , referenceField , value ) ; 
if ( ! this . transitIds . contains ( referenceTransitId ) ) { 
NewGTFSError referentialIntegrityError = NewGTFSError 
. forLine ( table , lineNumber , REFERENTIAL_INTEGRITY , referenceTransitId ) 
. setEntityId ( keyValue ) ; 
if ( isOrderField ) referentialIntegrityError . setSequence ( value ) ; 
errors . add ( referentialIntegrityError ) ; 
Set < String > listOfUniqueIds = this . transitIds ; 
String uniqueId = transitId ; 
if ( field . name . equals ( uniqueKeyField ) ) { 
if ( isOrderField ) { 
listOfUniqueIds = this . transitIdsWithSequence ; 
uniqueId = String . join ( ":" , field . name , keyValue , value ) ; 
boolean valueAlreadyExists = ! listOfUniqueIds . add ( uniqueId ) ; 
if ( valueAlreadyExists ) { 
NewGTFSError duplicateIdError = 
NewGTFSError . forLine ( table , lineNumber , DUPLICATE_ID , uniqueId ) 
if ( isOrderField ) { duplicateIdError . setSequence ( value ) ; } 
errors . add ( duplicateIdError ) ; 
} else if ( field . name . equals ( keyField ) && ! field . isForeignReference ( ) ) { 
this . transitIds . add ( uniqueId ) ; 
return errors ; 
this . tablePrefix = this . namespace = randomIdString ( ) ; 
registerFeed ( ) ; 
this . errorStorage = new SQLErrorStorage ( connection , tablePrefix , true ) ; 
List < Calendar > calendars = gtfsFeed . services . values ( ) 
. map ( service -> service . calendar ) 
List < CalendarDate > calendarDates = gtfsFeed . services . values ( ) 
. map ( service -> service . calendar_dates . values ( ) ) 
. flatMap ( Collection :: stream ) 
List < FareAttribute > fareAttributes = gtfsFeed . fares . values ( ) 
. map ( fare -> fare . fare_attribute ) 
List < FareRule > fareRules = gtfsFeed . fares . values ( ) 
. map ( fare -> fare . fare_rules ) 
List < Frequency > frequencies = gtfsFeed . frequencies . stream ( ) 
. map ( stringFrequencyTuple2 -> stringFrequencyTuple2 . b ) 
copyEntityToSql ( gtfsFeed . agency . values ( ) , Table . AGENCY ) ; 
copyEntityToSql ( calendars , Table . CALENDAR ) ; 
copyEntityToSql ( calendarDates , Table . CALENDAR_DATES ) ; 
copyEntityToSql ( gtfsFeed . routes . values ( ) , Table . ROUTES ) ; 
copyEntityToSql ( gtfsFeed . patterns . values ( ) , Table . PATTERNS ) ; 
copyEntityToSql ( fareAttributes , Table . FARE_ATTRIBUTES ) ; 
copyEntityToSql ( fareRules , Table . FARE_RULES ) ; 
copyEntityToSql ( gtfsFeed . feedInfo . values ( ) , Table . FEED_INFO ) ; 
copyEntityToSql ( gtfsFeed . shape_points . values ( ) , Table . SHAPES ) ; 
copyEntityToSql ( gtfsFeed . stops . values ( ) , Table . STOPS ) ; 
copyEntityToSql ( gtfsFeed . transfers . values ( ) , Table . TRANSFERS ) ; 
copyEntityToSql ( gtfsFeed . trips . values ( ) , Table . TRIPS ) ; 
copyEntityToSql ( frequencies , Table . FREQUENCIES ) ; 
copyEntityToSql ( gtfsFeed . stop_times . values ( ) , Table . STOP_TIMES ) ; 
result . fatalException = ex . getMessage ( ) ; 
} private void registerFeed ( ) { 
FeedInfo feedInfo = gtfsFeed . feedInfo . isEmpty ( ) ? null : gtfsFeed . feedInfo . values ( ) . iterator ( ) . next ( ) ; 
if ( feedInfo != null ) { 
feedId = feedInfo . feed_id ; 
feedVersion = feedInfo . feed_version ; 
insertStatement . setString ( 2 , null ) ; 
insertStatement . setString ( 3 , null ) ; 
insertStatement . setString ( 6 , "mapdb_gtfs_feed" ) ; 
} private < E extends Entity > void copyEntityToSql ( Iterable < E > entities , Table table ) throws SQLException { 
table . createSqlTable ( connection , namespace , true ) ; 
String entityInsertSql = table . generateInsertSql ( namespace , true ) ; 
PreparedStatement insertStatement = connection . prepareStatement ( entityInsertSql ) ; 
int count = 0 , batchSize = 0 ; 
for ( E entity : entities ) { 
entity . setStatementParameters ( insertStatement , true ) ; 
batchSize ++ ; 
if ( batchSize > JdbcGtfsLoader . INSERT_BATCH_SIZE ) { 
batchSize = 0 ; 
table . createIndexes ( connection , namespace ) ; 
} public static ValidateFieldResult < String > from ( ValidateFieldResult result ) { 
ValidateFieldResult < String > stringResult = new ValidateFieldResult < > ( ) ; 
stringResult . clean = String . valueOf ( result . clean ) ; 
stringResult . errors . addAll ( result . errors ) ; 
return stringResult ; 
} public int getErrorCount ( ) { 
this . commit ( ) ; 
ResultSet resultSet = statement . getResultSet ( ) ; 
int count = resultSet . getInt ( 1 ) ; 
throw new StorageException ( ex ) ; 
} private void commit ( ) { 
insertError . executeBatch ( ) ; 
insertInfo . executeBatch ( ) ; 
} public void commitAndClose ( ) { 
public ValidateFieldResult < String > validateAndConvert ( String hhmmss ) { 
return ValidateFieldResult . from ( getSeconds ( hhmmss ) ) ; 
public String getColumnExpression ( String prefix , boolean csvOutput ) { 
String columnName = super . getColumnExpression ( prefix , csvOutput ) ; 
return csvOutput 
: columnName ; 
public int compareTo ( GTFSError o ) { 
int compare = super . compareTo ( o ) ; 
if ( compare != 0 ) return compare ; 
return this . badReference . compareTo ( ( ( ( ReferentialIntegrityError ) o ) . badReference ) ) ; 
public static int 
getEPSGCodefromUTS ( Coordinate refLonLat ) { 
int epsg_code = 32600 ; 
if ( refLonLat . y < 0 ) { 
epsg_code += 100 ; 
epsg_code += getUTMZoneForLongitude ( refLonLat . x ) ; 
return epsg_code ; 
public static int getUTMZoneForLongitude ( double lon ) { 
if ( lon < - 180 || lon > 180 ) 
int lonZone = ( int ) ( ( lon + 180 ) / 6 ) ; 
if ( lonZone == 60 ) 
lonZone -- ; 
return lonZone + 1 ; 
} public static double getDistance ( LineString tripGeometry ) { 
double distance = 0 ; 
for ( int i = 0 ; i < tripGeometry . getNumPoints ( ) - 1 ; i ++ ) { 
distance += JTS . orthodromicDistance ( tripGeometry . getCoordinateN ( i ) , tripGeometry . getCoordinateN ( i + 1 ) , DefaultGeographicCRS . WGS84 ) ; 
} catch ( TransformException e ) { 
return distance ; 
} public static GraphQLFieldDefinition field ( String fieldName , String tableName ) { 
return newFieldDefinition ( ) 
. name ( fieldName ) 
. type ( GraphQLInt ) 
. dataFetcher ( new RowCountFetcher ( tableName ) ) 
} public static GraphQLFieldDefinition groupedField ( String tableName , String groupByColumn ) { 
. name ( groupByColumn ) 
. type ( groupCountType ) 
. argument ( stringArg ( "pattern_id" ) ) 
. type ( new GraphQLList ( groupCountType ) ) 
. dataFetcher ( new RowCountFetcher ( tableName , null , groupByColumn ) ) 
} public int [ ] deduplicateIntArray ( int [ ] original ) { 
if ( original == null ) return null ; 
IntArray intArray = new IntArray ( original ) ; 
IntArray canonical = canonicalIntArrays . get ( intArray ) ; 
if ( canonical == null ) { 
canonical = intArray ; 
canonicalIntArrays . put ( canonical , canonical ) ; 
return canonical . array ; 
} public ValidationResult validate ( ) { 
long validationStartTime = System . currentTimeMillis ( ) ; 
ValidationResult validationResult = new ValidationResult ( ) ; 
SQLErrorStorage errorStorage = null ; 
errorStorage = new SQLErrorStorage ( dataSource . getConnection ( ) , tablePrefix , false ) ; 
} catch ( SQLException | InvalidNamespaceException ex ) { 
int errorCountBeforeValidation = errorStorage . getErrorCount ( ) ; 
List < FeedValidator > feedValidators = Arrays . asList ( 
new MisplacedStopValidator ( this , errorStorage , validationResult ) , 
new DuplicateStopsValidator ( this , errorStorage ) , 
new TimeZoneValidator ( this , errorStorage ) , 
new NewTripTimesValidator ( this , errorStorage ) , 
new NamesValidator ( this , errorStorage ) ) ; 
for ( FeedValidator feedValidator : feedValidators ) { 
String validatorName = feedValidator . getClass ( ) . getSimpleName ( ) ; 
int errorCountBefore = errorStorage . getErrorCount ( ) ; 
feedValidator . validate ( ) ; 
String badValue = String . join ( ":" , validatorName , e . toString ( ) ) ; 
errorStorage . storeError ( NewGTFSError . forFeed ( VALIDATOR_FAILED , badValue ) ) ; 
LOG . error ( e . toString ( ) ) ; 
feedValidator . complete ( validationResult ) ; 
String badValue = String . join ( ":" , feedValidator . getClass ( ) . getSimpleName ( ) , e . toString ( ) ) ; 
int totalValidationErrors = errorStorage . getErrorCount ( ) ; 
long validationEndTime = System . currentTimeMillis ( ) ; 
long totalValidationTime = validationEndTime - validationStartTime ; 
validationResult . errorCount = totalValidationErrors ; 
validationResult . validationTime = totalValidationTime ; 
return validationResult ; 
} public List < Trip > getTripsForDate ( String stop_id , LocalDate date ) { 
List < String > tripIds = stats . getTripsForDate ( date ) . stream ( ) 
. map ( trip -> trip . trip_id ) 
return feed . getDistinctTripsForStop ( stop_id ) . stream ( ) 
. filter ( t -> tripIds . contains ( t . trip_id ) ) 
} public int getAverageHeadwayForStop ( String stop_id , LocalDate date , LocalTime from , LocalTime to ) { 
List < Trip > tripsForStop = getTripsForDate ( stop_id , date ) ; 
return getStopHeadwayForTrips ( stop_id , tripsForStop , from , to ) ; 
} public Map < String , Integer > getRouteHeadwaysForStop ( String stop_id , LocalDate date , LocalTime from , LocalTime to ) { 
Map < String , Integer > routeHeadwayMap = new HashMap < > ( ) ; 
List < Route > routes = feed . patterns . values ( ) . stream ( ) 
. filter ( p -> p . orderedStops . contains ( stop_id ) ) 
. map ( p -> feed . routes . get ( p . route_id ) ) 
for ( Route route : routes ) { 
routeHeadwayMap . put ( route . route_id , getHeadwayForStopByRoute ( stop_id , route . route_id , date , from , to ) ) ; 
return routeHeadwayMap ; 
} public int getStopHeadwayForTrips ( String stop_id , List < Trip > trips , LocalTime from , LocalTime to ) { 
TIntList timesAtStop = new TIntArrayList ( ) ; 
Set < String > tripIds = trips . stream ( ) 
. map ( t -> t . trip_id ) 
List < StopTime > stopTimes = feed . getStopTimesForStop ( stop_id ) . stream ( ) 
. filter ( st -> tripIds . contains ( st . trip_id ) ) 
for ( StopTime st : stopTimes ) { 
if ( st . departure_time > 86399 || st . departure_time < 0 ) continue ; 
LocalTime timeAtStop = LocalTime . ofSecondOfDay ( st . departure_time ) ; 
if ( timeAtStop . isAfter ( to ) || timeAtStop . isBefore ( from ) ) { 
timesAtStop . add ( st . departure_time ) ; 
timesAtStop . sort ( ) ; 
TIntList deltas = new TIntArrayList ( ) ; 
for ( int i = 0 ; i < timesAtStop . size ( ) - 1 ; i ++ ) { 
int delta = timesAtStop . get ( i + 1 ) - timesAtStop . get ( i ) ; 
if ( delta > 60 ) deltas . add ( delta ) ; 
if ( deltas . isEmpty ( ) ) return - 1 ; 
return deltas . sum ( ) / deltas . size ( ) ; 
} public int getHeadwayForStopByRoute ( String stop_id , String route_id , LocalDate date , LocalTime from , LocalTime to ) { 
List < Trip > tripsForStop = feed . getDistinctTripsForStop ( stop_id ) . stream ( ) 
. filter ( trip -> feed . trips . get ( trip . trip_id ) . route_id . equals ( route_id ) ) 
. filter ( trip -> feed . services . get ( trip . service_id ) . activeOn ( date ) ) 
} public List < TransferPerformanceSummary > getTransferPerformance ( String stop_id , LocalDate date ) { 
List < StopTime > stopTimes = feed . getStopTimesForStop ( stop_id ) ; 
Map < String , List < StopTime > > routeStopTimeMap = new HashMap < > ( ) ; 
List < TransferPerformanceSummary > transferPerformanceMap = new ArrayList < > ( ) ; 
stopTimes . stream ( ) 
. forEach ( st -> { 
Trip trip = feed . trips . get ( st . trip_id ) ; 
Service service = feed . services . get ( trip . service_id ) ; 
if ( service != null && service . activeOn ( date ) ) { 
Route route = feed . routes . get ( trip . route_id ) ; 
List < StopTime > times = new ArrayList < > ( ) ; 
if ( routeStopTimeMap . containsKey ( route . route_id ) ) { 
times . addAll ( routeStopTimeMap . get ( route . route_id ) ) ; 
times . add ( st ) ; 
routeStopTimeMap . put ( route . route_id , times ) ; 
Map < Fun . Tuple2 < String , String > , TIntList > waitTimesByRoute = new HashMap < > ( ) ; 
Map < Fun . Tuple2 < String , String > , Set < Fun . Tuple2 < StopTime , StopTime > > > missedTransfers = new HashMap < > ( ) ; 
for ( Map . Entry < String , List < StopTime > > entry : routeStopTimeMap . entrySet ( ) ) { 
final int MISSED_TRANSFER_THRESHOLD = 60 * 10 ; 
List < StopTime > currentTimes = entry . getValue ( ) ; 
String currentRoute = entry . getKey ( ) ; 
for ( StopTime currentTime : currentTimes ) { 
if ( currentTime . arrival_time > 0 ) { 
for ( Map . Entry < String , List < StopTime > > entry2 : routeStopTimeMap . entrySet ( ) ) { 
List < StopTime > compareTimes = entry2 . getValue ( ) ; 
String compareRoute = entry2 . getKey ( ) ; 
Fun . Tuple2 < String , String > routeKey = new Fun . Tuple2 ( currentRoute , compareRoute ) ; 
if ( compareRoute . equals ( currentRoute ) ) { 
if ( ! waitTimesByRoute . containsKey ( routeKey ) ) { 
waitTimesByRoute . put ( routeKey , new TIntArrayList ( ) ) ; 
int shortestWait = Integer . MAX_VALUE ; 
for ( StopTime compareTime : compareTimes ) { 
if ( compareTime . departure_time > 0 ) { 
int waitTime = compareTime . departure_time - currentTime . arrival_time ; 
if ( waitTime >= 0 && waitTime < shortestWait ) { 
shortestWait = waitTime ; 
if ( waitTime < 0 && waitTime * - 1 <= MISSED_TRANSFER_THRESHOLD ) { 
Fun . Tuple2 < StopTime , StopTime > missedTransfer = new Fun . Tuple2 ( compareTime , currentTime ) ; 
if ( ! missedTransfers . containsKey ( routeKey ) ) { 
missedTransfers . put ( routeKey , new HashSet < > ( ) ) ; 
missedTransfers . get ( routeKey ) . add ( missedTransfer ) ; 
if ( shortestWait < Integer . MAX_VALUE ) 
waitTimesByRoute . get ( routeKey ) . add ( shortestWait ) ; 
for ( Map . Entry < Fun . Tuple2 < String , String > , TIntList > entry : waitTimesByRoute . entrySet ( ) ) { 
Fun . Tuple2 < String , String > routeKey = entry . getKey ( ) ; 
TIntList waitTimes = entry . getValue ( ) ; 
if ( waitTimes . isEmpty ( ) ) { 
int min = waitTimes . min ( ) ; 
int max = waitTimes . max ( ) ; 
waitTimes . sort ( ) ; 
int median = waitTimes . get ( waitTimes . size ( ) / 2 ) ; 
TransferPerformanceSummary routeTransferPerformance = new TransferPerformanceSummary ( routeKey . a , routeKey . b , min , max , median , missedTransfers . get ( routeKey ) ) ; 
transferPerformanceMap . add ( routeTransferPerformance ) ; 
return transferPerformanceMap ; 
} private static JsonNode getJsonNode ( String json ) throws IOException { 
return mapper . readTree ( json ) ; 
public String create ( String json , boolean autoCommit ) throws SQLException , IOException { 
return update ( null , json , autoCommit ) ; 
public String update ( Integer id , String json , boolean autoCommit ) throws SQLException , IOException { 
final boolean isCreating = id == null ; 
JsonNode jsonNode = getJsonNode ( json ) ; 
if ( jsonNode . isArray ( ) ) { 
List < String > updatedObjects = new ArrayList < > ( ) ; 
for ( JsonNode node : jsonNode ) { 
JsonNode idNode = node . get ( "id" ) ; 
Integer nodeId = idNode == null || isCreating ? null : idNode . asInt ( ) ; 
String updatedObject = update ( nodeId , node . toString ( ) , false ) ; 
updatedObjects . add ( updatedObject ) ; 
if ( autoCommit ) connection . commit ( ) ; 
return mapper . writeValueAsString ( updatedObjects ) ; 
ObjectNode jsonObject = ( ObjectNode ) jsonNode ; 
ensureReferentialIntegrity ( jsonObject , tablePrefix , specTable , id ) ; 
PreparedStatement preparedStatement = createPreparedUpdate ( id , isCreating , jsonObject , specTable , connection , false ) ; 
long newId = handleStatementExecution ( preparedStatement , isCreating ) ; 
Set < Table > referencingTables = getReferencingTables ( specTable ) ; 
if ( specTable . name . equals ( "patterns" ) ) { 
referencingTables . add ( Table . SHAPES ) ; 
for ( Table referencingTable : referencingTables ) { 
Table parentTable = referencingTable . getParentTable ( ) ; 
if ( parentTable != null && parentTable . name . equals ( specTable . name ) || referencingTable . name . equals ( "shapes" ) ) { 
JsonNode childEntities = jsonObject . get ( referencingTable . name ) ; 
if ( childEntities == null || childEntities . isNull ( ) || ! childEntities . isArray ( ) ) { 
int entityId = isCreating ? ( int ) newId : id ; 
ArrayNode childEntitiesArray = ( ArrayNode ) childEntities ; 
boolean referencedPatternUsesFrequencies = false ; 
if ( jsonObject . has ( "pattern_id" ) && ! jsonObject . get ( "pattern_id" ) . isNull ( ) ) { 
PreparedStatement statement = connection . prepareStatement ( String . format ( 
Table . PATTERNS . name 
statement . setString ( 1 , jsonObject . get ( "pattern_id" ) . asText ( ) ) ; 
LOG . info ( statement . toString ( ) ) ; 
ResultSet selectResults = statement . executeQuery ( ) ; 
while ( selectResults . next ( ) ) { 
referencedPatternUsesFrequencies = selectResults . getBoolean ( 1 ) ; 
String keyValue = updateChildTable ( 
childEntitiesArray , 
entityId , 
referencedPatternUsesFrequencies , 
isCreating , 
referencingTable , 
connection 
jsonObject . put ( referencingTable . getKeyFieldName ( ) , keyValue ) ; 
switch ( specTable . name ) { 
case "routes" : 
updateLinkedFields ( 
specTable , 
jsonObject , 
"trips" , 
"wheelchair_accessible" 
case "patterns" : 
"pattern_id" , 
"direction_id" , "shape_id" 
if ( autoCommit ) { 
jsonObject . put ( "id" , newId ) ; 
return jsonObject . toString ( ) ; 
} public int normalizeStopTimesForPattern ( int id , int beginWithSequence ) throws SQLException { 
JDBCTableReader < PatternStop > patternStops = new JDBCTableReader ( 
Table . PATTERN_STOP , 
tablePrefix + "." , 
EntityPopulator . PATTERN_STOP 
String patternId = getValueForId ( id , "pattern_id" , tablePrefix , Table . PATTERNS , connection ) ; 
List < PatternStop > patternStopsToNormalize = new ArrayList < > ( ) ; 
for ( PatternStop patternStop : patternStops . getOrdered ( patternId ) ) { 
if ( patternStop . stop_sequence >= beginWithSequence ) { 
patternStopsToNormalize . add ( patternStop ) ; 
int stopTimesUpdated = updateStopTimesForPatternStops ( patternStopsToNormalize ) ; 
return stopTimesUpdated ; 
} private void updateLinkedFields ( 
Table referenceTable , 
ObjectNode exemplarEntity , 
String linkedTableName , 
String keyField , 
String ... linkedFieldsToUpdate 
boolean updatingStopTimes = "stop_times" . equals ( linkedTableName ) ; 
List < Field > fields = new ArrayList < > ( ) ; 
List < JsonNode > values = new ArrayList < > ( ) ; 
List < String > fieldStrings = new ArrayList < > ( ) ; 
for ( String field : linkedFieldsToUpdate ) { 
fields . add ( referenceTable . getFieldForName ( field ) ) ; 
values . add ( exemplarEntity . get ( field ) ) ; 
Field orderField = updatingStopTimes ? referenceTable . getFieldForName ( referenceTable . getOrderFieldName ( ) ) : null ; 
String sql = updatingStopTimes 
? String . format ( 
setFields , 
keyField , 
orderField . name 
PreparedStatement statement = connection . prepareStatement ( sql ) ; 
Field field = fields . get ( i ) ; 
String newValue = values . get ( i ) . isNull ( ) ? null : values . get ( i ) . asText ( ) ; 
if ( newValue == null ) field . setNull ( statement , oneBasedIndex ++ ) ; 
else field . setParameter ( statement , oneBasedIndex ++ , newValue ) ; 
statement . setString ( oneBasedIndex ++ , exemplarEntity . get ( keyField ) . asText ( ) ) ; 
if ( updatingStopTimes ) { 
String orderValue = exemplarEntity . get ( orderField . name ) . asText ( ) ; 
orderField . setParameter ( statement , oneBasedIndex ++ , orderValue ) ; 
LOG . debug ( statement . toString ( ) ) ; 
int entitiesUpdated = statement . executeUpdate ( ) ; 
} private PreparedStatement createPreparedUpdate ( 
Integer id , 
boolean isCreating , 
ObjectNode jsonObject , 
Table table , 
Connection connection , 
boolean batch 
String statementString ; 
if ( isCreating ) { 
statementString = table . generateInsertSql ( tablePrefix , true ) ; 
statementString = table . generateUpdateSql ( tablePrefix , id ) ; 
PreparedStatement preparedStatement = connection . prepareStatement ( 
statementString , 
Statement . RETURN_GENERATED_KEYS ) ; 
if ( ! batch ) { 
setStatementParameters ( jsonObject , table , preparedStatement , connection ) ; 
return preparedStatement ; 
} private void setStatementParameters ( 
PreparedStatement preparedStatement , 
Connection connection 
List < String > missingFieldNames = new ArrayList < > ( ) ; 
if ( ! jsonObject . has ( field . name ) ) { 
missingFieldNames . add ( field . name ) ; 
JsonNode value = jsonObject . get ( field . name ) ; 
LOG . debug ( "{}={}" , field . name , value ) ; 
if ( value == null || value . isNull ( ) ) { 
if ( field . isRequired ( ) && ! field . isEmptyValuePermitted ( ) ) { 
field . setNull ( preparedStatement , index ) ; 
List < String > values = new ArrayList < > ( ) ; 
if ( value . isArray ( ) ) { 
for ( JsonNode node : value ) { 
values . add ( node . asText ( ) ) ; 
field . setParameter ( preparedStatement , index , String . join ( "," , values ) ) ; 
field . setParameter ( preparedStatement , index , value . asText ( ) ) ; 
} catch ( StorageException e ) { 
if ( field . name . contains ( "_time" ) ) { 
if ( field . isRequired ( ) ) { 
preparedStatement . setInt ( index , Integer . parseInt ( value . asText ( ) ) ) ; 
index += 1 ; 
if ( missingFieldNames . size ( ) > 0 ) { 
table . name , 
missingFieldNames . toString ( ) 
} private String updateChildTable ( 
ArrayNode subEntities , 
int id , 
boolean referencedPatternUsesFrequencies , 
boolean isCreatingNewEntity , 
Table subTable , 
) throws SQLException , IOException { 
Field keyField = specTable . getFieldForName ( subTable . getKeyFieldName ( ) ) ; 
String keyValue = getValueForId ( id , keyField . name , tablePrefix , specTable , connection ) ; 
String childTableName = String . join ( "." , tablePrefix , subTable . name ) ; 
if ( ! referencedPatternUsesFrequencies && subTable . name . equals ( Table . FREQUENCIES . name ) && subEntities . size ( ) > 0 ) { 
if ( Table . PATTERN_STOP . name . equals ( subTable . name ) ) { 
List < PatternStop > newPatternStops = new ArrayList < > ( ) ; 
for ( JsonNode node : subEntities ) { 
ObjectNode objectNode = ( ObjectNode ) node ; 
if ( ! objectNode . get ( "id" ) . isNumber ( ) ) { 
objectNode . put ( "id" , 0 ) ; 
newPatternStops . add ( mapper . readValue ( objectNode . toString ( ) , PatternStop . class ) ) ; 
reconcilePatternStops ( keyValue , newPatternStops , connection ) ; 
if ( ! isCreatingNewEntity ) { 
if ( Table . SHAPES . name . equals ( subTable . name ) ) { 
PreparedStatement statement = connection . prepareStatement ( patternsForShapeIdSql ) ; 
statement . setString ( 1 , keyValue ) ; 
ResultSet resultSet = statement . executeQuery ( ) ; 
int patternsForShapeId = 0 ; 
patternsForShapeId ++ ; 
if ( patternsForShapeId > 1 ) { 
keyValue = UUID . randomUUID ( ) . toString ( ) ; 
PreparedStatement updateStatement = connection . prepareStatement ( updatePatternShapeIdSql ) ; 
updateStatement . setString ( 1 , keyValue ) ; 
updateStatement . setInt ( 2 , id ) ; 
LOG . info ( updateStatement . toString ( ) ) ; 
updateStatement . executeUpdate ( ) ; 
deleteChildEntities ( subTable , keyField , keyValue ) ; 
int entityCount = 0 ; 
PreparedStatement insertStatement = null ; 
String orderFieldName = subTable . getOrderFieldName ( ) ; 
boolean hasOrderField = orderFieldName != null ; 
int previousOrder = - 1 ; 
TIntSet orderValues = new TIntHashSet ( ) ; 
Multimap < Table , String > referencesPerTable = HashMultimap . create ( ) ; 
int cumulativeTravelTime = 0 ; 
for ( JsonNode entityNode : subEntities ) { 
ObjectNode subEntity = ( ObjectNode ) entityNode ; 
subEntity . put ( keyField . name , keyValue ) ; 
for ( Field field : subTable . specFields ( ) ) { 
if ( field . referenceTable != null && ! field . referenceTable . name . equals ( specTable . name ) ) { 
JsonNode refValueNode = subEntity . get ( field . name ) ; 
if ( refValueNode . isNull ( ) && ! field . isRequired ( ) ) continue ; 
String refValue = refValueNode . asText ( ) ; 
referencesPerTable . put ( field . referenceTable , refValue ) ; 
if ( entityCount == 0 ) { 
insertStatement = createPreparedUpdate ( id , true , subEntity , subTable , connection , true ) ; 
if ( "pattern_stops" . equals ( subTable . name ) ) { 
if ( referencedPatternUsesFrequencies ) { 
cumulativeTravelTime += updateStopTimesForPatternStop ( subEntity , cumulativeTravelTime ) ; 
subTable , 
subEntity , 
"stop_times" , 
"timepoint" , 
"drop_off_type" , 
"pickup_type" , 
"shape_dist_traveled" 
setStatementParameters ( subEntity , subTable , insertStatement , connection ) ; 
if ( hasOrderField ) { 
int orderValue = subEntity . get ( orderFieldName ) . asInt ( ) ; 
boolean orderIsUnique = orderValues . add ( orderValue ) ; 
boolean valuesAreIncrementing = ++ previousOrder == orderValue ; 
if ( ! orderIsUnique || ! valuesAreIncrementing ) { 
subTable . name , 
orderFieldName , 
entityCount , 
previousOrder == 0 ? "non-zero" : ! valuesAreIncrementing ? "non-incrementing" : "duplicate" , 
orderValue 
if ( entityCount == 0 ) LOG . info ( insertStatement . toString ( ) ) ; 
if ( ++ entityCount % INSERT_BATCH_SIZE == 0 ) { 
int [ ] newIds = insertStatement . executeBatch ( ) ; 
verifyReferencesExist ( subTable . name , referencesPerTable ) ; 
if ( insertStatement != null ) { 
return keyValue ; 
} private void deleteChildEntities ( Table childTable , Field keyField , String keyValue ) throws SQLException { 
String childTableName = String . join ( "." , tablePrefix , childTable . name ) ; 
PreparedStatement deleteStatement = getUpdateReferencesStatement ( SqlMethod . DELETE , childTableName , keyField , keyValue , null ) ; 
LOG . info ( deleteStatement . toString ( ) ) ; 
int result = deleteStatement . executeUpdate ( ) ; 
} private int updateStopTimesForPatternStop ( ObjectNode patternStop , int previousTravelTime ) throws SQLException { 
tablePrefix 
int travelTime = patternStop . get ( "default_travel_time" ) . asInt ( ) ; 
int arrivalTime = previousTravelTime + travelTime ; 
statement . setInt ( oneBasedIndex ++ , arrivalTime ) ; 
int dwellTime = patternStop . get ( "default_dwell_time" ) . asInt ( ) ; 
statement . setInt ( oneBasedIndex ++ , arrivalTime + dwellTime ) ; 
statement . setString ( oneBasedIndex ++ , patternStop . get ( "pattern_id" ) . asText ( ) ) ; 
statement . setInt ( oneBasedIndex ++ , patternStop . get ( "stop_sequence" ) . asInt ( ) ) ; 
return travelTime + dwellTime ; 
} private int updateStopTimesForPatternStops ( List < PatternStop > patternStops ) throws SQLException { 
PatternStop firstPatternStop = patternStops . iterator ( ) . next ( ) ; 
int firstStopSequence = firstPatternStop . stop_sequence ; 
int previousStopSequence = firstStopSequence > 0 ? firstStopSequence - 1 : 0 ; 
String timeField = firstStopSequence > 0 ? "departure_time" : "arrival_time" ; 
String getFirstTravelTimeSql = String . format ( 
timeField , 
PreparedStatement statement = connection . prepareStatement ( getFirstTravelTimeSql ) ; 
statement . setInt ( 1 , previousStopSequence ) ; 
statement . setString ( 2 , firstPatternStop . pattern_id ) ; 
Map < String , Integer > timesForTripIds = new HashMap < > ( ) ; 
timesForTripIds . put ( resultSet . getString ( 1 ) , resultSet . getInt ( 2 ) ) ; 
String updateTravelTimeSql = String . format ( 
PreparedStatement updateStopTimeStatement = connection . prepareStatement ( updateTravelTimeSql ) ; 
LOG . info ( updateStopTimeStatement . toString ( ) ) ; 
final BatchTracker stopTimesTracker = new BatchTracker ( "stop_times" , updateStopTimeStatement ) ; 
for ( String tripId : timesForTripIds . keySet ( ) ) { 
int cumulativeTravelTime = timesForTripIds . get ( tripId ) ; 
for ( PatternStop patternStop : patternStops ) { 
int travelTime = patternStop . default_travel_time == Entity . INT_MISSING ? 0 : patternStop . default_travel_time ; 
int dwellTime = patternStop . default_dwell_time == Entity . INT_MISSING ? 0 : patternStop . default_dwell_time ; 
cumulativeTravelTime += travelTime ; 
updateStopTimeStatement . setInt ( oneBasedIndex ++ , cumulativeTravelTime ) ; 
cumulativeTravelTime += dwellTime ; 
updateStopTimeStatement . setString ( oneBasedIndex ++ , tripId ) ; 
updateStopTimeStatement . setInt ( oneBasedIndex ++ , patternStop . stop_sequence ) ; 
stopTimesTracker . addBatch ( ) ; 
return stopTimesTracker . executeRemaining ( ) ; 
} private void verifyReferencesExist ( String referringTableName , Multimap < Table , String > referencesPerTable ) throws SQLException { 
for ( Table referencedTable : referencesPerTable . keySet ( ) ) { 
Collection < String > referenceStrings = referencesPerTable . get ( referencedTable ) ; 
String referenceFieldName = referencedTable . getKeyFieldName ( ) ; 
String checkCountSql = String . format ( 
referenceFieldName , 
referencedTable . name , 
questionMarks ) ; 
PreparedStatement preparedStatement = connection . prepareStatement ( checkCountSql ) ; 
for ( String ref : referenceStrings ) { 
preparedStatement . setString ( oneBasedIndex ++ , ref ) ; 
LOG . info ( preparedStatement . toString ( ) ) ; 
ResultSet resultSet = preparedStatement . executeQuery ( ) ; 
Set < String > foundReferences = new HashSet < > ( ) ; 
String referenceValue = resultSet . getString ( 1 ) ; 
foundReferences . add ( referenceValue ) ; 
referenceStrings . removeAll ( foundReferences ) ; 
if ( referenceStrings . size ( ) > 0 ) { 
referringTableName , 
} private void reconcilePatternStops ( String patternId , List < PatternStop > newStops , Connection connection ) throws SQLException { 
PreparedStatement getStopsStatement = connection . prepareStatement ( getStopIdsSql ) ; 
getStopsStatement . setString ( 1 , patternId ) ; 
LOG . info ( getStopsStatement . toString ( ) ) ; 
ResultSet stopsResults = getStopsStatement . executeQuery ( ) ; 
List < String > originalStopIds = new ArrayList < > ( ) ; 
while ( stopsResults . next ( ) ) { 
originalStopIds . add ( stopsResults . getString ( 1 ) ) ; 
PreparedStatement getTripsStatement = connection . prepareStatement ( getTripIdsSql ) ; 
getTripsStatement . setString ( 1 , patternId ) ; 
ResultSet tripsResults = getTripsStatement . executeQuery ( ) ; 
List < String > tripsForPattern = new ArrayList < > ( ) ; 
while ( tripsResults . next ( ) ) { 
tripsForPattern . add ( tripsResults . getString ( 1 ) ) ; 
if ( tripsForPattern . size ( ) == 0 ) { 
tablePrefix , tablePrefix , tablePrefix , patternId ) ; 
if ( originalStopIds . size ( ) == newStops . size ( ) - 1 ) { 
int differenceLocation = - 1 ; 
for ( int i = 0 ; i < newStops . size ( ) ; i ++ ) { 
if ( differenceLocation != - 1 ) { 
if ( i < originalStopIds . size ( ) && ! originalStopIds . get ( i ) . equals ( newStops . get ( i + 1 ) . stop_id ) ) { 
else if ( i == newStops . size ( ) - 1 || ! originalStopIds . get ( i ) . equals ( newStops . get ( i ) . stop_id ) ) { 
differenceLocation = i ; 
String updateSql = String . format ( 
differenceLocation , 
joinToTrips 
LOG . info ( updateSql ) ; 
PreparedStatement updateStatement = connection . prepareStatement ( updateSql ) ; 
int updated = updateStatement . executeUpdate ( ) ; 
insertBlankStopTimes ( tripsForPattern , newStops , differenceLocation , 1 , connection ) ; 
else if ( originalStopIds . size ( ) == newStops . size ( ) + 1 ) { 
for ( int i = 0 ; i < originalStopIds . size ( ) ; i ++ ) { 
if ( ! originalStopIds . get ( i ) . equals ( newStops . get ( i - 1 ) . stop_id ) ) { 
} else if ( i == originalStopIds . size ( ) - 1 || ! originalStopIds . get ( i ) . equals ( newStops . get ( i ) . stop_id ) ) { 
String deleteSql = String . format ( 
LOG . info ( deleteSql ) ; 
PreparedStatement deleteStatement = connection . prepareStatement ( deleteSql ) ; 
int deleted = deleteStatement . executeUpdate ( ) ; 
String removedStopId = originalStopIds . get ( differenceLocation ) ; 
else if ( originalStopIds . size ( ) == newStops . size ( ) ) { 
int firstDifferentIndex = 0 ; 
while ( originalStopIds . get ( firstDifferentIndex ) . equals ( newStops . get ( firstDifferentIndex ) . stop_id ) ) { 
firstDifferentIndex ++ ; 
if ( firstDifferentIndex == originalStopIds . size ( ) ) 
int lastDifferentIndex = originalStopIds . size ( ) - 1 ; 
while ( originalStopIds . get ( lastDifferentIndex ) . equals ( newStops . get ( lastDifferentIndex ) . stop_id ) ) { 
lastDifferentIndex -- ; 
if ( firstDifferentIndex == lastDifferentIndex ) { 
String conditionalUpdate ; 
int from , to ; 
if ( originalStopIds . get ( firstDifferentIndex ) . equals ( newStops . get ( lastDifferentIndex ) . stop_id ) ) { 
from = firstDifferentIndex ; 
to = lastDifferentIndex ; 
verifyInteriorStopsAreUnchanged ( originalStopIds , newStops , firstDifferentIndex , lastDifferentIndex , true ) ; 
tablePrefix , from , to , from , to , tablePrefix , joinToTrips ) ; 
} else if ( newStops . get ( firstDifferentIndex ) . stop_id . equals ( originalStopIds . get ( lastDifferentIndex ) ) ) { 
from = lastDifferentIndex ; 
to = firstDifferentIndex ; 
verifyInteriorStopsAreUnchanged ( originalStopIds , newStops , firstDifferentIndex , lastDifferentIndex , false ) ; 
PreparedStatement updateStatement = connection . prepareStatement ( conditionalUpdate ) ; 
else if ( originalStopIds . size ( ) < newStops . size ( ) ) { 
while ( 
firstDifferentIndex < originalStopIds . size ( ) && 
originalStopIds . get ( firstDifferentIndex ) . equals ( newStops . get ( firstDifferentIndex ) . stop_id ) 
if ( firstDifferentIndex != originalStopIds . size ( ) ) 
int stopsToInsert = newStops . size ( ) - firstDifferentIndex ; 
insertBlankStopTimes ( tripsForPattern , newStops , firstDifferentIndex , stopsToInsert , connection ) ; 
else throw new IllegalStateException ( RECONCILE_STOPS_ERROR_MSG ) ; 
} private static void verifyInteriorStopsAreUnchanged ( 
List < String > originalStopIds , 
List < PatternStop > newStops , 
int firstDifferentIndex , 
int lastDifferentIndex , 
boolean movedRight 
List < String > newStopIds = newStops . stream ( ) . map ( s -> s . stop_id ) . collect ( Collectors . toList ( ) ) ; 
int beginRegion = movedRight ? firstDifferentIndex : firstDifferentIndex + 1 ; 
int endRegion = movedRight ? lastDifferentIndex - 1 : lastDifferentIndex ; 
for ( int i = beginRegion ; i <= endRegion ; i ++ ) { 
int shiftedIndex = movedRight ? i + 1 : i - 1 ; 
String newStopId = newStopIds . get ( i ) ; 
String originalStopId = originalStopIds . get ( shiftedIndex ) ; 
if ( ! newStopId . equals ( originalStopId ) ) { 
throw new IllegalStateException ( RECONCILE_STOPS_ERROR_MSG ) ; 
} private void insertBlankStopTimes ( 
List < String > tripIds , 
int startingStopSequence , 
int stopTimesToAdd , 
if ( tripIds . isEmpty ( ) ) { 
String insertSql = Table . STOP_TIMES . generateInsertSql ( tablePrefix , true ) ; 
PreparedStatement insertStatement = connection . prepareStatement ( insertSql ) ; 
int totalRowsUpdated = 0 ; 
for ( int i = startingStopSequence ; i < stopTimesToAdd + startingStopSequence ; i ++ ) { 
PatternStop patternStop = newStops . get ( i ) ; 
StopTime stopTime = new StopTime ( ) ; 
stopTime . stop_id = patternStop . stop_id ; 
stopTime . drop_off_type = patternStop . drop_off_type ; 
stopTime . pickup_type = patternStop . pickup_type ; 
stopTime . timepoint = patternStop . timepoint ; 
stopTime . shape_dist_traveled = patternStop . shape_dist_traveled ; 
stopTime . stop_sequence = i ; 
for ( String tripId : tripIds ) { 
stopTime . trip_id = tripId ; 
stopTime . setStatementParameters ( insertStatement , true ) ; 
if ( count % INSERT_BATCH_SIZE == 0 ) { 
int [ ] rowsUpdated = insertStatement . executeBatch ( ) ; 
totalRowsUpdated += rowsUpdated . length ; 
public int deleteWhere ( String fieldName , String value , boolean autoCommit ) throws SQLException { 
String tableName = String . join ( "." , tablePrefix , specTable . name ) ; 
TIntSet idsToDelete = getIdsForCondition ( tableName , fieldName , value , connection ) ; 
TIntIterator iterator = idsToDelete . iterator ( ) ; 
TIntList results = new TIntArrayList ( ) ; 
int id = iterator . next ( ) ; 
int result = delete ( id , false ) ; 
if ( result != 1 ) { 
results . add ( result ) ; 
return results . size ( ) ; 
public int delete ( Integer id , boolean autoCommit ) throws SQLException { 
deleteFromReferencingTables ( tablePrefix , specTable , id ) ; 
PreparedStatement statement = connection . prepareStatement ( specTable . generateDeleteSql ( tablePrefix ) ) ; 
statement . setInt ( 1 , id ) ; 
int result = statement . executeUpdate ( ) ; 
if ( autoCommit ) connection . close ( ) ; 
} private void deleteFromReferencingTables ( String namespace , Table table , int id ) throws SQLException { 
updateReferencingTables ( namespace , table , id , null ) ; 
} private static long handleStatementExecution ( PreparedStatement statement , boolean isCreating ) throws SQLException { 
int affectedRows = statement . executeUpdate ( ) ; 
String messageAction = isCreating ? "Creating" : "Updating" ; 
if ( affectedRows == 0 ) { 
try ( ResultSet generatedKeys = statement . getGeneratedKeys ( ) ) { 
if ( generatedKeys . next ( ) ) { 
long newId = generatedKeys . getLong ( 1 ) ; 
return newId ; 
} private void ensureReferentialIntegrity ( 
String namespace , 
Integer id 
String keyField = table . getKeyFieldName ( ) ; 
String tableName = String . join ( "." , namespace , table . name ) ; 
if ( jsonObject . get ( keyField ) == null || jsonObject . get ( keyField ) . isNull ( ) ) { 
if ( "trip_id" . equals ( keyField ) ) { 
jsonObject . put ( keyField , UUID . randomUUID ( ) . toString ( ) ) ; 
} else if ( "agency_id" . equals ( keyField ) ) { 
int rowSize = getRowCount ( tableName , connection ) ; 
if ( rowSize > 1 || ( isCreating && rowSize > 0 ) ) { 
String keyValue = jsonObject . get ( keyField ) . asText ( ) ; 
TIntSet uniqueIds = getIdsForCondition ( tableName , keyField , keyValue , connection ) ; 
int size = uniqueIds . size ( ) ; 
if ( size == 0 || ( size == 1 && id != null && uniqueIds . contains ( id ) ) ) { 
if ( size == 0 && ! isCreating ) { 
updateReferencingTables ( namespace , table , id , keyValue ) ; 
table . entityClass . getSimpleName ( ) , 
keyValue ) 
if ( ! uniqueIds . contains ( id ) ) { 
} else if ( size > 1 ) { 
size , 
keyValue ) ; 
LOG . error ( message ) ; 
throw new SQLException ( message ) ; 
} private static int getRowCount ( String tableName , Connection connection ) throws SQLException { 
LOG . info ( rowCountSql ) ; 
ResultSet resultSet = statement . executeQuery ( rowCountSql ) ; 
if ( resultSet . next ( ) ) return resultSet . getInt ( 1 ) ; 
} private static TIntSet getIdsForCondition ( 
String tableName , 
String keyValue , 
PreparedStatement statement = connection . prepareStatement ( idCheckSql ) ; 
TIntSet uniqueIds = new TIntHashSet ( ) ; 
int uniqueId = resultSet . getInt ( 1 ) ; 
uniqueIds . add ( uniqueId ) ; 
return uniqueIds ; 
} private static Set < Table > getReferencingTables ( Table table ) { 
Set < Table > referencingTables = new HashSet < > ( ) ; 
for ( Table gtfsTable : Table . tablesInOrder ) { 
if ( table . name . equals ( gtfsTable . name ) ) continue ; 
for ( Field field : gtfsTable . fields ) { 
if ( field . isForeignReference ( ) && field . referenceTable . name . equals ( table . name ) ) { 
referencingTables . add ( gtfsTable ) ; 
return referencingTables ; 
} private static String getValueForId ( int id , String fieldName , String namespace , Table table , Connection connection ) throws SQLException { 
LOG . info ( selectIdSql ) ; 
Statement selectIdStatement = connection . createStatement ( ) ; 
ResultSet selectResults = selectIdStatement . executeQuery ( selectIdSql ) ; 
value = selectResults . getString ( 1 ) ; 
} private void updateReferencingTables ( 
String newKeyValue 
Field keyField = table . getFieldForName ( table . getKeyFieldName ( ) ) ; 
Class < ? extends Entity > entityClass = table . getEntityClass ( ) ; 
SqlMethod sqlMethod = newKeyValue != null ? SqlMethod . UPDATE : SqlMethod . DELETE ; 
Set < Table > referencingTables = getReferencingTables ( table ) ; 
if ( referencingTables . size ( ) == 0 ) return ; 
String keyValue = getValueForId ( id , keyField . name , namespace , table , connection ) ; 
if ( keyValue == null ) { 
String refTableName = String . join ( "." , namespace , referencingTable . name ) ; 
for ( Field field : referencingTable . editorFields ( ) ) { 
Table . TRIPS . name . equals ( referencingTable . name ) && 
sqlMethod . equals ( SqlMethod . DELETE ) && 
table . name . equals ( Table . PATTERNS . name ) 
String stopTimesTable = String . join ( "." , namespace , "stop_times" ) ; 
String frequenciesTable = String . join ( "." , namespace , "frequencies" ) ; 
String tripsTable = String . join ( "." , namespace , "trips" ) ; 
String deleteStopTimes = String . format ( 
stopTimesTable , tripsTable , stopTimesTable , tripsTable , tripsTable ) ; 
PreparedStatement deleteStopTimesStatement = connection . prepareStatement ( deleteStopTimes ) ; 
deleteStopTimesStatement . setString ( 1 , keyValue ) ; 
LOG . info ( deleteStopTimesStatement . toString ( ) ) ; 
int deletedStopTimes = deleteStopTimesStatement . executeUpdate ( ) ; 
String deleteFrequencies = String . format ( 
frequenciesTable , tripsTable , frequenciesTable , tripsTable , tripsTable ) ; 
PreparedStatement deleteFrequenciesStatement = connection . prepareStatement ( deleteFrequencies ) ; 
deleteFrequenciesStatement . setString ( 1 , keyValue ) ; 
LOG . info ( deleteFrequenciesStatement . toString ( ) ) ; 
int deletedFrequencies = deleteFrequenciesStatement . executeUpdate ( ) ; 
PreparedStatement updateStatement = getUpdateReferencesStatement ( sqlMethod , refTableName , field , keyValue , newKeyValue ) ; 
int result = updateStatement . executeUpdate ( ) ; 
if ( result > 0 ) { 
if ( sqlMethod . equals ( SqlMethod . DELETE ) ) { 
if ( table . isCascadeDeleteRestricted ( ) ) { 
entityClass . getSimpleName ( ) , 
keyField . name , 
keyValue , 
result , 
referencingTable . name , 
entityClass . getSimpleName ( ) 
} private PreparedStatement getUpdateReferencesStatement ( 
SqlMethod sqlMethod , 
String refTableName , 
Field keyField , 
String sql ; 
PreparedStatement statement ; 
boolean isArrayField = keyField . getSqlType ( ) . equals ( JDBCType . ARRAY ) ; 
switch ( sqlMethod ) { 
case DELETE : 
if ( isArrayField ) { 
refTableName , 
keyField . name 
statement = connection . prepareStatement ( sql ) ; 
return statement ; 
case UPDATE : 
statement . setString ( 2 , newKeyValue ) ; 
String [ ] values = new String [ ] { keyValue } ; 
statement . setArray ( 3 , connection . createArrayOf ( "text" , values ) ) ; 
statement . setString ( 1 , newKeyValue ) ; 
statement . setString ( 2 , keyValue ) ; 
statement . setString ( oneBasedIndex ++ , agency_id ) ; 
statement . setString ( oneBasedIndex ++ , agency_name ) ; 
statement . setString ( oneBasedIndex ++ , agency_url != null ? agency_url . toString ( ) : null ) ; 
statement . setString ( oneBasedIndex ++ , agency_timezone ) ; 
statement . setString ( oneBasedIndex ++ , agency_lang ) ; 
statement . setString ( oneBasedIndex ++ , agency_phone ) ; 
statement . setString ( oneBasedIndex ++ , agency_branding_url != null ? agency_branding_url . toString ( ) : null ) ; 
statement . setString ( oneBasedIndex ++ , agency_fare_url != null ? agency_fare_url . toString ( ) : null ) ; 
statement . setString ( oneBasedIndex ++ , agency_email ) ; 
} public T put ( String id , File feedFile ) throws Exception { 
return put ( id , feedFile , null ) ; 
} public T put ( Function < GTFSFeed , String > idGenerator , File feedFile ) throws Exception { 
return put ( null , feedFile , idGenerator ) ; 
} private T retrieveAndProcessFeed ( String originalId ) { 
String id = cleanId ( originalId ) ; 
String key = bucketFolder != null ? String . join ( "/" , bucketFolder , id ) : id ; 
File dbFile = new File ( cacheDir , id + ".db" ) ; 
GTFSFeed feed ; 
if ( dbFile . exists ( ) ) { 
feed = new GTFSFeed ( dbFile . getAbsolutePath ( ) ) ; 
if ( feed != null ) { 
return processFeed ( feed ) ; 
deleteLocalDBFiles ( id ) ; 
if ( bucket != null ) { 
S3Object db = s3 . getObject ( bucket , key + ".db" ) ; 
InputStream is = db . getObjectContent ( ) ; 
FileOutputStream fos = new FileOutputStream ( dbFile ) ; 
ByteStreams . copy ( is , fos ) ; 
S3Object dbp = s3 . getObject ( bucket , key + ".db.p" ) ; 
InputStream isp = dbp . getObjectContent ( ) ; 
FileOutputStream fosp = new FileOutputStream ( new File ( cacheDir , id + ".db.p" ) ) ; 
ByteStreams . copy ( isp , fosp ) ; 
isp . close ( ) ; 
fosp . close ( ) ; 
} catch ( AmazonS3Exception e ) { 
} catch ( ExecutionException | IOException e ) { 
File feedFile = new File ( cacheDir , id + ".zip" ) ; 
if ( feedFile . exists ( ) ) { 
if ( ! feedFile . exists ( ) && bucket != null ) { 
S3Object gtfs = s3 . getObject ( bucket , key + ".zip" ) ; 
InputStream is = gtfs . getObjectContent ( ) ; 
FileOutputStream fos = new FileOutputStream ( feedFile ) ; 
return put ( originalId , feedFile ) ; 
throw new NoSuchElementException ( originalId ) ; 
} public boolean activeOn ( LocalDate date ) { 
CalendarDate exception = calendar_dates . get ( date ) ; 
if ( exception != null ) 
return exception . exception_type == 1 ; 
else if ( calendar == null ) 
boolean outsideValidityRange = date . isAfter ( calendar . end_date ) || date . isBefore ( calendar . start_date ) ; 
if ( outsideValidityRange ) return false ; 
switch ( date . getDayOfWeek ( ) ) { 
case MONDAY : 
return calendar . monday == 1 ; 
case TUESDAY : 
return calendar . tuesday == 1 ; 
case WEDNESDAY : 
return calendar . wednesday == 1 ; 
case THURSDAY : 
return calendar . thursday == 1 ; 
case FRIDAY : 
return calendar . friday == 1 ; 
case SATURDAY : 
return calendar . saturday == 1 ; 
case SUNDAY : 
return calendar . sunday == 1 ; 
setIntParameter ( statement , oneBasedIndex ++ , stop_sequence ) ; 
statement . setString ( oneBasedIndex ++ , stop_id ) ; 
setIntParameter ( statement , oneBasedIndex ++ , arrival_time ) ; 
setIntParameter ( statement , oneBasedIndex ++ , departure_time ) ; 
statement . setString ( oneBasedIndex ++ , stop_headsign ) ; 
setIntParameter ( statement , oneBasedIndex ++ , pickup_type ) ; 
setIntParameter ( statement , oneBasedIndex ++ , drop_off_type ) ; 
setIntParameter ( statement , oneBasedIndex ++ , timepoint ) ; 
statement . setString ( oneBasedIndex ++ , route_short_name ) ; 
statement . setString ( oneBasedIndex ++ , route_long_name ) ; 
statement . setString ( oneBasedIndex ++ , route_desc ) ; 
setIntParameter ( statement , oneBasedIndex ++ , route_type ) ; 
statement . setString ( oneBasedIndex ++ , route_url != null ? route_url . toString ( ) : null ) ; 
statement . setString ( oneBasedIndex ++ , route_branding_url != null ? route_branding_url . toString ( ) : null ) ; 
statement . setString ( oneBasedIndex ++ , route_color ) ; 
statement . setString ( oneBasedIndex ++ , route_text_color ) ; 
setIntParameter ( statement , oneBasedIndex ++ , 0 ) ; 
setIntParameter ( statement , oneBasedIndex ++ , route_sort_order ) ; 
} public static GraphQLFieldDefinition field ( String tableName ) { 
. name ( tableName ) 
. type ( new GraphQLList ( GraphQLGtfsSchema . routeType ) ) 
. argument ( stringArg ( "namespace" ) ) 
. argument ( multiStringArg ( "route_id" ) ) 
. dataFetcher ( new JDBCFetcher ( tableName , null ) ) 
public List < Map < String , Object > > get ( DataFetchingEnvironment environment ) { 
Map < String , Object > parentEntityMap = environment . getSource ( ) ; 
String namespace = ( String ) parentEntityMap . get ( "namespace" ) ; 
List < String > parentJoinValues = new ArrayList < > ( ) ; 
if ( parentJoinField != null ) { 
Map < String , Object > enclosingEntity = environment . getSource ( ) ; 
Object parentJoinValue = enclosingEntity . get ( parentJoinField ) ; 
String parentJoinString = parentJoinValue == null ? null : parentJoinValue . toString ( ) ; 
parentJoinValues . add ( parentJoinString ) ; 
if ( parentJoinValue == null ) { 
Map < String , Object > arguments = environment . getArguments ( ) ; 
return getResults ( namespace , parentJoinValues , arguments ) ; 
} List < Map < String , Object > > getResults ( 
List < String > parentJoinValues , 
Map < String , Object > graphQLQueryArguments 
List < String > preparedStatementParameters = new ArrayList < > ( ) ; 
List < Map < String , Object > > results = new ArrayList < > ( ) ; 
if ( graphQLQueryArguments == null ) graphQLQueryArguments = new HashMap < > ( ) ; 
validateNamespace ( namespace ) ; 
StringBuilder sqlBuilder = new StringBuilder ( ) ; 
Set < String > fromTables = new HashSet < > ( ) ; 
fromTables . add ( String . join ( "." , namespace , tableName ) ) ; 
List < String > whereConditions = new ArrayList < > ( ) ; 
String sortBy = "" ; 
if ( childJoinField != null && parentJoinValues != null && ! parentJoinValues . isEmpty ( ) ) { 
if ( filterByExistingColumns ( namespace , childJoinField ) . contains ( childJoinField ) ) { 
whereConditions . add ( 
makeInClause ( childJoinField , parentJoinValues , preparedStatementParameters ) 
LOG . warn ( 
childJoinField , 
namespace , 
tableName 
if ( sortField != null ) { 
Set < String > argumentKeys = graphQLQueryArguments . keySet ( ) ; 
for ( String key : argumentKeys ) { 
if ( argsToSkip . contains ( key ) ) continue ; 
if ( ID_ARG . equals ( key ) ) { 
Integer value = ( Integer ) graphQLQueryArguments . get ( key ) ; 
List < String > values = ( List < String > ) graphQLQueryArguments . get ( key ) ; 
if ( values != null && ! values . isEmpty ( ) ) 
whereConditions . add ( makeInClause ( key , values , preparedStatementParameters ) ) ; 
if ( argumentKeys . containsAll ( boundingBoxArgs ) ) { 
Set < String > boundsConditions = new HashSet < > ( ) ; 
for ( String bound : boundingBoxArgs ) { 
Double value = ( Double ) graphQLQueryArguments . get ( bound ) ; 
String field = bound . toLowerCase ( ) . endsWith ( "lon" ) ? "stop_lon" : "stop_lat" ; 
String fieldWithNamespace = String . join ( "." , namespace , "stops" , field ) ; 
boundsConditions . add ( String . join ( delimiter , fieldWithNamespace , value . toString ( ) ) ) ; 
if ( "stops" . equals ( tableName ) ) { 
whereConditions . addAll ( boundsConditions ) ; 
} else if ( "patterns" . equals ( tableName ) ) { 
fromTables . add ( 
namespace 
if ( argumentKeys . contains ( DATE_ARG ) ) { 
String tripsTable = String . format ( "%s.trips" , namespace ) ; 
fromTables . add ( tripsTable ) ; 
String date = getDateArgument ( graphQLQueryArguments ) ; 
fromTables . add ( String . format ( 
namespace ) 
preparedStatementParameters . add ( 0 , date ) ; 
if ( argumentKeys . contains ( FROM_ARG ) && argumentKeys . contains ( TO_ARG ) ) { 
String timeFilteredTrips = "trips_beginning_in_time_period" ; 
( int ) graphQLQueryArguments . get ( FROM_ARG ) , 
( int ) graphQLQueryArguments . get ( TO_ARG ) , 
timeFilteredTrips ) ) ; 
if ( argumentKeys . contains ( SEARCH_ARG ) ) { 
String value = ( String ) graphQLQueryArguments . get ( SEARCH_ARG ) ; 
if ( ! value . isEmpty ( ) ) { 
String [ ] searchColumns = new String [ ] { } ; 
switch ( tableName ) { 
case "stops" : 
searchColumns = stopSearchColumns ; 
searchColumns = routeSearchColumns ; 
Set < String > searchFields = filterByExistingColumns ( namespace , searchColumns ) ; 
List < String > searchClauses = new ArrayList < > ( ) ; 
for ( String field : searchFields ) { 
preparedStatementParameters . add ( String . format ( "%%%s%%" , value ) ) ; 
if ( ! searchClauses . isEmpty ( ) ) { 
if ( ! whereConditions . isEmpty ( ) ) { 
sqlBuilder . append ( sortBy ) ; 
Integer limit = ( Integer ) graphQLQueryArguments . get ( LIMIT_ARG ) ; 
limit = autoLimit ? DEFAULT_ROWS_TO_FETCH : - 1 ; 
if ( limit > MAX_ROWS_TO_FETCH ) { 
limit = MAX_ROWS_TO_FETCH ; 
if ( limit == - 1 ) { 
Integer offset = ( Integer ) graphQLQueryArguments . get ( OFFSET_ARG ) ; 
if ( offset != null && offset >= 0 ) { 
connection = GTFSGraphQL . getConnection ( ) ; 
PreparedStatement preparedStatement = connection . prepareStatement ( sqlBuilder . toString ( ) ) ; 
for ( String parameter : preparedStatementParameters ) { 
preparedStatement . setString ( oneBasedIndex ++ , parameter ) ; 
if ( preparedStatement . execute ( ) ) { 
ResultSet resultSet = preparedStatement . getResultSet ( ) ; 
ResultSetMetaData meta = resultSet . getMetaData ( ) ; 
int nColumns = meta . getColumnCount ( ) ; 
Map < String , Object > resultMap = new HashMap < > ( ) ; 
resultMap . put ( "namespace" , namespace ) ; 
for ( int i = 1 ; i <= nColumns ; i ++ ) { 
resultMap . put ( meta . getColumnName ( i ) , resultSet . getObject ( i ) ) ; 
results . add ( resultMap ) ; 
} private Set < String > filterByExistingColumns ( String namespace , String ... columnsToCheck ) { 
Set < String > columnsForTable = new HashSet < > ( ) ; 
ResultSet columns = connection 
. getMetaData ( ) 
. getColumns ( null , namespace , tableName , null ) ; 
while ( columns . next ( ) ) { 
String column = columns . getString ( 4 ) ; 
columnsForTable . add ( column ) ; 
columnsForTable . retainAll ( Arrays . asList ( columnsToCheck ) ) ; 
return columnsForTable ; 
} static String filterEquals ( String filterField , String string , List < String > parameters ) { 
parameters . add ( string ) ; 
} static String makeInClause ( String filterField , List < String > strings , List < String > parameters ) { 
if ( strings . size ( ) == 1 ) { 
return filterEquals ( filterField , strings . get ( 0 ) , parameters ) ; 
parameters . addAll ( strings ) ; 
} public static void initialize ( DataSource dataSource ) { 
GTFSGraphQL . dataSource = dataSource ; 
GRAPHQL = GraphQL . newGraphQL ( GraphQLGtfsSchema . feedBasedSchema ) 
} public List < Field > editorFields ( ) { 
List < Field > editorFields = new ArrayList < > ( ) ; 
for ( Field f : fields ) if ( f . requirement == REQUIRED || f . requirement == OPTIONAL || f . requirement == EDITOR ) { 
editorFields . add ( f ) ; 
return editorFields ; 
} public List < Field > requiredFields ( ) { 
List < Field > requiredFields = new ArrayList < > ( ) ; 
for ( Field f : fields ) if ( f . requirement == REQUIRED ) requiredFields . add ( f ) ; 
return requiredFields ; 
} public List < Field > specFields ( ) { 
List < Field > specFields = new ArrayList < > ( ) ; 
for ( Field f : fields ) if ( f . requirement == REQUIRED || f . requirement == OPTIONAL ) specFields . add ( f ) ; 
return specFields ; 
} public boolean createSqlTable ( Connection connection , String namespace , boolean makeIdSerial , String [ ] primaryKeyFields ) { 
String tableName = namespace != null ? String . join ( "." , namespace , name ) : name ; 
String fieldDeclarations = Arrays . stream ( fields ) 
. map ( Field :: getSqlDeclaration ) 
if ( primaryKeyFields != null ) { 
String idFieldType = makeIdSerial ? "serial" : "bigint" ; 
LOG . info ( dropSql ) ; 
statement . execute ( dropSql ) ; 
LOG . info ( createSql ) ; 
return statement . execute ( createSql ) ; 
} public String generateInsertSql ( String namespace , boolean setDefaultId ) { 
String tableName = namespace == null 
: String . join ( "." , namespace , name ) ; 
String joinedFieldNames = commaSeparatedNames ( editorFields ( ) ) ; 
String idValue = setDefaultId ? "DEFAULT" : "?" ; 
tableName , 
joinedFieldNames , 
idValue , 
} public CsvReader getCsvReader ( ZipFile zipFile , SQLErrorStorage sqlErrorStorage ) { 
final String tableFileName = this . name + ".txt" ; 
ZipEntry entry = zipFile . getEntry ( tableFileName ) ; 
Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; 
ZipEntry e = entries . nextElement ( ) ; 
if ( e . getName ( ) . endsWith ( tableFileName ) ) { 
entry = e ; 
if ( sqlErrorStorage != null ) sqlErrorStorage . storeError ( NewGTFSError . forTable ( this , TABLE_IN_SUBDIRECTORY ) ) ; 
InputStream zipInputStream = zipFile . getInputStream ( entry ) ; 
InputStream bomInputStream = new BOMInputStream ( zipInputStream ) ; 
CsvReader csvReader = new CsvReader ( bomInputStream , ',' , Charset . forName ( "UTF8" ) ) ; 
csvReader . readHeaders ( ) ; 
return csvReader ; 
} public static String commaSeparatedNames ( List < Field > fieldsToJoin , String prefix , boolean csvOutput ) { 
return fieldsToJoin . stream ( ) 
. map ( f -> f . getColumnExpression ( prefix , csvOutput ) ) 
} public String generateUpdateSql ( String namespace , int id ) { 
String joinedFieldNames = editorFields ( ) . stream ( ) 
String tableName = namespace == null ? name : String . join ( "." , namespace , name ) ; 
} public String generateSelectSql ( String namespace , Requirement minimumRequirement ) { 
String fieldsString ; 
String tableName = String . join ( "." , namespace , name ) ; 
String fieldPrefix = tableName + "." ; 
if ( minimumRequirement . equals ( EDITOR ) ) { 
fieldsString = commaSeparatedNames ( editorFields ( ) , fieldPrefix , true ) ; 
} else if ( minimumRequirement . equals ( OPTIONAL ) ) { 
fieldsString = commaSeparatedNames ( specFields ( ) , fieldPrefix , true ) ; 
} else if ( minimumRequirement . equals ( REQUIRED ) ) { 
fieldsString = commaSeparatedNames ( requiredFields ( ) , fieldPrefix , true ) ; 
} else fieldsString = "*" ; 
} public String generateSelectAllExistingFieldsSql ( Connection connection , String namespace ) throws SQLException { 
PreparedStatement statement = connection . prepareStatement ( 
statement . setString ( 1 , namespace ) ; 
statement . setString ( 2 , name ) ; 
ResultSet result = statement . executeQuery ( ) ; 
List < Field > existingFields = new ArrayList < > ( ) ; 
while ( result . next ( ) ) { 
String columnName = result . getString ( 1 ) ; 
existingFields . add ( getFieldForName ( columnName ) ) ; 
} public String generateJoinSql ( String optionalSelect , Table joinTable , String joinType , String namespace , String fieldName , boolean prefixTableName ) { 
fieldName = getKeyFieldName ( ) ; 
if ( joinType == null ) { 
String joinTableQuery ; 
String joinTableName ; 
if ( optionalSelect != null ) { 
joinTableName = joinTable . name ; 
joinTableQuery = joinTableName = String . format ( "%s.%s" , namespace , joinTable . name ) ; 
String tableName = prefixTableName ? String . format ( "%s.%s" , namespace , this . name ) : this . name ; 
joinType , 
joinTableQuery , 
tableName , fieldName , 
joinTableName , fieldName ) ; 
} public String generateDeleteSql ( String namespace , String fieldName ) { 
String whereField = fieldName == null ? "id" : fieldName ; 
} public String getOrderFieldName ( ) { 
String name = fields [ 1 ] . name ; 
if ( name . contains ( "_sequence" ) || compoundKey ) return name ; 
} public String getIndexFields ( ) { 
String orderFieldName = getOrderFieldName ( ) ; 
if ( orderFieldName == null ) return getKeyFieldName ( ) ; 
else return String . join ( "," , getKeyFieldName ( ) , orderFieldName ) ; 
} public void createIndexes ( Connection connection , String namespace ) throws SQLException { 
if ( "agency" . equals ( name ) || "feed_info" . equals ( name ) ) { 
String tableName ; 
if ( namespace == null ) { 
tableName = namespace . endsWith ( "." ) ? namespace + name : String . join ( "." , namespace , name ) ; 
String indexColumns = getIndexFields ( ) ; 
String indexName = String . join ( "_" , tableName . replace ( "." , "_" ) , "idx" ) ; 
LOG . info ( indexSql ) ; 
connection . createStatement ( ) . execute ( indexSql ) ; 
if ( field . shouldBeIndexed ( ) ) { 
String fieldIndex = String . join ( "_" , tableName . replace ( "." , "_" ) , field . name , "idx" ) ; 
LOG . info ( sql ) ; 
statement . execute ( sql ) ; 
} public boolean createSqlTableFrom ( Connection connection , String tableToClone ) { 
if ( tableToClone . endsWith ( "stop_times" ) ) { 
normalizeAndCloneStopTimes ( statement , name , tableToClone ) ; 
LOG . info ( createTableAsSql ) ; 
statement . execute ( createTableAsSql ) ; 
applyAutoIncrementingSequence ( statement ) ; 
if ( usePrimaryKey ) { 
LOG . info ( addPrimaryKeySql ) ; 
statement . execute ( addPrimaryKeySql ) ; 
createSqlTable ( connection , true ) ; 
} private void normalizeAndCloneStopTimes ( Statement statement , String name , String tableToClone ) throws SQLException { 
LOG . info ( createTableLikeSql ) ; 
statement . execute ( createTableLikeSql ) ; 
long normalizeStartTime = System . currentTimeMillis ( ) ; 
List < String > columns = new ArrayList < > ( ) ; 
ResultSetMetaData metadata = resultSet . getMetaData ( ) ; 
int nColumns = metadata . getColumnCount ( ) ; 
columns . add ( metadata . getColumnName ( i ) ) ; 
LOG . info ( insertAllSql ) ; 
statement . execute ( insertAllSql ) ; 
} private void applyAutoIncrementingSequence ( Statement statement ) throws SQLException { 
int maxID = 0 ; 
LOG . info ( selectMaxSql ) ; 
statement . execute ( selectMaxSql ) ; 
ResultSet maxIdResult = statement . getResultSet ( ) ; 
if ( maxIdResult . next ( ) ) { 
maxID = maxIdResult . getInt ( 1 ) ; 
if ( maxID < 1 ) { 
maxID = 1 ; 
String sequenceName = name + "_id_seq" ; 
LOG . info ( createSequenceSql ) ; 
statement . execute ( createSequenceSql ) ; 
LOG . info ( alterColumnNextSql ) ; 
statement . execute ( alterColumnNextSql ) ; 
LOG . info ( alterColumnNotNullSql ) ; 
statement . execute ( alterColumnNotNullSql ) ; 
} public Field [ ] getFieldsFromFieldHeaders ( String [ ] headers , SQLErrorStorage errorStorage ) { 
Field [ ] fields = new Field [ headers . length ] ; 
Set < String > fieldsSeen = new HashSet < > ( ) ; 
for ( int h = 0 ; h < headers . length ; h ++ ) { 
String header = sanitize ( headers [ h ] , errorStorage ) ; 
if ( fieldsSeen . contains ( header ) || "id" . equals ( header ) ) { 
if ( errorStorage != null ) errorStorage . storeError ( NewGTFSError . forTable ( this , DUPLICATE_HEADER ) . setBadValue ( header ) ) ; 
fields [ h ] = null ; 
fields [ h ] = getFieldForName ( header ) ; 
fieldsSeen . add ( header ) ; 
} public int getKeyFieldIndex ( Field [ ] fields ) { 
String keyField = getKeyFieldName ( ) ; 
return Field . getFieldIndex ( fields , keyField ) ; 
} public static String randomIdString ( ) { 
MersenneTwister twister = new MersenneTwister ( ) ; 
final int length = 27 ; 
chars [ i ] = ( char ) ( 'a' + twister . nextInt ( 26 ) ) ; 
chars [ 4 ] = '_' ; 
} public static void ensureValidNamespace ( String namespace ) throws InvalidNamespaceException { 
Pattern pattern = Pattern . compile ( "[^a-zA-Z0-9_\\.]" ) ; 
Matcher matcher = pattern . matcher ( namespace ) ; 
throw new InvalidNamespaceException ( ) ; 
} public static int getFieldIndex ( Field [ ] fields , String name ) { 
for ( int i = 0 ; i < fields . length ; i ++ ) if ( fields [ i ] . name . equals ( name ) ) return i ; 
} public String getColumnExpression ( String prefix , boolean csvOutput ) { 
return prefix != null ? String . format ( "%s%s" , prefix , name ) : name ; 
public Set < Integer > keySet ( ) { 
Set < Integer > ret = new LinkedHashSet < > ( ) ; 
for ( Tuple2 < String , Integer > t : wrapped . keySet ( ) ) { 
ret . add ( t . b ) ; 
return Collections . unmodifiableSet ( ret ) ; 
} public Set < NewGTFSError > setParameter ( PreparedStatement preparedStatement , int oneBasedIndex , LocalDate localDate ) { 
if ( localDate == null ) setNull ( preparedStatement , oneBasedIndex ) ; 
else preparedStatement . setString ( oneBasedIndex , localDate . format ( GTFS_DATE_FORMATTER ) ) ; 
throw new StorageException ( e ) ; 
} public void loadFromFile ( ZipFile zip , String fid ) throws Exception { 
checksum = zip . stream ( ) . mapToLong ( ZipEntry :: getCrc ) . reduce ( ( l1 , l2 ) -> l1 ^ l2 ) . getAsLong ( ) ; 
db . getAtomicLong ( "checksum" ) . set ( checksum ) ; 
new FeedInfo . Loader ( this ) . loadTable ( zip ) ; 
if ( fid != null ) { 
feedId = fid ; 
else if ( feedId == null || feedId . isEmpty ( ) ) { 
feedId = new File ( zip . getName ( ) ) . getName ( ) . replaceAll ( "\\.zip$" , "" ) ; 
db . getAtomicString ( "feed_id" ) . set ( feedId ) ; 
new Agency . Loader ( this ) . loadTable ( zip ) ; 
Map < String , Service > serviceTable = new HashMap < > ( ) ; 
new Calendar . Loader ( this , serviceTable ) . loadTable ( zip ) ; 
new CalendarDate . Loader ( this , serviceTable ) . loadTable ( zip ) ; 
this . services . putAll ( serviceTable ) ; 
serviceTable = null ; 
Map < String , Fare > fares = new HashMap < > ( ) ; 
new FareAttribute . Loader ( this , fares ) . loadTable ( zip ) ; 
new FareRule . Loader ( this , fares ) . loadTable ( zip ) ; 
this . fares . putAll ( fares ) ; 
fares = null ; 
new Route . Loader ( this ) . loadTable ( zip ) ; 
new ShapePoint . Loader ( this ) . loadTable ( zip ) ; 
new Stop . Loader ( this ) . loadTable ( zip ) ; 
new Transfer . Loader ( this ) . loadTable ( zip ) ; 
new Trip . Loader ( this ) . loadTable ( zip ) ; 
new Frequency . Loader ( this ) . loadTable ( zip ) ; 
new StopTime . Loader ( this ) . loadTable ( zip ) ; 
for ( GTFSError error : errors ) { 
LOG . info ( "{}" , error ) ; 
Bind . histogram ( stop_times , stopCountByStopTime , ( key , stopTime ) -> stopTime . stop_id ) ; 
Bind . secondaryKeys ( stop_times , stopStopTimeSet , ( key , stopTime ) -> new String [ ] { stopTime . stop_id } ) ; 
Bind . secondaryKeys ( trips , tripsPerService , ( key , trip ) -> new String [ ] { trip . service_id } ) ; 
Bind . secondaryKeys ( services , servicesPerDate , ( key , service ) -> { 
LocalDate startDate = service . calendar != null 
? service . calendar . start_date 
: service . calendar_dates . keySet ( ) . stream ( ) . sorted ( ) . findFirst ( ) . get ( ) ; 
LocalDate endDate = service . calendar != null 
? service . calendar . end_date 
: service . calendar_dates . keySet ( ) . stream ( ) . sorted ( ) . reduce ( ( first , second ) -> second ) . get ( ) ; 
int daysOfService = ( int ) ChronoUnit . DAYS . between ( startDate , endDate . plus ( 1 , ChronoUnit . DAYS ) ) ; 
return IntStream . range ( 0 , daysOfService ) 
. mapToObj ( offset -> startDate . plusDays ( offset ) ) 
. filter ( service :: activeOn ) 
. map ( date -> date . format ( dateFormatter ) ) 
. toArray ( size -> new String [ size ] ) ; 
loaded = true ; 
} public void validate ( boolean repair , Validator ... validators ) { 
long startValidation = System . currentTimeMillis ( ) ; 
for ( Validator validator : validators ) { 
long startValidator = System . currentTimeMillis ( ) ; 
long endValidator = System . currentTimeMillis ( ) ; 
long diff = endValidator - startValidator ; 
long endValidation = System . nanoTime ( ) ; 
long total = endValidation - startValidation ; 
} public static GTFSFeed fromFile ( String file , String feedId ) { 
ZipFile zip ; 
zip = new ZipFile ( file ) ; 
if ( feedId == null ) { 
feed . loadFromFile ( zip ) ; 
feed . loadFromFile ( zip , feedId ) ; 
return feed ; 
} public STRtree getSpatialIndex ( ) { 
if ( this . spatialIndex == null ) { 
STRtree stopIndex = new STRtree ( ) ; 
for ( Stop stop : this . stops . values ( ) ) { 
if ( Double . isNaN ( stop . stop_lat ) || Double . isNaN ( stop . stop_lon ) ) { 
Coordinate stopCoord = new Coordinate ( stop . stop_lat , stop . stop_lon ) ; 
stopIndex . insert ( new Envelope ( stopCoord ) , stop ) ; 
stopIndex . build ( ) ; 
this . spatialIndex = stopIndex ; 
return this . spatialIndex ; 
} public void findPatterns ( ) { 
PatternFinder patternFinder = new PatternFinder ( ) ; 
for ( Trip trip : this . trips . values ( ) ) { 
Iterable < StopTime > orderedStopTimesForTrip = this . getOrderedStopTimesForTrip ( trip . trip_id ) ; 
patternFinder . processTrip ( trip , orderedStopTimesForTrip ) ; 
Map < TripPatternKey , Pattern > patternObjects = patternFinder . createPatternObjects ( this . stops , null ) ; 
this . patterns . putAll ( patternObjects . values ( ) . stream ( ) 
. collect ( Collectors . toMap ( Pattern :: getId , pattern -> pattern ) ) ) ; 
} public Iterable < StopTime > getInterpolatedStopTimesForTrip ( String trip_id ) throws FirstAndLastStopsDoNotHaveTimes { 
StopTime [ ] stopTimes = StreamSupport . stream ( getOrderedStopTimesForTrip ( trip_id ) . spliterator ( ) , false ) 
. map ( st -> st . clone ( ) ) 
. toArray ( i -> new StopTime [ i ] ) ; 
if ( stopTimes . length == 0 ) return Collections . emptyList ( ) ; 
if ( st . arrival_time != Entity . INT_MISSING && st . departure_time == Entity . INT_MISSING ) { 
st . departure_time = st . arrival_time ; 
if ( st . arrival_time == Entity . INT_MISSING && st . departure_time != Entity . INT_MISSING ) { 
st . arrival_time = st . departure_time ; 
if ( stopTimes [ 0 ] . departure_time == Entity . INT_MISSING || stopTimes [ stopTimes . length - 1 ] . departure_time == Entity . INT_MISSING ) { 
throw new FirstAndLastStopsDoNotHaveTimes ( ) ; 
int startOfInterpolatedBlock = - 1 ; 
for ( int stopTime = 0 ; stopTime < stopTimes . length ; stopTime ++ ) { 
if ( stopTimes [ stopTime ] . departure_time == Entity . INT_MISSING && startOfInterpolatedBlock == - 1 ) { 
startOfInterpolatedBlock = stopTime ; 
else if ( stopTimes [ stopTime ] . departure_time != Entity . INT_MISSING && startOfInterpolatedBlock != - 1 ) { 
int nInterpolatedStops = stopTime - startOfInterpolatedBlock ; 
double totalLengthOfInterpolatedSection = 0 ; 
double [ ] lengthOfInterpolatedSections = new double [ nInterpolatedStops ] ; 
GeodeticCalculator calc = new GeodeticCalculator ( ) ; 
for ( int stopTimeToInterpolate = startOfInterpolatedBlock , i = 0 ; stopTimeToInterpolate < stopTime ; stopTimeToInterpolate ++ , i ++ ) { 
Stop start = stops . get ( stopTimes [ stopTimeToInterpolate - 1 ] . stop_id ) ; 
Stop end = stops . get ( stopTimes [ stopTimeToInterpolate ] . stop_id ) ; 
calc . setStartingGeographicPoint ( start . stop_lon , start . stop_lat ) ; 
calc . setDestinationGeographicPoint ( end . stop_lon , end . stop_lat ) ; 
double segLen = calc . getOrthodromicDistance ( ) ; 
totalLengthOfInterpolatedSection += segLen ; 
lengthOfInterpolatedSections [ i ] = segLen ; 
Stop start = stops . get ( stopTimes [ stopTime - 1 ] . stop_id ) ; 
Stop end = stops . get ( stopTimes [ stopTime ] . stop_id ) ; 
totalLengthOfInterpolatedSection += calc . getOrthodromicDistance ( ) ; 
int departureBeforeInterpolation = stopTimes [ startOfInterpolatedBlock - 1 ] . departure_time ; 
int arrivalAfterInterpolation = stopTimes [ stopTime ] . arrival_time ; 
int totalTime = arrivalAfterInterpolation - departureBeforeInterpolation ; 
double lengthSoFar = 0 ; 
lengthSoFar += lengthOfInterpolatedSections [ i ] ; 
int time = ( int ) ( departureBeforeInterpolation + totalTime * ( lengthSoFar / totalLengthOfInterpolatedSection ) ) ; 
stopTimes [ stopTimeToInterpolate ] . arrival_time = stopTimes [ stopTimeToInterpolate ] . departure_time = time ; 
startOfInterpolatedBlock = - 1 ; 
return Arrays . asList ( stopTimes ) ; 
} public double getTripDistance ( String trip_id , boolean straightLine ) { 
return straightLine 
? GeoUtils . getDistance ( this . getStraightLineForStops ( trip_id ) ) 
: GeoUtils . getDistance ( this . getTripGeometry ( trip_id ) ) ; 
} public double getTripSpeed ( String trip_id , boolean straightLine ) { 
StopTime firstStopTime = this . stop_times . ceilingEntry ( Fun . t2 ( trip_id , null ) ) . getValue ( ) ; 
StopTime lastStopTime = this . stop_times . floorEntry ( Fun . t2 ( trip_id , Fun . HI ) ) . getValue ( ) ; 
if ( ! firstStopTime . trip_id . equals ( trip_id ) || ! lastStopTime . trip_id . equals ( trip_id ) ) { 
double distance = getTripDistance ( trip_id , straightLine ) ; 
int time = lastStopTime . arrival_time - firstStopTime . departure_time ; 
return distance / time ; 
} public List < StopTime > getStopTimesForStop ( String stop_id ) { 
SortedSet < Tuple2 < String , Tuple2 > > index = this . stopStopTimeSet 
. subSet ( new Tuple2 < > ( stop_id , null ) , new Tuple2 ( stop_id , Fun . HI ) ) ; 
return index . stream ( ) 
. map ( tuple -> this . stop_times . get ( tuple . b ) ) 
} public List < Service > getServicesForDate ( LocalDate date ) { 
String dateString = date . format ( dateFormatter ) ; 
SortedSet < Tuple2 < String , String > > index = this . servicesPerDate 
. subSet ( new Tuple2 < > ( dateString , null ) , new Tuple2 ( dateString , Fun . HI ) ) ; 
. map ( tuple -> this . services . get ( tuple . b ) ) 
} public List < Trip > getDistinctTripsForStop ( String stop_id ) { 
return getStopTimesForStop ( stop_id ) . stream ( ) 
. map ( stopTime -> this . trips . get ( stopTime . trip_id ) ) 
. distinct ( ) 
} public ZoneId getAgencyTimeZoneForStop ( String stop_id ) { 
StopTime stopTime = getStopTimesForStop ( stop_id ) . iterator ( ) . next ( ) ; 
Trip trip = this . trips . get ( stopTime . trip_id ) ; 
Route route = this . routes . get ( trip . route_id ) ; 
Agency agency = route . agency_id != null ? this . agency . get ( route . agency_id ) : this . agency . get ( 0 ) ; 
return ZoneId . of ( agency . agency_timezone ) ; 
} public Geometry getMergedBuffers ( ) { 
if ( this . mergedBuffers == null ) { 
Collection < Geometry > polygons = new ArrayList < > ( ) ; 
if ( getStopTimesForStop ( stop . stop_id ) . isEmpty ( ) ) { 
if ( stop . stop_lat > - 1 && stop . stop_lat < 1 || stop . stop_lon > - 1 && stop . stop_lon < 1 ) { 
Point stopPoint = gf . createPoint ( new Coordinate ( stop . stop_lon , stop . stop_lat ) ) ; 
Polygon stopBuffer = ( Polygon ) stopPoint . buffer ( .01 ) ; 
polygons . add ( stopBuffer ) ; 
Geometry multiGeometry = gf . buildGeometry ( polygons ) ; 
this . mergedBuffers = multiGeometry . union ( ) ; 
if ( polygons . size ( ) > 100 ) { 
this . mergedBuffers = DouglasPeuckerSimplifier . simplify ( this . mergedBuffers , .001 ) ; 
return this . mergedBuffers ; 
statement . setDouble ( oneBasedIndex ++ , price ) ; 
statement . setString ( oneBasedIndex ++ , currency_type ) ; 
setIntParameter ( statement , oneBasedIndex ++ , payment_method ) ; 
setIntParameter ( statement , oneBasedIndex ++ , transfers ) ; 
setIntParameter ( statement , oneBasedIndex ++ , transfer_duration ) ; 
} public static Geometry getNetherlands ( ) { 
CoordinateSequence netherlandsBoundaryCoordinates = new PackedCoordinateSequence . Double ( new double [ ] { 
5.920645 , 50.748480 , 
5.914113 , 50.747530 , 
5.911786 , 50.752290 , 
5.900865 , 50.748480 , 
5.888615 , 50.753490 , 
5.885185 , 50.766310 , 
5.864401 , 50.760600 , 
5.849655 , 50.750500 , 
5.842990 , 50.761710 , 
5.831393 , 50.755630 , 
5.806889 , 50.753150 , 
5.792512 , 50.766680 , 
5.782796 , 50.764700 , 
5.773869 , 50.780210 , 
5.749096 , 50.768200 , 
5.740229 , 50.754260 , 
5.720635 , 50.760300 , 
5.699182 , 50.752280 , 
5.681583 , 50.754740 , 
5.680362 , 50.763910 , 
5.698492 , 50.782620 , 
5.688232 , 50.795590 , 
5.696357 , 50.805360 , 
5.652121 , 50.817740 , 
5.635965 , 50.846910 , 
5.642047 , 50.873480 , 
5.676125 , 50.883900 , 
5.693287 , 50.899480 , 
5.698111 , 50.913440 , 
5.721419 , 50.911900 , 
5.725882 , 50.927620 , 
5.738869 , 50.937550 , 
5.744784 , 50.949700 , 
5.756042 , 50.953140 , 
5.746100 , 50.958630 , 
5.725894 , 50.952350 , 
5.716823 , 50.961980 , 
5.735358 , 50.980980 , 
5.748154 , 50.984990 , 
5.764667 , 51.000650 , 
5.764155 , 51.013410 , 
5.773253 , 51.022760 , 
5.757832 , 51.028300 , 
5.755501 , 51.035840 , 
5.767694 , 51.049870 , 
5.772074 , 51.064960 , 
5.797835 , 51.062840 , 
5.793751 , 51.072700 , 
5.801836 , 51.079130 , 
5.793118 , 51.086550 , 
5.793639 , 51.093300 , 
5.806251 , 51.099130 , 
5.823016 , 51.095330 , 
5.829870 , 51.098960 , 
5.828523 , 51.103860 , 
5.811779 , 51.105140 , 
5.804669 , 51.113010 , 
5.819013 , 51.129230 , 
5.839765 , 51.134040 , 
5.847521 , 51.144960 , 
5.834189 , 51.151610 , 
5.829746 , 51.160620 , 
5.824630 , 51.164330 , 
5.816153 , 51.156060 , 
5.805567 , 51.159410 , 
5.777226 , 51.148330 , 
5.771871 , 51.153870 , 
5.774877 , 51.160270 , 
5.767215 , 51.163820 , 
5.772426 , 51.177410 , 
5.766246 , 51.180770 , 
5.745984 , 51.186290 , 
5.740733 , 51.181920 , 
5.709280 , 51.177420 , 
5.688692 , 51.182170 , 
5.657367 , 51.181820 , 
5.647189 , 51.192040 , 
5.648135 , 51.196140 , 
5.559201 , 51.219600 , 
5.551906 , 51.244010 , 
5.553776 , 51.264200 , 
5.527008 , 51.279270 , 
5.513870 , 51.292470 , 
5.485651 , 51.296920 , 
5.465753 , 51.281710 , 
5.444162 , 51.279340 , 
5.417866 , 51.259320 , 
5.349209 , 51.272180 , 
5.337141 , 51.260140 , 
5.295677 , 51.258520 , 
5.263199 , 51.263750 , 
5.236915 , 51.258520 , 
5.222979 , 51.268460 , 
5.238275 , 51.303600 , 
5.200519 , 51.319290 , 
5.162749 , 51.307320 , 
5.131953 , 51.313700 , 
5.128835 , 51.345240 , 
5.068350 , 51.392500 , 
5.100715 , 51.431820 , 
5.077345 , 51.468360 , 
5.044581 , 51.468360 , 
5.035358 , 51.477740 , 
5.036552 , 51.484140 , 
5.012929 , 51.469860 , 
5.013917 , 51.454840 , 
5.006537 , 51.441650 , 
4.921044 , 51.390690 , 
4.911727 , 51.392960 , 
4.913135 , 51.398490 , 
4.905760 , 51.405610 , 
4.888757 , 51.412180 , 
4.876084 , 51.412170 , 
4.867381 , 51.406110 , 
4.839025 , 51.411590 , 
4.789316 , 51.405990 , 
4.769536 , 51.412410 , 
4.763576 , 51.430300 , 
4.766441 , 51.433650 , 
4.787077 , 51.435690 , 
4.824689 , 51.426100 , 
4.820426 , 51.449230 , 
4.833136 , 51.460930 , 
4.837352 , 51.478910 , 
4.819916 , 51.480330 , 
4.814349 , 51.491900 , 
4.782196 , 51.496690 , 
4.778101 , 51.501420 , 
4.754141 , 51.497100 , 
4.748593 , 51.487300 , 
4.731148 , 51.481530 , 
4.718609 , 51.466400 , 
4.706865 , 51.464440 , 
4.694952 , 51.449370 , 
4.670006 , 51.442420 , 
4.671392 , 51.423890 , 
4.641470 , 51.419020 , 
4.574917 , 51.429810 , 
4.534364 , 51.420220 , 
4.526970 , 51.450180 , 
4.544128 , 51.472940 , 
4.537175 , 51.479270 , 
4.476857 , 51.475260 , 
4.465859 , 51.468230 , 
4.443222 , 51.465730 , 
4.393420 , 51.449040 , 
4.401744 , 51.434580 , 
4.397519 , 51.425000 , 
4.387858 , 51.419980 , 
4.393899 , 51.410180 , 
4.434043 , 51.376910 , 
4.432594 , 51.361120 , 
4.422241 , 51.362140 , 
4.384498 , 51.351350 , 
4.340371 , 51.354730 , 
4.332372 , 51.374530 , 
4.222024 , 51.371040 , 
4.244665 , 51.352500 , 
4.167273 , 51.290120 , 
4.062695 , 51.241690 , 
4.040278 , 51.238330 , 
4.014192 , 51.241800 , 
3.987056 , 51.230400 , 
3.980126 , 51.222620 , 
3.966785 , 51.221280 , 
3.959444 , 51.212940 , 
3.935476 , 51.208930 , 
3.928753 , 51.215900 , 
3.921538 , 51.214080 , 
3.919711 , 51.204970 , 
3.886517 , 51.197170 , 
3.874627 , 51.207940 , 
3.887993 , 51.219510 , 
3.859817 , 51.207840 , 
3.837323 , 51.210640 , 
3.824674 , 51.205960 , 
3.789446 , 51.211540 , 
3.785459 , 51.226510 , 
3.790882 , 51.254070 , 
3.775507 , 51.260170 , 
3.768807 , 51.256900 , 
3.753589 , 51.266830 , 
3.693150 , 51.273140 , 
3.657541 , 51.287200 , 
3.640011 , 51.285180 , 
3.589920 , 51.301560 , 
3.586048 , 51.298150 , 
3.590697 , 51.291810 , 
3.582435 , 51.283980 , 
3.562355 , 51.292800 , 
3.556428 , 51.286890 , 
3.545540 , 51.288170 , 
3.538944 , 51.280780 , 
3.519408 , 51.284680 , 
3.528826 , 51.243300 , 
3.448568 , 51.238510 , 
3.426458 , 51.241840 , 
3.420358 , 51.253670 , 
3.406010 , 51.254300 , 
3.373119 , 51.275680 , 
3.377565 , 51.285800 , 
3.363010 , 51.298030 , 
3.370756 , 51.302930 , 
3.355429 , 51.315530 , 
3.381920 , 51.335370 , 
3.380865 , 51.339460 , 
3.371422 , 51.347100 , 
3.371675 , 51.358150 , 
3.350258 , 51.376730 , 
3.306017 , 51.431030 , 
3.078404 , 51.551970 , 
2.992192 , 51.633610 , 
4.362889 , 53.305060 , 
5.530069 , 54.017860 , 
6.346609 , 53.728270 , 
6.414744 , 53.697610 , 
6.594984 , 53.595190 , 
6.821311 , 53.496490 , 
6.858844 , 53.471530 , 
6.891564 , 53.468070 , 
6.917659 , 53.459810 , 
6.934755 , 53.439730 , 
6.954578 , 53.395700 , 
6.995954 , 53.350730 , 
6.997671 , 53.334020 , 
7.006850 , 53.329430 , 
7.061512 , 53.327040 , 
7.111054 , 53.334810 , 
7.189534 , 53.334480 , 
7.220022 , 53.214900 , 
7.220549 , 53.197160 , 
7.212982 , 53.189670 , 
7.230455 , 53.180790 , 
7.205009 , 53.173520 , 
7.194018 , 53.160900 , 
7.192205 , 53.146470 , 
7.182299 , 53.135820 , 
7.188436 , 53.122690 , 
7.205696 , 53.114170 , 
7.202251 , 53.081510 , 
7.215711 , 53.012480 , 
7.220429 , 53.006720 , 
7.211986 , 52.998620 , 
7.183969 , 52.939860 , 
7.090966 , 52.849050 , 
7.095411 , 52.836830 , 
7.074470 , 52.809300 , 
7.057560 , 52.641040 , 
7.039568 , 52.629710 , 
6.975989 , 52.643210 , 
6.953745 , 52.636000 , 
6.918933 , 52.636860 , 
6.912264 , 52.644010 , 
6.872838 , 52.650240 , 
6.821407 , 52.644690 , 
6.784084 , 52.649540 , 
6.743337 , 52.642560 , 
6.717383 , 52.627770 , 
6.730256 , 52.615370 , 
6.722265 , 52.590200 , 
6.768056 , 52.566190 , 
6.769131 , 52.559890 , 
6.752295 , 52.556040 , 
6.727875 , 52.559800 , 
6.716428 , 52.545530 , 
6.687630 , 52.549380 , 
6.708209 , 52.521860 , 
6.700986 , 52.488160 , 
6.753652 , 52.466990 , 
6.774899 , 52.462600 , 
6.854735 , 52.462670 , 
6.856230 , 52.453520 , 
6.941407 , 52.438530 , 
6.959788 , 52.446690 , 
6.975400 , 52.467790 , 
6.988624 , 52.472590 , 
6.996353 , 52.467220 , 
7.013247 , 52.431210 , 
7.024209 , 52.425000 , 
7.037172 , 52.405650 , 
7.060917 , 52.401460 , 
7.075066 , 52.373840 , 
7.074867 , 52.350400 , 
7.059279 , 52.336640 , 
7.050042 , 52.322630 , 
7.050009 , 52.313690 , 
7.029410 , 52.290960 , 
7.031167 , 52.275610 , 
7.044544 , 52.258330 , 
7.068264 , 52.242930 , 
7.063317 , 52.232510 , 
7.026832 , 52.222750 , 
6.989159 , 52.223250 , 
6.953173 , 52.178760 , 
6.910407 , 52.173560 , 
6.907694 , 52.167660 , 
6.884791 , 52.155000 , 
6.875589 , 52.128170 , 
6.856423 , 52.117620 , 
6.763181 , 52.115770 , 
6.758851 , 52.095340 , 
6.748639 , 52.091730 , 
6.754072 , 52.085770 , 
6.750768 , 52.080660 , 
6.736213 , 52.071730 , 
6.699834 , 52.067700 , 
6.690838 , 52.053740 , 
6.690935 , 52.042880 , 
6.714943 , 52.042950 , 
6.753837 , 52.031280 , 
6.814332 , 51.997460 , 
6.828034 , 51.996170 , 
6.835752 , 51.973060 , 
6.830667 , 51.962000 , 
6.801478 , 51.956260 , 
6.799999 , 51.941300 , 
6.790685 , 51.927210 , 
6.771269 , 51.913460 , 
6.722739 , 51.893160 , 
6.693687 , 51.911890 , 
6.681975 , 51.914160 , 
6.634806 , 51.898070 , 
6.586462 , 51.891150 , 
6.561388 , 51.879320 , 
6.544918 , 51.881310 , 
6.505764 , 51.865820 , 
6.501361 , 51.859470 , 
6.472824 , 51.850840 , 
6.449746 , 51.862380 , 
6.431991 , 51.856420 , 
6.425879 , 51.862940 , 
6.392888 , 51.869980 , 
6.390379 , 51.864800 , 
6.411849 , 51.854130 , 
6.405673 , 51.843820 , 
6.411140 , 51.835980 , 
6.407495 , 51.825030 , 
6.380975 , 51.831870 , 
6.366882 , 51.830600 , 
6.360515 , 51.833680 , 
6.358099 , 51.843710 , 
6.346470 , 51.847750 , 
6.305316 , 51.846210 , 
6.295315 , 51.865260 , 
6.279113 , 51.871180 , 
6.262056 , 51.865150 , 
6.209305 , 51.866150 , 
6.181319 , 51.880520 , 
6.179351 , 51.887170 , 
6.185248 , 51.889760 , 
6.156526 , 51.902040 , 
6.116557 , 51.895290 , 
6.138796 , 51.888300 , 
6.147601 , 51.871940 , 
6.169398 , 51.863420 , 
6.167472 , 51.837860 , 
6.100394 , 51.846090 , 
6.064946 , 51.861680 , 
6.057291 , 51.850110 , 
6.036744 , 51.839840 , 
6.028512 , 51.841750 , 
5.994722 , 51.827930 , 
5.963244 , 51.833400 , 
5.950530 , 51.824140 , 
5.960760 , 51.818410 , 
5.957302 , 51.812950 , 
5.981246 , 51.799710 , 
5.978057 , 51.788780 , 
5.992548 , 51.785320 , 
5.987021 , 51.775330 , 
5.995037 , 51.770670 , 
5.991943 , 51.763650 , 
5.956302 , 51.748090 , 
5.956064 , 51.742220 , 
5.994732 , 51.741260 , 
6.046624 , 51.719400 , 
6.043521 , 51.710750 , 
6.029834 , 51.708290 , 
6.034777 , 51.692680 , 
6.033234 , 51.679120 , 
6.037929 , 51.675530 , 
6.119859 , 51.658390 , 
6.120054 , 51.649660 , 
6.110479 , 51.640020 , 
6.095011 , 51.607500 , 
6.123231 , 51.595190 , 
6.132643 , 51.583300 , 
6.158656 , 51.569100 , 
6.178861 , 51.540980 , 
6.201415 , 51.529990 , 
6.214704 , 51.514740 , 
6.215800 , 51.492330 , 
6.226676 , 51.468740 , 
6.209491 , 51.403570 , 
6.229287 , 51.401730 , 
6.218449 , 51.386690 , 
6.229390 , 51.360290 , 
6.194644 , 51.338740 , 
6.195852 , 51.332350 , 
6.172269 , 51.330150 , 
6.156020 , 51.305400 , 
6.131365 , 51.283730 , 
6.126709 , 51.272700 , 
6.077269 , 51.241140 , 
6.088301 , 51.220720 , 
6.071111 , 51.218870 , 
6.076000 , 51.184150 , 
6.083935 , 51.174430 , 
6.105466 , 51.175170 , 
6.165647 , 51.197330 , 
6.182602 , 51.188700 , 
6.183035 , 51.184450 , 
6.147734 , 51.172980 , 
6.177047 , 51.160980 , 
6.177587 , 51.156390 , 
6.164554 , 51.145950 , 
6.126782 , 51.141710 , 
6.093797 , 51.131760 , 
6.088709 , 51.122140 , 
6.061897 , 51.113350 , 
6.038192 , 51.094000 , 
5.999214 , 51.081580 , 
5.973847 , 51.059610 , 
5.971765 , 51.045220 , 
5.958617 , 51.031850 , 
5.936460 , 51.032630 , 
5.913405 , 51.063380 , 
5.893022 , 51.050310 , 
5.869790 , 51.048620 , 
5.880831 , 51.038650 , 
5.878007 , 51.028400 , 
5.881900 , 51.019230 , 
5.897435 , 51.013490 , 
5.898569 , 51.006870 , 
5.908300 , 51.003290 , 
5.906599 , 50.986330 , 
5.899490 , 50.977780 , 
5.955096 , 50.991420 , 
5.967899 , 50.982380 , 
5.981279 , 50.986220 , 
6.027451 , 50.986120 , 
6.029409 , 50.979820 , 
6.012523 , 50.957300 , 
6.019548 , 50.953960 , 
6.020674 , 50.937290 , 
6.051754 , 50.932770 , 
6.058370 , 50.924710 , 
6.097096 , 50.921280 , 
6.080364 , 50.898360 , 
6.079201 , 50.890810 , 
6.089250 , 50.881000 , 
6.091101 , 50.872330 , 
6.079903 , 50.858810 , 
6.076394 , 50.844520 , 
6.055450 , 50.848330 , 
6.053880 , 50.853070 , 
6.021010 , 50.843360 , 
6.019818 , 50.833840 , 
6.028167 , 50.828600 , 
6.027036 , 50.811900 , 
6.004115 , 50.798500 , 
5.985312 , 50.807300 , 
5.978653 , 50.801100 , 
6.029923 , 50.776130 , 
6.021710 , 50.762600 , 
6.023293 , 50.752340 , 
5.982748 , 50.749850 , 
5.958986 , 50.759260 , 
5.920645 , 50.748480 } , 2 ) ; 
Polygon boundary = geometryFactory . createPolygon ( netherlandsBoundaryCoordinates ) ; 
return boundary ; 
} public void processTrip ( Trip trip , Iterable < StopTime > orderedStopTimes ) { 
if ( ++ nTripsProcessed % 100000 == 0 ) { 
TripPatternKey key = new TripPatternKey ( trip . route_id ) ; 
for ( StopTime st : orderedStopTimes ) { 
key . addStopTime ( st ) ; 
tripsForPattern . put ( key , trip ) ; 
} public Map < TripPatternKey , Pattern > createPatternObjects ( Map < String , Stop > stopById , SQLErrorStorage errorStorage ) { 
int nextPatternId = 1 ; 
Map < TripPatternKey , Pattern > patterns = new HashMap < > ( ) ; 
for ( TripPatternKey key : tripsForPattern . keySet ( ) ) { 
Collection < Trip > trips = tripsForPattern . get ( key ) ; 
Pattern pattern = new Pattern ( key . stops , trips , null ) ; 
pattern . pattern_id = Integer . toString ( nextPatternId ++ ) ; 
pattern . associatedShapes = new HashSet < > ( ) ; 
trips . stream ( ) . forEach ( trip -> pattern . associatedShapes . add ( trip . shape_id ) ) ; 
if ( pattern . associatedShapes . size ( ) > 1 && errorStorage != null ) { 
errorStorage . storeError ( NewGTFSError . forEntity ( 
pattern , 
NewGTFSErrorType . MULTIPLE_SHAPES_FOR_PATTERN ) 
. setBadValue ( pattern . associatedShapes . toString ( ) ) ) ; 
patterns . put ( key , pattern ) ; 
renamePatterns ( patterns . values ( ) , stopById ) ; 
return patterns ; 
} public static void renamePatterns ( Collection < Pattern > patterns , Map < String , Stop > stopById ) { 
Map < String , PatternNamingInfo > namingInfoForRoute = new HashMap < > ( ) ; 
for ( Pattern pattern : patterns ) { 
if ( pattern . associatedTrips . isEmpty ( ) || pattern . orderedStops . isEmpty ( ) ) continue ; 
PatternNamingInfo namingInfo = namingInfoForRoute . get ( pattern . route_id ) ; 
if ( namingInfo == null ) { 
namingInfo = new PatternNamingInfo ( ) ; 
namingInfoForRoute . put ( pattern . route_id , namingInfo ) ; 
String fromName = stopById . get ( pattern . orderedStops . get ( 0 ) ) . stop_name ; 
String toName = stopById . get ( pattern . orderedStops . get ( pattern . orderedStops . size ( ) - 1 ) ) . stop_name ; 
namingInfo . fromStops . put ( fromName , pattern ) ; 
namingInfo . toStops . put ( toName , pattern ) ; 
for ( String stopId : pattern . orderedStops ) { 
Stop stop = stopById . get ( stopId ) ; 
if ( fromName . equals ( stop . stop_name ) || toName . equals ( stop . stop_name ) ) continue ; 
namingInfo . vias . put ( stop . stop_name , pattern ) ; 
namingInfo . patternsOnRoute . add ( pattern ) ; 
for ( PatternNamingInfo info : namingInfoForRoute . values ( ) ) { 
for ( Pattern pattern : info . patternsOnRoute ) { 
pattern . name = null ; 
Set < Pattern > intersection = new HashSet < > ( info . fromStops . get ( fromName ) ) ; 
intersection . retainAll ( info . toStops . get ( toName ) ) ; 
if ( intersection . size ( ) == 1 ) { 
pattern . orderedStops . stream ( ) . map ( stopById :: get ) . forEach ( stop -> { 
Set < Pattern > viaIntersection = new HashSet < > ( intersection ) ; 
viaIntersection . retainAll ( info . vias . get ( stop . stop_name ) ) ; 
if ( viaIntersection . size ( ) == 1 ) { 
if ( pattern . name == null ) { 
if ( intersection . size ( ) == 2 ) { 
Iterator < Pattern > it = intersection . iterator ( ) ; 
Pattern p0 = it . next ( ) ; 
Pattern p1 = it . next ( ) ; 
if ( p0 . orderedStops . size ( ) > p1 . orderedStops . size ( ) ) { 
} else if ( p1 . orderedStops . size ( ) > p0 . orderedStops . size ( ) ) { 
pattern . orderedStops . size ( ) , pattern . name , pattern . associatedTrips . size ( ) ) ; 
int wheelchairBoarding = 0 ; 
wheelchairBoarding = Integer . parseInt ( wheelchair_boarding ) ; 
statement . setString ( oneBasedIndex ++ , stop_code ) ; 
statement . setString ( oneBasedIndex ++ , stop_name ) ; 
statement . setString ( oneBasedIndex ++ , stop_desc ) ; 
statement . setDouble ( oneBasedIndex ++ , stop_lat ) ; 
statement . setDouble ( oneBasedIndex ++ , stop_lon ) ; 
statement . setString ( oneBasedIndex ++ , zone_id ) ; 
statement . setString ( oneBasedIndex ++ , stop_url != null ? stop_url . toString ( ) : null ) ; 
setIntParameter ( statement , oneBasedIndex ++ , location_type ) ; 
statement . setString ( oneBasedIndex ++ , parent_station ) ; 
statement . setString ( oneBasedIndex ++ , stop_timezone ) ; 
setIntParameter ( statement , oneBasedIndex ++ , wheelchairBoarding ) ; 
} public ValidateFieldResult < String > validateAndConvert ( String string ) { 
ValidateFieldResult < String > result = new ValidateFieldResult < > ( string ) ; 
if ( string . length ( ) != 6 ) { 
result . errors . add ( NewGTFSError . forFeed ( NewGTFSErrorType . COLOR_FORMAT , string ) ) ; 
int integer = Integer . parseInt ( string , 16 ) ; 
throw new StorageException ( NewGTFSErrorType . COLOR_FORMAT , string ) ; 
public void complete ( ValidationResult validationResult ) { 
Map < String , Stop > stopById = new HashMap < > ( ) ; 
for ( Stop stop : feed . stops ) { 
stopById . put ( stop . stop_id , stop ) ; 
Map < TripPatternKey , Pattern > patterns = patternFinder . createPatternObjects ( stopById , errorStorage ) ; 
connection = feed . getConnection ( ) ; 
String tripsTableName = feed . tablePrefix + "trips" ; 
String patternsTableName = feed . tablePrefix + "patterns" ; 
String patternStopsTableName = feed . tablePrefix + "pattern_stops" ; 
Table patternsTable = new Table ( patternsTableName , Pattern . class , Requirement . EDITOR , Table . PATTERNS . fields ) ; 
Table patternStopsTable = new Table ( patternStopsTableName , PatternStop . class , Requirement . EDITOR , 
Table . PATTERN_STOP . fields ) ; 
patternsTable . createSqlTable ( connection , null , true ) ; 
patternStopsTable . createSqlTable ( connection , null , true ) ; 
String insertPatternSql = patternsTable . generateInsertSql ( true ) ; 
String insertPatternStopSql = patternStopsTable . generateInsertSql ( true ) ; 
PreparedStatement insertPatternStatement = connection . prepareStatement ( insertPatternSql ) ; 
BatchTracker patternTracker = new BatchTracker ( "pattern" , insertPatternStatement ) ; 
PreparedStatement insertPatternStopStatement = connection . prepareStatement ( insertPatternStopSql ) ; 
int currentPatternIndex = 0 ; 
tempPatternForTripsTable = "pattern_for_trips" ; 
tempPatternForTripsTextFile = File . createTempFile ( tempPatternForTripsTable , "text" ) ; 
LOG . info ( createTempSql ) ; 
statement . execute ( createTempSql ) ; 
patternForTripsFileStream = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( tempPatternForTripsTextFile ) ) ) ; 
for ( Map . Entry < TripPatternKey , Pattern > entry : patterns . entrySet ( ) ) { 
Pattern pattern = entry . getValue ( ) ; 
TripPatternKey key = entry . getKey ( ) ; 
pattern . setStatementParameters ( insertPatternStatement , true ) ; 
patternTracker . addBatch ( ) ; 
int lastValidDeparture = key . departureTimes . get ( 0 ) ; 
for ( int i = 0 ; i < key . stops . size ( ) ; i ++ ) { 
int travelTime = 0 ; 
String stopId = key . stops . get ( i ) ; 
int arrival = key . arrivalTimes . get ( i ) ; 
int prevDeparture = key . departureTimes . get ( i - 1 ) ; 
if ( prevDeparture != INT_MISSING ) { 
lastValidDeparture = prevDeparture ; 
travelTime = arrival == INT_MISSING || lastValidDeparture == INT_MISSING 
? INT_MISSING 
: arrival - lastValidDeparture ; 
int departure = key . departureTimes . get ( i ) ; 
int dwellTime = arrival == INT_MISSING || departure == INT_MISSING 
: departure - arrival ; 
insertPatternStopStatement . setString ( 1 , pattern . pattern_id ) ; 
setIntParameter ( insertPatternStopStatement , 2 , i ) ; 
insertPatternStopStatement . setString ( 3 , stopId ) ; 
setIntParameter ( insertPatternStopStatement , 4 , travelTime ) ; 
setIntParameter ( insertPatternStopStatement , 5 , dwellTime ) ; 
setIntParameter ( insertPatternStopStatement , 6 , key . dropoffTypes . get ( i ) ) ; 
setIntParameter ( insertPatternStopStatement , 7 , key . pickupTypes . get ( i ) ) ; 
setDoubleParameter ( insertPatternStopStatement , 8 , key . shapeDistances . get ( i ) ) ; 
setIntParameter ( insertPatternStopStatement , 9 , key . timepoints . get ( i ) ) ; 
patternStopTracker . addBatch ( ) ; 
PreparedStatement updateTripStatement = connection . prepareStatement ( 
updateTripStatement . setString ( oneBasedIndex ++ , pattern . pattern_id ) ; 
for ( String tripId : pattern . associatedTrips ) { 
String [ ] strings = new String [ ] { tripId , pattern . pattern_id } ; 
patternForTripsFileStream . println ( String . join ( "\t" , strings ) ) ; 
updateTripStatement . setString ( oneBasedIndex ++ , tripId ) ; 
if ( ! postgresText ) { 
updateTripStatement . executeUpdate ( ) ; 
currentPatternIndex += 1 ; 
patternTracker . executeRemaining ( ) ; 
patternStopTracker . executeRemaining ( ) ; 
patternForTripsFileStream . close ( ) ; 
copyFromFile ( connection , tempPatternForTripsTextFile , tempPatternForTripsTable ) ; 
LOG . info ( patternForTripsIndexSql ) ; 
statement . execute ( patternForTripsIndexSql ) ; 
LOG . info ( updateTripsSql ) ; 
statement . executeUpdate ( updateTripsSql ) ; 
tempPatternForTripsTextFile . delete ( ) ; 
} catch ( SQLException | IOException e ) { 
DbUtils . rollbackAndCloseQuietly ( connection ) ; 
ValidateFieldResult < String > result = cleanString ( string ) ; 
new URL ( result . clean ) ; 
result . errors . add ( NewGTFSError . forFeed ( NewGTFSErrorType . URL_FORMAT , string ) ) ; 
} public void restoreState ( Bundle state , View v ) { 
Parcelable [ ] messages = state . getParcelableArray ( SAVED_MSGS ) ; 
boolean showImmediately = true ; 
for ( Parcelable message : messages ) { 
showSnack ( ( Snack ) message , v , null , showImmediately ) ; 
showImmediately = false ; 
} private int getPxFromDp ( int dp ) { 
Resources rs = getResources ( ) ; 
int pxConverter = ( int ) TypedValue . applyDimension ( TypedValue . COMPLEX_UNIT_DIP , 1 , rs . getDisplayMetrics ( ) ) ; 
int px = pxConverter * dp ; 
return px ; 
} public void writeToParcel ( Parcel out , int flags ) { 
out . writeString ( mMessage ) ; 
out . writeString ( mActionMessage ) ; 
out . writeInt ( mActionIcon ) ; 
out . writeParcelable ( mToken , 0 ) ; 
out . writeInt ( ( int ) mDuration ) ; 
out . writeParcelable ( mBtnTextColor , 0 ) ; 
out . writeParcelable ( mBackgroundColor , 0 ) ; 
out . writeInt ( mHeight ) ; 
out . writeValue ( mTypeface ) ; 
} public int getHeight ( ) { 
mParentView . measure ( View . MeasureSpec . makeMeasureSpec ( mParentView . getWidth ( ) , View . MeasureSpec . EXACTLY ) , 
View . MeasureSpec . makeMeasureSpec ( mParentView . getHeight ( ) , View . MeasureSpec . AT_MOST ) ) ; 
return mParentView . getMeasuredHeight ( ) ; 
} public static boolean parseStringToBooleanDefaultingToFalse ( final String stringToParse ) { 
if ( "true" . equals ( stringToParse ) ) { 
} else if ( "false" . equals ( stringToParse ) ) { 
} else if ( null == stringToParse ) { 
} static void throwIfUnrecognizedParamName ( final Enumeration initParamNames ) { 
final Set < String > recognizedParameterNames = new HashSet < String > ( ) ; 
recognizedParameterNames . add ( INIT_PARAM_ENABLE_CACHE_CONTROL ) ; 
recognizedParameterNames . add ( INIT_PARAM_ENABLE_XCONTENT_OPTIONS ) ; 
recognizedParameterNames . add ( INIT_PARAM_ENABLE_STRICT_TRANSPORT_SECURITY ) ; 
recognizedParameterNames . add ( INIT_PARAM_ENABLE_STRICT_XFRAME_OPTIONS ) ; 
recognizedParameterNames . add ( INIT_PARAM_STRICT_XFRAME_OPTIONS ) ; 
recognizedParameterNames . add ( INIT_PARAM_CONTENT_SECURITY_POLICY ) ; 
recognizedParameterNames . add ( LOGGER_HANDLER_CLASS_NAME ) ; 
recognizedParameterNames . add ( INIT_PARAM_ENABLE_XSS_PROTECTION ) ; 
recognizedParameterNames . add ( INIT_PARAM_XSS_PROTECTION ) ; 
while ( initParamNames . hasMoreElements ( ) ) { 
final String initParamName = ( String ) initParamNames . nextElement ( ) ; 
if ( ! recognizedParameterNames . contains ( initParamName ) ) { 
} static void throwIfUnrecognizedParamName ( Enumeration initParamNames ) throws ServletException { 
recognizedParameterNames . add ( ALLOW_MULTI_VALUED_PARAMETERS ) ; 
recognizedParameterNames . add ( PARAMETERS_TO_CHECK ) ; 
recognizedParameterNames . add ( ONLY_POST_PARAMETERS ) ; 
recognizedParameterNames . add ( CHARACTERS_TO_FORBID ) ; 
} static Set < String > parseParametersList ( final String initParamValue , final boolean allowWildcard ) { 
final Set < String > parameterNames = new HashSet < String > ( ) ; 
if ( null == initParamValue ) { 
return parameterNames ; 
final String [ ] tokens = initParamValue . split ( "\\s+" ) ; 
if ( 0 == tokens . length ) { 
FilterUtils . logException ( LOGGER , new IllegalArgumentException ( "[" + initParamValue + 
if ( 1 == tokens . length && "*" . equals ( tokens [ 0 ] ) && allowWildcard ) { 
for ( final String parameterName : tokens ) { 
if ( "*" . equals ( parameterName ) ) { 
parameterNames . add ( parameterName ) ; 
} static Set < Character > parseCharactersToForbid ( String paramValue ) { 
final Set < Character > charactersToForbid = new HashSet < Character > ( ) ; 
if ( null == paramValue ) { 
paramValue = DEFAULT_CHARACTERS_BLOCKED ; 
if ( "none" . equals ( paramValue ) ) { 
return charactersToForbid ; 
final String [ ] tokens = paramValue . split ( "\\s+" ) ; 
if ( token . length ( ) > 1 ) { 
final Character character = token . charAt ( 0 ) ; 
charactersToForbid . add ( character ) ; 
} static void enforceParameterContentCharacterRestrictions ( 
final Set < String > parametersToCheck , final Set < Character > charactersToForbid , final Map parameterMap ) { 
if ( charactersToForbid . isEmpty ( ) ) { 
for ( final String parameterToCheck : parametersToCheck ) { 
final String [ ] parameterValues = ( String [ ] ) parameterMap . get ( parameterToCheck ) ; 
if ( null != parameterValues ) { 
for ( final String parameterValue : parameterValues ) { 
for ( final Character forbiddenCharacter : charactersToForbid ) { 
final StringBuilder characterAsStringBuilder = new StringBuilder ( ) ; 
characterAsStringBuilder . append ( forbiddenCharacter ) ; 
if ( parameterValue . contains ( characterAsStringBuilder ) ) { 
+ parameterToCheck + "]" ) ) ; 
} static void checkOnlyPostParameters ( final String method , final Map parameterMap , final Set < String > onlyPostParameters ) { 
if ( ! "POST" . equals ( method ) ) { 
Set < String > names = parameterMap . keySet ( ) ; 
for ( String onlyPostParameter : onlyPostParameters ) { 
if ( names . contains ( onlyPostParameter ) ) { 
} public float [ ] predict ( FVec feat , boolean output_margin , int ntree_limit ) { 
float [ ] preds = predictRaw ( feat , ntree_limit ) ; 
if ( ! output_margin ) { 
preds = obj . predTransform ( preds ) ; 
return preds ; 
} public float predictSingle ( FVec feat , boolean output_margin , int ntree_limit ) { 
float pred = predictSingleRaw ( feat , ntree_limit ) ; 
pred = obj . predTransform ( pred ) ; 
return pred ; 
} public static ObjFunction fromName ( String name ) { 
ObjFunction result = FUNCTIONS . get ( name ) ; 
} public static void useFastMathExp ( boolean useJafama ) { 
if ( useJafama ) { 
register ( "binary:logistic" , new RegLossObjLogistic_Jafama ( ) ) ; 
register ( "multi:softprob" , new SoftmaxMultiClassObjProb_Jafama ( ) ) ; 
register ( "binary:logistic" , new RegLossObjLogistic ( ) ) ; 
register ( "multi:softprob" , new SoftmaxMultiClassObjProb ( ) ) ; 
} public void loadModel ( ModelReader reader ) throws IOException { 
param = new Param ( reader ) ; 
nodes = new Node [ param . num_nodes ] ; 
for ( int i = 0 ; i < param . num_nodes ; i ++ ) { 
nodes [ i ] = new Node ( reader ) ; 
stats = new RTreeNodeStat [ param . num_nodes ] ; 
stats [ i ] = new RTreeNodeStat ( reader ) ; 
public int getLeafIndex ( FVec feat , int root_id ) { 
int pid = root_id ; 
Node n ; 
while ( ! ( n = nodes [ pid ] ) . _isLeaf ) { 
pid = n . next ( feat ) ; 
return pid ; 
public float getLeafValue ( FVec feat , int root_id ) { 
Node n = nodes [ root_id ] ; 
while ( ! n . _isLeaf ) { 
n = nodes [ n . next ( feat ) ] ; 
return n . leaf_value ; 
} public JsonUnflattener withSeparator ( char separator ) { 
isTrue ( ! Character . toString ( separator ) . matches ( "[\"\\s]" ) , 
Character . toString ( separator ) ) ; 
isTrue ( ! leftBracket . equals ( separator ) && ! rightBracket . equals ( separator ) , 
this . separator = separator ; 
} public JsonUnflattener withLeftAndRightBrackets ( char leftBracket , 
char rightBracket ) { 
isTrue ( ! Character . toString ( leftBracket ) . matches ( illegalBracketsRegex ( ) ) , 
Character . toString ( leftBracket ) ) ; 
isTrue ( ! Character . toString ( rightBracket ) . matches ( illegalBracketsRegex ( ) ) , 
Character . toString ( rightBracket ) ) ; 
this . leftBracket = leftBracket ; 
this . rightBracket = rightBracket ; 
} public String unflatten ( ) { 
if ( root . isArray ( ) ) { 
unflattenArray ( root . asArray ( ) ) . writeTo ( sw , getWriterConfig ( ) ) ; 
if ( ! root . isObject ( ) ) { 
return root . toString ( ) ; 
JsonObject flattened = root . asObject ( ) ; 
JsonValue unflattened = flattened . names ( ) . isEmpty ( ) ? Json . object ( ) : null ; 
for ( String key : flattened . names ( ) ) { 
JsonValue currentVal = unflattened ; 
String objKey = null ; 
Integer aryIdx = null ; 
Matcher matcher = keyPartPattern ( ) . matcher ( key ) ; 
String keyPart = matcher . group ( ) ; 
if ( objKey != null ^ aryIdx != null ) { 
if ( isJsonArray ( keyPart ) ) { 
currentVal = findOrCreateJsonArray ( currentVal , objKey , aryIdx ) ; 
objKey = null ; 
aryIdx = extractIndex ( keyPart ) ; 
if ( flattened . get ( key ) . isArray ( ) ) { 
flattened . set ( key , unflattenArray ( flattened . get ( key ) . asArray ( ) ) ) ; 
currentVal = findOrCreateJsonObject ( currentVal , objKey , aryIdx ) ; 
objKey = extractKey ( keyPart ) ; 
aryIdx = null ; 
if ( objKey == null && aryIdx == null ) { 
if ( currentVal == null ) currentVal = Json . array ( ) ; 
if ( currentVal == null ) currentVal = Json . object ( ) ; 
if ( unflattened == null ) unflattened = currentVal ; 
setUnflattenedValue ( flattened , key , currentVal , objKey , aryIdx ) ; 
unflattened . writeTo ( sw , getWriterConfig ( ) ) ; 
} public static < T > IndexedPeekIterator < T > newIndexedPeekIterator ( 
Iterable < T > iter ) { 
return new IndexedPeekIterator < T > ( iter . iterator ( ) ) ; 
} public JsonFlattener withSeparator ( char separator ) { 
flattenedMap = null ; 
} public JsonFlattener withLeftAndRightBrackets ( char leftBracket , 
} public String flatten ( ) { 
flattenAsMap ( ) ; 
if ( source . isObject ( ) || isObjectifiableArray ( ) ) 
return flattenedMap . toString ( printMode ) ; 
return javaObj2Json ( flattenedMap . get ( ROOT ) ) ; 
} public Map < String , Object > flattenAsMap ( ) { 
if ( flattenedMap != null ) return flattenedMap ; 
flattenedMap = newJsonifyLinkedHashMap ( ) ; 
reduce ( source ) ; 
while ( ! elementIters . isEmpty ( ) ) { 
IndexedPeekIterator < ? > deepestIter = elementIters . getLast ( ) ; 
if ( ! deepestIter . hasNext ( ) ) { 
elementIters . removeLast ( ) ; 
} else if ( deepestIter . peek ( ) instanceof Member ) { 
Member mem = ( Member ) deepestIter . next ( ) ; 
reduce ( mem . getValue ( ) ) ; 
JsonValue val = ( JsonValue ) deepestIter . next ( ) ; 
reduce ( val ) ; 
return flattenedMap ; 
} public static String format ( Locale locale , Messages message , Object ... args ) { 
String formatString = message . getFormatString ( locale ) ; 
Object [ ] sortArgs = sortArgs ( formatString , args ) ; 
String printfString = Stream . of ( formatString . split ( "%%" ) ) 
. map ( part -> placeholderPattern . matcher ( part ) . replaceAll ( "%s" ) ) 
. collect ( Collectors . joining ( "%%" ) ) ; 
return String . format ( printfString , sortArgs ) ; 
} public CoderResult encode ( CharBuffer input , CharBuffer output , boolean endOfInput ) { 
if ( input . hasRemaining ( ) ) { 
if ( input . hasArray ( ) && output . hasArray ( ) ) { 
return encodeArrays ( input , output , endOfInput ) ; 
return encodeBuffers ( input , output , endOfInput ) ; 
return CoderResult . UNDERFLOW ; 
} static CoderResult overflow ( CharBuffer input , int i , CharBuffer output , int j ) { 
input . position ( i - input . arrayOffset ( ) ) ; 
output . position ( j - output . arrayOffset ( ) ) ; 
return CoderResult . OVERFLOW ; 
} static CoderResult underflow ( CharBuffer input , int i , CharBuffer output , int j ) { 
} ASCIIBits clear ( String chars ) { 
for ( int i = 0 , n = chars . length ( ) ; i < n ; ++ i ) { 
char ch = chars . charAt ( i ) ; 
if ( ch < 64 ) { 
_lowerMask &= ~ ( 1L << ch ) ; 
_upperMask &= ~ ( 1L << ch ) ; 
} ASCIIBits set ( int min , int max ) { 
int i = min ; 
for ( int n = Math . min ( max , 63 ) ; i <= n ; ++ i ) { 
_lowerMask |= ( 1L << i ) ; 
for ( ; i <= max ; ++ i ) { 
_upperMask |= ( 1L << i ) ; 
} protected CoderResult encodeArrays ( CharBuffer input , CharBuffer output , boolean endOfInput ) { 
final char [ ] in = input . array ( ) ; 
final char [ ] out = output . array ( ) ; 
int i = input . arrayOffset ( ) + input . position ( ) ; 
final int n = input . arrayOffset ( ) + input . limit ( ) ; 
int j = output . arrayOffset ( ) + output . position ( ) ; 
final int m = output . arrayOffset ( ) + output . limit ( ) ; 
for ( ; i < n ; ++ i ) { 
final char ch = in [ i ] ; 
if ( ch < Unicode . DEL ) { 
if ( ch > '>' || ( ( _validMask & ( 1L << ch ) ) != 0 ) ) { 
if ( j >= m ) { 
return overflow ( input , i , output , j ) ; 
out [ j ++ ] = ch ; 
if ( j + AMP_LENGTH > m ) { 
out [ j ++ ] = '&' ; 
out [ j ++ ] = 'a' ; 
out [ j ++ ] = 'm' ; 
out [ j ++ ] = 'p' ; 
out [ j ++ ] = ';' ; 
if ( j + LT_LENGTH > m ) { 
out [ j ++ ] = 'l' ; 
out [ j ++ ] = 't' ; 
if ( j + GT_LENGTH > m ) { 
out [ j ++ ] = 'g' ; 
if ( j + APOS_LENGTH > m ) { 
out [ j ++ ] = '#' ; 
out [ j ++ ] = '3' ; 
out [ j ++ ] = '9' ; 
if ( j + QUOT_LENGTH > m ) { 
out [ j ++ ] = '4' ; 
out [ j ++ ] = INVALID_CHARACTER_REPLACEMENT ; 
} else if ( ch < Character . MIN_HIGH_SURROGATE ) { 
if ( ch > Unicode . MAX_C1_CTRL_CHAR || ch == Unicode . NEL ) { 
} else if ( ch <= Character . MAX_HIGH_SURROGATE ) { 
if ( i + 1 < n ) { 
if ( Character . isLowSurrogate ( in [ i + 1 ] ) ) { 
int cp = Character . toCodePoint ( ch , in [ i + 1 ] ) ; 
if ( Unicode . isNonCharacter ( cp ) ) { 
if ( j + 1 >= m ) { 
out [ j ++ ] = in [ ++ i ] ; 
} else if ( endOfInput ) { 
ch <= Character . MAX_LOW_SURROGATE 
|| ch > '' 
|| ( '' <= ch && ch <= '' ) ) 
return underflow ( input , i , output , j ) ; 
} public static void forHtmlUnquotedAttribute ( Writer out , String input ) 
encode ( Encoders . HTML_UNQUOTED_ATTRIBUTE_ENCODER , out , input ) ; 
} public static void forCssString ( Writer out , String input ) 
encode ( Encoders . CSS_STRING_ENCODER , out , input ) ; 
} public static void forCssUrl ( Writer out , String input ) 
encode ( Encoders . CSS_URL_ENCODER , out , input ) ; 
} @ Deprecated public static void forUri ( Writer out , String input ) 
encode ( Encoders . URI_ENCODER , out , input ) ; 
} public static void forUriComponent ( Writer out , String input ) 
encode ( Encoders . URI_COMPONENT_ENCODER , out , input ) ; 
} public static void forXml ( Writer out , String input ) 
encode ( Encoders . XML_ENCODER , out , input ) ; 
} public static void forXmlContent ( Writer out , String input ) 
encode ( Encoders . XML_CONTENT_ENCODER , out , input ) ; 
} public static void forXmlAttribute ( Writer out , String input ) 
encode ( Encoders . XML_ATTRIBUTE_ENCODER , out , input ) ; 
} public static void forXmlComment ( Writer out , String input ) 
encode ( Encoders . XML_COMMENT_ENCODER , out , input ) ; 
} public static void forCDATA ( Writer out , String input ) 
encode ( Encoders . CDATA_ENCODER , out , input ) ; 
} public static void forJava ( Writer out , String input ) 
encode ( Encoders . JAVA_ENCODER , out , input ) ; 
} public static void forJavaScript ( Writer out , String input ) 
encode ( Encoders . JAVASCRIPT_ENCODER , out , input ) ; 
} public static void forJavaScriptAttribute ( Writer out , String input ) 
encode ( Encoders . JAVASCRIPT_ATTRIBUTE_ENCODER , out , input ) ; 
} public static void forJavaScriptBlock ( Writer out , String input ) 
encode ( Encoders . JAVASCRIPT_BLOCK_ENCODER , out , input ) ; 
} public static void forJavaScriptSource ( Writer out , String input ) 
encode ( Encoders . JAVASCRIPT_SOURCE_ENCODER , out , input ) ; 
} static String encode ( Encoder encoder , String str ) { 
str = "null" ; 
final int n = str . length ( ) ; 
int j = encoder . firstEncodedOffset ( str , 0 , n ) ; 
if ( j == n ) { 
return new Buffer ( ) . encode ( encoder , str , j ) ; 
} static void encode ( Encoder encoder , Writer out , String str ) 
out . write ( str ) ; 
new Buffer ( ) . encode ( encoder , out , str , j ) ; 
} private static < T extends Encoder > T map ( String name , T encoder ) { 
Encoder old = ENCODERS_MAP . put ( name , encoder ) ; 
assert old == null ; 
return encoder ; 
} public static Encoder forName ( String contextName ) throws NullPointerException , UnsupportedContextException { 
Encoder encoder = ENCODERS_MAP . get ( contextName ) ; 
throw new UnsupportedContextException ( contextName ) ; 
} static int append ( char [ ] src , char [ ] out , int j ) { 
System . arraycopy ( src , 0 , out , j , src . length ) ; 
return j + src . length ; 
} static int encode ( int codePoint , char [ ] out , int j ) { 
if ( codePoint >= 1000 ) { 
out [ j ++ ] = ( char ) ( codePoint / 1000 % 10 + '0' ) ; 
if ( codePoint >= 100 ) { 
out [ j ++ ] = ( char ) ( codePoint / 100 % 10 + '0' ) ; 
if ( codePoint >= 10 ) { 
out [ j ++ ] = ( char ) ( codePoint / 10 % 10 + '0' ) ; 
out [ j ++ ] = ( char ) ( codePoint % 10 + '0' ) ; 
return j ; 
} public String encode ( String str ) { 
int n = str . length ( ) ; 
int j = _first . firstEncodedOffset ( str , 0 , n ) ; 
return Encode . encode ( _last , str ) ; 
final int remaining = n - j ; 
final int m = j + _first . maxEncodedLength ( n ) ; 
CharBuffer input = CharBuffer . allocate ( m ) ; 
str . getChars ( 0 , j , input . array ( ) , 0 ) ; 
str . getChars ( j , n , input . array ( ) , m - remaining ) ; 
input . limit ( m ) . position ( m - remaining ) ; 
CharBuffer tmp = input . duplicate ( ) ; 
tmp . position ( j ) ; 
CoderResult cr = _first . encode ( input , tmp , true ) ; 
CharBuffer output = CharBuffer . allocate ( _last . maxEncodedLength ( tmp . position ( ) ) ) ; 
tmp . flip ( ) ; 
cr = _last . encode ( tmp , output , true ) ; 
return new String ( output . array ( ) , 0 , output . position ( ) ) ; 
public CoderResult encode ( CharBuffer input , CharBuffer output , boolean endOfInput ) { 
CoderResult cr1 = _first . encode ( input , _buffer , endOfInput ) ; 
_buffer . flip ( ) ; 
CoderResult cr2 = _last . encode ( _buffer , output , endOfInput && cr1 . isUnderflow ( ) ) ; 
_buffer . compact ( ) ; 
if ( cr2 . isOverflow ( ) ) { 
return cr2 ; 
if ( cr1 . isUnderflow ( ) ) { 
} private void flushBufferToWriter ( ) throws IOException { 
_out . write ( _buffer . array ( ) , 0 , _buffer . position ( ) ) ; 
_buffer . clear ( ) ; 
} private void flushLeftOver ( CharBuffer input ) throws IOException { 
if ( ! _hasLeftOver ) { 
if ( input != null && input . hasRemaining ( ) ) { 
_leftOverBuffer . put ( input . get ( ) ) ; 
_leftOverBuffer . flip ( ) ; 
CoderResult cr = _encoder . encode ( _leftOverBuffer , _buffer , input == null ) ; 
if ( cr . isUnderflow ( ) ) { 
if ( _leftOverBuffer . hasRemaining ( ) ) { 
_leftOverBuffer . compact ( ) ; 
if ( cr . isOverflow ( ) ) { 
flushBufferToWriter ( ) ; 
_hasLeftOver = false ; 
_leftOverBuffer . clear ( ) ; 
} public static Predicate < ReactiveSensorEvent > filterSensorChanged ( ) { 
return new Predicate < ReactiveSensorEvent > ( ) { 
@ Override public boolean test ( ReactiveSensorEvent event ) throws Exception { 
return event . isSensorChanged ( ) ; 
} public static Predicate < ReactiveSensorEvent > filterAccuracyChanged ( ) { 
return event . isAccuracyChanged ( ) ; 
} public Flowable < ReactiveSensorEvent > observeSensor ( int sensorType , final int samplingPeriodInUs , 
final Handler handler , final BackpressureStrategy strategy ) { 
if ( ! hasSensor ( sensorType ) ) { 
String message = String . format ( Locale . getDefault ( ) , format , sensorType ) ; 
return Flowable . error ( new SensorNotFoundException ( message ) ) ; 
final Sensor sensor = sensorManager . getDefaultSensor ( sensorType ) ; 
final SensorEventListenerWrapper wrapper = new SensorEventListenerWrapper ( ) ; 
final SensorEventListener listener = wrapper . create ( ) ; 
return Flowable . create ( new FlowableOnSubscribe < ReactiveSensorEvent > ( ) { 
@ Override public void subscribe ( final FlowableEmitter < ReactiveSensorEvent > emitter ) 
wrapper . setEmitter ( emitter ) ; 
if ( handler == null ) { 
sensorManager . registerListener ( listener , sensor , samplingPeriodInUs ) ; 
sensorManager . registerListener ( listener , sensor , samplingPeriodInUs , handler ) ; 
} , strategy ) . doOnCancel ( new Action ( ) { 
@ Override public void run ( ) throws Exception { 
sensorManager . unregisterListener ( listener ) ; 
} private void updateDialogMetaData ( Map < String , Object > dialogMetaData , Object dialogAppData , HASipDialog haSipDialog , boolean recreation ) throws ParseException , 
PeerUnavailableException { 
haSipDialog . setMetaDataToReplicate ( dialogMetaData , recreation ) ; 
haSipDialog . setApplicationDataToReplicate ( dialogAppData ) ; 
final String contactStringified = ( String ) dialogMetaData . get ( AbstractHASipDialog . CONTACT_HEADER ) ; 
if ( logger . isLoggingEnabled ( StackLogger . TRACE_DEBUG ) ) { 
if ( contactStringified != null ) { 
Address contactAddress = SipFactory . getInstance ( ) . createAddressFactory ( ) . createAddress ( contactStringified ) ; 
ContactHeader contactHeader = SipFactory . getInstance ( ) . createHeaderFactory ( ) . createContactHeader ( contactAddress ) ; 
haSipDialog . setContactHeader ( contactHeader ) ; 
} private void updateServerTransactionMetaData ( Map < String , Object > transactionMetaData , Object transactionAppData , MobicentsHASIPServerTransaction haServerTransaction , boolean recreation ) throws ParseException , 
haServerTransaction . setMetaDataToReplicate ( transactionMetaData , recreation ) ; 
haServerTransaction . setApplicationDataToReplicate ( transactionAppData ) ; 
} public SIPDialog getDialog ( String dialogId ) throws SipCacheException { 
Node dialogNode = ( ( Node ) dialogRootNode . getChild ( Fqn . fromString ( dialogId ) ) ) ; 
if ( dialogNode != null ) { 
return ( SIPDialog ) dialogNode . get ( dialogId ) ; 
} catch ( CacheException e ) { 
} public void updateDialog ( SIPDialog sipDialog ) throws SipCacheException { 
Node dialogNode = ( ( Node ) dialogRootNode . getChild ( Fqn . fromString ( sipDialog . getDialogId ( ) ) ) ) ; 
sipDialog = ( SIPDialog ) dialogNode . get ( sipDialog . getDialogId ( ) ) ; 
} public void putDialog ( SIPDialog dialog ) throws SipCacheException { 
UserTransaction tx = null ; 
prop . put ( Context . INITIAL_CONTEXT_FACTORY , "org.jboss.cache.transaction.DummyContextFactory" ) ; 
tx = ( UserTransaction ) new InitialContext ( prop ) . lookup ( "UserTransaction" ) ; 
tx . begin ( ) ; 
Node dialogNode = dialogRootNode . addChild ( Fqn . fromString ( dialog . getDialogId ( ) ) ) ; 
dialogNode . put ( dialog . getDialogId ( ) , dialog ) ; 
tx . commit ( ) ; 
try { tx . rollback ( ) ; } catch ( Throwable t ) { } 
} public void removeDialog ( String dialogId ) throws SipCacheException { 
dialogRootNode . removeChild ( dialogId ) ; 
public void stop ( ) throws SipCacheException { 
if ( configProperties . getProperty ( ManagedMobicentsSipCache . STANDALONE ) != null || "true" . equals ( configProperties . getProperty ( ManagedMobicentsSipCache . STANDALONE ) ) ) { 
} private Address createAddress ( String balancerDescription ) { 
String host = balancerDescription ; 
int sipPort = LoadBalancerHeartBeatingServiceImpl . DEFAULT_LB_SIP_PORT ; 
if ( balancerDescription 
. indexOf ( LoadBalancerHeartBeatingServiceImpl . BALANCER_SIP_PORT_CHAR_SEPARATOR ) != - 1 ) { 
String [ ] balancerDescriptionSplitted = balancerDescription 
. split ( LoadBalancerHeartBeatingServiceImpl . BALANCER_SIP_PORT_CHAR_SEPARATOR ) ; 
host = balancerDescriptionSplitted [ 0 ] ; 
sipPort = Integer . parseInt ( balancerDescriptionSplitted [ 1 ] ) ; 
logger . logError ( 
+ balancerDescriptionSplitted [ 1 ] , e ) ; 
return createAddress ( host , sipPort ) ; 
} private Address createAddress ( String host , int port ) { 
SipUri sipUri = new SipUri ( ) ; 
sipUri . setHost ( host ) ; 
sipUri . setPort ( port ) ; 
return addressFactory . createAddress ( sipUri ) ; 
} public void loadBalancerRemoved ( SipLoadBalancer balancerDescription ) { 
Address address = createAddress ( balancerDescription . getAddress ( ) 
. getHostName ( ) , balancerDescription . getSipPort ( ) ) ; 
if ( address != null ) { 
removeLoadBalancer ( address ) ; 
} public void setService ( LoadBalancerHeartBeatingService service ) throws IllegalStateException , NullPointerException { 
if ( addressFactory == null || logger == null ) { 
this . service = service ; 
service . addLoadBalancerHeartBeatingListener ( this ) ; 
for ( SipLoadBalancer balancer : service . getLoadBalancers ( ) ) { 
addLoadBalancer ( balancer ) ; 
} public void passivateDialog ( HASipDialog dialog ) { 
String dialogId = dialog . getDialogIdToReplicate ( ) ; 
sipCache . evictDialog ( dialogId ) ; 
String mergeId = dialog . getMergeId ( ) ; 
if ( mergeId != null ) { 
serverDialogMergeTestTable . remove ( mergeId ) ; 
dialogTable . remove ( dialogId ) ; 
public void start ( ) throws ProviderDoesNotExistException , SipException { 
sipCache . start ( ) ; 
if ( loadBalancerHeartBeatingService != null ) { 
loadBalancerHeartBeatingService . start ( ) ; 
sipCache . stop ( ) ; 
loadBalancerHeartBeatingService . stop ( ) ; 
public SIPDialog createDialog ( SIPTransaction transaction ) { 
if ( sipCache . inLocalMode ( ) ) { 
return super . createDialog ( transaction ) ; 
SIPDialog retval = null ; 
if ( transaction instanceof SIPClientTransaction ) { 
final String dialogId = ( ( SIPRequest ) transaction . getRequest ( ) ) . getDialogId ( false ) ; 
retval = this . earlyDialogTable . get ( dialogId ) ; 
if ( retval == null || ( retval . getState ( ) != null && retval . getState ( ) != DialogState . EARLY ) ) { 
retval = ( SIPDialog ) HASipDialogFactory . createHASipDialog ( replicationStrategy , transaction ) ; 
this . earlyDialogTable . put ( dialogId , retval ) ; 
public SIPDialog createDialog ( SIPClientTransaction transaction , SIPResponse sipResponse ) { 
return super . createDialog ( transaction , sipResponse ) ; 
SIPDialog retval = this . earlyDialogTable . get ( dialogId ) ; 
if ( retval != null && sipResponse . isFinalResponse ( ) ) { 
this . earlyDialogTable . remove ( dialogId ) ; 
retval = ( SIPDialog ) HASipDialogFactory . createHASipDialog ( replicationStrategy , transaction , sipResponse ) ; 
public SIPDialog createDialog ( SipProviderImpl sipProvider , 
SIPResponse sipResponse ) { 
return super . createDialog ( sipProvider , sipResponse ) ; 
return ( SIPDialog ) HASipDialogFactory . createHASipDialog ( replicationStrategy , sipProvider , sipResponse ) ; 
public SIPDialog getDialog ( String dialogId ) { 
return super . getDialog ( dialogId ) ; 
if ( getStackLogger ( ) . isLoggingEnabled ( StackLogger . TRACE_DEBUG ) ) { 
SIPDialog sipDialog = super . getDialog ( dialogId ) ; 
int nbToken = new StringTokenizer ( dialogId , Separators . COLON ) . countTokens ( ) ; 
if ( nbToken >= 3 ) { 
if ( sipDialog == null ) { 
sipDialog = getDialogFromDistributedCache ( dialogId ) ; 
if ( sipDialog != null ) { 
SIPDialog existingDialog = super . putDialog ( sipDialog ) ; 
if ( existingDialog != null ) { 
sipDialog = existingDialog ; 
if ( sipDialog . getState ( ) == DialogState . CONFIRMED ) { 
sipCache . updateDialog ( sipDialog ) ; 
} catch ( SipCacheException e ) { 
return sipDialog ; 
public void removeDialog ( SIPDialog dialog ) { 
if ( ! sipCache . inLocalMode ( ) ) { 
removeDialogFromDistributedCache ( dialog . getDialogId ( ) ) ; 
super . removeDialog ( dialog ) ; 
} public void remoteDialogRemoval ( String dialogId ) { 
SIPDialog sipDialog = super . dialogTable . remove ( dialogId ) ; 
String mergeId = sipDialog . getMergeId ( ) ; 
super . serverDialogMergeTestTable . remove ( mergeId ) ; 
} protected SIPDialog getDialogFromDistributedCache ( String dialogId ) { 
SIPDialog sipDialog = null ; 
sipDialog = sipCache . getDialog ( dialogId ) ; 
( ( HASipDialog ) sipDialog ) . initAfterLoad ( this ) ; 
} protected void putDialogIntoDistributedCache ( SIPDialog dialog ) { 
String dialogId = dialog . getDialogId ( ) ; 
sipCache . putDialog ( dialog ) ; 
} protected void removeDialogFromDistributedCache ( String dialogId ) { 
sipCache . removeDialog ( dialogId ) ; 
public SIPTransaction findTransaction ( String transactionId , boolean isServer ) { 
if ( sipCache . inLocalMode ( ) || replicationStrategy != ReplicationStrategy . EarlyDialog ) { 
return super . findTransaction ( transactionId , isServer ) ; 
final String txId = transactionId . toLowerCase ( ) ; 
SIPTransaction sipTransaction = super . findTransaction ( txId , isServer ) ; 
if ( sipTransaction == null && transactionFactory != null ) { 
sipTransaction = sipCache . getServerTransaction ( txId ) ; 
if ( sipTransaction != null ) { 
SIPServerTransaction retval = serverTransactionTable . putIfAbsent ( txId , ( SIPServerTransaction ) sipTransaction ) ; 
if ( retval != null ) { 
sipTransaction = retval ; 
sipTransaction = sipCache . getClientTransaction ( txId ) ; 
SIPClientTransaction retval = clientTransactionTable . putIfAbsent ( txId , ( SIPClientTransaction ) sipTransaction ) ; 
( ( MobicentsHASIPClientTransaction ) sipTransaction ) . startTransactionTimerOnFailover ( ) ; 
return sipTransaction ; 
} public void remoteServerTransactionRemoval ( String transactionId ) { 
SIPServerTransaction sipServerTransaction = super . serverTransactionTable . remove ( txId ) ; 
if ( sipServerTransaction != null ) { 
super . removeFromMergeTable ( sipServerTransaction ) ; 
super . removePendingTransaction ( sipServerTransaction ) ; 
super . removeTransactionPendingAck ( sipServerTransaction ) ; 
} public void remoteClientTransactionRemoval ( String transactionId ) { 
SIPClientTransaction sipClientTransaction = super . clientTransactionTable . remove ( txId ) ; 
} private void updateClientTransactionMetaData ( Map < String , Object > transactionMetaData , Object transactionAppData , MobicentsHASIPClientTransaction haClientTransaction , boolean recreation ) throws ParseException , 
haClientTransaction . setMetaDataToReplicate ( transactionMetaData , recreation ) ; 
haClientTransaction . setApplicationDataToReplicate ( transactionAppData ) ; 
int next = ( current == balancers . size ( ) ? 1 : current + 1 ) ; 
} public void start ( ) throws SipCacheException { 
cluster . getMobicentsCache ( ) . startCache ( ) ; 
dialogsCacheData = new SIPDialogCacheData ( Fqn . fromElements ( name , SipCache . DIALOG_PARENT_FQN_ELEMENT ) , cluster . getMobicentsCache ( ) , clusteredSipStack ) ; 
dialogsCacheData . create ( ) ; 
dialogDataRemovalListener = new DialogDataRemovalListener ( dialogsCacheData . getNodeFqn ( ) , clusteredSipStack ) ; 
cluster . addDataRemovalListener ( dialogDataRemovalListener ) ; 
if ( clusteredSipStack . getReplicationStrategy ( ) == ReplicationStrategy . EarlyDialog ) { 
serverTransactionCacheData = new ServerTransactionCacheData ( Fqn . fromElements ( name , SipCache . SERVER_TX_PARENT_FQN_ELEMENT ) , cluster . getMobicentsCache ( ) , clusteredSipStack ) ; 
serverTransactionCacheData . create ( ) ; 
serverTransactionDataRemovalListener = new ServerTransactionDataRemovalListener ( serverTransactionCacheData . getNodeFqn ( ) , clusteredSipStack ) ; 
cluster . addDataRemovalListener ( serverTransactionDataRemovalListener ) ; 
clientTransactionCacheData = new ClientTransactionCacheData ( Fqn . fromElements ( name , SipCache . CLIENT_TX_PARENT_FQN_ELEMENT ) , cluster . getMobicentsCache ( ) , clusteredSipStack ) ; 
clientTransactionCacheData . create ( ) ; 
clientTransactionDataRemovalListener = new ClientTransactionDataRemovalListener ( clientTransactionCacheData . getNodeFqn ( ) , clusteredSipStack ) ; 
cluster . addDataRemovalListener ( clientTransactionDataRemovalListener ) ; 
if ( serializationClassLoader != null ) { 
Region region = getMobicentsCache ( ) . getJBossCache ( ) . getRegion ( dialogsCacheData . getNodeFqn ( ) , true ) ; 
region . registerContextClassLoader ( serializationClassLoader ) ; 
region . activate ( ) ; 
Region stxRegion = getMobicentsCache ( ) . getJBossCache ( ) . getRegion ( serverTransactionCacheData . getNodeFqn ( ) , true ) ; 
stxRegion . registerContextClassLoader ( serializationClassLoader ) ; 
stxRegion . activate ( ) ; 
Region ctxRegion = getMobicentsCache ( ) . getJBossCache ( ) . getRegion ( clientTransactionCacheData . getNodeFqn ( ) , true ) ; 
ctxRegion . registerContextClassLoader ( serializationClassLoader ) ; 
ctxRegion . activate ( ) ; 
} public void stop ( ) throws SipCacheException { 
dialogsCacheData . remove ( ) ; 
cluster . removeDataRemovalListener ( dialogDataRemovalListener ) ; 
serverTransactionCacheData . remove ( ) ; 
cluster . removeDataRemovalListener ( serverTransactionDataRemovalListener ) ; 
clientTransactionCacheData . remove ( ) ; 
cluster . removeDataRemovalListener ( clientTransactionDataRemovalListener ) ; 
} public SIPClientTransaction createClientTransaction ( SIPRequest sipRequest , 
MessageChannel encapsulatedMessageChannel ) { 
MobicentsHASIPClientTransaction ct = new MobicentsHASIPClientTransaction ( sipStack , 
encapsulatedMessageChannel ) ; 
ct . setOriginalRequest ( sipRequest ) ; 
} public void initAfterLoad ( ClusteredSipStack sipStackImpl ) { 
String transport = getLastResponseTopMostVia ( ) . getTransport ( ) ; 
Iterator < SipProviderImpl > providers = sipStackImpl . getSipProviders ( ) ; 
boolean providerNotFound = true ; 
while ( providers . hasNext ( ) ) { 
SipProviderImpl providerImpl = providers . next ( ) ; 
if ( providerImpl . getListeningPoint ( transport ) != null ) { 
setSipProvider ( providerImpl ) ; 
providerNotFound = false ; 
if ( providerNotFound ) { 
setStack ( ( SIPTransactionStack ) sipStackImpl ) ; 
setAssigned ( ) ; 
firstTransactionPort = getSipProvider ( ) . getListeningPoint ( getLastResponseTopMostVia ( ) . getTransport ( ) ) . getPort ( ) ; 
ackProcessed = true ; 
public boolean addTransaction ( SIPTransaction transaction ) { 
if ( transaction instanceof ServerTransaction ) { 
isLatestTxServer = true ; 
isLatestTxServer = false ; 
return super . addTransaction ( transaction ) ; 
} protected void replicateState ( ) { 
final DialogState dialogState = getState ( ) ; 
final ReplicationStrategy replicationStrategy = ( ( ClusteredSipStack ) getStack ( ) ) . getReplicationStrategy ( ) ; 
boolean replicationStateVsDialogStateOK = false ; 
if ( dialogState == DialogState . CONFIRMED && ( replicationStrategy == ReplicationStrategy . ConfirmedDialog || replicationStrategy == ReplicationStrategy . ConfirmedDialogNoApplicationData ) ) { 
replicationStateVsDialogStateOK = true ; 
if ( ( dialogState == DialogState . EARLY || dialogState == DialogState . CONFIRMED || 
dialogState == DialogState . TERMINATED ) 
&& replicationStrategy == ReplicationStrategy . EarlyDialog ) { 
if ( replicationStateVsDialogStateOK && isCreated && super . dialogId != null && isRemoteTagSet ( ) && isLocalTagSet ( ) && getStack ( ) . getDialog ( getDialogIdToReplicate ( ) ) != null ) { 
( ( ClusteredSipStack ) getStack ( ) ) . getSipCache ( ) . putDialog ( this ) ; 
} public void setHeartBeatInterval ( long heartBeatInterval ) { 
if ( heartBeatInterval < 100 ) 
this . heartBeatInterval = heartBeatInterval ; 
this . hearBeatTaskToRun . cancel ( ) ; 
this . hearBeatTaskToRun = new BalancerPingTimerTask ( ) ; 
this . heartBeatTimer . scheduleAtFixedRate ( this . hearBeatTaskToRun , 0 , 
this . heartBeatInterval ) ; 
} protected ArrayList < SIPNode > getReachableSIPNodeInfo ( InetAddress balancerAddr , ArrayList < SIPNode > info ) { 
if ( balancerAddr . isLoopbackAddress ( ) ) { 
ArrayList < SIPNode > rv = new ArrayList < SIPNode > ( ) ; 
for ( SIPNode node : info ) { 
if ( logger . isLoggingEnabled ( StackLogger . TRACE_TRACE ) ) { 
NetworkInterface ni = NetworkInterface . getByInetAddress ( InetAddress . getByName ( node . getIp ( ) ) ) ; 
boolean b = balancerAddr . isReachable ( ni , 5 , 900 ) ; 
rv . add ( node ) ; 
logger . logError ( "IOException" , e ) ; 
} public void sendSwitchoverInstruction ( SipLoadBalancer sipLoadBalancer , String fromJvmRoute , String toJvmRoute ) { 
if ( logger . isLoggingEnabled ( StackLogger . TRACE_INFO ) ) { 
if ( fromJvmRoute == null || toJvmRoute == null ) { 
Thread . currentThread ( ) . setContextClassLoader ( NodeRegisterRMIStub . class . getClassLoader ( ) ) ; 
Registry registry = LocateRegistry . getRegistry ( sipLoadBalancer . getAddress ( ) . getHostAddress ( ) , sipLoadBalancer . getRmiPort ( ) ) ; 
NodeRegisterRMIStub reg = ( NodeRegisterRMIStub ) registry . lookup ( "SIPBalancer" ) ; 
reg . switchover ( fromJvmRoute , toJvmRoute ) ; 
sipLoadBalancer . setDisplayWarning ( true ) ; 
if ( logger . isLoggingEnabled ( StackLogger . TRACE_INFO ) && ! sipLoadBalancer . isAvailable ( ) ) { 
sipLoadBalancer . setAvailable ( false ) ; 
if ( sipLoadBalancer . isDisplayWarning ( ) ) { 
sipLoadBalancer . setDisplayWarning ( false ) ; 
if ( sipNodes . isEmpty ( ) ) { 
updateConnectorsAsSIPNode ( ) ; 
} public boolean addBalancer ( String addr , int sipPort , int httpPort , int rmiPort ) { 
if ( addr == null ) 
address = InetAddress . getByName ( addr ) ; 
String balancerName = address . getCanonicalHostName ( ) + ":" + rmiPort ; 
if ( register . get ( balancerName ) != null ) { 
SipLoadBalancer sipLoadBalancer = new SipLoadBalancer ( this , address , sipPort , httpPort , rmiPort ) ; 
register . put ( balancerName , sipLoadBalancer ) ; 
for ( LoadBalancerHeartBeatingListener loadBalancerHeartBeatingListener : loadBalancerHeartBeatingListeners ) { 
loadBalancerHeartBeatingListener . loadBalancerAdded ( sipLoadBalancer ) ; 
} public boolean addBalancer ( String hostName , int sipPort , int httpPort , int index , int rmiPort ) { 
return this . addBalancer ( fetchHostAddress ( hostName , index ) 
. getHostAddress ( ) , sipPort , httpPort , rmiPort ) ; 
} public boolean removeBalancer ( String addr , int sipPort , int httpPort , int rmiPort ) { 
String keyToRemove = null ; 
Iterator < String > keyIterator = register . keySet ( ) . iterator ( ) ; 
while ( keyIterator . hasNext ( ) && keyToRemove == null ) { 
String key = keyIterator . next ( ) ; 
if ( register . get ( key ) . equals ( sipLoadBalancer ) ) { 
keyToRemove = key ; 
if ( keyToRemove != null ) { 
register . remove ( keyToRemove ) ; 
loadBalancerHeartBeatingListener . loadBalancerRemoved ( sipLoadBalancer ) ; 
} public boolean removeBalancer ( String hostName , int sipPort , int httpPort , int index , int rmiPort ) { 
InetAddress [ ] hostAddr = null ; 
hostAddr = InetAddress . getAllByName ( hostName ) ; 
} catch ( UnknownHostException uhe ) { 
uhe ) ; 
if ( index < 0 || index >= hostAddr . length ) { 
InetAddress address = hostAddr [ index ] ; 
return this . removeBalancer ( address . getHostAddress ( ) , sipPort , httpPort , rmiPort ) ; 
} protected ArrayList < SIPNode > getReachableSIPNodeInfo ( SipLoadBalancer balancer , ArrayList < SIPNode > info ) { 
InetAddress balancerAddr = balancer . getAddress ( ) ; 
if ( balancer . getCustomInfo ( ) != null && ! balancer . getCustomInfo ( ) . isEmpty ( ) ) { 
for ( Entry < Object , Object > entry : balancer . getCustomInfo ( ) . entrySet ( ) ) { 
node . getProperties ( ) . put ( ( String ) entry . getKey ( ) , ( String ) entry . getValue ( ) ) ; 
} public static Geometry readGeometry ( ByteReader reader ) { 
Geometry geometry = readGeometry ( reader , null ) ; 
return geometry ; 
} public static < T extends Geometry > T readGeometry ( ByteReader reader , 
Class < T > expectedType ) { 
ByteOrder originalByteOrder = reader . getByteOrder ( ) ; 
GeometryTypeInfo geometryTypeInfo = readGeometryType ( reader ) ; 
GeometryType geometryType = geometryTypeInfo . getGeometryType ( ) ; 
boolean hasZ = geometryTypeInfo . hasZ ( ) ; 
boolean hasM = geometryTypeInfo . hasM ( ) ; 
Geometry geometry = null ; 
switch ( geometryType ) { 
case GEOMETRY : 
geometry = readPoint ( reader , hasZ , hasM ) ; 
case LINESTRING : 
geometry = readLineString ( reader , hasZ , hasM ) ; 
geometry = readPolygon ( reader , hasZ , hasM ) ; 
case MULTIPOINT : 
geometry = readMultiPoint ( reader , hasZ , hasM ) ; 
case MULTILINESTRING : 
geometry = readMultiLineString ( reader , hasZ , hasM ) ; 
case MULTIPOLYGON : 
geometry = readMultiPolygon ( reader , hasZ , hasM ) ; 
case GEOMETRYCOLLECTION : 
case MULTICURVE : 
case MULTISURFACE : 
geometry = readGeometryCollection ( reader , hasZ , hasM ) ; 
case CIRCULARSTRING : 
geometry = readCircularString ( reader , hasZ , hasM ) ; 
case COMPOUNDCURVE : 
geometry = readCompoundCurve ( reader , hasZ , hasM ) ; 
case CURVEPOLYGON : 
geometry = readCurvePolygon ( reader , hasZ , hasM ) ; 
case CURVE : 
case SURFACE : 
case POLYHEDRALSURFACE : 
geometry = readPolyhedralSurface ( reader , hasZ , hasM ) ; 
case TIN : 
geometry = readTIN ( reader , hasZ , hasM ) ; 
case TRIANGLE : 
geometry = readTriangle ( reader , hasZ , hasM ) ; 
+ geometryType ) ; 
if ( expectedType != null && geometry != null 
&& ! expectedType . isAssignableFrom ( geometry . getClass ( ) ) ) { 
+ geometry . getClass ( ) . getSimpleName ( ) ) ; 
reader . setByteOrder ( originalByteOrder ) ; 
T result = ( T ) geometry ; 
} public static GeometryTypeInfo readGeometryType ( ByteReader reader ) { 
byte byteOrderValue = reader . readByte ( ) ; 
ByteOrder byteOrder = byteOrderValue == 0 ? ByteOrder . BIG_ENDIAN 
reader . setByteOrder ( byteOrder ) ; 
long unsignedGeometryTypeCode = reader . readUnsignedInt ( ) ; 
boolean hasZ = false ; 
if ( unsignedGeometryTypeCode > WKB25D ) { 
hasZ = true ; 
unsignedGeometryTypeCode -= WKB25D ; 
int geometryTypeCode = ( int ) unsignedGeometryTypeCode ; 
GeometryType geometryType = GeometryCodes 
. getGeometryType ( geometryTypeCode ) ; 
if ( ! hasZ ) { 
hasZ = GeometryCodes . hasZ ( geometryTypeCode ) ; 
boolean hasM = GeometryCodes . hasM ( geometryTypeCode ) ; 
GeometryTypeInfo geometryInfo = new GeometryTypeInfo ( geometryTypeCode , 
geometryType , hasZ , hasM ) ; 
return geometryInfo ; 
} public static Point readPoint ( ByteReader reader , boolean hasZ , boolean hasM ) { 
double x = reader . readDouble ( ) ; 
double y = reader . readDouble ( ) ; 
Point point = new Point ( hasZ , hasM , x , y ) ; 
if ( hasZ ) { 
double z = reader . readDouble ( ) ; 
point . setZ ( z ) ; 
if ( hasM ) { 
double m = reader . readDouble ( ) ; 
point . setM ( m ) ; 
} public static LineString readLineString ( ByteReader reader , boolean hasZ , 
boolean hasM ) { 
LineString lineString = new LineString ( hasZ , hasM ) ; 
int numPoints = reader . readInt ( ) ; 
for ( int i = 0 ; i < numPoints ; i ++ ) { 
Point point = readPoint ( reader , hasZ , hasM ) ; 
lineString . addPoint ( point ) ; 
return lineString ; 
} public static Polygon readPolygon ( ByteReader reader , boolean hasZ , 
Polygon polygon = new Polygon ( hasZ , hasM ) ; 
int numRings = reader . readInt ( ) ; 
for ( int i = 0 ; i < numRings ; i ++ ) { 
LineString ring = readLineString ( reader , hasZ , hasM ) ; 
polygon . addRing ( ring ) ; 
return polygon ; 
} public static MultiPoint readMultiPoint ( ByteReader reader , boolean hasZ , 
MultiPoint multiPoint = new MultiPoint ( hasZ , hasM ) ; 
Point point = readGeometry ( reader , Point . class ) ; 
multiPoint . addPoint ( point ) ; 
return multiPoint ; 
} public static MultiLineString readMultiLineString ( ByteReader reader , 
boolean hasZ , boolean hasM ) { 
MultiLineString multiLineString = new MultiLineString ( hasZ , hasM ) ; 
int numLineStrings = reader . readInt ( ) ; 
for ( int i = 0 ; i < numLineStrings ; i ++ ) { 
LineString lineString = readGeometry ( reader , LineString . class ) ; 
multiLineString . addLineString ( lineString ) ; 
return multiLineString ; 
} public static MultiPolygon readMultiPolygon ( ByteReader reader , 
MultiPolygon multiPolygon = new MultiPolygon ( hasZ , hasM ) ; 
int numPolygons = reader . readInt ( ) ; 
for ( int i = 0 ; i < numPolygons ; i ++ ) { 
Polygon polygon = readGeometry ( reader , Polygon . class ) ; 
multiPolygon . addPolygon ( polygon ) ; 
return multiPolygon ; 
} public static GeometryCollection < Geometry > readGeometryCollection ( 
ByteReader reader , boolean hasZ , boolean hasM ) { 
GeometryCollection < Geometry > geometryCollection = new GeometryCollection < Geometry > ( 
hasZ , hasM ) ; 
int numGeometries = reader . readInt ( ) ; 
for ( int i = 0 ; i < numGeometries ; i ++ ) { 
Geometry geometry = readGeometry ( reader , Geometry . class ) ; 
geometryCollection . addGeometry ( geometry ) ; 
return geometryCollection ; 
} public static CircularString readCircularString ( ByteReader reader , 
CircularString circularString = new CircularString ( hasZ , hasM ) ; 
circularString . addPoint ( point ) ; 
return circularString ; 
} public static CompoundCurve readCompoundCurve ( ByteReader reader , 
CompoundCurve compoundCurve = new CompoundCurve ( hasZ , hasM ) ; 
compoundCurve . addLineString ( lineString ) ; 
return compoundCurve ; 
} public static CurvePolygon < Curve > readCurvePolygon ( ByteReader reader , 
CurvePolygon < Curve > curvePolygon = new CurvePolygon < Curve > ( hasZ , hasM ) ; 
Curve ring = readGeometry ( reader , Curve . class ) ; 
curvePolygon . addRing ( ring ) ; 
return curvePolygon ; 
} public static PolyhedralSurface readPolyhedralSurface ( ByteReader reader , 
PolyhedralSurface polyhedralSurface = new PolyhedralSurface ( hasZ , hasM ) ; 
polyhedralSurface . addPolygon ( polygon ) ; 
return polyhedralSurface ; 
} public static TIN readTIN ( ByteReader reader , boolean hasZ , boolean hasM ) { 
TIN tin = new TIN ( hasZ , hasM ) ; 
tin . addPolygon ( polygon ) ; 
return tin ; 
} public static Triangle readTriangle ( ByteReader reader , boolean hasZ , 
Triangle triangle = new Triangle ( hasZ , hasM ) ; 
triangle . addRing ( ring ) ; 
return triangle ; 
} public static void writeGeometry ( ByteWriter writer , Geometry geometry ) 
byte byteOrder = writer . getByteOrder ( ) == ByteOrder . BIG_ENDIAN ? ( byte ) 0 
: ( byte ) 1 ; 
writer . writeByte ( byteOrder ) ; 
writer . writeInt ( GeometryCodes . getCode ( geometry ) ) ; 
GeometryType geometryType = geometry . getGeometryType ( ) ; 
writePoint ( writer , ( Point ) geometry ) ; 
writeLineString ( writer , ( LineString ) geometry ) ; 
writePolygon ( writer , ( Polygon ) geometry ) ; 
writeMultiPoint ( writer , ( MultiPoint ) geometry ) ; 
writeMultiLineString ( writer , ( MultiLineString ) geometry ) ; 
writeMultiPolygon ( writer , ( MultiPolygon ) geometry ) ; 
writeGeometryCollection ( writer , ( GeometryCollection < ? > ) geometry ) ; 
writeCircularString ( writer , ( CircularString ) geometry ) ; 
writeCompoundCurve ( writer , ( CompoundCurve ) geometry ) ; 
writeCurvePolygon ( writer , ( CurvePolygon < ? > ) geometry ) ; 
writePolyhedralSurface ( writer , ( PolyhedralSurface ) geometry ) ; 
writeTIN ( writer , ( TIN ) geometry ) ; 
writeTriangle ( writer , ( Triangle ) geometry ) ; 
} public static void writePoint ( ByteWriter writer , Point point ) 
writer . writeDouble ( point . getX ( ) ) ; 
writer . writeDouble ( point . getY ( ) ) ; 
if ( point . hasZ ( ) ) { 
writer . writeDouble ( point . getZ ( ) ) ; 
if ( point . hasM ( ) ) { 
writer . writeDouble ( point . getM ( ) ) ; 
} public static void writeLineString ( ByteWriter writer , LineString lineString ) 
writer . writeInt ( lineString . numPoints ( ) ) ; 
for ( Point point : lineString . getPoints ( ) ) { 
writePoint ( writer , point ) ; 
} public static void writePolygon ( ByteWriter writer , Polygon polygon ) 
writer . writeInt ( polygon . numRings ( ) ) ; 
for ( LineString ring : polygon . getRings ( ) ) { 
writeLineString ( writer , ring ) ; 
} public static void writeMultiPoint ( ByteWriter writer , MultiPoint multiPoint ) 
writer . writeInt ( multiPoint . numPoints ( ) ) ; 
for ( Point point : multiPoint . getPoints ( ) ) { 
writeGeometry ( writer , point ) ; 
} public static void writeMultiLineString ( ByteWriter writer , 
MultiLineString multiLineString ) throws IOException { 
writer . writeInt ( multiLineString . numLineStrings ( ) ) ; 
for ( LineString lineString : multiLineString . getLineStrings ( ) ) { 
writeGeometry ( writer , lineString ) ; 
} public static void writeMultiPolygon ( ByteWriter writer , 
MultiPolygon multiPolygon ) throws IOException { 
writer . writeInt ( multiPolygon . numPolygons ( ) ) ; 
for ( Polygon polygon : multiPolygon . getPolygons ( ) ) { 
writeGeometry ( writer , polygon ) ; 
} public static void writeGeometryCollection ( ByteWriter writer , 
GeometryCollection < ? > geometryCollection ) throws IOException { 
writer . writeInt ( geometryCollection . numGeometries ( ) ) ; 
for ( Geometry geometry : geometryCollection . getGeometries ( ) ) { 
writeGeometry ( writer , geometry ) ; 
} public static void writeCircularString ( ByteWriter writer , 
CircularString circularString ) throws IOException { 
writer . writeInt ( circularString . numPoints ( ) ) ; 
for ( Point point : circularString . getPoints ( ) ) { 
} public static void writeCompoundCurve ( ByteWriter writer , 
CompoundCurve compoundCurve ) throws IOException { 
writer . writeInt ( compoundCurve . numLineStrings ( ) ) ; 
for ( LineString lineString : compoundCurve . getLineStrings ( ) ) { 
} public static void writeCurvePolygon ( ByteWriter writer , 
CurvePolygon < ? > curvePolygon ) throws IOException { 
writer . writeInt ( curvePolygon . numRings ( ) ) ; 
for ( Curve ring : curvePolygon . getRings ( ) ) { 
writeGeometry ( writer , ring ) ; 
} public static void writePolyhedralSurface ( ByteWriter writer , 
PolyhedralSurface polyhedralSurface ) throws IOException { 
writer . writeInt ( polyhedralSurface . numPolygons ( ) ) ; 
for ( Polygon polygon : polyhedralSurface . getPolygons ( ) ) { 
} public static void writeTIN ( ByteWriter writer , TIN tin ) throws IOException { 
writer . writeInt ( tin . numPolygons ( ) ) ; 
for ( Polygon polygon : tin . getPolygons ( ) ) { 
} public static void writeTriangle ( ByteWriter writer , Triangle triangle ) 
writer . writeInt ( triangle . numRings ( ) ) ; 
for ( LineString ring : triangle . getRings ( ) ) { 
} public static int getCode ( Geometry geometry ) { 
int code = getCode ( geometry . getGeometryType ( ) ) ; 
if ( geometry . hasZ ( ) ) { 
code += 1000 ; 
if ( geometry . hasM ( ) ) { 
code += 2000 ; 
return code ; 
} public static int getCode ( GeometryType geometryType ) { 
code = 0 ; 
code = 1 ; 
code = 2 ; 
code = 3 ; 
code = 4 ; 
code = 5 ; 
code = 6 ; 
code = 7 ; 
code = 8 ; 
code = 9 ; 
code = 10 ; 
code = 11 ; 
code = 12 ; 
code = 13 ; 
code = 14 ; 
code = 15 ; 
code = 16 ; 
code = 17 ; 
throw new SFException ( 
} public static GeometryType getGeometryType ( int code ) { 
int geometryTypeCode = code % 1000 ; 
GeometryType geometryType = null ; 
switch ( geometryTypeCode ) { 
geometryType = GeometryType . GEOMETRY ; 
geometryType = GeometryType . POINT ; 
geometryType = GeometryType . LINESTRING ; 
geometryType = GeometryType . POLYGON ; 
geometryType = GeometryType . MULTIPOINT ; 
geometryType = GeometryType . MULTILINESTRING ; 
geometryType = GeometryType . MULTIPOLYGON ; 
geometryType = GeometryType . GEOMETRYCOLLECTION ; 
geometryType = GeometryType . CIRCULARSTRING ; 
geometryType = GeometryType . COMPOUNDCURVE ; 
geometryType = GeometryType . CURVEPOLYGON ; 
geometryType = GeometryType . MULTICURVE ; 
geometryType = GeometryType . MULTISURFACE ; 
geometryType = GeometryType . CURVE ; 
geometryType = GeometryType . SURFACE ; 
geometryType = GeometryType . POLYHEDRALSURFACE ; 
geometryType = GeometryType . TIN ; 
geometryType = GeometryType . TRIANGLE ; 
return geometryType ; 
} public static boolean hasZ ( int code ) { 
int mode = getGeometryMode ( code ) ; 
return hasZ ; 
} public static boolean hasM ( int code ) { 
boolean hasM = false ; 
hasM = true ; 
return hasM ; 
} public static < T > Filter < T > filter ( final Path . Filter filter , final Content . Type < T > contentType ) { 
return new Filter < T > ( ) { 
public boolean matches ( Path . ID id , Content . Type < T > ct ) { 
return ct == contentType && filter . matches ( id ) ; 
public boolean matchesSubpath ( Path . ID id ) { 
return filter . matchesSubpath ( id ) ; 
return filter . toString ( ) ; 
} public static < T > Filter < T > or ( final Filter < T > f1 , final Filter < T > f2 ) { 
return f1 . matches ( id , ct ) || f2 . matches ( id , ct ) ; 
return f1 . matchesSubpath ( id ) || f2 . matchesSubpath ( id ) ; 
return f1 . toString ( ) + "|" + f2 . toString ( ) ; 
} public ConfigFile read ( ) { 
List < Declaration > declarations = new ArrayList < > ( ) ; 
skipWhiteSpace ( ) ; 
while ( index < tokens . size ( ) ) { 
Token lookahead = tokens . get ( index ) ; 
if ( lookahead . kind == LeftSquare ) { 
declarations . add ( parseSection ( ) ) ; 
declarations . add ( parseKeyValuePair ( ) ) ; 
file . setDeclarations ( new Tuple < > ( declarations ) ) ; 
} private void checkNotEof ( ) { 
if ( index >= tokens . size ( ) ) { 
} private boolean isLineSpace ( Token token ) { 
return token . kind == Token . Kind . Indent || token . kind == Token . Kind . LineComment ; 
} protected String parseString ( String v ) { 
v = v . substring ( 1 , v . length ( ) - 1 ) ; 
StringBuffer result = new StringBuffer ( ) ; 
for ( int i = 0 ; i < v . length ( ) ; i ++ ) { 
if ( v . charAt ( i ) == '\\' ) { 
if ( v . length ( ) <= i + 1 ) { 
char replace = 0 ; 
int len = 2 ; 
switch ( v . charAt ( i + 1 ) ) { 
replace = '\b' ; 
replace = '\t' ; 
replace = '\n' ; 
replace = '\f' ; 
replace = '\r' ; 
replace = '\"' ; 
replace = '\'' ; 
replace = '\\' ; 
len = 6 ; 
String unicode = v . substring ( i + 2 , i + 6 ) ; 
replace = ( char ) Integer . parseInt ( unicode , 16 ) ; 
i = i + 5 ; 
result = result . append ( replace ) ; 
i = i + 1 ; 
result = result . append ( v . charAt ( i ) ) ; 
} public List < Token > scan ( ) throws Error { 
ArrayList < Token > tokens = new ArrayList < > ( ) ; 
while ( pos < input . length ( ) ) { 
for ( int i = 0 ; i != rules . length ; ++ i ) { 
Rule rule = rules [ i ] ; 
int left = input . length ( ) - pos ; 
if ( left >= rule . lookahead ( ) ) { 
Token t = rule . match ( input , pos ) ; 
tokens . add ( t ) ; 
pos = pos + t . text . length ( ) ; 
if ( pos == start ) { 
} private static boolean matchString ( StringBuffer input , int pos , 
java . lang . String syntax ) { 
int diff = input . length ( ) - pos ; 
if ( syntax . length ( ) > diff ) { 
for ( int i = 0 ; i != syntax . length ( ) ; ++ i ) { 
if ( syntax . charAt ( i ) != input . charAt ( pos + i ) ) { 
} protected Command . Template parse ( Command . Descriptor root , String [ ] args , int index ) { 
ArrayList < Command . Option > options = new ArrayList < > ( ) ; 
ArrayList < String > arguments = new ArrayList < > ( ) ; 
Command . Template sub = null ; 
while ( index < args . length ) { 
String arg = args [ index ] ; 
if ( isLongOption ( arg ) ) { 
options . add ( parseLongOption ( root , args [ index ] ) ) ; 
} else if ( isCommand ( arg , root . getCommands ( ) ) ) { 
Command . Descriptor cmd = getCommandDescriptor ( arg , root . getCommands ( ) ) ; 
sub = parse ( cmd , args , index + 1 ) ; 
arguments . add ( arg ) ; 
index = index + 1 ; 
Command . Options optionMap = new OptionsMap ( options , root . getOptionDescriptors ( ) ) ; 
return new ConcreteTemplate ( root , optionMap , arguments , sub ) ; 
} private static Pair < String , Object > parseOption ( String arg ) { 
arg = arg . substring ( 2 ) ; 
String [ ] split = arg . split ( "=" ) ; 
Object data = null ; 
if ( split . length > 1 ) { 
data = parseData ( split [ 1 ] ) ; 
return new Pair < > ( split [ 0 ] , data ) ; 
} private static Object parseData ( String str ) { 
if ( str . equals ( "true" ) ) { 
} else if ( str . equals ( "false" ) ) { 
} else if ( Character . isDigit ( str . charAt ( 0 ) ) ) { 
return Integer . parseInt ( str ) ; 
} protected void printUsage ( ) { 
List < Command . Descriptor > descriptors = project . getParent ( ) . getCommandDescriptors ( ) ; 
int maxWidth = determineCommandNameWidth ( descriptors ) ; 
out . println ( "Commands:" ) ; 
for ( Command . Descriptor d : descriptors ) { 
out . print ( rightPad ( d . getName ( ) , maxWidth ) ) ; 
} private static int determineCommandNameWidth ( List < Command . Descriptor > descriptors ) { 
max = Math . max ( max , d . getName ( ) . length ( ) ) ; 
} private List < Path . Entry < ? > > determinePackageContents ( ) throws IOException { 
ArrayList < Path . Entry < ? > > files = new ArrayList < > ( ) ; 
Path . Root root = project . getParent ( ) . getLocalRoot ( ) ; 
for ( int i = 0 ; i != includes . length ; ++ i ) { 
Content . Filter filter = createFilter ( includes [ i ] . toString ( ) ) ; 
files . addAll ( root . get ( filter ) ) ; 
return files ; 
} private ZipFile createZipFile ( List < Path . Entry < ? > > files ) throws IOException { 
HashSet < Path . ID > paths = new HashSet < > ( ) ; 
ZipFile zf = new ZipFile ( ) ; 
for ( int i = 0 ; i != files . size ( ) ; ++ i ) { 
Path . Entry < ? > file = files . get ( i ) ; 
addPaths ( file . id ( ) . parent ( ) , paths , zf ) ; 
String filename = file . id ( ) . toString ( ) + "." + file . contentType ( ) . getSuffix ( ) ; 
byte [ ] contents = readFileContents ( file ) ; 
zf . add ( new ZipEntry ( filename ) , contents ) ; 
return zf ; 
} private void addPaths ( Path . ID path , HashSet < Path . ID > paths , ZipFile zf ) { 
if ( path . size ( ) > 0 && ! paths . contains ( path ) ) { 
addPaths ( path . parent ( ) , paths , zf ) ; 
String directory = path . toString ( ) + "/" ; 
zf . add ( new ZipEntry ( directory ) , new byte [ 0 ] ) ; 
paths . add ( path ) ; 
} private byte [ ] readFileContents ( Path . Entry < ? > file ) throws IOException { 
InputStream in = file . inputStream ( ) ; 
int nRead ; 
byte [ ] data = new byte [ 1024 ] ; 
while ( ( nRead = in . read ( data , 0 , data . length ) ) != - 1 ) { 
buffer . write ( data , 0 , nRead ) ; 
buffer . flush ( ) ; 
return buffer . toByteArray ( ) ; 
} private Path . Entry < ZipFile > getPackageFile ( ) throws IOException { 
Value . UTF8 name = configuration . get ( Value . UTF8 . class , Trie . fromString ( "package/name" ) ) ; 
Value . UTF8 version = configuration . get ( Value . UTF8 . class , Trie . fromString ( "package/version" ) ) ; 
Trie pkg = Trie . fromString ( name + "-v" + version ) ; 
return project . getRepositoryRoot ( ) . create ( pkg , ZipFile . ContentType ) ; 
} private Content . Filter createFilter ( String filter ) { 
String [ ] split = filter . split ( "\\." ) ; 
Content . Type contentType = getContentType ( split [ 1 ] ) ; 
return Content . filter ( split [ 0 ] , contentType ) ; 
} private Content . Type getContentType ( String suffix ) { 
List < Content . Type < ? > > cts = project . getParent ( ) . getContentTypes ( ) ; 
for ( int i = 0 ; i != cts . size ( ) ; ++ i ) { 
Content . Type < ? > ct = cts . get ( i ) ; 
if ( ct . getSuffix ( ) . equals ( suffix ) ) { 
public void write ( int i ) throws IOException { 
output . write ( i & 0xFF ) ; 
write_un ( i & 0xFF , 8 ) ; 
} public void write_u32 ( int w ) throws IOException { 
write_u8 ( ( w > > 24 ) & 0xFF ) ; 
write_u8 ( ( w > > 16 ) & 0xFF ) ; 
write_u8 ( ( w > > 8 ) & 0xFF ) ; 
write_u8 ( w & 0xFF ) ; 
} public void write_uv ( int w ) throws IOException { 
int t = w & 7 ; 
w = w > > 3 ; 
write_un ( 8 | t , 4 ) ; 
write_un ( t , 4 ) ; 
} while ( w != 0 ) ; 
} public void write_un ( int bits , int n ) throws IOException { 
int mask = 1 ; 
for ( int i = 0 ; i < n ; ++ i ) { 
boolean bit = ( bits & mask ) != 0 ; 
write_bit ( bit ) ; 
mask = mask << 1 ; 
} public static void printSyntacticMarkers ( PrintStream output , Collection < Path . Entry < ? > > sources , Path . Entry < ? > target ) throws IOException { 
List < SyntacticItem . Marker > items = extractSyntacticMarkers ( target ) ; 
for ( int i = 0 ; i != items . size ( ) ; ++ i ) { 
printSyntacticMarkers ( output , sources , items . get ( i ) ) ; 
} private static void printSyntacticMarkers ( PrintStream output , Collection < Path . Entry < ? > > sources , SyntacticItem . Marker marker ) { 
Path . Entry < ? > source = getSourceEntry ( sources , marker . getSource ( ) ) ; 
Span span = marker . getTarget ( ) . getAncestor ( AbstractCompilationUnit . Attribute . Span . class ) ; 
EnclosingLine line = readEnclosingLine ( source , span ) ; 
if ( line != null ) { 
printLineHighlight ( output , line ) ; 
} private static List < SyntacticItem . Marker > extractSyntacticMarkers ( Path . Entry < ? > ... binaries ) throws IOException { 
List < SyntacticItem . Marker > annotated = new ArrayList < > ( ) ; 
for ( Path . Entry < ? > binary : binaries ) { 
Object o = binary . read ( ) ; 
if ( o instanceof SyntacticHeap ) { 
SyntacticHeap h = ( SyntacticHeap ) o ; 
extractSyntacticMarkers ( h . getRootItem ( ) , annotated , new BitSet ( ) ) ; 
return annotated ; 
} public Path . Root getPackageRoot ( String name , SemanticVersion version ) throws IOException { 
Path . ID path = Trie . ROOT . append ( name ) . append ( version . toString ( ) ) ; 
return root . createRelativeRoot ( path ) ; 
public < T extends SyntacticItem > T getParent ( Class < T > kind ) { 
return parent . getParent ( this , kind ) ; 
public < T extends SyntacticItem > List < T > getParents ( Class < T > kind ) { 
return parent . getParents ( this , kind ) ; 
public < T extends SyntacticItem > T getAncestor ( Class < T > kind ) { 
return parent . getAncestor ( this , kind ) ; 
} private int compareData ( Object leftData , Object rightData ) { 
if ( leftData == null || rightData == null ) { 
if ( leftData == rightData ) { 
} else if ( leftData == null ) { 
int leftKind = getDataKind ( leftData ) ; 
int rightKind = getDataKind ( rightData ) ; 
if ( leftKind != rightKind ) { 
return leftKind - rightKind ; 
switch ( leftKind ) { 
return ( ( Boolean ) leftData ) . compareTo ( ( Boolean ) rightData ) ; 
return ( ( BigInteger ) leftData ) . compareTo ( ( BigInteger ) rightData ) ; 
return ( ( String ) leftData ) . compareTo ( ( String ) rightData ) ; 
byte [ ] leftBytes = ( byte [ ] ) leftData ; 
byte [ ] rightBytes = ( byte [ ] ) rightData ; 
if ( leftBytes . length != rightBytes . length ) { 
return leftBytes . length - rightBytes . length ; 
for ( int i = 0 ; i != leftBytes . length ; ++ i ) { 
int c = Byte . compare ( leftBytes [ i ] , rightBytes [ i ] ) ; 
if ( c != 0 ) { 
} public static int [ ] range ( int start , int end ) { 
if ( end <= start ) { 
int [ ] rs = new int [ Math . abs ( end - start ) ] ; 
for ( int i = start ; i < end ; ++ i ) { 
rs [ i - start ] = i ; 
} public static int [ ] append ( int lhs , int [ ] rhs ) { 
int [ ] rs = new int [ rhs . length + 1 ] ; 
rs [ 0 ] = lhs ; 
System . arraycopy ( rhs , 0 , rs , 1 , rhs . length ) ; 
} public static int [ ] append ( int first , int second , int [ ] rhs ) { 
int [ ] rs = new int [ rhs . length + 2 ] ; 
rs [ 0 ] = first ; 
rs [ 1 ] = second ; 
System . arraycopy ( rhs , 0 , rs , 2 , rhs . length ) ; 
} public static int [ ] append ( int [ ] lhs , int [ ] rhs ) { 
int [ ] rs = java . util . Arrays . copyOf ( lhs , lhs . length + rhs . length ) ; 
System . arraycopy ( rhs , 0 , rs , lhs . length , rhs . length ) ; 
} public static < T > T [ ] append ( Class < T > type , T lhs , T ... rhs ) { 
T [ ] rs = ( T [ ] ) Array . newInstance ( type , rhs . length + 1 ) ; 
} public static < T > void addAll ( T [ ] lhs , Collection < T > rhs ) { 
for ( int i = 0 ; i != lhs . length ; ++ i ) { 
rhs . add ( lhs [ i ] ) ; 
} public static String [ ] toStringArray ( Collection < String > items ) { 
String [ ] result = new String [ items . size ( ) ] ; 
for ( String s : items ) { 
result [ i ++ ] = s ; 
} public static int [ ] toIntArray ( Collection < Integer > items ) { 
int [ ] result = new int [ items . size ( ) ] ; 
for ( Integer v : items ) { 
result [ i ++ ] = v ; 
} public static < T , S > T [ ] toArray ( Class < T > type , S [ ] src ) { 
T [ ] dest = ( T [ ] ) Array . newInstance ( type , src . length ) ; 
System . arraycopy ( src , 0 , dest , 0 , src . length ) ; 
return dest ; 
public static < T , S > T [ ] toArray ( Class < T > type , Collection < S > src ) { 
T [ ] dest = ( T [ ] ) Array . newInstance ( type , src . size ( ) ) ; 
for ( S s : src ) { 
dest [ i ++ ] = ( T ) s ; 
} public static < T > T [ ] removeDuplicates ( T [ ] items ) { 
BitSet duplicates = new BitSet ( items . length ) ; 
for ( int i = 0 ; i != items . length ; ++ i ) { 
T ith = items [ i ] ; 
for ( int j = i + 1 ; j < items . length ; ++ j ) { 
T jth = items [ j ] ; 
if ( ith == null ) { 
if ( jth == null ) { 
duplicates . set ( i ) ; 
count = count + 1 ; 
} else if ( ith . equals ( jth ) ) { 
return items ; 
T [ ] nItems = Arrays . copyOf ( items , items . length - count ) ; 
for ( int i = 0 , j = 0 ; i != items . length ; ++ i ) { 
if ( duplicates . get ( i ) ) { 
nItems [ j ++ ] = items [ i ] ; 
return nItems ; 
} public static < T extends S , S extends Comparable < S > > T [ ] sortAndRemoveDuplicates ( T [ ] children ) { 
int r = isSortedAndUnique ( children ) ; 
switch ( r ) { 
return ArrayUtils . sortedRemoveDuplicates ( children ) ; 
children = Arrays . copyOf ( children , children . length ) ; 
Arrays . sort ( children ) ; 
} public static < T extends Comparable < T > > int isSortedAndUnique ( T [ ] children ) { 
int r = 0 ; 
for ( int i = 1 ; i < children . length ; ++ i ) { 
int c = children [ i - 1 ] . compareTo ( children [ i ] ) ; 
if ( c == 0 ) { 
r = 1 ; 
} else if ( c > 0 ) { 
} public static < T > T [ ] removeAll ( T [ ] items , T item ) { 
if ( ith == item || ( item != null && item . equals ( ith ) ) ) { 
nItems [ j ++ ] = ith ; 
} public static < S , T extends Comparable < S > > int compareTo ( T [ ] lhs , T [ ] rhs ) { 
if ( lhs . length != rhs . length ) { 
return lhs . length - rhs . length ; 
int r = lhs [ i ] . compareTo ( ( S ) rhs [ i ] ) ; 
} public static < T > int firstIndexOf ( T [ ] items , T item ) { 
if ( ith == item || ( ith != null && ith . equals ( item ) ) ) { 
} public Configuration . Schema getBuildSchema ( ) { 
Configuration . Schema [ ] schemas = new Configuration . Schema [ buildPlatforms . size ( ) + 1 ] ; 
schemas [ 0 ] = LOCAL_CONFIG_SCHEMA ; 
for ( int i = 0 ; i != buildPlatforms . size ( ) ; ++ i ) { 
wybs . lang . Build . Platform platform = buildPlatforms . get ( i ) ; 
schemas [ i + 1 ] = platform . getConfigurationSchema ( ) ; 
return Configuration . toCombinedSchema ( schemas ) ; 
} private void createTemplateExtensionPoint ( ) { 
context . create ( Command . Descriptor . class , new Module . ExtensionPoint < Command . Descriptor > ( ) { 
public void register ( Command . Descriptor command ) { 
commandDescriptors . add ( command ) ; 
} private void createContentTypeExtensionPoint ( ) { 
context . create ( Content . Type . class , new Module . ExtensionPoint < Content . Type > ( ) { 
public void register ( Content . Type contentType ) { 
contentTypes . add ( contentType ) ; 
} private void createBuildPlatformExtensionPoint ( ) { 
context . create ( wybs . lang . Build . Platform . class , new Module . ExtensionPoint < wybs . lang . Build . Platform > ( ) { 
public void register ( wybs . lang . Build . Platform platform ) { 
buildPlatforms . add ( platform ) ; 
} private void activateDefaultPlugins ( Configuration global ) { 
List < Path . ID > plugins = global . matchAll ( Trie . fromString ( "plugins/*" ) ) ; 
for ( Path . ID id : plugins ) { 
UTF8 activator = global . get ( UTF8 . class , id ) ; 
Class < ? > c = Class . forName ( activator . toString ( ) ) ; 
Module . Activator instance = ( Module . Activator ) c . newInstance ( ) ; 
instance . start ( context ) ; 
String systemDir = determineSystemRoot ( ) ; 
String globalDir = determineGlobalRoot ( ) ; 
String localDir = determineLocalRoot ( ) ; 
new WyMain ( systemDir , globalDir , localDir ) . execute ( args ) ; 
} private static String determineSystemRoot ( ) throws IOException { 
String whileyhome = System . getenv ( "WHILEYHOME" ) ; 
if ( whileyhome == null ) { 
return whileyhome ; 
} private static String determineGlobalRoot ( ) throws IOException { 
String userhome = System . getProperty ( "user.home" ) ; 
String whileydir = userhome + File . separator + ".whiley" ; 
return whileydir ; 
} private static String determineLocalRoot ( ) throws IOException { 
File dir = new File ( "." ) ; 
while ( dir != null && dir . exists ( ) && dir . isDirectory ( ) ) { 
File wyf = new File ( dir + File . separator + "wy.toml" ) ; 
if ( wyf . exists ( ) ) { 
return dir . getPath ( ) ; 
return "." ; 
} private static Configuration readConfigFile ( String name , String dir , Configuration . Schema ... schemas ) throws IOException { 
DirectoryRoot root = new DirectoryRoot ( dir , BOOT_REGISTRY ) ; 
Path . Entry < ConfigFile > config = root . get ( Trie . fromString ( name ) , ConfigFile . ContentType ) ; 
return Configuration . EMPTY ; 
ConfigFile cf = config . read ( ) ; 
return cf . toConfiguration ( Configuration . toCombinedSchema ( schemas ) ) ; 
} catch ( SyntacticException e ) { 
e . outputSourceError ( System . out , false ) ; 
} private static void printStackTrace ( PrintStream out , Throwable err ) { 
for ( StackTraceElement ste : err . getStackTrace ( ) ) { 
if ( err . getCause ( ) != null ) { 
printStackTrace ( out , err . getCause ( ) ) ; 
} public < T extends Module > T getInstance ( Class < T > module ) { 
return ( T ) instances . get ( module ) ; 
URL [ ] urls = new URL [ modules . size ( ) ] ; 
for ( int i = 0 ; i != modules . size ( ) ; ++ i ) { 
urls [ i ] = modules . get ( i ) . getLocation ( ) ; 
URLClassLoader loader = new URLClassLoader ( urls ) ; 
activateModules ( loader ) ; 
} private void activateModules ( URLClassLoader loader ) { 
Descriptor module = modules . get ( i ) ; 
Class c = loader . loadClass ( module . getActivator ( ) ) ; 
Module . Activator self = ( Module . Activator ) c . newInstance ( ) ; 
Module instance = self . start ( context ) ; 
instances . put ( c , instance ) ; 
} public void outputSourceError ( PrintStream output , boolean brief ) { 
Attribute . Span span ; 
if ( entry == null || element == null ) { 
} else if ( element instanceof Attribute . Span ) { 
span = ( Attribute . Span ) element ; 
SyntacticHeap parent = element . getHeap ( ) ; 
span = parent . getParent ( element , Attribute . Span . class ) ; 
EnclosingLine enclosing = ( span == null ) ? null : readEnclosingLine ( entry , span ) ; 
if ( enclosing == null ) { 
} else if ( brief ) { 
printBriefError ( output , entry , enclosing , getMessage ( ) ) ; 
printFullError ( output , entry , enclosing , getMessage ( ) ) ; 
} private boolean ready ( Build . Task task ) { 
Path . Entry < ? > target = task . getTarget ( ) ; 
for ( Path . Entry < ? > s : task . getSources ( ) ) { 
if ( s . lastModified ( ) > target . lastModified ( ) ) { 
} public static Map < String , Object > parseOptions ( List < String > args , OptArg ... options ) { 
HashMap < String , Object > result = new HashMap < > ( ) ; 
HashMap < String , OptArg > optmap = new HashMap < > ( ) ; 
for ( OptArg opt : options ) { 
if ( opt . defaultValue != null ) { 
result . put ( opt . option , opt . defaultValue ) ; 
optmap . put ( opt . option , opt ) ; 
optmap . put ( opt . shortForm , opt ) ; 
Iterator < String > iter = args . iterator ( ) ; 
String arg = iter . next ( ) ; 
if ( arg . startsWith ( "-" ) ) { 
arg = arg . substring ( 1 , arg . length ( ) ) ; 
OptArg opt = optmap . get ( arg ) ; 
if ( opt != null ) { 
Kind k = opt . argument ; 
if ( k != null ) { 
String param = iter . next ( ) ; 
k . process ( opt . option , param , result ) ; 
result . put ( opt . option , null ) ; 
} private static Map < String , Object > splitConfig ( String str ) { 
HashMap < String , Object > options = new HashMap < > ( ) ; 
String [ ] splits = str . split ( "," ) ; 
for ( String s : splits ) { 
String [ ] p = s . split ( "=" ) ; 
options . put ( p [ 0 ] , parseValue ( p [ 1 ] ) ) ; 
} public void refresh ( ) throws IOException { 
root . refresh ( ) ; 
for ( Build . Rule rule : rules ) { 
rule . apply ( executor ) ; 
public < T extends SyntacticItem > T getParent ( SyntacticItem child , Class < T > kind ) { 
for ( int i = 0 ; i != syntacticItems . size ( ) ; ++ i ) { 
SyntacticItem parent = syntacticItems . get ( i ) ; 
if ( kind . isInstance ( parent ) ) { 
for ( int j = 0 ; j != parent . size ( ) ; ++ j ) { 
if ( parent . get ( j ) == child ) { 
return ( T ) parent ; 
public < T extends SyntacticItem > T getAncestor ( SyntacticItem child , Class < T > kind ) { 
if ( kind . isInstance ( child ) ) { 
return ( T ) child ; 
if ( parent . get ( j ) == child && ! ( parent instanceof AbstractCompilationUnit . Ref ) ) { 
T tmp = getAncestor ( parent , kind ) ; 
if ( tmp != null ) { 
} public static SyntacticItem substitute ( SyntacticItem item , SyntacticItem from , SyntacticItem to ) { 
SyntacticItem nItem = substitute ( item , from , to , new IdentityHashMap < > ( ) ) ; 
if ( nItem != item ) { 
item . getHeap ( ) . allocate ( nItem ) ; 
return nItem ; 
} private static SyntacticItem substitute ( SyntacticItem item , SyntacticItem from , SyntacticItem to , 
Map < SyntacticItem , SyntacticItem > mapping ) { 
SyntacticItem sItem = mapping . get ( item ) ; 
if ( sItem != null ) { 
return sItem ; 
} else if ( item == from ) { 
SyntacticItem nItem = item ; 
SyntacticItem [ ] children = item . getAll ( ) ; 
SyntacticItem [ ] nChildren = children ; 
if ( children != null ) { 
for ( int i = 0 ; i != children . length ; ++ i ) { 
SyntacticItem child = children [ i ] ; 
SyntacticItem nChild = substitute ( child , from , to , mapping ) ; 
if ( nChild != child && children == nChildren ) { 
nChildren = Arrays . copyOf ( children , children . length ) ; 
nChildren [ i ] = nChild ; 
if ( children != nChildren ) { 
nItem = item . clone ( nChildren ) ; 
mapping . put ( item , nItem ) ; 
} private Content . Type < ? > getContentType ( String file ) { 
String suffix = "." + ct . getSuffix ( ) ; 
if ( file . endsWith ( suffix ) ) { 
return Content . BinaryFile ; 
} public Path . Entry < ? > getEntry ( String file , Content . Type < ? > ct ) throws IOException { 
file = file . replace ( "." + ct . getSuffix ( ) , "" ) ; 
Path . ID id = Trie . fromString ( file ) ; 
return project . getParent ( ) . getLocalRoot ( ) . get ( id , ct ) ; 
} private void inspect ( Path . Entry < ? > entry , Content . Type < ? > ct , boolean garbage ) throws IOException { 
Object o = entry . read ( ) ; 
new SyntacticHeapPrinter ( new PrintWriter ( out ) , garbage ) . print ( ( SyntacticHeap ) o ) ; 
inspectBinaryFile ( readAllBytes ( entry . inputStream ( ) ) ) ; 
} private void inspectBinaryFile ( byte [ ] bytes ) { 
for ( int i = 0 ; i < bytes . length ; i += width ) { 
for ( int j = 0 ; j < width ; ++ j ) { 
if ( j + i < bytes . length ) { 
char c = ( char ) bytes [ i + j ] ; 
if ( c >= 32 && c < 128 ) { 
out . print ( c ) ; 
out . print ( "." ) ; 
} protected Pair < Integer , SyntacticItem [ ] > readItems ( ) throws IOException { 
checkHeader ( ) ; 
int size = in . read_uv ( ) ; 
int root = in . read_uv ( ) ; 
Bytecode [ ] items = new Bytecode [ size ] ; 
items [ i ] = readItem ( ) ; 
return new Pair < > ( root , constructItems ( items ) ) ; 
} public static Trie fromString ( String str ) { 
String [ ] components = str . split ( "/" ) ; 
Trie r = ROOT ; 
for ( int i = 0 ; i != components . length ; ++ i ) { 
r = r . append ( components [ i ] ) ; 
} public static Trie fromString ( Path . ID id ) { 
if ( id instanceof Trie ) { 
return ( ( Trie ) id ) ; 
for ( int i = 0 ; i != id . size ( ) ; ++ i ) { 
r = r . append ( id . get ( i ) ) ; 
} private boolean match ( Path . ID id , int idIndex , int myIndex , boolean submatch ) { 
int mySize = depth + 1 ; 
if ( myIndex == mySize && idIndex == id . size ( ) ) { 
} else if ( idIndex == id . size ( ) ) { 
return submatch ; 
} else if ( myIndex == mySize ) { 
String myComponent = get ( myIndex ) ; 
if ( myComponent . equals ( "*" ) ) { 
return match ( id , idIndex + 1 , myIndex + 1 , submatch ) ; 
} else if ( myComponent . equals ( "**" ) ) { 
myIndex ++ ; 
for ( int i = idIndex ; i <= id . size ( ) ; ++ i ) { 
if ( match ( id , i , myIndex , submatch ) ) { 
return myComponent . equals ( id . get ( idIndex ) ) 
&& match ( id , idIndex + 1 , myIndex + 1 , submatch ) ; 
} public static Command . Descriptor DESCRIPTOR ( List < Command . Descriptor > descriptors ) { 
return new Command . Descriptor ( ) { 
public Schema getConfigurationSchema ( ) { 
public List < Option . Descriptor > getOptionDescriptors ( ) { 
return Arrays . asList ( 
public Command initialise ( Command environment , Configuration configuration ) { 
return new WyProject ( ( WyMain ) environment , configuration , System . out , System . err ) ; 
return "wy" ; 
public List < Command . Descriptor > getCommands ( ) { 
} public List < wybs . lang . Build . Platform > getTargetPlatforms ( ) { 
ArrayList < Build . Platform > targetPlatforms = new ArrayList < > ( ) ; 
if ( configuration . hasKey ( BUILD_PLATFORMS ) ) { 
Value . UTF8 [ ] targetPlatformNames = configuration . get ( Value . Array . class , BUILD_PLATFORMS ) . toArray ( Value . UTF8 . class ) ; 
List < wybs . lang . Build . Platform > platforms = environment . getBuildPlatforms ( ) ; 
for ( int i = 0 ; i != platforms . size ( ) ; ++ i ) { 
Build . Platform platform = platforms . get ( i ) ; 
Value . UTF8 name = new Value . UTF8 ( platform . getName ( ) . getBytes ( ) ) ; 
if ( ArrayUtils . firstIndexOf ( targetPlatformNames , name ) >= 0 ) { 
targetPlatforms . add ( platform ) ; 
return targetPlatforms ; 
} public Path . Root getRepositoryRoot ( ) throws IOException { 
Path . Root root = environment . getGlobalRoot ( ) . createRelativeRoot ( REPOSITORY_PATH ) ; 
} private void resolvePackageDependencies ( ) throws IOException { 
Configuration . Schema buildSchema = environment . getBuildSchema ( ) ; 
Path . Root repository = getRepositoryRoot ( ) ; 
List < Path . ID > deps = configuration . matchAll ( Trie . fromString ( "dependencies/**" ) ) ; 
for ( int i = 0 ; i != deps . size ( ) ; ++ i ) { 
Path . ID dep = deps . get ( i ) ; 
String name = dep . get ( 1 ) ; 
UTF8 version = configuration . get ( UTF8 . class , dep ) ; 
Trie root = Trie . fromString ( name + "-v" + version ) ; 
if ( ! repository . exists ( root , ZipFile . ContentType ) ) { 
Path . Entry < ZipFile > zipfile = repository . get ( root , ZipFile . ContentType ) ; 
Path . Root pkgRoot = new ZipFileRoot ( zipfile , environment . getContentRegistry ( ) ) ; 
Path . Entry < ConfigFile > entry = pkgRoot . get ( Trie . fromString ( "wy" ) , ConfigFile . ContentType ) ; 
ConfigFile pkgcfg = pkgRoot . get ( Trie . fromString ( "wy" ) , ConfigFile . ContentType ) . read ( ) ; 
Build . Package pkg = new Package ( pkgRoot , pkgcfg . toConfiguration ( buildSchema ) ) ; 
project . getPackages ( ) . add ( pkg ) ; 
} private void initialisePlatforms ( ) throws IOException { 
List < Build . Platform > platforms = getTargetPlatforms ( ) ; 
platform . initialise ( configuration , project ) ; 
} public < T > List < Path . Entry < T > > find ( List < File > files , 
Content . Type < T > contentType ) 
ArrayList < Path . Entry < T > > sources = new ArrayList < > ( ) ; 
String suffix = "." + contentTypes . suffix ( contentType ) ; 
String location = location ( ) . getCanonicalPath ( ) ; 
String filePath = file . getCanonicalPath ( ) ; 
if ( filePath . startsWith ( location ) ) { 
int end = location . length ( ) ; 
if ( end > 1 ) { 
end ++ ; 
String module = filePath . substring ( end ) . replace ( 
File . separatorChar , '/' ) ; 
if ( module . endsWith ( suffix ) ) { 
module = module . substring ( 0 , 
module . length ( ) - suffix . length ( ) ) ; 
Path . ID mid = Trie . fromString ( module ) ; 
Path . Entry < T > entry = this . get ( mid , contentType ) ; 
sources . add ( entry ) ; 
return sources ; 
} public List < Token > scan ( ) { 
char c = input . charAt ( pos ) ; 
tokens . add ( scanNumericConstant ( ) ) ; 
tokens . add ( scanStringConstant ( ) ) ; 
} else if ( c == '\'' ) { 
tokens . add ( scanCharacterConstant ( ) ) ; 
} else if ( isOperatorStart ( c ) ) { 
tokens . add ( scanOperator ( ) ) ; 
} else if ( Character . isLetter ( c ) || c == '_' ) { 
tokens . add ( scanIdentifier ( ) ) ; 
scanWhiteSpace ( tokens ) ; 
} public Token scanNumericConstant ( ) { 
while ( pos < input . length ( ) && Character . isDigit ( input . charAt ( pos ) ) ) { 
pos = pos + 1 ; 
return new Token ( Token . Kind . IntValue , input . substring ( start , pos ) , 
start ) ; 
} public Token scanCharacterConstant ( ) { 
char c = input . charAt ( pos ++ ) ; 
switch ( input . charAt ( pos ++ ) ) { 
c = '\b' ; 
c = '\"' ; 
c = '\'' ; 
c = '\\' ; 
if ( input . charAt ( pos ) != '\'' ) { 
return new Token ( Token . Kind . CharValue , input . substring ( start , pos ) , 
} private void syntaxError ( String msg , int index ) { 
throw new SyntacticException ( msg , entry , new ConfigFile . Attribute . Span ( null , index , index ) ) ; 
} protected void insert ( Path . Item item ) throws IOException { 
if ( item . id ( ) . parent ( ) != id ) { 
updateContents ( ) ; 
Path . ID id = item . id ( ) ; 
int index = binarySearch ( contents , nentries , id ) ; 
index = - index - 1 ; 
insert ( index , item ) ; 
} @ FormatMethod 
public void log ( String format , @ Nullable Object ... args ) { 
System . out . print ( getIndentString ( ) ) ; 
System . out . printf ( format , args ) ; 
} public void logStackTrace ( ) { 
Throwable t = new Throwable ( ) ; 
t . fillInStackTrace ( ) ; 
StackTraceElement [ ] ste_arr = t . getStackTrace ( ) ; 
for ( int ii = 2 ; ii < ste_arr . length ; ii ++ ) { 
StackTraceElement ste = ste_arr [ ii ] ; 
} private String getIndentString ( ) { 
assert enabled ; 
if ( indentString == null ) { 
for ( int i = indentStrings . size ( ) ; i <= indentLevel ; i ++ ) { 
indentStrings . add ( indentStrings . get ( i - 1 ) + INDENT_STR_ONE_LEVEL ) ; 
indentString = indentStrings . get ( indentLevel ) ; 
return indentString ; 
} private void circulationPump ( 
final MethodGen m , 
final ControlFlowGraph cfg , 
final InstructionContext start , 
final Frame vanillaFrame , 
final InstConstraintVisitor icv , 
final ExecutionVisitor ev ) { 
final Random random = new Random ( ) ; 
final InstructionContextQueue icq = new InstructionContextQueue ( ) ; 
execute ( start , vanillaFrame , new ArrayList < InstructionContext > ( ) , icv , ev ) ; 
icq . add ( start , new ArrayList < InstructionContext > ( ) ) ; 
while ( ! icq . isEmpty ( ) ) { 
InstructionContext u ; 
ArrayList < InstructionContext > ec ; 
if ( ! DEBUG ) { 
final int r = random . nextInt ( icq . size ( ) ) ; 
u = icq . getIC ( r ) ; 
ec = icq . getEC ( r ) ; 
icq . remove ( r ) ; 
u = icq . getIC ( 0 ) ; 
ec = icq . getEC ( 0 ) ; 
icq . remove ( 0 ) ; 
final ArrayList < InstructionContext > oldchain = ( ArrayList < InstructionContext > ) ( ec . clone ( ) ) ; 
final ArrayList < InstructionContext > newchain = ( ArrayList < InstructionContext > ) ( ec . clone ( ) ) ; 
newchain . add ( u ) ; 
if ( ( u . getInstruction ( ) . getInstruction ( ) ) instanceof RET ) { 
final RET ret = ( RET ) ( u . getInstruction ( ) . getInstruction ( ) ) ; 
final ReturnaddressType t = 
( ReturnaddressType ) u . getOutFrame ( oldchain ) . getLocals ( ) . get ( ret . getIndex ( ) ) ; 
final InstructionContext theSuccessor = cfg . contextOf ( t . getTarget ( ) ) ; 
InstructionContext lastJSR = null ; 
int skip_jsr = 0 ; 
for ( int ss = oldchain . size ( ) - 1 ; ss >= 0 ; ss -- ) { 
if ( skip_jsr < 0 ) { 
if ( ( oldchain . get ( ss ) ) . getInstruction ( ) . getInstruction ( ) instanceof JsrInstruction ) { 
if ( skip_jsr == 0 ) { 
lastJSR = oldchain . get ( ss ) ; 
skip_jsr -- ; 
if ( ( oldchain . get ( ss ) ) . getInstruction ( ) . getInstruction ( ) instanceof RET ) { 
skip_jsr ++ ; 
if ( lastJSR == null ) { 
throw new AssertionViolatedException ( 
final JsrInstruction jsr = ( JsrInstruction ) ( lastJSR . getInstruction ( ) . getInstruction ( ) ) ; 
if ( theSuccessor != ( cfg . contextOf ( jsr . physicalSuccessor ( ) ) ) ) { 
+ u . getInstruction ( ) 
+ theSuccessor 
+ cfg . contextOf ( jsr . physicalSuccessor ( ) ) 
+ "'?" ) ; 
if ( execute ( theSuccessor , u . getOutFrame ( oldchain ) , newchain , icv , ev ) ) { 
@ SuppressWarnings ( 
"unchecked" ) 
final ArrayList < InstructionContext > newchainClone = 
( ArrayList < InstructionContext > ) newchain . clone ( ) ; 
icq . add ( theSuccessor , newchainClone ) ; 
final InstructionContext [ ] succs = u . getSuccessors ( ) ; 
for ( final InstructionContext v : succs ) { 
if ( execute ( v , u . getOutFrame ( oldchain ) , newchain , icv , ev ) ) { 
icq . add ( v , newchainClone ) ; 
final ExceptionHandler [ ] exc_hds = u . getExceptionHandlers ( ) ; 
for ( final ExceptionHandler exc_hd : exc_hds ) { 
final InstructionContext v = cfg . contextOf ( exc_hd . getHandlerStart ( ) ) ; 
if ( execute ( 
v , 
new Frame ( 
u . getOutFrame ( oldchain ) . getLocals ( ) , 
new OperandStack ( 
u . getOutFrame ( oldchain ) . getStack ( ) . maxStack ( ) , 
exc_hd . getExceptionType ( ) == null 
? Type . THROWABLE 
: exc_hd . getExceptionType ( ) ) ) , 
new ArrayList < InstructionContext > ( ) , 
icv , 
ev ) ) { 
icq . add ( v , new ArrayList < InstructionContext > ( ) ) ; 
InstructionHandle ih = start . getInstruction ( ) ; 
if ( ( ih . getInstruction ( ) instanceof ReturnInstruction ) && ( ! ( cfg . isDead ( ih ) ) ) ) { 
final InstructionContext ic = cfg . contextOf ( ih ) ; 
final Frame f = ic . getOutFrame ( new ArrayList < InstructionContext > ( ) ) ; 
final LocalVariables lvs = f . getLocals ( ) ; 
for ( int i = 0 ; i < lvs . maxLocals ( ) ; i ++ ) { 
if ( lvs . get ( i ) instanceof UninitializedObjectType ) { 
this . addMessage ( 
+ ic 
+ lvs 
+ "'." ) ; 
final OperandStack os = f . getStack ( ) ; 
for ( int i = 0 ; i < os . size ( ) ; i ++ ) { 
if ( os . peek ( i ) instanceof UninitializedObjectType ) { 
+ os 
} while ( ( ih = ih . getNext ( ) ) != null ) ; 
} public VerificationResult do_stack_ver ( MethodGen mg ) { 
final ConstantPoolGen constantPoolGen = mg . getConstantPool ( ) ; 
final InstConstraintVisitor icv = new NoConstraintsVisitor ( ) ; 
icv . setConstantPoolGen ( constantPoolGen ) ; 
final ExecutionVisitor ev = new ExecutionVisitor ( ) ; 
ev . setConstantPoolGen ( constantPoolGen ) ; 
stack_types = new StackTypes ( mg ) ; 
icv . setMethodGen ( mg ) ; 
if ( ! ( mg . isAbstract ( ) || mg . isNative ( ) ) ) { 
final ControlFlowGraph cfg = new ControlFlowGraph ( mg , false ) ; 
final Frame f = new Frame ( mg . getMaxLocals ( ) , mg . getMaxStack ( ) ) ; 
if ( ! mg . isStatic ( ) ) { 
if ( mg . getName ( ) . equals ( Const . CONSTRUCTOR_NAME ) ) { 
Frame . setThis ( new UninitializedObjectType ( new ObjectType ( mg . getClassName ( ) ) ) ) ; 
f . getLocals ( ) . set ( 0 , Frame . getThis ( ) ) ; 
@ SuppressWarnings ( "nullness" ) 
@ NonNull UninitializedObjectType dummy = null ; 
Frame . setThis ( dummy ) ; 
f . getLocals ( ) . set ( 0 , new ObjectType ( mg . getClassName ( ) ) ) ; 
final Type [ ] argtypes = mg . getArgumentTypes ( ) ; 
int twoslotoffset = 0 ; 
for ( int j = 0 ; j < argtypes . length ; j ++ ) { 
if ( argtypes [ j ] == Type . SHORT 
|| argtypes [ j ] == Type . BYTE 
|| argtypes [ j ] == Type . CHAR 
|| argtypes [ j ] == Type . BOOLEAN ) { 
argtypes [ j ] = Type . INT ; 
f . getLocals ( ) . set ( twoslotoffset + j + ( mg . isStatic ( ) ? 0 : 1 ) , argtypes [ j ] ) ; 
if ( argtypes [ j ] . getSize ( ) == 2 ) { 
twoslotoffset ++ ; 
f . getLocals ( ) . set ( twoslotoffset + j + ( mg . isStatic ( ) ? 0 : 1 ) , Type . UNKNOWN ) ; 
circulationPump ( mg , cfg , cfg . contextOf ( mg . getInstructionList ( ) . getStart ( ) ) , f , icv , ev ) ; 
} catch ( final VerifierConstraintViolatedException ce ) { 
return new VerificationResult ( VerificationResult . VERIFIED_REJECTED , ce . getMessage ( ) ) ; 
} catch ( final RuntimeException re ) { 
final StringWriter sw = new StringWriter ( ) ; 
final PrintWriter pw = new PrintWriter ( sw ) ; 
re . printStackTrace ( pw ) ; 
+ mg . getClassName ( ) 
+ mg 
+ sw 
+ "---\n" , 
re ) ; 
return VerificationResult . VR_OK ; 
} boolean execute ( 
InstructionContext ic , 
Frame inFrame , 
ArrayList < InstructionContext > executionPredecessors , 
InstConstraintVisitor icv , 
ExecutionVisitor ev ) { 
stack_types . set ( ic . getInstruction ( ) . getPosition ( ) , inFrame ) ; 
return ic . execute ( inFrame , executionPredecessors , icv , ev ) ; 
} protected String [ ] add_string ( String [ ] arr , String new_string ) { 
String [ ] new_arr = new String [ arr . length + 1 ] ; 
for ( int ii = 0 ; ii < arr . length ; ii ++ ) { 
new_arr [ ii ] = arr [ ii ] ; 
new_arr [ arr . length ] = new_string ; 
return new_arr ; 
} @ Pure 
protected final String get_attribute_name ( Attribute a ) { 
int con_index = a . getNameIndex ( ) ; 
Constant c = pool . getConstant ( con_index ) ; 
String att_name = ( ( ConstantUtf8 ) c ) . getBytes ( ) ; 
return att_name ; 
protected final @ Nullable Attribute get_stack_map_table_attribute ( MethodGen mgen ) { 
for ( Attribute a : mgen . getCodeAttributes ( ) ) { 
if ( is_stack_map_table ( a ) ) { 
protected final @ Nullable Attribute get_local_variable_type_table_attribute ( MethodGen mgen ) { 
if ( is_local_variable_type_table ( a ) ) { 
} protected final void update_stack_map_offset ( int position , int delta ) { 
running_offset = - 1 ; 
for ( int i = 0 ; i < stack_map_table . length ; i ++ ) { 
running_offset = stack_map_table [ i ] . getByteCodeOffset ( ) + running_offset + 1 ; 
if ( running_offset > position ) { 
stack_map_table [ i ] . updateByteCodeOffset ( delta ) ; 
} protected final StackMapEntry find_stack_map_equal ( int offset ) { 
if ( running_offset > offset ) { 
if ( running_offset == offset ) { 
return stack_map_table [ i ] ; 
} protected final int find_stack_map_index_before ( int offset ) { 
number_active_locals = initial_locals_count ; 
running_offset = running_offset + stack_map_table [ i ] . getByteCodeOffset ( ) + 1 ; 
if ( running_offset >= offset ) { 
running_offset = running_offset - stack_map_table [ i ] . getByteCodeOffset ( ) - 1 ; 
return i - 1 ; 
int frame_type = stack_map_table [ i ] . getFrameType ( ) ; 
if ( frame_type >= Const . APPEND_FRAME && frame_type <= Const . APPEND_FRAME_MAX ) { 
number_active_locals += frame_type - 251 ; 
} else if ( frame_type >= Const . CHOP_FRAME && frame_type <= Const . CHOP_FRAME_MAX ) { 
number_active_locals -= 251 - frame_type ; 
} else if ( frame_type == Const . FULL_FRAME ) { 
number_active_locals = stack_map_table [ i ] . getNumberOfLocals ( ) ; 
if ( stack_map_table . length == 0 ) { 
return stack_map_table . length - 1 ; 
} protected final @ IndexOrLow ( "stack_map_table" ) int find_stack_map_index_after ( int offset ) { 
} protected final void modify_stack_maps_for_switches ( InstructionHandle ih , InstructionList il ) { 
Instruction inst ; 
short opcode ; 
if ( ! needStackMap ) { 
il . setPositions ( ) ; 
while ( ih != null ) { 
inst = ih . getInstruction ( ) ; 
opcode = inst . getOpcode ( ) ; 
if ( opcode == Const . TABLESWITCH || opcode == Const . LOOKUPSWITCH ) { 
int current_offset = ih . getPosition ( ) ; 
int index = find_stack_map_index_after ( current_offset ) ; 
if ( index == - 1 ) { 
StackMapEntry stack_map = stack_map_table [ index ] ; 
int delta = ( current_offset + inst . getLength ( ) ) - running_offset ; 
if ( delta != 0 ) { 
stack_map . updateByteCodeOffset ( delta ) ; 
ih = ih . getNext ( ) ; 
} protected final int gen_temp_locals ( MethodGen mgen , int offset ) { 
int live_start = 0 ; 
Type live_type = null ; 
InstructionList il = mgen . getInstructionList ( ) ; 
int locals_offset_height = 0 ; 
int byte_code_offset = - 1 ; 
LocalVariableGen new_lvg ; 
int min_size = 3 ; 
StackMapType [ ] types_of_active_locals = new StackMapType [ number_active_locals ] ; 
for ( int ii = 0 ; ii < number_active_locals ; ii ++ ) { 
types_of_active_locals [ ii ] = initial_type_list [ ii ] ; 
locals_offset_height += getSize ( initial_type_list [ ii ] ) ; 
for ( StackMapEntry smte : stack_map_table ) { 
int frame_type = smte . getFrameType ( ) ; 
byte_code_offset += smte . getByteCodeOffset ( ) + 1 ; 
types_of_active_locals = 
Arrays . copyOf ( types_of_active_locals , number_active_locals + frame_type - 251 ) ; 
for ( StackMapType smt : smte . getTypesOfLocals ( ) ) { 
types_of_active_locals [ number_active_locals ++ ] = smt ; 
locals_offset_height += getSize ( smt ) ; 
int number_to_chop = 251 - frame_type ; 
while ( number_to_chop > 0 ) { 
locals_offset_height -= getSize ( types_of_active_locals [ -- number_active_locals ] ) ; 
number_to_chop -- ; 
types_of_active_locals = Arrays . copyOf ( types_of_active_locals , number_active_locals ) ; 
locals_offset_height = 0 ; 
number_active_locals = 0 ; 
types_of_active_locals = new StackMapType [ smte . getNumberOfLocals ( ) ] ; 
if ( live_start == 0 ) { 
if ( offset < locals_offset_height ) { 
live_start = byte_code_offset ; 
int running_offset = 0 ; 
for ( StackMapType smt : types_of_active_locals ) { 
live_type = generate_Type_from_StackMapType ( smt ) ; 
running_offset += getSize ( smt ) ; 
if ( live_type == null ) { 
live_start = 0 ; 
if ( offset >= locals_offset_height ) { 
new_lvg = 
mgen . addLocalVariable ( 
"DaIkOnTeMp" + offset , 
live_type , 
il . findHandle ( live_start ) , 
il . findHandle ( byte_code_offset ) ) ; 
debug_instrument . log ( 
new_lvg . getIndex ( ) , 
new_lvg . getStart ( ) . getPosition ( ) , 
new_lvg . getEnd ( ) . getPosition ( ) , 
new_lvg . getName ( ) , 
new_lvg . getType ( ) ) ; 
min_size = Math . min ( min_size , live_type . getSize ( ) ) ; 
live_type = null ; 
if ( live_start != 0 ) { 
"DaIkOnTeMp" + offset , live_type , offset , il . findHandle ( live_start ) , null ) ; 
il . getEnd ( ) . getPosition ( ) , 
if ( min_size == 3 ) { 
if ( byte_code_offset == - 1 ) { 
byte_code_offset = 0 ; 
"DaIkOnTeMp" + offset , Type . OBJECT , offset , il . findHandle ( byte_code_offset ) , null ) ; 
min_size = Math . min ( min_size , Type . OBJECT . getSize ( ) ) ; 
return offset + min_size ; 
} protected final void build_unitialized_NEW_map ( InstructionList il ) { 
uninitialized_NEW_map . clear ( ) ; 
if ( ( frame_type >= Const . SAME_LOCALS_1_STACK_ITEM_FRAME 
&& frame_type <= Const . SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED ) 
|| ( frame_type >= Const . APPEND_FRAME && frame_type <= Const . APPEND_FRAME_MAX ) 
|| ( frame_type == Const . FULL_FRAME ) ) { 
if ( smte . getNumberOfLocals ( ) > 0 ) { 
if ( smt . getType ( ) == Const . ITEM_NewObject ) { 
int i = smt . getIndex ( ) ; 
uninitialized_NEW_map . put ( il . findHandle ( i ) , i ) ; 
if ( smte . getNumberOfStackItems ( ) > 0 ) { 
for ( StackMapType smt : smte . getTypesOfStackItems ( ) ) { 
} private final void update_NEW_object_stack_map_entries ( int old_offset , int new_offset ) { 
if ( old_offset == smt . getIndex ( ) ) { 
smt . setIndex ( new_offset ) ; 
} protected final void update_uninitialized_NEW_offsets ( InstructionList il ) { 
for ( Map . Entry < InstructionHandle , Integer > e : uninitialized_NEW_map . entrySet ( ) ) { 
InstructionHandle ih = e . getKey ( ) ; 
int old_offset = e . getValue ( ) . intValue ( ) ; 
int new_offset = ih . getPosition ( ) ; 
if ( old_offset != new_offset ) { 
update_NEW_object_stack_map_entries ( old_offset , new_offset ) ; 
e . setValue ( new_offset ) ; 
} protected final void adjust_code_for_locals_change ( 
MethodGen mgen , int index_first_moved_local , int size ) { 
for ( InstructionHandle ih = il . getStart ( ) ; ih != null ; ih = ih . getNext ( ) ) { 
Instruction inst = ih . getInstruction ( ) ; 
int orig_length = inst . getLength ( ) ; 
int operand ; 
if ( ( inst instanceof RET ) || ( inst instanceof IINC ) ) { 
IndexedInstruction index_inst = ( IndexedInstruction ) inst ; 
if ( index_inst . getIndex ( ) >= index_first_moved_local ) { 
index_inst . setIndex ( index_inst . getIndex ( ) + size ) ; 
} else if ( inst instanceof LocalVariableInstruction ) { 
operand = ( ( LocalVariableInstruction ) inst ) . getIndex ( ) ; 
if ( operand >= index_first_moved_local ) { 
( ( LocalVariableInstruction ) inst ) . setIndex ( operand + size ) ; 
int delta = inst . getLength ( ) - orig_length ; 
if ( delta > 0 ) { 
update_stack_map_offset ( ih . getPosition ( ) , delta ) ; 
modify_stack_maps_for_switches ( ih , il ) ; 
} @ EnsuresNonNull ( { "stack_map_table" } ) 
protected final void set_current_stack_map_table ( MethodGen mgen , int java_class_version ) { 
smta = ( StackMap ) get_stack_map_table_attribute ( mgen ) ; 
if ( smta != null ) { 
stack_map_table = ( ( StackMap ) ( smta . copy ( smta . getConstantPool ( ) ) ) ) . getStackMap ( ) ; 
needStackMap = true ; 
smta . getTag ( ) , smta . getLength ( ) , smta . getNameIndex ( ) ) ; 
mgen . removeCodeAttribute ( smta ) ; 
stack_map_table = empty_stack_map_table ; 
if ( java_class_version > Const . MAJOR_1_6 ) { 
print_stack_map_table ( "Original" ) ; 
} protected final void print_stack_map_table ( String prefix ) { 
} protected final void create_new_stack_map_attribute ( MethodGen mgen ) throws IOException { 
if ( stack_map_table == empty_stack_map_table ) { 
print_stack_map_table ( "Final" ) ; 
StackMap map_table = 
new StackMap ( pool . addUtf8 ( "StackMapTable" ) , 0 , null , pool . getConstantPool ( ) ) ; 
map_table . setStackMap ( stack_map_table ) ; 
mgen . addCodeAttribute ( map_table ) ; 
} @ SuppressWarnings ( "signature" ) 
protected static @ ClassGetName String typeToClassGetName ( Type t ) { 
if ( t instanceof ObjectType ) { 
return ( ( ObjectType ) t ) . getClassName ( ) ; 
} else if ( t instanceof BasicType ) { 
return t . toString ( ) ; 
return t . getSignature ( ) . replace ( '/' , '.' ) ; 
} protected final StackMapType generate_StackMapType_from_Type ( Type t ) { 
case Const . T_BOOLEAN : 
case Const . T_CHAR : 
case Const . T_BYTE : 
case Const . T_SHORT : 
case Const . T_INT : 
return new StackMapType ( Const . ITEM_Integer , - 1 , pool . getConstantPool ( ) ) ; 
case Const . T_FLOAT : 
return new StackMapType ( Const . ITEM_Float , - 1 , pool . getConstantPool ( ) ) ; 
case Const . T_DOUBLE : 
return new StackMapType ( Const . ITEM_Double , - 1 , pool . getConstantPool ( ) ) ; 
case Const . T_LONG : 
return new StackMapType ( Const . ITEM_Long , - 1 , pool . getConstantPool ( ) ) ; 
case Const . T_ARRAY : 
case Const . T_OBJECT : 
return new StackMapType ( 
Const . ITEM_Object , pool . addClass ( typeToClassGetName ( t ) ) , pool . getConstantPool ( ) ) ; 
case Const . T_UNKNOWN : 
return new StackMapType ( Const . ITEM_NewObject , 0 , pool . getConstantPool ( ) ) ; 
} protected final Type generate_Type_from_StackMapType ( StackMapType smt ) { 
switch ( smt . getType ( ) ) { 
case Const . ITEM_Integer : 
case Const . ITEM_Bogus : 
return Type . INT ; 
case Const . ITEM_Float : 
return Type . FLOAT ; 
case Const . ITEM_Double : 
return Type . DOUBLE ; 
case Const . ITEM_Long : 
return Type . LONG ; 
case Const . ITEM_Object : 
return Type . OBJECT ; 
Thread . dumpStack ( ) ; 
} protected final void update_full_frame_stack_map_entries ( 
int offset , Type type_new_var , LocalVariableGen [ ] locals ) { 
@ NonNegative int index ; 
if ( stack_map_table [ i ] . getFrameType ( ) == Const . FULL_FRAME ) { 
int num_locals = stack_map_table [ i ] . getNumberOfLocals ( ) ; 
StackMapType [ ] new_local_types = new StackMapType [ num_locals + 1 ] ; 
StackMapType [ ] old_local_types = stack_map_table [ i ] . getTypesOfLocals ( ) ; 
for ( index = 0 ; index < num_locals ; index ++ ) { 
if ( index >= locals . length ) { 
if ( locals [ index ] . getIndex ( ) >= offset ) { 
new_local_types [ index ] = old_local_types [ index ] ; 
new_local_types [ index ++ ] = generate_StackMapType_from_Type ( type_new_var ) ; 
while ( index <= num_locals ) { 
new_local_types [ index ] = old_local_types [ index - 1 ] ; 
stack_map_table [ i ] . setTypesOfLocals ( new_local_types ) ; 
protected final LocalVariableGen add_new_argument ( 
MethodGen mgen , String arg_name , Type arg_type ) { 
return add_new_parameter ( mgen , arg_name , arg_type ) ; 
} protected final LocalVariableGen add_new_parameter ( 
LocalVariableGen arg_new = null ; 
LocalVariableGen [ ] locals = mgen . getLocalVariables ( ) ; 
Type [ ] arg_types = mgen . getArgumentTypes ( ) ; 
int new_index = 0 ; 
int new_offset = 0 ; 
boolean has_code = ( mgen . getInstructionList ( ) != null ) ; 
if ( has_code ) { 
if ( ! mgen . isStatic ( ) ) { 
new_index ++ ; 
new_offset ++ ; 
if ( arg_types . length > 0 ) { 
LocalVariableGen last_arg ; 
new_index = new_index + arg_types . length ; 
last_arg = locals [ new_index - 1 ] ; 
new_offset = last_arg . getIndex ( ) + ( last_arg . getType ( ) ) . getSize ( ) ; 
arg_new = mgen . addLocalVariable ( arg_name , arg_type , new_offset , null , null ) ; 
first_local_index ++ ; 
initial_locals_count ++ ; 
arg_types = BcelUtil . postpendToArray ( arg_types , arg_type ) ; 
String [ ] arg_names = add_string ( mgen . getArgumentNames ( ) , arg_name ) ; 
mgen . setArgumentTypes ( arg_types ) ; 
mgen . setArgumentNames ( arg_names ) ; 
for ( int i = new_index ; i < locals . length ; i ++ ) { 
LocalVariableGen lv = locals [ i ] ; 
lv . setIndex ( lv . getIndex ( ) + arg_type . getSize ( ) ) ; 
mgen . setMaxLocals ( mgen . getMaxLocals ( ) + arg_type . getSize ( ) ) ; 
adjust_code_for_locals_change ( mgen , new_offset , arg_type . getSize ( ) ) ; 
update_full_frame_stack_map_entries ( new_offset , arg_type , locals ) ; 
return arg_new ; 
} protected final LocalVariableGen create_method_scope_local ( 
MethodGen mgen , String local_name , Type local_type ) { 
LocalVariableGen lv_new ; 
int max_offset = 0 ; 
int new_offset = - 1 ; 
@ IndexOrLow ( "locals" ) int compiler_temp_i = - 1 ; 
int new_index = - 1 ; 
for ( i = 0 ; i < locals . length ; i ++ ) { 
if ( i >= first_local_index ) { 
if ( lv . getStart ( ) . getPosition ( ) != 0 ) { 
if ( new_offset == - 1 ) { 
if ( compiler_temp_i != - 1 ) { 
new_offset = locals [ compiler_temp_i ] . getIndex ( ) ; 
new_index = compiler_temp_i ; 
new_offset = lv . getIndex ( ) ; 
new_index = i ; 
max_offset = lv . getIndex ( ) + lv . getType ( ) . getSize ( ) ; 
if ( lv . getName ( ) . startsWith ( "DaIkOnTeMp" ) ) { 
if ( compiler_temp_i == - 1 ) { 
compiler_temp_i = i ; 
compiler_temp_i = - 1 ; 
if ( ( new_offset == - 1 ) && ( compiler_temp_i != - 1 ) ) { 
new_offset = max_offset ; 
if ( new_offset < mgen . getMaxLocals ( ) ) { 
mgen . setMaxLocals ( mgen . getMaxLocals ( ) + local_type . getSize ( ) ) ; 
lv_new = mgen . addLocalVariable ( local_name , local_type , new_offset , null , null ) ; 
for ( i = new_index ; i < locals . length ; i ++ ) { 
lv . setIndex ( lv . getIndex ( ) + local_type . getSize ( ) ) ; 
adjust_code_for_locals_change ( mgen , new_offset , local_type . getSize ( ) ) ; 
update_full_frame_stack_map_entries ( new_offset , local_type , locals ) ; 
return lv_new ; 
} protected final void fix_local_variable_table ( MethodGen mgen ) { 
if ( il == null ) { 
first_local_index = 0 ; 
LocalVariableGen l ; 
for ( int ii = 0 ; ii < locals . length ; ii ++ ) { 
locals [ ii ] = ( LocalVariableGen ) ( locals [ ii ] . clone ( ) ) ; 
int loc_index = 0 ; 
mgen . setMaxLocals ( ) ; 
int max_locals = mgen . getMaxLocals ( ) ; 
mgen . removeLocalVariables ( ) ; 
mgen . setMaxLocals ( 0 ) ; 
first_local_index = arg_types . length ; 
l = locals [ 0 ] ; 
new_lvg = mgen . addLocalVariable ( l . getName ( ) , l . getType ( ) , l . getIndex ( ) , null , null ) ; 
loc_index = 1 ; 
offset = 1 ; 
for ( int ii = 0 ; ii < arg_types . length ; ii ++ ) { 
if ( ( loc_index >= locals . length ) || ( offset != locals [ loc_index ] . getIndex ( ) ) ) { 
new_lvg = mgen . addLocalVariable ( "$hidden$" + offset , arg_types [ ii ] , offset , null , null ) ; 
l = locals [ loc_index ] ; 
loc_index ++ ; 
offset += arg_types [ ii ] . getSize ( ) ; 
LocalVariableGen [ ] initial_locals = mgen . getLocalVariables ( ) ; 
initial_locals_count = initial_locals . length ; 
initial_type_list = new StackMapType [ initial_locals_count ] ; 
for ( int ii = 0 ; ii < initial_locals_count ; ii ++ ) { 
initial_type_list [ ii ] = generate_StackMapType_from_Type ( initial_locals [ ii ] . getType ( ) ) ; 
for ( int ii = first_local_index ; ii < locals . length ; ii ++ ) { 
l = locals [ ii ] ; 
if ( l . getIndex ( ) > offset ) { 
offset = gen_temp_locals ( mgen , offset ) ; 
ii -- ; 
mgen . addLocalVariable ( l . getName ( ) , l . getType ( ) , l . getIndex ( ) , l . getStart ( ) , l . getEnd ( ) ) ; 
offset = new_lvg . getIndex ( ) + ( new_lvg . getType ( ) ) . getSize ( ) ; 
while ( offset < max_locals ) { 
} protected final StackTypes bcel_calc_stack_types ( MethodGen mg ) { 
StackVer stackver = new StackVer ( ) ; 
VerificationResult vr ; 
vr = stackver . do_stack_ver ( mg ) ; 
if ( vr != VerificationResult . VR_OK ) { 
System . out . printf ( 
return stackver . get_stack_types ( ) ; 
} public static String methodDeclarationToString ( Method m ) { 
String flags = accessFlagsToString ( m ) ; 
boolean argsExist = false ; 
if ( flags != null && ! flags . isEmpty ( ) ) { 
for ( Type at : m . getArgumentTypes ( ) ) { 
argsExist = true ; 
if ( argsExist ) { 
sb . setLength ( sb . length ( ) - 2 ) ; 
sb . append ( ")" ) ; 
} static String accessFlagsToString ( Method m ) { 
int flags = m . getAccessFlags ( ) ; 
for ( int i = 0 , pow = 1 ; i <= Const . MAX_ACC_FLAG ; i ++ ) { 
if ( ( flags & pow ) != 0 ) { 
if ( buf . length ( ) > 0 ) { 
if ( i < Const . ACCESS_NAMES_LENGTH ) { 
buf . append ( Const . getAccessName ( i ) ) ; 
buf . append ( String . format ( "ACC_BIT(%x)" , pow ) ) ; 
pow <<= 1 ; 
} public static String instructionListToString ( InstructionList il , ConstantPoolGen pool ) { 
StringBuilder out = new StringBuilder ( ) ; 
for ( Iterator < InstructionHandle > i = il . iterator ( ) ; i . hasNext ( ) ; ) { 
InstructionHandle handle = i . next ( ) ; 
out . append ( handle . getInstruction ( ) . toString ( pool . getConstantPool ( ) ) + "\n" ) ; 
} public static String localVariablesToString ( MethodGen mg ) { 
LocalVariableGen [ ] lvgs = mg . getLocalVariables ( ) ; 
if ( ( lvgs != null ) && ( lvgs . length > 0 ) ) { 
for ( LocalVariableGen lvg : lvgs ) { 
} public static String attributeNameToString ( Attribute a ) { 
ConstantPool pool = a . getConstantPool ( ) ; 
int conIndex = a . getNameIndex ( ) ; 
Constant c = pool . getConstant ( conIndex ) ; 
String attName = ( ( ConstantUtf8 ) c ) . getBytes ( ) ; 
return attName ; 
} public static boolean isConstructor ( MethodGen mg ) { 
if ( mg . getName ( ) . equals ( "" ) ) { 
return mg . getName ( ) . equals ( "<init>" ) ; 
} public static boolean isConstructor ( Method m ) { 
if ( m . getName ( ) . equals ( "" ) ) { 
return m . getName ( ) . equals ( "<init>" ) ; 
} public static boolean inJdk ( @ ClassGetName String classname ) { 
return classname . startsWith ( "java." ) 
|| classname . startsWith ( "com.oracle." ) 
|| classname . startsWith ( "com.sun." ) 
|| classname . startsWith ( "javax." ) 
|| classname . startsWith ( "jdk." ) 
|| classname . startsWith ( "org.ietf." ) 
|| classname . startsWith ( "org.jcp." ) 
|| classname . startsWith ( "org.omg." ) 
|| classname . startsWith ( "org.w3c." ) 
|| classname . startsWith ( "org.xml." ) 
|| classname . startsWith ( "sun." ) 
|| classname . startsWith ( "sunw." ) ; 
} public static boolean inJdkInternalform ( @ InternalForm String classname ) { 
return classname . startsWith ( "java/" ) 
|| classname . startsWith ( "com/oracle/" ) 
|| classname . startsWith ( "com/sun/" ) 
|| classname . startsWith ( "javax/" ) 
|| classname . startsWith ( "jdk/" ) 
|| classname . startsWith ( "org/ietj/" ) 
|| classname . startsWith ( "org/jcp/" ) 
|| classname . startsWith ( "org/omg/" ) 
|| classname . startsWith ( "org/w3c/" ) 
|| classname . startsWith ( "org/xml/" ) 
|| classname . startsWith ( "sun/" ) 
|| classname . startsWith ( "sunw/" ) ; 
} public static boolean isMain ( MethodGen mg ) { 
Type [ ] argTypes = mg . getArgumentTypes ( ) ; 
return mg . isStatic ( ) 
&& ( mg . getReturnType ( ) == Type . VOID ) 
&& mg . getName ( ) . equals ( "main" ) 
&& ( argTypes . length == 1 ) 
&& argTypes [ 0 ] . equals ( stringArray ) ; 
} public static void checkMgen ( MethodGen mgen ) { 
if ( skipChecks ) { 
mgen . toString ( ) ; 
mgen . getLineNumberTable ( mgen . getConstantPool ( ) ) ; 
InstructionList ilist = mgen . getInstructionList ( ) ; 
if ( ilist == null || ilist . getStart ( ) == null ) { 
CodeExceptionGen [ ] exceptionHandlers = mgen . getExceptionHandlers ( ) ; 
for ( CodeExceptionGen gen : exceptionHandlers ) { 
assert ilist . contains ( gen . getStartPC ( ) ) 
+ gen 
+ mgen . getClassName ( ) 
+ "." 
+ mgen . getName ( ) ; 
MethodGen nmg = new MethodGen ( mgen . getMethod ( ) , mgen . getClassName ( ) , mgen . getConstantPool ( ) ) ; 
nmg . getLineNumberTable ( mgen . getConstantPool ( ) ) ; 
Error e = 
new Error ( 
t ) ; 
} public static void checkMgens ( final ClassGen gen ) { 
Method [ ] methods = gen . getMethods ( ) ; 
Method method = methods [ i ] ; 
checkMgen ( new MethodGen ( method , gen . getClassName ( ) , gen . getConstantPool ( ) ) ) ; 
dumpStackTrace ( ) ; 
dumpMethods ( gen ) ; 
} public static void dumpStackTrace ( ) { 
StackTraceElement [ ] ste = Thread . currentThread ( ) . getStackTrace ( ) ; 
if ( ste . length < 3 ) { 
StackTraceElement caller = ste [ 2 ] ; 
caller . getClassName ( ) , 
caller . getMethodName ( ) , 
caller . getFileName ( ) , 
caller . getLineNumber ( ) ) ; 
for ( int ii = 3 ; ii < ste . length ; ii ++ ) { 
System . out . printf ( "%n" ) ; 
} static void dumpMethods ( ClassGen gen ) { 
for ( Method m : gen . getMethods ( ) ) { 
} public static void dump ( JavaClass jc , File dumpDir ) { 
dumpDir . mkdir ( ) ; 
File path = new File ( dumpDir , jc . getClassName ( ) + ".bcel" ) ; 
PrintStream p = new PrintStream ( path ) ; 
String [ ] inames = jc . getInterfaceNames ( ) ; 
if ( ( inames != null ) && ( inames . length > 0 ) ) { 
for ( String iname : inames ) { 
p . printf ( "%s" , iname ) ; 
p . printf ( "%n" ) ; 
p . printf ( "%nFields%n" ) ; 
for ( Field f : jc . getFields ( ) ) { 
p . printf ( "%nMethods%n" ) ; 
for ( Method m : jc . getMethods ( ) ) { 
Code code = m . getCode ( ) ; 
if ( code != null ) { 
ConstantPool cp = jc . getConstantPool ( ) ; 
Constant [ ] constants = cp . getConstantPool ( ) ; 
for ( int ii = 0 ; ii < constants . length ; ii ++ ) { 
throw new Error ( 
} public static void addToStart ( MethodGen mg , InstructionList newList ) { 
InstructionList il = mg . getInstructionList ( ) ; 
InstructionHandle oldStart = il . getStart ( ) ; 
InstructionHandle newStart = il . insert ( newList ) ; 
if ( oldStart . hasTargeters ( ) ) { 
for ( InstructionTargeter it : oldStart . getTargeters ( ) ) { 
if ( ( it instanceof LineNumberGen ) || ( it instanceof LocalVariableGen ) ) { 
it . updateTarget ( oldStart , newStart ) ; 
mg . setMaxStack ( ) ; 
mg . setMaxLocals ( ) ; 
} public static String getConstantString ( ConstantPool pool , int index ) { 
Constant c = pool . getConstant ( index ) ; 
if ( c instanceof ConstantUtf8 ) { 
return ( ( ConstantUtf8 ) c ) . getBytes ( ) ; 
} else if ( c instanceof ConstantClass ) { 
ConstantClass cc = ( ConstantClass ) c ; 
} public static void resetLocalsToFormals ( MethodGen mg ) { 
@ SuppressWarnings ( "nullness" 
Type @ SameLen ( { "argTypes" , "mg.getArgumentTypes()" } ) [ ] argTypes = mg . getArgumentTypes ( ) ; 
String @ SameLen ( { "argTypes" , "argNames" , "mg.getArgumentTypes()" , "mg.getArgumentNames()" } ) [ ] 
argNames = mg . getArgumentNames ( ) ; 
mg . setMaxLocals ( 0 ) ; 
mg . removeLocalVariables ( ) ; 
mg . addLocalVariable ( "this" , new ObjectType ( mg . getClassName ( ) ) , null , null ) ; 
for ( int ii = 0 ; ii < argNames . length ; ii ++ ) { 
mg . addLocalVariable ( argNames [ ii ] , argTypes [ ii ] , null , null ) ; 
} public static void makeMethodBodyEmpty ( MethodGen mg ) { 
mg . setInstructionList ( new InstructionList ( new RETURN ( ) ) ) ; 
mg . removeExceptionHandlers ( ) ; 
mg . removeLineNumbers ( ) ; 
} public static void removeLocalVariableTypeTables ( MethodGen mg ) { 
for ( Attribute a : mg . getCodeAttributes ( ) ) { 
if ( isLocalVariableTypeTable ( a , mg . getConstantPool ( ) ) ) { 
mg . removeCodeAttribute ( a ) ; 
} public static @ ClassGetName String typeToClassgetname ( Type type ) { 
String signature = type . getSignature ( ) ; 
return Signatures . fieldDescriptorToClassGetName ( signature ) ; 
} public static Class < ? > typeToClass ( Type type ) { 
String classname = typeToClassgetname ( type ) ; 
return ReflectionPlume . classForName ( classname ) ; 
} public static Type [ ] postpendToArray ( Type [ ] types , Type newType ) { 
if ( types . length == Integer . MAX_VALUE ) { 
Type [ ] newTypes = new Type [ types . length + 1 ] ; 
System . arraycopy ( types , 0 , newTypes , 0 , types . length ) ; 
newTypes [ types . length ] = newType ; 
return newTypes ; 
} public static Type classnameToType ( @ BinaryName String classname ) { 
classname = classname . intern ( ) ; 
if ( classname == "int" ) { 
} else if ( classname == "boolean" ) { 
return Type . BOOLEAN ; 
} else if ( classname == "byte" ) { 
return Type . BYTE ; 
} else if ( classname == "char" ) { 
return Type . CHAR ; 
} else if ( classname == "double" ) { 
} else if ( classname == "float" ) { 
} else if ( classname == "long" ) { 
} else if ( classname == "short" ) { 
return Type . SHORT ; 
return new ObjectType ( classname ) ; 
} public void set ( @ IndexFor ( { "loc_arr" , "os_arr" } ) int offset , Frame f ) { 
OperandStack os = f . getStack ( ) ; 
loc_arr [ offset ] = ( LocalVariables ) ( f . getLocals ( ) . clone ( ) ) ; 
os_arr [ offset ] = ( OperandStack ) ( os . clone ( ) ) ; 
public static @ FieldDescriptor String binaryNameToFieldDescriptor ( @ BinaryName String classname ) { 
int dims = 0 ; 
String sansArray = classname ; 
while ( sansArray . endsWith ( "[]" ) ) { 
dims ++ ; 
sansArray = sansArray . substring ( 0 , sansArray . length ( ) - 2 ) ; 
String result = primitiveClassesJvm . get ( sansArray ) ; 
result = "L" + sansArray + ";" ; 
for ( int i = 0 ; i < dims ; i ++ ) { 
result = "[" + result ; 
return result . replace ( '.' , '/' ) ; 
} public static @ FieldDescriptor String primitiveTypeNameToFieldDescriptor ( String primitiveName ) { 
String result = primitiveClassesJvm . get ( primitiveName ) ; 
public static @ ClassGetName String binaryNameToClassGetName ( String bn ) { 
if ( bn . endsWith ( "[]" ) ) { 
return binaryNameToFieldDescriptor ( bn ) . replace ( '/' , '.' ) ; 
return bn ; 
public static @ ClassGetName String fieldDescriptorToClassGetName ( String fd ) { 
if ( fd . startsWith ( "[" ) ) { 
return fd . replace ( '/' , '.' ) ; 
return fieldDescriptorToBinaryName ( fd ) ; 
} public static String arglistToJvm ( String arglist ) { 
if ( ! ( arglist . startsWith ( "(" ) && arglist . endsWith ( ")" ) ) ) { 
String result = "(" ; 
String commaSepArgs = arglist . substring ( 1 , arglist . length ( ) - 1 ) ; 
StringTokenizer argsTokenizer = new StringTokenizer ( commaSepArgs , "," , false ) ; 
while ( argsTokenizer . hasMoreTokens ( ) ) { 
@ SuppressWarnings ( "signature" ) 
@ BinaryName String arg = argsTokenizer . nextToken ( ) . trim ( ) ; 
result += binaryNameToFieldDescriptor ( arg ) ; 
result += ")" ; 
public static @ BinaryName String fieldDescriptorToBinaryName ( String classname ) { 
if ( classname . equals ( "" ) ) { 
while ( classname . startsWith ( "[" ) ) { 
classname = classname . substring ( 1 ) ; 
if ( classname . startsWith ( "L" ) && classname . endsWith ( ";" ) ) { 
result = classname . substring ( 1 , classname . length ( ) - 1 ) ; 
result = primitiveClassesFromJvm . get ( classname ) ; 
result += "[]" ; 
return result . replace ( '/' , '.' ) ; 
} public static String arglistFromJvm ( String arglist ) { 
@ Positive int pos = 1 ; 
while ( pos < arglist . length ( ) - 1 ) { 
if ( pos > 1 ) { 
int nonarrayPos = pos ; 
while ( arglist . charAt ( nonarrayPos ) == '[' ) { 
nonarrayPos ++ ; 
if ( nonarrayPos >= arglist . length ( ) ) { 
char c = arglist . charAt ( nonarrayPos ) ; 
if ( c == 'L' ) { 
int semicolonPos = arglist . indexOf ( ';' , nonarrayPos ) ; 
if ( semicolonPos == - 1 ) { 
String fieldDescriptor = arglist . substring ( pos , semicolonPos + 1 ) ; 
result += fieldDescriptorToBinaryName ( fieldDescriptor ) ; 
pos = semicolonPos + 1 ; 
String maybe = fieldDescriptorToBinaryName ( arglist . substring ( pos , nonarrayPos + 1 ) ) ; 
if ( maybe == null ) { 
result += maybe ; 
pos = nonarrayPos + 1 ; 
return result + ")" ; 
} protected final void append_inst ( InstructionList il , Instruction inst ) { 
if ( inst instanceof LOOKUPSWITCH ) { 
LOOKUPSWITCH ls = ( LOOKUPSWITCH ) inst ; 
il . append ( new LOOKUPSWITCH ( ls . getMatchs ( ) , ls . getTargets ( ) , ls . getTarget ( ) ) ) ; 
} else if ( inst instanceof TABLESWITCH ) { 
TABLESWITCH ts = ( TABLESWITCH ) inst ; 
il . append ( new TABLESWITCH ( ts . getMatchs ( ) , ts . getTargets ( ) , ts . getTarget ( ) ) ) ; 
} else if ( inst instanceof IfInstruction ) { 
IfInstruction ifi = ( IfInstruction ) inst ; 
il . append ( InstructionFactory . createBranchInstruction ( inst . getOpcode ( ) , ifi . getTarget ( ) ) ) ; 
il . append ( inst ) ; 
} protected final void insert_at_method_start ( MethodGen mg , InstructionList new_il ) { 
insert_before_handle ( mg , il . getStart ( ) , new_il , false ) ; 
} protected final void insert_before_handle ( 
MethodGen mg , 
InstructionHandle ih , 
@ Nullable InstructionList new_il , 
boolean redirect_branches ) { 
if ( new_il == null ) { 
boolean at_start = ( ih . getPrev ( ) == null ) ; 
new_il . setPositions ( ) ; 
InstructionHandle new_end = new_il . getEnd ( ) ; 
int new_length = new_end . getPosition ( ) + new_end . getInstruction ( ) . getLength ( ) ; 
InstructionHandle new_start = il . insert ( ih , new_il ) ; 
if ( redirect_branches ) { 
il . redirectBranches ( ih , new_start ) ; 
if ( ih . hasTargeters ( ) ) { 
for ( InstructionTargeter it : ih . getTargeters ( ) ) { 
if ( ( it instanceof LineNumberGen ) && redirect_branches ) { 
it . updateTarget ( ih , new_start ) ; 
} else if ( it instanceof LocalVariableGen ) { 
LocalVariableGen lvg = ( LocalVariableGen ) it ; 
if ( ( lvg . getStart ( ) == ih ) && at_start ) { 
} else if ( ( it instanceof CodeExceptionGen ) && redirect_branches ) { 
CodeExceptionGen exc = ( CodeExceptionGen ) it ; 
if ( exc . getStartPC ( ) == ih ) exc . updateTarget ( ih , new_start ) ; 
else if ( exc . getHandlerPC ( ) == ih ) exc . setHandlerPC ( new_start ) ; 
update_stack_map_offset ( new_start . getPosition ( ) - ( redirect_branches ? 0 : 1 ) , new_length ) ; 
modify_stack_maps_for_switches ( new_start , il ) ; 
} private void print_il ( InstructionHandle start , String label ) { 
if ( debug_instrument . enabled ( ) ) { 
print_stack_map_table ( label ) ; 
InstructionHandle tih = start ; 
while ( tih != null ) { 
if ( tih . hasTargeters ( ) ) { 
for ( InstructionTargeter it : tih . getTargeters ( ) ) { 
tih = tih . getNext ( ) ; 
} protected final InstructionList build_il ( Instruction ... instructions ) { 
InstructionList il = new InstructionList ( ) ; 
for ( Instruction inst : instructions ) { 
append_inst ( il , inst ) ; 
return il ; 
} protected final void delete_instructions ( 
MethodGen mg , InstructionHandle start_ih , InstructionHandle end_ih ) { 
InstructionHandle new_start = end_ih . getNext ( ) ; 
if ( new_start == null ) { 
int size_deletion = start_ih . getPosition ( ) - new_start . getPosition ( ) ; 
il . redirectBranches ( start_ih , new_start ) ; 
if ( start_ih . hasTargeters ( ) ) { 
for ( InstructionTargeter it : start_ih . getTargeters ( ) ) { 
if ( it instanceof LineNumberGen ) { 
it . updateTarget ( start_ih , new_start ) ; 
} else if ( it instanceof CodeExceptionGen ) { 
if ( exc . getStartPC ( ) == start_ih ) exc . updateTarget ( start_ih , new_start ) ; 
else if ( exc . getEndPC ( ) == start_ih ) exc . updateTarget ( start_ih , new_start ) ; 
else if ( exc . getHandlerPC ( ) == start_ih ) exc . setHandlerPC ( new_start ) ; 
il . delete ( start_ih , end_ih ) ; 
update_stack_map_offset ( new_start . getPosition ( ) , size_deletion ) ; 
} protected final StackMapType [ ] calculate_live_local_types ( MethodGen mg , int location ) { 
int max_local_index = - 1 ; 
StackMapType [ ] local_map_types = new StackMapType [ mg . getMaxLocals ( ) ] ; 
Arrays . fill ( local_map_types , new StackMapType ( Const . ITEM_Bogus , - 1 , pool . getConstantPool ( ) ) ) ; 
for ( LocalVariableGen lv : mg . getLocalVariables ( ) ) { 
if ( location >= lv . getStart ( ) . getPosition ( ) ) { 
if ( lv . getLiveToEnd ( ) || location < lv . getEnd ( ) . getPosition ( ) ) { 
int i = lv . getIndex ( ) ; 
local_map_types [ i ] = generate_StackMapType_from_Type ( lv . getType ( ) ) ; 
max_local_index = Math . max ( max_local_index , i ) ; 
return Arrays . copyOf ( local_map_types , max_local_index + 1 ) ; 
} protected final StackMapType [ ] calculate_live_stack_types ( OperandStack stack ) { 
int ss = stack . size ( ) ; 
StackMapType [ ] stack_map_types = new StackMapType [ ss ] ; 
for ( int ii = 0 ; ii < ss ; ii ++ ) { 
stack_map_types [ ii ] = generate_StackMapType_from_Type ( stack . peek ( ss - ii - 1 ) ) ; 
return stack_map_types ; 
} protected final void replace_instructions ( 
MethodGen mg , InstructionList il , InstructionHandle ih , @ Nullable InstructionList new_il ) { 
InstructionHandle new_end ; 
InstructionHandle new_start ; 
int old_length = ih . getInstruction ( ) . getLength ( ) ; 
InstructionHandle end = new_il . getEnd ( ) ; 
int new_length = end . getPosition ( ) + end . getInstruction ( ) . getLength ( ) ; 
if ( new_il . getLength ( ) == 1 ) { 
ih . setInstruction ( new_il . getEnd ( ) . getInstruction ( ) ) ; 
if ( old_length == new_length ) { 
new_end = ih ; 
update_stack_map_offset ( ih . getPosition ( ) , ( new_length - old_length ) ) ; 
modify_stack_maps_for_switches ( new_end , il ) ; 
new_end = new_il . getEnd ( ) ; 
new_start = il . insert ( ih , new_il ) ; 
new_length = new_end . getNext ( ) . getPosition ( ) - new_start . getPosition ( ) ; 
it . updateTarget ( ih , new_end ) ; 
else if ( exc . getEndPC ( ) == ih ) exc . updateTarget ( ih , new_end ) ; 
il . delete ( ih ) ; 
if ( needStackMap ) { 
update_stack_map_offset ( new_start . getPosition ( ) , ( new_length - old_length ) ) ; 
InstructionHandle nih = new_start ; 
int target_count = 0 ; 
int target_offsets [ ] = new int [ 2 ] ; 
nih = nih . getNext ( ) ; 
new_end = new_end . getNext ( ) ; 
while ( nih != new_end ) { 
if ( nih . hasTargeters ( ) ) { 
for ( InstructionTargeter it : nih . getTargeters ( ) ) { 
if ( it instanceof BranchInstruction ) { 
target_offsets [ target_count ++ ] = nih . getPosition ( ) ; 
if ( target_count != 0 ) { 
int cur_loc = new_start . getPosition ( ) ; 
int orig_size = stack_map_table . length ; 
StackMapEntry [ ] new_stack_map_table = new StackMapEntry [ orig_size + target_count ] ; 
StackTypes stack_types = bcel_calc_stack_types ( mg ) ; 
OperandStack stack ; 
int new_index = find_stack_map_index_before ( target_offsets [ 0 ] ) + 1 ; 
StackMapType [ ] local_map_types = calculate_live_local_types ( mg , cur_loc ) ; 
int local_map_index = local_map_types . length ; 
int number_extra_locals = local_map_index - number_active_locals ; 
assert number_extra_locals >= 0 
System . arraycopy ( stack_map_table , 0 , new_stack_map_table , 0 , new_index ) ; 
boolean need_full_maps = false ; 
for ( int i = 0 ; i < target_count ; i ++ ) { 
stack = stack_types . get ( target_offsets [ i ] ) ; 
if ( number_extra_locals == 0 && stack . size ( ) == 1 && ! need_full_maps ) { 
StackMapType stack_map_type0 = generate_StackMapType_from_Type ( stack . peek ( 0 ) ) ; 
StackMapType [ ] stack_map_types0 = { stack_map_type0 } ; 
new_stack_map_table [ new_index + i ] = 
new StackMapEntry ( 
Const . SAME_LOCALS_1_STACK_ITEM_FRAME , 
stack_map_types0 , 
pool . getConstantPool ( ) ) ; 
need_full_maps = true ; 
Const . FULL_FRAME , 
calculate_live_local_types ( mg , target_offsets [ i ] ) , 
calculate_live_stack_types ( stack ) , 
new_stack_map_table [ new_index + i ] . updateByteCodeOffset ( 
target_offsets [ i ] - ( running_offset + 1 ) ) ; 
running_offset = target_offsets [ i ] ; 
int remainder = orig_size - new_index ; 
if ( remainder > 0 ) { 
l1 : 
while ( nih != null ) { 
stack_map_table [ new_index ] . updateByteCodeOffset ( 
nih . getPosition ( ) 
- target_offsets [ target_count - 1 ] 
- 1 
- stack_map_table [ new_index ] . getByteCodeOffset ( ) ) ; 
break l1 ; 
if ( exc . getHandlerPC ( ) == nih ) { 
if ( need_full_maps ) { 
while ( remainder > 0 ) { 
int stack_map_offset = stack_map_table [ new_index ] . getByteCodeOffset ( ) ; 
running_offset = running_offset + stack_map_offset + 1 ; 
stack = stack_types . get ( running_offset ) ; 
new_stack_map_table [ new_index + target_count ] = 
stack_map_offset , 
calculate_live_local_types ( mg , running_offset ) , 
remainder -- ; 
System . arraycopy ( 
stack_map_table , 
new_index , 
new_stack_map_table , 
new_index + target_count , 
remainder ) ; 
stack_map_table = new_stack_map_table ; 
debug_instrument . log ( "%n" ) ; 
public void read ( InputStream input , Handler handler ) throws IOException { 
@ SuppressWarnings ( "resource" ) 
LittleEndianDataInputStream in = new LittleEndianDataInputStream ( input ) ; 
long header = in . readInt ( ) & 0xFFFFFFFF ; 
if ( header != 0xA1B2C3D4 ) { 
int majorVersionNumber = in . readUnsignedShort ( ) ; 
int minorVersionNumber = in . readUnsignedShort ( ) ; 
long zone = in . readInt ( ) & 0xFFFFFFFF ; 
long timestampAccuracy = in . readInt ( ) & 0xFFFFFFFF ; 
long maxCaptureLength = in . readInt ( ) & 0xFFFFFFFF ; 
long dataLinkType = in . readInt ( ) & 0xFFFFFFFF ; 
long timestampSeconds = in . readInt ( ) & 0xFFFFFFFF ; 
long timestampMicroSeconds = in . readInt ( ) & 0xFFFFFFFF ; 
int savedLength = in . readInt ( ) ; 
int actualLength = in . readInt ( ) ; 
double timestamp = ( ( double ) timestampSeconds ) + ( ( ( double ) timestampMicroSeconds ) / 1_000_000d ) ; 
byte [ ] destinationMac = new byte [ 6 ] ; 
byte [ ] sourceMac = new byte [ 6 ] ; 
in . readFully ( destinationMac ) ; 
in . readFully ( sourceMac ) ; 
byte [ ] unused = new byte [ any ? 4 : 2 ] ; 
in . readFully ( unused ) ; 
int l = actualLength - destinationMac . length - sourceMac . length - unused . length ; 
if ( l > MAX_SIZE ) { 
byte [ ] bytes = new byte [ l ] ; 
in . readFully ( bytes ) ; 
IpPacketReadUtils . read ( timestamp , bytes , 0 , bytes . length , handler ) ; 
} private static double floorTime ( double now , double period ) { 
double precision = 1000d ; 
long t = ( long ) ( now * precision ) ; 
long d = ( long ) ( period * precision ) ; 
return ( t - ( t % d ) ) / precision ; 
} public void init ( String encryptionAlgorithm , String cipherAlgorithm , int keyLength , String macAlgorithm , byte [ ] K , byte [ ] H , byte [ ] sessionId ) throws GeneralSecurityException { 
MessageDigest sha = MessageDigest . getInstance ( "SHA-1" ) ; 
sha . reset ( ) ; 
sha . update ( new SshPacketBuilder ( ) . writeMpInt ( K ) . append ( H ) . writeByte ( 'B' ) . append ( sessionId ) . finish ( ) ) ; 
byte [ ] iv = sha . digest ( ) ; 
sha . update ( new SshPacketBuilder ( ) . writeMpInt ( K ) . append ( H ) . writeByte ( 'D' ) . append ( sessionId ) . finish ( ) ) ; 
byte [ ] cipherKey = sha . digest ( ) ; 
cipher = Cipher . getInstance ( encryptionAlgorithm + "/" + cipherAlgorithm + "/NoPadding" ) ; 
iv = CipherUtils . expandKey ( K , H , iv , sha , cipher . getBlockSize ( ) ) ; 
cipherKey = CipherUtils . expandKey ( K , H , cipherKey , sha , keyLength ) ; 
iv = CipherUtils . shrinkKey ( iv , cipher . getBlockSize ( ) ) ; 
cipherKey = CipherUtils . shrinkKey ( cipherKey , keyLength ) ; 
cipher . init ( Cipher . DECRYPT_MODE , new SecretKeySpec ( cipherKey , encryptionAlgorithm ) , new IvParameterSpec ( iv ) ) ; 
sha . update ( new SshPacketBuilder ( ) . writeMpInt ( K ) . append ( H ) . writeByte ( 'F' ) . append ( sessionId ) . finish ( ) ) ; 
byte [ ] macKey = sha . digest ( ) ; 
mac = Mac . getInstance ( macAlgorithm ) ; 
macKey = CipherUtils . expandKey ( K , H , macKey , sha , mac . getMacLength ( ) ) ; 
macKey = CipherUtils . shrinkKey ( macKey , mac . getMacLength ( ) ) ; 
mac . init ( new SecretKeySpec ( macKey , macAlgorithm ) ) ; 
firstBuffer = ByteBuffer . allocate ( cipher . getBlockSize ( ) ) ; 
macBuffer = ByteBuffer . allocate ( mac . getMacLength ( ) ) ; 
cipher = null ; 
mac = null ; 
} public static Builder builder ( ) { 
return new Builder ( ) { 
private final ImmutableList . Builder < HttpServiceHandler > handlers = ImmutableList . builder ( ) ; 
private int threads = DEFAULT_THREADS ; 
public Builder threading ( int threads ) { 
this . threads = threads ; 
public Builder register ( HttpServiceHandler handler ) { 
handlers . add ( handler ) ; 
public HttpService build ( ) { 
return new HttpService ( threads , handlers . build ( ) ) ; 
} public static ImmutableList < String > path ( String path ) { 
int i = path . indexOf ( HttpSpecification . PARAMETERS_START ) ; 
i = path . indexOf ( HttpSpecification . HASH_SEPARATOR ) ; 
int j = path . indexOf ( HttpSpecification . HASH_SEPARATOR ) ; 
if ( ( j >= 0 ) && ( j < i ) ) { 
i = j ; 
i = path . length ( ) ; 
String p = path . substring ( 0 , i ) ; 
if ( p . charAt ( 0 ) != HttpSpecification . PATH_SEPARATOR ) { 
String s = p . substring ( 1 ) ; 
Deque < String > l = new LinkedList < > ( ) ; 
for ( String k : Splitter . on ( HttpSpecification . PATH_SEPARATOR ) . splitToList ( s ) ) { 
if ( k . isEmpty ( ) ) { 
if ( k . equals ( "." ) ) { 
if ( k . equals ( ".." ) ) { 
if ( ! l . isEmpty ( ) ) { 
l . removeLast ( ) ; 
l . add ( k ) ; 
return ImmutableList . copyOf ( l ) ; 
Thread t = new ClassThreadFactory ( InternalQueue . class ) . newThread ( new Runnable ( ) { 
Thread . sleep ( ( long ) ( WAIT_ON_CLOSE * 1000d ) ) ; 
selector . close ( ) ; 
selector . wakeup ( ) ; 
t . setDaemon ( true ) ; 
public void received ( ByteBuffer buffer ) { 
if ( ended ) { 
if ( ( countRead + buffer . remaining ( ) ) > contentLength ) { 
ByteBuffer b = buffer . duplicate ( ) ; 
int l = ( int ) ( contentLength - countRead ) ; 
b . limit ( b . position ( ) + l ) ; 
buffer . position ( buffer . position ( ) + l ) ; 
buffer = b ; 
countRead += buffer . remaining ( ) ; 
wrappee . received ( buffer ) ; 
if ( countRead == contentLength ) { 
ended = true ; 
wrappee . ended ( ) ; 
} public Queue register ( NinioPriority priority ) { 
i = index ; 
if ( index == THREADING ) { 
return internalQueues [ priority . ordinal ( ) ] [ i ] . open ( ) ; 
} private static int doReadLength ( ByteBuffer buffer ) throws IOException { 
int lengthbyte = buffer . get ( ) & 0xFF ; 
if ( ( lengthbyte & BerConstants . ASN_BIT8 ) == BerConstants . ASN_BIT8 ) { 
lengthbyte &= ~ BerConstants . ASN_BIT8 ; 
if ( lengthbyte == 0 ) { 
if ( lengthbyte > 4 ) { 
int length = 0 ; 
for ( int i = 0 ; i < lengthbyte ; i ++ ) { 
length <<= 8 ; 
length |= buffer . get ( ) & 0xFF ; 
if ( length < 0 ) { 
return lengthbyte ; 
} private static long doReadLong ( ByteBuffer buffer , int length ) throws IOException { 
int b = buffer . get ( ) & 0xFF ; 
if ( ( i == 0 ) && ( ( b & 0x80 ) == 0x80 ) ) { 
value = 0xFFFFFFFFL ; 
value <<= 8 ; 
value |= b ; 
while ( ! chunkHeaderRead ) { 
String line = lineReader . handle ( buffer ) ; 
chunkLength = Integer . parseInt ( line , 16 ) ; 
chunkHeaderRead = true ; 
chunkCountRead = 0 ; 
if ( chunkHeaderRead ) { 
if ( chunkCountRead < chunkLength ) { 
if ( ! buffer . hasRemaining ( ) ) { 
long toRead = chunkLength - chunkCountRead ; 
ByteBuffer d = buffer . duplicate ( ) ; 
if ( toRead >= 0 ) { 
if ( d . remaining ( ) > toRead ) { 
d . limit ( ( int ) ( buffer . position ( ) + toRead ) ) ; 
chunkCountRead += d . remaining ( ) ; 
buffer . position ( ( int ) ( buffer . position ( ) + d . remaining ( ) ) ) ; 
wrappee . received ( d ) ; 
if ( chunkCountRead == chunkLength ) { 
while ( chunkHeaderRead ) { 
if ( ! line . isEmpty ( ) ) { 
chunkHeaderRead = false ; 
if ( chunkLength == 0 ) { 
} public static Version3PacketBuilder getBulk ( AuthRemoteEngine authEngine , int requestId , Oid oid , int bulkLength ) { 
return new Version3PacketBuilder ( authEngine , requestId , BerConstants . GETBULK , bulkLength , oid ) ; 
} public Extractor extract ( ) throws IOException { 
int [ ] iFrom = new int [ from . length ] ; 
int [ ] iTo = new int [ to . length ] ; 
int k = on . read ( ) ; 
if ( k < 0 ) { 
char c = ( char ) k ; 
for ( StringBuilder b : accumulators ) { 
if ( ignoreWhitespaces && Character . isWhitespace ( c ) ) { 
for ( int u = 0 ; u < iFrom . length ; u ++ ) { 
if ( c == from [ u ] . charAt ( iFrom [ u ] ) ) { 
iFrom [ u ] ++ ; 
if ( iFrom [ u ] == from [ u ] . length ( ) ) { 
return new Extractor ( from [ u ] , Lists . newLinkedList ( accumulators ) ) . on ( on ) . to ( to ) . ignoreWhitespaces ( ignoreWhitespaces ) ; 
} else if ( iFrom [ u ] > 0 ) { 
iFrom [ u ] = 0 ; 
for ( int u = 0 ; u < iTo . length ; u ++ ) { 
if ( c == to [ u ] . charAt ( iTo [ u ] ) ) { 
iTo [ u ] ++ ; 
if ( iTo [ u ] == to [ u ] . length ( ) ) { 
if ( accumulator != null ) { 
accumulator . delete ( accumulator . length ( ) - to [ u ] . length ( ) , accumulator . length ( ) ) ; 
} else if ( iTo [ u ] > 0 ) { 
iTo [ u ] = 0 ; 
} public static byte [ ] expandKey ( byte [ ] K , byte [ ] H , byte [ ] key , MessageDigest hash , int requiredLength ) { 
byte [ ] result = key ; 
while ( result . length < requiredLength ) { 
SshPacketBuilder buf = new SshPacketBuilder ( ) ; 
buf . writeMpInt ( K ) ; 
buf . append ( H ) ; 
buf . append ( result ) ; 
hash . update ( buf . finish ( ) ) ; 
byte [ ] d = hash . digest ( ) ; 
byte [ ] tmp = new byte [ result . length + d . length ] ; 
System . arraycopy ( result , 0 , tmp , 0 , result . length ) ; 
System . arraycopy ( d , 0 , tmp , result . length , d . length ) ; 
result = tmp ; 
} public static synchronized Config load ( Dependencies dependencies , String resource ) { 
return load ( dependencies , resource , new Override ( ) ) ; 
} public PrivateKey getPrivateKey ( String alias , String password ) { 
return ( PrivateKey ) ksKeys . getKey ( alias , password . toCharArray ( ) ) ; 
} private static final int find ( boolean skipBlocks , String s , char toFind , int from ) { 
int open = 0 ; 
boolean escaping = false ; 
for ( int i = from ; i < s . length ( ) ; i ++ ) { 
if ( escaping ) { 
escaping = false ; 
escaping = true ; 
if ( ( open == 0 ) && ( c == toFind ) ) { 
} else if ( skipBlocks && ( c == '{' ) ) { 
open ++ ; 
} else if ( skipBlocks && ( c == '}' ) ) { 
open -- ; 
public void received ( ByteBuffer deflated ) { 
if ( deflated . remaining ( ) >= FOOTER_LENGTH ) { 
for ( ByteBuffer b : previewFooter ) { 
if ( ! read ( b ) ) { 
previewFooter . clear ( ) ; 
currentPreviewFooterLength = 0 ; 
ByteBuffer deflatedKeepingFooter = deflated . duplicate ( ) ; 
deflatedKeepingFooter . limit ( deflatedKeepingFooter . limit ( ) - FOOTER_LENGTH ) ; 
deflated . position ( deflated . position ( ) + deflatedKeepingFooter . remaining ( ) ) ; 
if ( ! read ( deflatedKeepingFooter ) ) { 
currentPreviewFooterLength += deflated . remaining ( ) ; 
previewFooter . addLast ( deflated . duplicate ( ) ) ; 
deflated . position ( deflated . position ( ) + deflated . remaining ( ) ) ; 
int toFlush = FOOTER_LENGTH - currentPreviewFooterLength ; 
while ( toFlush > 0 ) { 
ByteBuffer b = previewFooter . getFirst ( ) ; 
ByteBuffer d = b . duplicate ( ) ; 
d . limit ( Math . min ( d . limit ( ) , toFlush ) ) ; 
b . position ( b . position ( ) + d . remaining ( ) ) ; 
toFlush -= d . remaining ( ) ; 
if ( ! read ( d ) ) { 
if ( ! b . hasRemaining ( ) ) { 
previewFooter . removeFirst ( ) ; 
} public static < T > POrthonormalized3D < T > orthonormalize3D ( 
final PVector3D < T > v0 , 
final PVector3D < T > v1 , 
final PVector3D < T > v2 ) 
final PVector3D < T > rv0 = PVectors3D . normalize ( v0 ) ; 
final PVector3D < T > rv1 ; 
final PVector3D < T > rv2 ; 
final double v0_dot_v1 = PVectors3D . dotProduct ( rv0 , v1 ) ; 
final PVector3D < T > v0_s = PVectors3D . scale ( rv0 , v0_dot_v1 ) ; 
rv1 = PVectors3D . normalize ( PVectors3D . subtract ( v1 , v0_s ) ) ; 
final double v1_dot_v2 = PVectors3D . dotProduct ( rv1 , v2 ) ; 
final double v0_dot_v2 = PVectors3D . dotProduct ( rv0 , v2 ) ; 
final PVector3D < T > v0_s = PVectors3D . scale ( rv0 , v0_dot_v2 ) ; 
final PVector3D < T > v2_s = PVectors3D . scale ( rv1 , v1_dot_v2 ) ; 
final PVector3D < T > vs = PVectors3D . add ( v0_s , v2_s ) ; 
rv2 = PVectors3D . normalize ( PVectors3D . subtract ( v2 , vs ) ) ; 
return POrthonormalized3D . of ( rv0 , rv1 , rv2 ) ; 
} public static < T > POrthonormalized4D < T > orthonormalize4D ( 
final PVector4D < T > v0 , 
final PVector4D < T > v1 , 
final PVector4D < T > v2 ) 
final PVector4D < T > rv0 = PVectors4D . normalize ( v0 ) ; 
final PVector4D < T > rv1 ; 
final PVector4D < T > rv2 ; 
final double v0_dot_v1 = PVectors4D . dotProduct ( rv0 , v1 ) ; 
final PVector4D < T > v0_s = PVectors4D . scale ( rv0 , v0_dot_v1 ) ; 
rv1 = PVectors4D . normalize ( PVectors4D . subtract ( v1 , v0_s ) ) ; 
final double v1_dot_v2 = PVectors4D . dotProduct ( rv1 , v2 ) ; 
final double v0_dot_v2 = PVectors4D . dotProduct ( rv0 , v2 ) ; 
final PVector4D < T > v0_s = PVectors4D . scale ( rv0 , v0_dot_v2 ) ; 
final PVector4D < T > v2_s = PVectors4D . scale ( rv1 , v1_dot_v2 ) ; 
final PVector4D < T > vs = PVectors4D . add ( v0_s , v2_s ) ; 
rv2 = PVectors4D . normalize ( PVectors4D . subtract ( v2 , vs ) ) ; 
return POrthonormalized4D . of ( rv0 , rv1 , rv2 ) ; 
} public static < T > PVectorByteBufferedIntegral2s16 < T > createWithBase ( 
final ByteBuffer b , 
final MutableLongType base , 
final int offset ) 
return new PVectorByteBufferedIntegral2s16 < > ( b , base , offset ) ; 
} public static < T > Generator < PVector4F < T > > create ( ) 
return new PVector4FGenerator < > ( PrimitiveGenerators . doubles ( 
GeneratorConstants . BOUND_LARGE_FLOAT_LOWER , 
GeneratorConstants . BOUND_LARGE_FLOAT_UPPER 
} public static < T > Generator < PVector4F < T > > createSmall ( ) 
GeneratorConstants . BOUND_SMALL_FLOAT_LOWER , 
GeneratorConstants . BOUND_SMALL_FLOAT_UPPER 
} public static < T > Generator < PVector4F < T > > createNormal ( ) 
GeneratorConstants . BOUND_NORMAL_FLOAT_LOWER , 
GeneratorConstants . BOUND_NORMAL_FLOAT_UPPER 
} public static < T > PVectorByteBufferedIntegral2s64 < T > createWithBase ( 
return new PVectorByteBufferedIntegral2s64 < > ( b , base , offset ) ; 
} public static double determinant3x3 ( 
final double r0c0 , 
final double r0c1 , 
final double r0c2 , 
final double r1c0 , 
final double r1c1 , 
final double r1c2 , 
final double r2c0 , 
final double r2c1 , 
final double r2c2 ) 
sum += r0c0 * ( ( r1c1 * r2c2 ) - ( r1c2 * r2c1 ) ) ; 
sum -= r0c1 * ( ( r1c0 * r2c2 ) - ( r1c2 * r2c0 ) ) ; 
sum += r0c2 * ( ( r1c0 * r2c1 ) - ( r1c1 * r2c0 ) ) ; 
} public static double determinant4x4 ( 
final double r0c3 , 
final double r1c3 , 
final double r2c2 , 
final double r2c3 , 
final double r3c0 , 
final double r3c1 , 
final double r3c2 , 
final double r3c3 ) 
sum += r0c0 * r1c1 * r2c2 * r3c3 ; 
sum -= r0c0 * r1c1 * r2c3 * r3c2 ; 
sum += r0c0 * r1c2 * r2c3 * r3c1 ; 
sum -= r0c0 * r1c2 * r2c1 * r3c3 ; 
sum += r0c0 * r1c3 * r2c1 * r3c2 ; 
sum -= r0c0 * r1c3 * r2c2 * r3c1 ; 
sum -= r0c1 * r1c2 * r2c3 * r3c0 ; 
sum += r0c1 * r1c2 * r2c0 * r3c3 ; 
sum -= r0c1 * r1c3 * r2c0 * r3c2 ; 
sum += r0c1 * r1c3 * r2c2 * r3c0 ; 
sum -= r0c1 * r1c0 * r2c2 * r3c3 ; 
sum += r0c1 * r1c0 * r2c3 * r3c2 ; 
sum += r0c2 * r1c3 * r2c0 * r3c1 ; 
sum -= r0c2 * r1c3 * r2c1 * r3c0 ; 
sum += r0c2 * r1c0 * r2c1 * r3c3 ; 
sum -= r0c2 * r1c0 * r2c3 * r3c1 ; 
sum += r0c2 * r1c1 * r2c3 * r3c0 ; 
sum -= r0c2 * r1c1 * r2c0 * r3c3 ; 
sum -= r0c3 * r1c0 * r2c1 * r3c2 ; 
sum += r0c3 * r1c0 * r2c2 * r3c1 ; 
sum -= r0c3 * r1c1 * r2c2 * r3c0 ; 
sum += r0c3 * r1c1 * r2c0 * r3c2 ; 
sum -= r0c3 * r1c2 * r2c0 * r3c1 ; 
sum += r0c3 * r1c2 * r2c1 * r3c0 ; 
} public static VectorByteBufferedFloating3s32 createWithBase ( 
return new VectorByteBufferedFloating3s32 ( b , base , offset ) ; 
} public static Generator < Vector4F > create ( ) 
return new Vector4FGenerator ( PrimitiveGenerators . doubles ( 
} public static Generator < Vector4F > createSmall ( ) 
} public static Generator < Vector4F > createNormal ( ) 
} public static MatrixByteBuffered2x2s16 createWithBase ( 
return new MatrixByteBuffered2x2s16 ( b , base , offset ) ; 
} public static VectorByteBufferedFloating2s64 createWithBase ( 
return new VectorByteBufferedFloating2s64 ( b , base , offset ) ; 
} public static VectorByteBufferedIntegral3s32 createWithBase ( 
return new VectorByteBufferedIntegral3s32 ( b , base , offset ) ; 
} public static VectorByteBufferedIntegral2s8 createWithBase ( 
return new VectorByteBufferedIntegral2s8 ( b , base , offset ) ; 
} public R findBy ( ClassFileScanConfiguration scanConfig , SearchCriteria criteria ) { 
scanConfig = scanConfig . createCopy ( ) ; 
criteria = criteria . createCopy ( ) ; 
C context = createContext ( scanConfig , criteria ) ; 
criteria . init ( this . classHelper , context . pathMemoryClassLoader , this . memberFinder , this . pathHelper ) ; 
scanConfig . init ( ) ; 
fileSystemHelper . scan ( 
scanConfig . toScanConfiguration ( context , this ) 
Collection < String > skippedClassesNames = context . getSkippedClassNames ( ) ; 
if ( ! skippedClassesNames . isEmpty ( ) ) { 
return resultSupplier . apply ( context ) ; 
} public static < T > PVectorByteBufferedFloating3s32 < T > createWithBase ( 
return new PVectorByteBufferedFloating3s32 < > ( b , base , offset ) ; 
} public static VectorByteBufferedIntegral3s64 createWithBase ( 
return new VectorByteBufferedIntegral3s64 ( b , base , offset ) ; 
} public static VectorByteBufferedFloating2s16 createWithBase ( 
return new VectorByteBufferedFloating2s16 ( b , base , offset ) ; 
} public static VectorByteBufferedIntegral3s8 createWithBase ( 
return new VectorByteBufferedIntegral3s8 ( b , base , offset ) ; 
} public SearchResult < K , I > findBy ( PathSearchCriteria criteria ) { 
C context = createContext ( 
ClassFileScanConfiguration . forPaths ( criteria . getPaths ( ) ) . maxParallelTasksForUnit ( 
criteria . maxParallelTasksForUnit 
criteria 
scan ( context ) ; 
} public static Generator < Vector2D > create ( ) 
return new Vector2DGenerator ( PrimitiveGenerators . doubles ( 
GeneratorConstants . BOUND_LARGE_DOUBLE_LOWER , 
GeneratorConstants . BOUND_LARGE_DOUBLE_UPPER 
} public static Generator < Vector2D > createSmall ( ) 
GeneratorConstants . BOUND_SMALL_DOUBLE_LOWER , 
GeneratorConstants . BOUND_SMALL_DOUBLE_UPPER 
} public static Generator < Vector2D > createNormal ( ) 
GeneratorConstants . BOUND_NORMAL_DOUBLE_LOWER , 
GeneratorConstants . BOUND_NORMAL_DOUBLE_UPPER 
} public static MatrixByteBuffered4x4s16 createWithBase ( 
return new MatrixByteBuffered4x4s16 ( b , base , offset ) ; 
} public static < A , B > Generator < PMatrix2x2F < A , B > > create ( ) 
return new PMatrix2x2FGenerator < > ( PrimitiveGenerators . doubles ( 
} public static < A , B > Generator < PMatrix2x2F < A , B > > createNormal ( ) 
} public static Generator < Matrix4x4D > create ( ) 
return new Matrix4x4DGenerator ( PrimitiveGenerators . doubles ( 
} public static Generator < Matrix4x4D > createNormal ( ) 
} public static Generator < Matrix4x4D > createOrthogonal ( ) 
final SecureRandom rng = new SecureRandom ( ) ; 
final double r0c0 = 1.0 ; 
final double r0c1 = 0.0 ; 
final double r0c2 = 0.0 ; 
final double r0c3 = rng . nextDouble ( ) ; 
final double r1c0 = 0.0 ; 
final double r1c1 = 1.0 ; 
final double r1c2 = 0.0 ; 
final double r1c3 = rng . nextDouble ( ) ; 
final double r2c0 = 0.0 ; 
final double r2c1 = 0.0 ; 
final double r2c2 = 1.0 ; 
final double r2c3 = rng . nextDouble ( ) ; 
final double r3c0 = 0.0 ; 
final double r3c1 = 0.0 ; 
final double r3c2 = 0.0 ; 
final double r3c3 = 1.0 ; 
return Matrix4x4D . of ( 
r0c0 , r0c1 , r0c2 , r0c3 , 
r1c0 , r1c1 , r1c2 , r1c3 , 
r2c0 , r2c1 , r2c2 , r2c3 , 
r3c0 , r3c1 , r3c2 , r3c3 ) ; 
} public static long dotProduct3 ( 
final long x0 , 
final long y0 , 
final long z0 , 
final long x1 , 
final long y1 , 
final long z1 ) 
final long x = x0 * x1 ; 
final long y = y0 * y1 ; 
final long z = z0 * z1 ; 
return x + y + z ; 
} public static int dotProduct2 ( 
final int x0 , 
final int y0 , 
final int x1 , 
final int y1 ) 
final int x = x0 * x1 ; 
final int y = y0 * y1 ; 
return x + y ; 
} public static MatrixByteBuffered4x4s32 createWithBase ( 
return new MatrixByteBuffered4x4s32 ( b , base , offset ) ; 
} public static double dotProduct4 ( 
final double x0 , 
final double y0 , 
final double z0 , 
final double w0 , 
final double x1 , 
final double y1 , 
final double z1 , 
final double w1 ) 
final double x = x0 * x1 ; 
final double y = y0 * y1 ; 
final double z = z0 * z1 ; 
final double w = w0 * w1 ; 
return x + y + z + w ; 
} public static VectorByteBufferedIntegral4s64 createWithBase ( 
return new VectorByteBufferedIntegral4s64 ( b , base , offset ) ; 
} public static VectorByteBufferedFloating3s64 createWithBase ( 
return new VectorByteBufferedFloating3s64 ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedIntegral3s8 < T > createWithBase ( 
return new PVectorByteBufferedIntegral3s8 < > ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedFloating2s16 < T > createWithBase ( 
return new PVectorByteBufferedFloating2s16 < > ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedFloating4s64 < T > createWithBase ( 
return new PVectorByteBufferedFloating4s64 < > ( b , base , offset ) ; 
} public static < A , B > PMatrixByteBuffered3x3s16 < A , B > createWithBase ( 
return new PMatrixByteBuffered3x3s16 < > ( b , base , offset ) ; 
} public static VectorByteBufferedFloating3s16 createWithBase ( 
return new VectorByteBufferedFloating3s16 ( b , base , offset ) ; 
} public static VectorByteBufferedIntegral4s8 createWithBase ( 
return new VectorByteBufferedIntegral4s8 ( b , base , offset ) ; 
} public static Generator < Vector3F > create ( ) 
return new Vector3FGenerator ( PrimitiveGenerators . doubles ( 
} public static Generator < Vector3F > createSmall ( ) 
} public static Generator < Vector3F > createNormal ( ) 
} public static VectorByteBufferedIntegral2s16 createWithBase ( 
return new VectorByteBufferedIntegral2s16 ( b , base , offset ) ; 
} public static < T > Generator < PVector3F < T > > create ( ) 
return new PVector3FGenerator < > ( PrimitiveGenerators . doubles ( 
} public static < T > Generator < PVector3F < T > > createSmall ( ) 
} public static < T > Generator < PVector3F < T > > createNormal ( ) 
} public static MatrixByteBuffered3x3s64 createWithBase ( 
return new MatrixByteBuffered3x3s64 ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedIntegral3s64 < T > createWithBase ( 
return new PVectorByteBufferedIntegral3s64 < > ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedFloating4s32 < T > createWithBase ( 
return new PVectorByteBufferedFloating4s32 < > ( b , base , offset ) ; 
} public static Generator < Vector4D > create ( ) 
return new Vector4DGenerator ( PrimitiveGenerators . doubles ( 
} public static Generator < Vector4D > createSmall ( ) 
} public static Generator < Vector4D > createNormal ( ) 
} public static < T > PVectorByteBufferedFloating3s16 < T > createWithBase ( 
return new PVectorByteBufferedFloating3s16 < > ( b , base , offset ) ; 
} public static < A , B > Generator < PMatrix3x3D < A , B > > create ( ) 
return new PMatrix3x3DGenerator < > ( PrimitiveGenerators . doubles ( 
} public static < A , B > Generator < PMatrix3x3D < A , B > > createNormal ( ) 
} public static < T > Generator < PVector2F < T > > create ( ) 
return new PVector2FGenerator < > ( PrimitiveGenerators . doubles ( 
} public static < T > Generator < PVector2F < T > > createSmall ( ) 
} public static < T > Generator < PVector2F < T > > createNormal ( ) 
} public static < A , B > Generator < PMatrix2x2D < A , B > > create ( ) 
return new PMatrix2x2DGenerator < > ( PrimitiveGenerators . doubles ( 
} public static < A , B > Generator < PMatrix2x2D < A , B > > createNormal ( ) 
} public static Generator < Vector3D > create ( ) 
return new Vector3DGenerator ( PrimitiveGenerators . doubles ( 
} public static Generator < Vector3D > createSmall ( ) 
} public static Generator < Vector3D > createNormal ( ) 
} public static < T > Generator < PVector4D < T > > create ( ) 
return new PVector4DGenerator < > ( PrimitiveGenerators . doubles ( 
} public static < T > Generator < PVector4D < T > > createSmall ( ) 
} public static < T > Generator < PVector4D < T > > createNormal ( ) 
} public static < T > PVectorByteBufferedIntegral4s64 < T > createWithBase ( 
return new PVectorByteBufferedIntegral4s64 < > ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedIntegral2s32 < T > createWithBase ( 
return new PVectorByteBufferedIntegral2s32 < > ( b , base , offset ) ; 
} public static MatrixByteBuffered2x2s64 createWithBase ( 
return new MatrixByteBuffered2x2s64 ( b , base , offset ) ; 
} public static VectorByteBufferedIntegral2s32 createWithBase ( 
return new VectorByteBufferedIntegral2s32 ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedFloating3s64 < T > createWithBase ( 
return new PVectorByteBufferedFloating3s64 < > ( b , base , offset ) ; 
} public static < T > Generator < PVector2D < T > > createSmall ( ) 
return new PVector2DGenerator < > ( PrimitiveGenerators . doubles ( 
} public static < T > Generator < PVector2D < T > > create ( ) 
} public static < T > Generator < PVector2D < T > > createNormal ( ) 
} public static < A , B > Generator < PMatrix4x4F < A , B > > create ( ) 
return new PMatrix4x4FGenerator < > ( PrimitiveGenerators . doubles ( 
} public static < A , B > Generator < PMatrix4x4F < A , B > > createNormal ( ) 
} public static < T > PVectorByteBufferedIntegral4s32 < T > createWithBase ( 
return new PVectorByteBufferedIntegral4s32 < > ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedIntegral4s16 < T > createWithBase ( 
return new PVectorByteBufferedIntegral4s16 < > ( b , base , offset ) ; 
} static double determinant4x4 ( 
return Determinants . determinant4x4 ( 
} public static VectorByteBufferedIntegral2s64 createWithBase ( 
return new VectorByteBufferedIntegral2s64 ( b , base , offset ) ; 
} public static MatrixByteBuffered2x2s32 createWithBase ( 
return new MatrixByteBuffered2x2s32 ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedFloating2s64 < T > createWithBase ( 
return new PVectorByteBufferedFloating2s64 < > ( b , base , offset ) ; 
} public static Generator < Matrix3x3F > create ( ) 
return new Matrix3x3FGenerator ( PrimitiveGenerators . doubles ( 
} public static Generator < Matrix3x3F > createNormal ( ) 
} public static VectorByteBufferedIntegral4s16 createWithBase ( 
return new VectorByteBufferedIntegral4s16 ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedIntegral3s32 < T > createWithBase ( 
return new PVectorByteBufferedIntegral3s32 < > ( b , base , offset ) ; 
} public static VectorByteBufferedFloating4s16 createWithBase ( 
return new VectorByteBufferedFloating4s16 ( b , base , offset ) ; 
} public static < A , B > Generator < PMatrix3x3F < A , B > > create ( ) 
return new PMatrix3x3FGenerator < > ( PrimitiveGenerators . doubles ( 
} public static < A , B > Generator < PMatrix3x3F < A , B > > createNormal ( ) 
} public static Generator < Matrix2x2D > create ( ) 
return new Matrix2x2DGenerator ( PrimitiveGenerators . doubles ( 
} public static Generator < Matrix2x2D > createNormal ( ) 
} public static MatrixByteBuffered4x4s64 createWithBase ( 
return new MatrixByteBuffered4x4s64 ( b , base , offset ) ; 
} public static VectorByteBufferedIntegral3s16 createWithBase ( 
return new VectorByteBufferedIntegral3s16 ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedIntegral2s8 < T > createWithBase ( 
return new PVectorByteBufferedIntegral2s8 < > ( b , base , offset ) ; 
} public static VectorByteBufferedFloating4s64 createWithBase ( 
return new VectorByteBufferedFloating4s64 ( b , base , offset ) ; 
} public static Orthonormalized3D orthonormalize3D ( 
final Vector3D v0 , 
final Vector3D v1 , 
final Vector3D v2 ) 
final Vector3D rv0 = Vectors3D . normalize ( v0 ) ; 
final Vector3D rv1 ; 
final Vector3D rv2 ; 
final double v0_dot_v1 = Vectors3D . dotProduct ( rv0 , v1 ) ; 
final Vector3D v0_s = Vectors3D . scale ( rv0 , v0_dot_v1 ) ; 
rv1 = Vectors3D . normalize ( Vectors3D . subtract ( v1 , v0_s ) ) ; 
final double v1_dot_v2 = Vectors3D . dotProduct ( rv1 , v2 ) ; 
final double v0_dot_v2 = Vectors3D . dotProduct ( rv0 , v2 ) ; 
final Vector3D v0_s = Vectors3D . scale ( rv0 , v0_dot_v2 ) ; 
final Vector3D v2_s = Vectors3D . scale ( rv1 , v1_dot_v2 ) ; 
final Vector3D vs = Vectors3D . add ( v0_s , v2_s ) ; 
rv2 = Vectors3D . normalize ( Vectors3D . subtract ( v2 , vs ) ) ; 
return Orthonormalized3D . of ( rv0 , rv1 , rv2 ) ; 
} public static Orthonormalized4D orthonormalize4D ( 
final Vector4D v0 , 
final Vector4D v1 , 
final Vector4D v2 ) 
final Vector4D rv0 = Vectors4D . normalize ( v0 ) ; 
final Vector4D rv1 ; 
final Vector4D rv2 ; 
final double v0_dot_v1 = Vectors4D . dotProduct ( rv0 , v1 ) ; 
final Vector4D v0_s = Vectors4D . scale ( rv0 , v0_dot_v1 ) ; 
rv1 = Vectors4D . normalize ( Vectors4D . subtract ( v1 , v0_s ) ) ; 
final double v1_dot_v2 = Vectors4D . dotProduct ( rv1 , v2 ) ; 
final double v0_dot_v2 = Vectors4D . dotProduct ( rv0 , v2 ) ; 
final Vector4D v0_s = Vectors4D . scale ( rv0 , v0_dot_v2 ) ; 
final Vector4D v2_s = Vectors4D . scale ( rv1 , v1_dot_v2 ) ; 
final Vector4D vs = Vectors4D . add ( v0_s , v2_s ) ; 
rv2 = Vectors4D . normalize ( Vectors4D . subtract ( v2 , vs ) ) ; 
return Orthonormalized4D . of ( rv0 , rv1 , rv2 ) ; 
} public static Generator < Vector2F > create ( ) 
return new Vector2FGenerator ( PrimitiveGenerators . doubles ( 
} public static Generator < Vector2F > createSmall ( ) 
} public static Generator < Vector2F > createNormal ( ) 
} public static Generator < Matrix4x4F > create ( ) 
return new Matrix4x4FGenerator ( PrimitiveGenerators . doubles ( 
} public static Generator < Matrix4x4F > createNormal ( ) 
} public static MatrixByteBuffered3x3s16 createWithBase ( 
return new MatrixByteBuffered3x3s16 ( b , base , offset ) ; 
} public static VectorByteBufferedFloating2s32 createWithBase ( 
return new VectorByteBufferedFloating2s32 ( b , base , offset ) ; 
} public static Generator < Matrix2x2F > create ( ) 
return new Matrix2x2FGenerator ( PrimitiveGenerators . doubles ( 
} public static Generator < Matrix2x2F > createNormal ( ) 
} public static < T > PVectorByteBufferedFloating4s16 < T > createWithBase ( 
return new PVectorByteBufferedFloating4s16 < > ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedIntegral3s16 < T > createWithBase ( 
return new PVectorByteBufferedIntegral3s16 < > ( b , base , offset ) ; 
} public static < T > PVectorByteBufferedFloating2s32 < T > createWithBase ( 
return new PVectorByteBufferedFloating2s32 < > ( b , base , offset ) ; 
} public static VectorByteBufferedIntegral4s32 createWithBase ( 
return new VectorByteBufferedIntegral4s32 ( b , base , offset ) ; 
} public static < T > Generator < Quaternion4F > create ( ) 
return new Quaternion4FGenerator ( PrimitiveGenerators . doubles ( 
} public static < T > Generator < PVector3D < T > > createSmall ( ) 
return new PVector3DGenerator < > ( PrimitiveGenerators . doubles ( 
} public static < T > Generator < PVector3D < T > > create ( ) 
} public static < T > Generator < PVector3D < T > > createNormal ( ) 
} public static MatrixByteBuffered3x3s32 createWithBase ( 
return new MatrixByteBuffered3x3s32 ( b , base , offset ) ; 
} public static Generator < Matrix3x3D > create ( ) 
return new Matrix3x3DGenerator ( PrimitiveGenerators . doubles ( 
} public static Generator < Matrix3x3D > createNormal ( ) 
} public static VectorByteBufferedFloating4s32 createWithBase ( 
return new VectorByteBufferedFloating4s32 ( b , base , offset ) ; 
} public static < A , B > Generator < PMatrix4x4D < A , B > > create ( ) 
return new PMatrix4x4DGenerator < > ( PrimitiveGenerators . doubles ( 
} public static < A , B > Generator < PMatrix4x4D < A , B > > createNormal ( ) 
} public static < T > PVectorByteBufferedIntegral4s8 < T > createWithBase ( 
return new PVectorByteBufferedIntegral4s8 < > ( b , base , offset ) ; 
} public static Selector expressionSelector ( String expr , BeanFactory beanFactory ) { 
StandardEvaluationContext evalCtx = new StandardEvaluationContext ( ) ; 
if ( null != beanFactory ) { 
evalCtx . setBeanResolver ( new BeanFactoryResolver ( beanFactory ) ) ; 
return expressionSelector ( expr , evalCtx ) ; 
} public static Selector expressionSelector ( String expr , EvaluationContext evalCtx ) { 
return new ExpressionSelector ( SPEL_PARSER . parseExpression ( expr ) , evalCtx ) ; 
} public static Selector expressionSelector ( String expr , EvaluationContext evalCtx , SpelCompilerMode mode ) { 
SpelParserConfiguration configuration = new SpelParserConfiguration ( mode , null ) ; 
SpelExpressionParser parser = new SpelExpressionParser ( configuration ) ; 
return new ExpressionSelector ( parser . parseExpression ( expr ) , evalCtx ) ; 
} Dialog getErrorDialog ( int errorCode , int requestCode ) { 
final Dialog dialog = GoogleApiAvailability . getInstance ( ) . getErrorDialog ( activity , errorCode , requestCode ) ; 
dialog . setOnDismissListener ( new DialogInterface . OnDismissListener ( ) { 
public void onDismiss ( DialogInterface dialogInterface ) { 
resolvingError = false ; 
return dialog ; 
} void connectAndRequestGoogleAccount ( int signInRequestCode , int errorResolutionRequestCode ) { 
if ( client . isConnected ( ) ) { 
requestGoogleAccount ( signInRequestCode ) ; 
} else if ( ! client . isConnecting ( ) ) { 
this . signInRequestCode = signInRequestCode ; 
this . errorResolutionRequestCode = errorResolutionRequestCode ; 
client . connect ( ) ; 
} boolean parseSignInResult ( int requestCode , int resultCode , Intent intent ) { 
if ( requestCode == errorResolutionRequestCode ) { 
if ( resultCode == Activity . RESULT_OK ) { 
connectAndRequestGoogleAccount ( signInRequestCode , errorResolutionRequestCode ) ; 
} else if ( requestCode == signInRequestCode ) { 
final GoogleSignInResult result = Auth . GoogleSignInApi . getSignInResultFromIntent ( intent ) ; 
if ( result . isSuccess ( ) ) { 
googleCallback . onSuccess ( result . getSignInAccount ( ) ) ; 
} else if ( result . getStatus ( ) . isCanceled ( ) ) { 
googleCallback . onCancel ( ) ; 
} public void logoutAndClearState ( ) { 
if ( client != null && client . isConnected ( ) ) { 
client . disconnect ( ) ; 
activity = null ; 
} void logout ( ) { 
Auth . GoogleSignInApi . signOut ( client ) . setResultCallback ( new ResultCallback < Status > ( ) { 
public void onResult ( @ NonNull Status status ) { 
if ( ! status . isSuccess ( ) ) { 
} public void applyToTrimouMustacheEngineBuilder ( final MustacheEngineBuilder engineBuilder ) { 
engineBuilder 
. setProperty ( EngineConfigurationKey . START_DELIMITER , getStartDelimiter ( ) ) 
. setProperty ( EngineConfigurationKey . END_DELIMITER , getEndDelimiter ( ) ) 
. setProperty ( EngineConfigurationKey . PRECOMPILE_ALL_TEMPLATES , isPrecompileTemplates ( ) ) 
. setProperty ( EngineConfigurationKey . REMOVE_STANDALONE_LINES , isRemoveStandaloneLines ( ) ) 
. setProperty ( EngineConfigurationKey . REMOVE_UNNECESSARY_SEGMENTS , isRemoveUnnecessarySegments ( ) ) 
. setProperty ( EngineConfigurationKey . DEBUG_MODE , isDebugMode ( ) ) 
. setProperty ( EngineConfigurationKey . CACHE_SECTION_LITERAL_BLOCK , isCacheSectionLiteralBlock ( ) ) 
. setProperty ( EngineConfigurationKey . TEMPLATE_RECURSIVE_INVOCATION_LIMIT , 
getTemplateRecursiveInvocationLimit ( ) ) 
. setProperty ( EngineConfigurationKey . SKIP_VALUE_ESCAPING , isSkipValueEscaping ( ) ) 
. setProperty ( EngineConfigurationKey . DEFAULT_FILE_ENCODING , getCharset ( ) . name ( ) ) 
. setProperty ( EngineConfigurationKey . TEMPLATE_CACHE_ENABLED , isCache ( ) ) 
. setProperty ( EngineConfigurationKey . TEMPLATE_CACHE_EXPIRATION_TIMEOUT , 
getTemplateCacheExpirationTimeout ( ) ) 
. setProperty ( EngineConfigurationKey . HANDLEBARS_SUPPORT_ENABLED , isEnableHelper ( ) ) 
. setProperty ( EngineConfigurationKey . REUSE_LINE_SEPARATOR_SEGMENTS , isReuseLineSeparatorSegments ( ) ) 
. setProperty ( EngineConfigurationKey . ITERATION_METADATA_ALIAS , getIterationMetadataAlias ( ) ) 
. setProperty ( EngineConfigurationKey . RESOLVER_HINTS_ENABLED , isEnableResolverHints ( ) ) 
. setProperty ( EngineConfigurationKey . NESTED_TEMPLATE_SUPPORT_ENABLED , isEnableNestedTemplates ( ) ) 
. setProperty ( EngineConfigurationKey . TEMPLATE_CACHE_USED_FOR_SOURCE , isCacheTemplateSources ( ) ) ; 
} static MemberKey newInstance ( Object contextObject , String name ) { 
if ( contextObject instanceof Class < ? > ) { 
Class < ? > clazz = ( Class < ? > ) contextObject ; 
if ( clazz . isEnum ( ) && ( "values" . equals ( name ) || Reflections . isConstantName ( clazz , name ) ) ) { 
return new MemberKey ( clazz , name ) ; 
return new MemberKey ( contextObject . getClass ( ) , name ) ; 
public boolean isCache ( ) { 
return engine . getConfiguration ( ) . getBooleanPropertyValue ( EngineConfigurationKey . TEMPLATE_CACHE_ENABLED ) 
&& ! engine . getConfiguration ( ) . getBooleanPropertyValue ( EngineConfigurationKey . DEBUG_MODE ) 
&& super . isCache ( ) ; 
} private void lineSeparatorFound ( String lineSeparator ) { 
flushText ( ) ; 
flushLineSeparator ( lineSeparator ) ; 
line ++ ; 
state = State . TEXT ; 
separatorIdx = 0 ; 
} private void flushTag ( ) { 
handler . tag ( deriveTag ( buffer . toString ( ) ) ) ; 
delimiterIdx = 0 ; 
clearBuffer ( ) ; 
} private MustacheTagType identifyTagType ( String buffer ) { 
if ( buffer . length ( ) == 0 ) { 
return MustacheTagType . VARIABLE ; 
if ( delimiters . hasDefaultDelimitersSet ( ) 
&& buffer . charAt ( 0 ) == ( ( String ) EngineConfigurationKey . START_DELIMITER 
. getDefaultValue ( ) ) . charAt ( 0 ) 
&& buffer . charAt ( buffer . length ( ) - 1 ) == ( ( String ) EngineConfigurationKey . END_DELIMITER 
. getDefaultValue ( ) ) . charAt ( 0 ) ) { 
return MustacheTagType . UNESCAPE_VARIABLE ; 
Character command = buffer . charAt ( 0 ) ; 
for ( MustacheTagType type : MustacheTagType . values ( ) ) { 
if ( command . equals ( type . getCommand ( ) ) ) { 
} private String extractContent ( MustacheTagType tagType , String buffer ) { 
switch ( tagType ) { 
return buffer . trim ( ) ; 
case UNESCAPE_VARIABLE : 
return ( buffer . charAt ( 0 ) == ( ( String ) EngineConfigurationKey . START_DELIMITER 
. getDefaultValue ( ) ) . charAt ( 0 ) ? buffer . substring ( 1 , 
buffer . length ( ) - 1 ) . trim ( ) : buffer . substring ( 1 ) . trim ( ) ) ; 
case SECTION : 
case INVERTED_SECTION : 
case PARTIAL : 
case EXTEND : 
case EXTEND_SECTION : 
case SECTION_END : 
case NESTED_TEMPLATE : 
case COMMENT : 
return buffer . substring ( 1 ) . trim ( ) ; 
case DELIMITER : 
if ( releaseCallbacks == null ) { 
for ( ReleaseCallback callback : releaseCallbacks ) { 
callback . release ( ) ; 
LOGGER . warn ( 
} public static void forEachOperator ( BiConsumer < String , Helper > consumer ) { 
for ( Operator operator : Operator . values ( ) ) { 
consumer . accept ( operator . toString ( ) . toLowerCase ( ) , new NumericExpressionHelper ( operator ) ) ; 
} private static List < List < SegmentBase > > readSegmentLines ( 
ContainerSegmentBase container ) { 
List < List < SegmentBase > > lines = new ArrayList < > ( ) ; 
lines . add ( readSegmentLines ( lines , null , container ) ) ; 
return lines ; 
} public static Pattern newMustacheTagPattern ( Configuration configuration ) { 
StringBuilder regex = new StringBuilder ( ) ; 
regex . append ( Pattern . quote ( configuration 
. getStringPropertyValue ( EngineConfigurationKey . START_DELIMITER ) ) ) ; 
regex . append ( ".*?" ) ; 
. getStringPropertyValue ( EngineConfigurationKey . END_DELIMITER ) ) ) ; 
return Pattern . compile ( regex . toString ( ) ) ; 
} public static < T > Decorator < T > decorate ( T delegate , Map < String , Function < T , Object > > mappings , String delegateKey , 
Configuration configuration ) { 
return IterableDecorator . isIterable ( delegate ) 
? new IterableDecorator < > ( delegate , ImmutableMap . copyOf ( mappings ) , delegateKey , configuration ) 
: new Decorator < > ( delegate , ImmutableMap . copyOf ( mappings ) , delegateKey , configuration ) ; 
public static < T > T unwrap ( T instance ) { 
return instance instanceof Decorator ? unwrap ( ( ( Decorator < T > ) instance ) . delegate ) : instance ; 
} public synchronized MustacheEngine build ( ) { 
MustacheEngine engine = new DefaultMustacheEngine ( this ) ; 
for ( EngineBuiltCallback callback : engineReadyCallbacks ) { 
callback . engineBuilt ( engine ) ; 
BuildInfo buildInfo = BuildInfo . load ( ) ; 
engine . getConfiguration ( ) . getInfo ( ) ) ; 
isBuilt = true ; 
} public MustacheEngineBuilder addGlobalData ( String name , Object value ) { 
checkArgumentsNotNull ( name , value ) ; 
checkNotBuilt ( ) ; 
this . globalData . put ( name , value ) ; 
} public MustacheEngineBuilder addTemplateLocator ( TemplateLocator locator ) { 
checkArgumentNotNull ( locator ) ; 
this . templateLocators . add ( locator ) ; 
} public MustacheEngineBuilder addResolver ( Resolver resolver ) { 
checkArgumentNotNull ( resolver ) ; 
this . resolvers . add ( resolver ) ; 
} public MustacheEngineBuilder setProperty ( String key , Object value ) { 
checkArgumentsNotNull ( key , value ) ; 
this . properties . put ( key , value ) ; 
} public < T extends ConfigurationKey > MustacheEngineBuilder setProperty ( 
T configurationKey , Object value ) { 
checkArgumentsNotNull ( configurationKey , value ) ; 
setProperty ( configurationKey . get ( ) , value ) ; 
} public MustacheEngineBuilder registerCallback ( 
EngineBuiltCallback callback ) { 
checkArgumentNotNull ( callback ) ; 
this . engineReadyCallbacks . add ( callback ) ; 
} public MustacheEngineBuilder addMustacheListener ( 
MustacheListener listener ) { 
checkArgumentNotNull ( listener ) ; 
this . mustacheListeners . add ( listener ) ; 
} public MustacheEngineBuilder registerHelper ( String name , Helper helper ) { 
return registerHelper ( name , helper , false ) ; 
} public MustacheEngineBuilder registerHelper ( String name , Helper helper , 
boolean overwrite ) { 
checkArgumentsNotNull ( name , helper ) ; 
if ( ! overwrite && helpers . containsKey ( name ) ) { 
helpers . put ( name , helper ) ; 
} public MustacheEngineBuilder registerHelpers ( Map < String , Helper > helpers , 
checkArgumentNotNull ( helpers ) ; 
for ( Entry < String , Helper > entry : helpers . entrySet ( ) ) { 
registerHelper ( entry . getKey ( ) , entry . getValue ( ) , overwrite ) ; 
} public MustacheEngineBuilder addValueConverter ( ValueConverter converter ) { 
checkArgumentNotNull ( converter ) ; 
this . valueConverters . add ( converter ) ; 
} public MustacheEngineBuilder addContextConverter ( ContextConverter converter ) { 
this . contextConverters . add ( converter ) ; 
} public static String capitalizeFully ( String text , Character delimiter ) { 
if ( isEmpty ( text ) ) { 
text = text . toLowerCase ( ) ; 
boolean capitalizeNext = true ; 
for ( int i = 0 ; i < text . length ( ) ; i ++ ) { 
final char ch = text . charAt ( i ) ; 
if ( delimiter . equals ( ch ) ) { 
capitalizeNext = true ; 
builder . append ( ch ) ; 
} else if ( capitalizeNext ) { 
builder . append ( Character . toTitleCase ( ch ) ) ; 
capitalizeNext = false ; 
} protected void append ( Options options , CharSequence sequence ) { 
TextSupport textSupport = this . textSupport ; 
if ( textSupport == null || isUnescapeVariable ( options ) ) { 
options . append ( sequence ) ; 
textSupport . appendEscapedHtml ( sequence . toString ( ) , 
options . getAppendable ( ) ) ; 
throw new MustacheException ( MustacheProblem . RENDER_IO_ERROR , e ) ; 
} private ComputingCache < String , Optional < String > > buildSourceCache ( ) { 
return buildCache ( "Source" , 
key -> 
Optional . ofNullable ( locateAndRead ( key ) ) , 
( key , cause ) -> 
} private void changeDelimiters ( String key ) { 
if ( key . charAt ( 0 ) != MustacheTagType . DELIMITER . getCommand ( ) 
|| key . charAt ( key . length ( ) - 1 ) != MustacheTagType . DELIMITER 
. getCommand ( ) ) { 
throw new MustacheException ( 
MustacheProblem . COMPILE_INVALID_DELIMITERS , 
Matcher matcher = Patterns . newSetDelimitersContentPattern ( ) 
. matcher ( key . substring ( 1 , key . length ( ) - 1 ) ) ; 
delimiters . setNewValues ( matcher . group ( 1 ) , matcher . group ( 3 ) ) ; 
} private void push ( ContainerSegmentBase container ) { 
containerStack . addFirst ( container ) ; 
container . getContent ( ) ) ; 
} private void addSegment ( SegmentBase segment ) { 
containerStack . peekFirst ( ) . addSegment ( segment ) ; 
} private RootSegmentBase validate ( ) { 
ContainerSegmentBase root = containerStack . peekFirst ( ) ; 
if ( ! ( root instanceof RootSegmentBase ) ) { 
MustacheProblem . COMPILE_INVALID_TEMPLATE , 
containerStack . peekFirst ( ) . toString ( ) , line ) ; 
return ( RootSegmentBase ) root ; 
} static Iterator < String > splitHelperName ( String name , Segment segment ) { 
boolean stringLiteral = false ; 
boolean arrayLiteral = false ; 
boolean space = false ; 
List < String > parts = new ArrayList < > ( ) ; 
if ( ! space ) { 
if ( ! stringLiteral && ! arrayLiteral ) { 
if ( buffer . length ( ) > 0 ) { 
parts . add ( buffer . toString ( ) ) ; 
buffer = new StringBuilder ( ) ; 
space = true ; 
buffer . append ( name . charAt ( i ) ) ; 
if ( ! arrayLiteral 
&& Strings . isStringLiteralSeparator ( name . charAt ( i ) ) ) { 
stringLiteral = ! stringLiteral ; 
} else if ( ! stringLiteral 
&& Strings . isListLiteralStart ( name . charAt ( i ) ) ) { 
arrayLiteral = true ; 
&& Strings . isListLiteralEnd ( name . charAt ( i ) ) ) { 
arrayLiteral = false ; 
space = false ; 
if ( stringLiteral || arrayLiteral ) { 
MustacheProblem . COMPILE_HELPER_VALIDATION_FAILURE , 
segment ) ; 
return parts . iterator ( ) ; 
} static Object eval ( String expression , Options options , Configuration configuration ) { 
ELProcessorFactory elpFactory = ( ELProcessorFactory ) configuration 
. getPropertyValue ( ELProcessorFactory . EL_PROCESSOR_FACTORY_KEY ) ; 
ELProcessor elp = elpFactory . createELProcessor ( configuration ) ; 
elp . getELManager ( ) . addELResolver ( new OptionsELResolver ( options ) ) ; 
return elp . eval ( expression ) ; 
} public HelpersBuilder addIf ( String elseStartDelimiter , String elseEndDelimiter ) { 
builder . put ( IF , new IfHelper ( elseStartDelimiter , elseEndDelimiter ) ) ; 
} public HelpersBuilder addChoose ( ) { 
builder . put ( CHOOSE , new ChooseHelper ( ) ) ; 
builder . put ( WHEN , new ChooseHelper . WhenHelper ( ) ) ; 
builder . put ( OTHERWISE , new ChooseHelper . OtherwiseHelper ( ) ) ; 
} public HelpersBuilder addSwitch ( boolean caseDefaultIsBreak ) { 
builder . put ( SWITCH , new SwitchHelper ( ) ) ; 
builder . put ( CASE , new SwitchHelper . CaseHelper ( caseDefaultIsBreak ) ) ; 
builder . put ( DEFAULT , new SwitchHelper . DefaultHelper ( ) ) ; 
} public static < T > Builder < T > decorate ( Class < T > delegateType ) { 
return decorate ( o -> ( delegateType . isAssignableFrom ( Decorator . unwrap ( o ) . getClass ( ) ) ) ) ; 
} private void flush ( ) { 
parent . append ( future . get ( 60 , TimeUnit . SECONDS ) . collect ( this ) ) ; 
parent . append ( buffer ) ; 
if ( parent instanceof AsyncAppendable ) { 
( ( AsyncAppendable ) parent ) . flush ( ) ; 
MustacheProblem . RENDER_ASYNC_PROCESSING_ERROR , e ) ; 
public void init ( Configuration configuration ) { 
checkNotInitialized ( this . configuration != null ) ; 
this . configuration = configuration ; 
this . init ( ) ; 
} public void invalidateMemberCache ( Predicate < Class < ? > > predicate ) { 
if ( memberCache == null ) { 
if ( predicate == null ) { 
memberCache . clear ( ) ; 
memberCache . invalidate ( ( key ) -> predicate . test ( key . getClazz ( ) ) ) ; 
} static Method findMethod ( Class < ? > clazz , String name ) { 
checkArgumentNotNull ( clazz ) ; 
checkArgumentNotNull ( name ) ; 
Method foundMatch = null ; 
Method foundGetMatch = null ; 
Method foundIsMatch = null ; 
for ( Method method : SecurityActions . getMethods ( clazz ) ) { 
if ( ! isMethodValid ( method ) ) { 
if ( method . isBridge ( ) ) { 
if ( name . equals ( method . getName ( ) ) ) { 
foundMatch = method ; 
} else if ( Reflections . matchesPrefix ( name , method . getName ( ) , 
GET_PREFIX ) ) { 
foundGetMatch = method ; 
IS_PREFIX ) ) { 
foundIsMatch = method ; 
if ( foundMatch == null ) { 
foundMatch = ( foundGetMatch != null ? foundGetMatch : foundIsMatch ) ; 
foundMatch ) ; 
return foundMatch ; 
} static Field findField ( Class < ? > clazz , String name ) { 
Field found = null ; 
for ( Field field : SecurityActions . getFields ( clazz ) ) { 
if ( field . getName ( ) . equals ( name ) ) { 
found = field ; 
} private static boolean isMethodValid ( Method method ) { 
return method != null && Modifier . isPublic ( method . getModifiers ( ) ) 
&& method . getParameterTypes ( ) . length == 0 
&& ! method . getReturnType ( ) . equals ( Void . TYPE ) 
&& ! Object . class . equals ( method . getDeclaringClass ( ) ) ; 
} public static void registerHelpers ( ConfigurationExtensionBuilder builder , Map < String , Helper > helpers ) { 
Checker . checkArgumentsNotNull ( builder , helpers ) ; 
registerHelper ( builder , entry . getKey ( ) , entry . getValue ( ) ) ; 
} public static void registerHelper ( ConfigurationExtensionBuilder builder , String name , Helper helper ) { 
Checker . checkArgumentsNotNull ( builder , name , helper ) ; 
builder . registerHelper ( name , helper ) ; 
} catch ( IllegalArgumentException ignored ) { 
} static List < List < Segment > > readSegmentLinesBeforeRendering ( 
AbstractContainerSegment container ) { 
List < List < Segment > > lines = new ArrayList < > ( ) ; 
List < Segment > currentLine = new ArrayList < > ( ) ; 
for ( Segment segment : container ) { 
if ( ! SegmentType . LINE_SEPARATOR . equals ( segment . getType ( ) ) ) { 
currentLine . add ( segment ) ; 
lines . add ( currentLine ) ; 
currentLine = new ArrayList < > ( ) ; 
if ( ! currentLine . isEmpty ( ) ) { 
} public void invalidateFragments ( final String keyPart ) { 
if ( fragments == null || keyPart == null ) { 
fragments . invalidate ( fragmentKey -> fragmentKey . getKey ( ) . contains ( keyPart ) ) ; 
} private Object resolveLeadingContextObject ( String name , ValueWrapper value , 
AtomicReference < Hint > hintRef ) { 
Object leading = resolveContextObject ( name , value , hintRef ) ; 
if ( leading == null ) { 
Hint hint = hintRef != null ? hintRef . get ( ) : null ; 
leading = hint . resolve ( null , name , value ) ; 
leading = resolve ( null , name , value , hint == null 
&& hintRef != null ) ; 
return leading ; 
} protected TemporalAccessor getFormattableObject ( Object value , 
Locale locale , TimeZone timeZone , MustacheTagInfo tagInfo ) { 
if ( value instanceof TemporalAccessor ) { 
return ( TemporalAccessor ) value ; 
return LocalDateTime . ofInstant ( ( ( Date ) value ) . toInstant ( ) , 
timeZone . toZoneId ( ) ) ; 
} else if ( value instanceof Calendar ) { 
return LocalDateTime . ofInstant ( ( ( Calendar ) value ) . toInstant ( ) , 
} else if ( value instanceof Number ) { 
return LocalDateTime . ofInstant ( 
Instant . ofEpochMilli ( ( ( Number ) value ) . longValue ( ) ) , 
throw valueNotAFormattableObject ( value , tagInfo ) ; 
} static String buildPropertyKey ( String propertyName , String [ ] prefixParts ) { 
return buildPropertyKey ( propertyName , Strings . UNDERSCORE , prefixParts ) ; 
} static String buildPropertyKey ( String propertyName , String delimiter , 
String [ ] prefixParts ) { 
for ( final String prefixPart : prefixParts ) { 
key . append ( prefixPart ) ; 
key . append ( Strings . DOT ) ; 
key . append ( 
Strings . uncapitalize ( 
Strings . replace ( 
Strings . capitalizeFully ( propertyName , 
delimiter . toCharArray ( ) [ 0 ] ) , 
delimiter , "" ) ) ) ; 
} public static void main ( String [ ] args ) throws Throwable { 
Class < ? > initialClass ; 
initialClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( "kg.apc.cmdtools.PluginsCMD" ) ; 
Object instance = initialClass . newInstance ( ) ; 
Method startup = initialClass . getMethod ( "processParams" , ( new String [ 0 ] ) . getClass ( ) ) ; 
Object res = startup . invoke ( instance , new Object [ ] { args } ) ; 
int rc = ( Integer ) res ; 
if ( rc != 0 ) { 
System . exit ( rc ) ; 
if ( e . getCause ( ) != null ) { 
throw e . getCause ( ) ; 
public synchronized void init ( ProcessingEnvironment processingEnv ) { 
super . init ( processingEnv ) ; 
messager = processingEnv . getMessager ( ) ; 
types = processingEnv . getTypeUtils ( ) ; 
elements = processingEnv . getElementUtils ( ) ; 
filer = processingEnv . getFiler ( ) ; 
isDebug = processingEnv . getOptions ( ) . containsKey ( "debug" ) ; 
error = new Log ( Kind . ERROR , true ) ; 
warning = new Log ( Kind . WARNING , true ) ; 
debug = new Log ( Kind . NOTE , isDebug ) ; 
public final boolean process ( Set < ? extends TypeElement > annotations , RoundEnvironment roundEnv ) { 
handleAssert ( ( ) -> processActual ( annotations , roundEnv ) ) ; 
} protected void handleAssert ( Runnable task ) { 
} catch ( AssertException e ) { 
if ( e . getMessage ( ) != null && ! e . getMessage ( ) . isEmpty ( ) ) { 
error ( ) . log ( e . getMessage ( ) ) ; 
public Set < String > getSupportedAnnotationTypes ( ) { 
Set < String > set = new HashSet < > ( ) ; 
SupportedAnnotationTypes sat = this . getClass ( ) . getAnnotation ( SupportedAnnotationTypes . class ) ; 
if ( sat != null ) { 
Arrays . stream ( sat . value ( ) ) . forEach ( set :: add ) ; 
SupportedAnnotation sa = this . getClass ( ) . getAnnotation ( SupportedAnnotation . class ) ; 
Arrays . stream ( sa . value ( ) ) . map ( Class :: getCanonicalName ) . forEach ( set :: add ) ; 
if ( set . isEmpty ( ) && isInitialized ( ) ) { 
} public static long checkGreaterLong ( 
final long x , 
final String x_name , 
final long in_lower , 
final String lower_name ) 
if ( x > in_lower ) { 
@ SuppressWarnings ( "boxing" ) final var message = 
throw new RangeCheckException ( message ) ; 
} public static BigInteger checkGreaterBig ( 
final BigInteger x , 
final BigInteger in_lower , 
Objects . requireNonNull ( x , "Value" ) ; 
Objects . requireNonNull ( in_lower , "Lower" ) ; 
if ( x . compareTo ( in_lower ) > 0 ) { 
final var message = 
} public static long checkIncludedInLong ( 
final RangeInclusiveL range , 
final String range_name ) 
Objects . requireNonNull ( range , "Range" ) ; 
if ( range . includesValue ( x ) ) { 
final var message = String . format ( 
Long . valueOf ( range . lower ( ) ) , 
x_name , 
Long . valueOf ( x ) , 
Long . valueOf ( range . upper ( ) ) , 
range_name ) ; 
} public static int checkIncludedInInteger ( 
final int x , 
final RangeInclusiveI range , 
Integer . valueOf ( range . lower ( ) ) , 
Integer . valueOf ( x ) , 
Integer . valueOf ( range . upper ( ) ) , 
} public static BigInteger checkIncludedInBig ( 
final RangeInclusiveB range , 
range . lower ( ) , 
x , 
range . upper ( ) , 
} public static long checkLessLong ( 
final long in_upper , 
final String upper_name ) 
if ( x < in_upper ) { 
} public static BigInteger checkLessEqualBig ( 
final BigInteger in_upper , 
Objects . requireNonNull ( in_upper , "Upper" ) ; 
if ( x . compareTo ( in_upper ) <= 0 ) { 
} public static RangeInclusiveL checkRangeIncludedInLong ( 
final RangeInclusiveL inner , 
final String inner_name , 
final RangeInclusiveL outer , 
final String outer_name ) 
if ( inner . isIncludedIn ( outer ) ) { 
inner_name , 
inner , 
outer_name , 
outer ) ; 
} public static RangeInclusiveI checkRangeIncludedInInteger ( 
final RangeInclusiveI inner , 
final RangeInclusiveI outer , 
} public static RangeInclusiveB checkRangeIncludedInBig ( 
final RangeInclusiveB inner , 
final RangeInclusiveB outer , 
protected < D extends FileDescriptor > D toFileDescriptor ( Descriptor descriptor , Class < D > type , String path , ScannerContext context ) { 
if ( descriptor == null ) { 
D result = context . getStore ( ) . create ( type ) ; 
result . setFileName ( path ) ; 
return migrateOrCast ( descriptor , type , context ) ; 
} protected < D extends FileDescriptor > D getOrCreateAs ( String path , Class < D > type , Function < String , FileDescriptor > existing , ScannerContext context ) { 
FileDescriptor descriptor = cache . get ( path , p -> { 
FileDescriptor fileDescriptor = existing . apply ( p ) ; 
if ( fileDescriptor != null ) { 
return fileDescriptor ; 
fileDescriptor = context . getStore ( ) . create ( type ) ; 
fileDescriptor . setFileName ( path ) ; 
} private < D extends FileDescriptor > D migrateOrCast ( Descriptor descriptor , Class < D > type , ScannerContext context ) { 
return type . isAssignableFrom ( descriptor . getClass ( ) ) ? type . cast ( descriptor ) : context . getStore ( ) . addDescriptorType ( descriptor , type ) ; 
} public < D extends MD5Descriptor > D digest ( InputStream stream , DigestOperation < D > digestOperation ) throws IOException { 
DigestInputStream digestInputStream = new DigestInputStream ( stream , md5Digest ) ; 
D md5Descriptor = digestOperation . execute ( digestInputStream ) ; 
String md5 = DatatypeConverter . printHexBinary ( md5Digest . digest ( ) ) ; 
md5Descriptor . setMd5 ( md5 ) ; 
return md5Descriptor ; 
} public boolean accepts ( String path ) { 
if ( includeFilePatterns != null ) { 
result = matches ( path , includeFilePatterns ) ; 
if ( excludeFilePatterns != null ) { 
result = result && ! matches ( path , excludeFilePatterns ) ; 
} protected < T > Class < T > getTypeParameter ( Class < ? > expectedSuperClass , int genericTypeParameterIndex ) { 
Class < ? extends AbstractScannerPlugin > thisClass = this . getClass ( ) ; 
if ( ! thisClass . getSuperclass ( ) . equals ( expectedSuperClass ) ) { 
Type genericSuperclass = thisClass . getGenericSuperclass ( ) ; 
Type typeParameter = ( ( ParameterizedType ) genericSuperclass ) . getActualTypeArguments ( ) [ genericTypeParameterIndex ] ; 
if ( typeParameter instanceof ParameterizedType ) { 
return ( Class < T > ) ( ( ParameterizedType ) typeParameter ) . getRawType ( ) ; 
return ( Class < T > ) typeParameter ; 
} protected String getStringProperty ( String name , String defaultValue ) { 
Object value = properties . get ( name ) ; 
return value != null ? value . toString ( ) : defaultValue ; 
} protected Boolean getBooleanProperty ( String name , Boolean defaultValue ) { 
return value != null ? Boolean . valueOf ( value . toString ( ) ) : defaultValue ; 
} protected String getDirectoryPath ( File directory , File entry ) { 
String relativePath ; 
if ( entry . equals ( directory ) ) { 
relativePath = "/" ; 
String filePath = entry . getAbsolutePath ( ) ; 
String directoryPath = directory . getAbsolutePath ( ) ; 
relativePath = filePath . substring ( directoryPath . length ( ) ) . replace ( File . separator , "/" ) ; 
} public void flush ( ) { 
createHierarchy ( ) ; 
sync ( fileContainerDescriptor . getRequires ( ) , requiredFiles ) ; 
sync ( fileContainerDescriptor . getContains ( ) , containedFiles ) ; 
} private void sync ( Collection < FileDescriptor > target , Map < String , FileDescriptor > after ) { 
Map < String , FileDescriptor > before = getCache ( target ) ; 
Map < String , FileDescriptor > all = new HashMap < > ( ) ; 
all . putAll ( before ) ; 
all . putAll ( after ) ; 
for ( Map . Entry < String , FileDescriptor > entry : all . entrySet ( ) ) { 
FileDescriptor fileDescriptor = entry . getValue ( ) ; 
boolean hasBefore = before . containsKey ( key ) ; 
boolean hasAfter = after . containsKey ( key ) ; 
if ( hasBefore && ! hasAfter ) { 
target . remove ( fileDescriptor ) ; 
} else if ( ! hasBefore && hasAfter ) { 
target . add ( fileDescriptor ) ; 
} private Map < String , FileDescriptor > getCache ( Iterable < FileDescriptor > fileDescriptors ) { 
Map < String , FileDescriptor > cache = new HashMap < > ( ) ; 
for ( FileDescriptor fileDescriptor : fileDescriptors ) { 
cache . put ( fileDescriptor . getFileName ( ) , fileDescriptor ) ; 
return cache ; 
} private void createHierarchy ( ) { 
for ( Map . Entry < String , FileDescriptor > entry : containedFiles . entrySet ( ) ) { 
String relativePath = entry . getKey ( ) ; 
int separatorIndex = relativePath . lastIndexOf ( '/' ) ; 
if ( separatorIndex != - 1 ) { 
String parentName = relativePath . substring ( 0 , separatorIndex ) ; 
FileDescriptor parentDescriptor = containedFiles . get ( parentName ) ; 
if ( parentDescriptor instanceof FileContainerDescriptor ) { 
( ( FileContainerDescriptor ) parentDescriptor ) . getContains ( ) . add ( fileDescriptor ) ; 
} public static Set < IndexFlavor > complementOf ( final Set < IndexFlavor > indexFlavors ) { 
final Set < IndexFlavor > set = allOf ( ) ; 
set . removeAll ( indexFlavors ) ; 
} public static Set < IndexFlavor > of ( final IndexFlavor first , final IndexFlavor ... rest ) { 
final Set < IndexFlavor > set = new HashSet < > ( ) ; 
set . add ( first ) ; 
set . addAll ( Arrays . asList ( rest ) ) ; 
public V put ( final K key , final V value ) { 
entries . add ( new Entry ( key , value ) ) ; 
public V remove ( final Object key ) { 
final Iterator < Map . Entry < K , V > > iterator = entries . iterator ( ) ; 
V lastValue = null ; 
final Map . Entry < K , V > entry = iterator . next ( ) ; 
lastValue = entry . getValue ( ) ; 
if ( key . equals ( entry . getKey ( ) ) ) { 
return lastValue ; 
} public static Config getConfig ( String name , IConfigFactory factory ) { 
if ( configs == null ) { 
name = DEFAULT_CONFIG_NAME ; 
Config got = configs . get ( name ) ; 
if ( got == null ) { 
synchronized ( name . intern ( ) ) { 
got = configs . get ( name ) ; 
got = factory == null ? load ( name ) : factory . createConfig ( name ) ; 
throw new InvalidConfigException ( 
configs . put ( name , got ) ; 
return got ; 
} public ViewDocumentRequestBuilder addHighlightExpressions ( final String highlightExpression , final String ... highlightExpressions ) { 
this . highlightExpressions . add ( highlightExpression ) ; 
this . highlightExpressions . addAll ( Arrays . asList ( highlightExpressions ) ) ; 
} public ViewDocumentRequestBuilder addStartTags ( final String startTag , final String ... startTags ) { 
this . startTags . add ( startTag ) ; 
this . startTags . addAll ( Arrays . asList ( startTags ) ) ; 
} public ViewDocumentRequestBuilder addEndTags ( final String endTag , final String ... endTags ) { 
this . endTags . add ( endTag ) ; 
this . endTags . addAll ( Arrays . asList ( endTags ) ) ; 
} public < U > U makeRequest ( final Class < U > returnType , final BackendCaller < ? super E , ? super T > backendCaller ) throws HodErrorException { 
checkTokenProxyService ( ) ; 
return makeRequest ( tokenProxyService . getTokenProxy ( ) , returnType , backendCaller ) ; 
} public < U > U makeRequest ( final TypeReference < U > typeReference , final BackendCaller < ? super E , ? super T > backendCaller ) throws HodErrorException { 
return makeRequest ( tokenProxyService . getTokenProxy ( ) , typeReference , backendCaller ) ; 
} public InputStream makeRequest ( final BackendCaller < ? super E , ? super T > backendCaller ) throws HodErrorException { 
return makeRequest ( tokenProxyService . getTokenProxy ( ) , backendCaller ) ; 
} public < U > U unsafeMakeRequest ( final JavaType type , final BackendCaller < ? super E , ? super T > backendCaller ) throws HodErrorException { 
return unsafeMakeRequest ( tokenProxyService . getTokenProxy ( ) , type , backendCaller ) ; 
} public < U , BE extends EntityType , BT extends TokenType > U makeRequest ( 
final TokenProxy < BE , BT > tokenProxy , 
final Class < U > returnType , 
final BackendCaller < ? super BE , ? super BT > backendCaller 
) throws HodErrorException { 
return responseParser . parseResponse ( tokenProxy , returnType , backendCaller . makeRequest ( getAuthenticationToken ( tokenProxy ) ) ) ; 
final TypeReference < U > typeReference , 
return responseParser . parseResponse ( tokenProxy , typeReference , backendCaller . makeRequest ( getAuthenticationToken ( tokenProxy ) ) ) ; 
} public < BE extends EntityType , BT extends TokenType > InputStream makeRequest ( 
return responseParser . parseResponse ( tokenProxy , backendCaller . makeRequest ( getAuthenticationToken ( tokenProxy ) ) ) ; 
} public < U , BE extends EntityType , BT extends TokenType > U unsafeMakeRequest ( 
final JavaType type , 
return responseParser . unsafeParseResponse ( tokenProxy , type , backendCaller . makeRequest ( getAuthenticationToken ( tokenProxy ) ) ) ; 
public Object fromBody ( final TypedInput body , final Type type ) throws ConversionException { 
return converter . fromBody ( body , type ) ; 
} catch ( final ConversionException e ) { 
if ( e . getCause ( ) instanceof JsonParseException ) { 
throw new HodUnavailableException ( e . getCause ( ) ) ; 
public TypedOutput toBody ( final Object object ) { 
if ( object . getClass ( ) . isAnnotationPresent ( DoNotConvert . class ) ) { 
return new TypedString ( object . toString ( ) ) ; 
return converter . toBody ( object ) ; 
} public AddToTextIndexRequestBuilder addReferencePrefixes ( final String referencePrefix , final String ... referencePrefixes ) { 
this . referencePrefixes . add ( referencePrefix ) ; 
this . referencePrefixes . addAll ( Arrays . asList ( referencePrefixes ) ) ; 
} public AddToTextIndexRequestBuilder addAdditionalMetadata ( final Object metadatum , final Object ... metadata ) { 
this . additionalMetadata . add ( metadatum ) ; 
this . additionalMetadata . addAll ( Arrays . asList ( metadata ) ) ; 
} public QueryProfileRequestBuilder addPromotionCategories ( final String category0 , final String ... categories ) { 
promotionCategories . add ( category0 ) ; 
promotionCategories . addAll ( Arrays . asList ( categories ) ) ; 
} public QueryProfileRequestBuilder addSynonymCategories ( final String category0 , final String ... categories ) { 
synonymCategories . add ( category0 ) ; 
synonymCategories . addAll ( Arrays . asList ( categories ) ) ; 
} public QueryProfileRequestBuilder addBlacklistCategories ( final String category0 , final String ... categories ) { 
blacklistCategories . add ( category0 ) ; 
blacklistCategories . addAll ( Arrays . asList ( categories ) ) ; 
} private List < FieldValues > parseResponse ( final JsonNode response ) { 
if ( response == null || response . get ( "fields" ) == null ) { 
final JsonNode fieldsNode = response . get ( "fields" ) ; 
if ( fieldsNode . getNodeType ( ) == JsonNodeType . OBJECT || fieldsNode . getNodeType ( ) == JsonNodeType . ARRAY ) { 
final List < FieldValues > output = new ArrayList < > ( ) ; 
for ( final JsonNode node : fieldsNode ) { 
final FieldValues fieldValues = objectMapper . treeToValue ( node , FieldValues . class ) ; 
output . add ( fieldValues ) ; 
} catch ( final JsonProcessingException e ) { 
} < T > T parseResponse ( final TokenProxy < ? , ? > tokenProxy , final Class < T > clazz , final Response response ) { 
return unsafeParseResponse ( tokenProxy , objectMapper . constructType ( clazz ) , response ) ; 
} < T > T parseResponse ( final TokenProxy < ? , ? > tokenProxy , final TypeReference < T > typeReference , final Response response ) { 
return unsafeParseResponse ( tokenProxy , objectMapper . getTypeFactory ( ) . constructType ( typeReference ) , response ) ; 
} < T > T unsafeParseResponse ( final TokenProxy < ? , ? > tokenProxy , final JavaType type , final Response response ) { 
checkRefresh ( tokenProxy , response ) ; 
return objectMapper . readValue ( response . getBody ( ) . in ( ) , type ) ; 
} InputStream parseResponse ( final TokenProxy < ? , ? > tokenProxy , final Response response ) { 
return response . getBody ( ) . in ( ) ; 
final JobStatus < T > jobStatus ; 
if ( tokenProxy != null ) { 
jobStatus = jobService . getJobStatus ( tokenProxy , jobId ) ; 
jobStatus = jobService . getJobStatus ( jobId ) ; 
final Status jobStatusStatus = jobStatus . getStatus ( ) ; 
if ( jobStatusStatus == Status . FINISHED || jobStatusStatus == Status . FAILED ) { 
for ( final Action < T > action : jobStatus . getActions ( ) ) { 
final Status status = action . getStatus ( ) ; 
if ( status == Status . FINISHED ) { 
callback . success ( action . getResult ( ) ) ; 
else if ( status == Status . FAILED ) { 
for ( final HodError error : action . getErrors ( ) ) { 
callback . error ( error . getErrorCode ( ) ) ; 
else if ( timeout != null && timeout . isBefore ( LocalDateTime . now ( ) ) ) { 
callback . timeout ( ) ; 
tries . set ( 0 ) ; 
executorService . schedule ( this , WAIT_SECONDS , TimeUnit . SECONDS ) ; 
} catch ( final HodErrorException e ) { 
log . error ( "Cause:" , e ) ; 
if ( DO_NOT_RETRY_CODES . contains ( e . getErrorCode ( ) ) ) { 
callback . error ( e . getErrorCode ( ) ) ; 
else if ( tries . get ( ) >= MAX_TRIES ) { 
log . error ( "Retrying" ) ; 
tries . incrementAndGet ( ) ; 
callback . handleException ( e ) ; 
if ( ! executorService . awaitTermination ( 10 , TimeUnit . SECONDS ) ) { 
executorService . shutdownNow ( ) ; 
} public static GetContentServiceImpl < Document > documentsService ( final HodServiceConfig < ? , TokenType . Simple > hodServiceConfig ) { 
return new GetContentServiceImpl < > ( hodServiceConfig , Document . class ) ; 
} public static QueryTextIndexServiceImpl < Document > documentsService ( final HodServiceConfig < ? , TokenType . Simple > hodServiceConfig ) { 
return new QueryTextIndexServiceImpl < > ( hodServiceConfig , Document . class ) ; 
} public QueryRequestBuilder addIndexes ( final ResourceIdentifier index0 , final ResourceIdentifier ... indexes ) { 
this . indexes . add ( index0 ) ; 
this . indexes . addAll ( Arrays . asList ( indexes ) ) ; 
} public static Set < ResourceType > complementOf ( final Set < ResourceType > resourceTypes ) { 
final Set < ResourceType > set = allOf ( ) ; 
set . removeAll ( resourceTypes ) ; 
} public static Set < ResourceType > of ( final ResourceType first , final ResourceType ... rest ) { 
final Set < ResourceType > set = new HashSet < > ( ) ; 
} public static FindSimilarServiceImpl < Document > documentsService ( final HodServiceConfig < ? , TokenType . Simple > hodServiceConfig ) { 
return new FindSimilarServiceImpl < > ( hodServiceConfig , Document . class ) ; 
} private Map < String , Object > buildHierarchyParameters ( final List < String > parents , final List < String > children ) { 
final MultiMap < String , Object > parameters = new MultiMap < > ( ) ; 
if ( parents != null ) { 
for ( final String parent : parents ) { 
parameters . put ( "parents" , parent ) ; 
for ( final String child : children ) { 
parameters . put ( "children" , child ) ; 
} public static boolean rootElementMatches ( FileResource fileResource , String path , String expectedRootElement ) throws IOException { 
try ( InputStream stream = fileResource . createStream ( ) ) { 
XMLStreamReader reader = factory . createXMLStreamReader ( stream ) ; 
int event = reader . next ( ) ; 
switch ( event ) { 
case XMLStreamConstants . START_ELEMENT : 
String rootElement = reader . getLocalName ( ) ; 
return expectedRootElement . equals ( rootElement ) ; 
} catch ( XMLStreamException e ) { 
} public static void main ( final String [ ] args ) throws Throwable { 
final Preferences config = Preferences . systemNodeForPackage ( Example . class ) ; 
System . out . println ( config . get ( "mykey" , "my-default-value1" ) ) ; 
System . out . println ( config . get ( "mykey2" , "my-default-value2" ) ) ; 
System . out . println ( config . get ( "other.key" , "my-default-value3" ) ) ; 
System . out . println ( config . get ( "urlbase" , "my-default-value4" ) ) ; 
System . out . println ( config . get ( "urlsearch" , "my-default-value5" ) ) ; 
public String map ( final String propName ) { 
if ( propName == null ) 
String keyName = propName , defValue = null ; 
final int offsetDefault = propName . indexOf ( ':' ) ; 
if ( offsetDefault != - 1 ) { 
keyName = propName . substring ( 0 , offsetDefault ) ; 
defValue = propName . substring ( offsetDefault + 1 ) ; 
final ClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
String value = ClassLoaderMap . get ( ctxLoader , keyName , null ) ; 
value = System . getProperty ( propName , defValue ) ; 
} public static void transform ( final @ NonNull File xmlFile , final @ NonNull File xsltFile , 
final OutputStream outputStream ) 
throws TransformerConfigurationException , TransformerException 
final Source xmlSource = new StreamSource ( xmlFile ) ; 
final Source xsltSource = new StreamSource ( xsltFile ) ; 
transform ( xmlSource , xsltSource , outputStream ) ; 
} public static void transform ( final Source xmlSource , final Source xsltSource , 
final Transformer transformer = getTransformer ( xsltSource ) ; 
transformer . transform ( xmlSource , new StreamResult ( outputStream ) ) ; 
} public static void transform ( final String xmlInputFile , final String xsltInputFile , 
final File xmlFile = new File ( xmlInputFile ) ; 
final File xsltFile = new File ( xsltInputFile ) ; 
transform ( xmlFile , xsltFile , outputStream ) ; 
} public static DocumentBuilderFactory getDocumentBuilderFactory ( final String schema ) 
System . setProperty ( DOCUMENT_BUILDER_FACTORY_KEY , DOCUMENT_BUILDER_FACTORY_VALUE ) ; 
final DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; 
factory . setValidating ( true ) ; 
factory . setAttribute ( SCHEMA_LANGUAGE_KEY , HTTP_WWW_W3_ORG_2001_XML_SCHEMA ) ; 
factory . setAttribute ( SCHEMA_SOURCE_KEY , schema ) ; 
} public static DOMSource getDOMSource ( final File xml , final ErrorHandler errorHandler ) 
throws SAXException , ParserConfigurationException , IOException 
return new DOMSource ( parse ( xml , errorHandler ) ) ; 
} public static Schema getSchema ( final File xsd , final ErrorHandler errorHandler ) 
final SchemaFactory schemaFactory = SchemaFactory 
. newInstance ( HTTP_WWW_W3_ORG_2001_XML_SCHEMA ) ; 
schemaFactory . setErrorHandler ( errorHandler ) ; 
return schemaFactory . newSchema ( xsd ) ; 
} public static Document parse ( final File xml , final ErrorHandler errorHandler ) 
final DocumentBuilderFactory factory = getDocumentBuilderFactory ( xml . getName ( ) ) ; 
final DocumentBuilder builder = factory . newDocumentBuilder ( ) ; 
builder . setErrorHandler ( errorHandler ) ; 
return builder . parse ( xml ) ; 
} public static void validateSchema ( final File xsd , final File xml , 
final ErrorHandler errorHandler ) 
final Schema schemaXSD = getSchema ( xsd , errorHandler ) ; 
final Validator validator = schemaXSD . newValidator ( ) ; 
validator . validate ( getDOMSource ( xml , errorHandler ) ) ; 
} public static boolean validateSchema ( final String SchemaUrl , final String XmlDocumentUrl ) 
factory . setAttribute ( SCHEMA_SOURCE_KEY , SchemaUrl ) ; 
final ValidatorHandler handler = new ValidatorHandler ( ) ; 
builder . setErrorHandler ( handler ) ; 
builder . parse ( XmlDocumentUrl ) ; 
if ( handler . isValid ( ) ) 
} public static Optional < String > attributesToString ( Map < String , String > attributes ) 
if ( attributes != null && ! attributes . isEmpty ( ) ) 
for ( final Map . Entry < String , String > entry : attributes . entrySet ( ) ) 
builder . append ( entry . getKey ( ) ) ; 
builder . append ( "=" ) ; 
builder . append ( "\"" ) . append ( entry . getValue ( ) ) . append ( "\"" ) ; 
return Optional . of ( builder . toString ( ) ) ; 
} public boolean addChild ( final SimpleTag child ) 
if ( getChildren ( ) == null ) 
setChildren ( ListFactory . newArrayList ( ) ) ; 
return getChildren ( ) . add ( child ) ; 
} public String removeAttribute ( final String name ) 
if ( getAttributes ( ) != null ) 
getAttributes ( ) . remove ( name ) ; 
} public StringBuilder toVelocityTemplate ( ) 
buffer . append ( "<" ) ; 
buffer . append ( "${" ) . append ( getName ( ) ) . append ( ".name}\n" ) ; 
if ( getAttributes ( ) != null && ! getAttributes ( ) . isEmpty ( ) ) 
. append ( ".attributes.keySet()" + ")\n" ) ; 
buffer . append ( "$attribute=\"$" ) . append ( getName ( ) ) 
. append ( ".getAttributes().get($attribute)\"\n" ) ; 
buffer . append ( "#if(${" ) . append ( getName ( ) ) . append ( ".endTag})>${" ) . append ( getName ( ) ) 
. append ( ".content}\n" ) ; 
if ( getChildren ( ) != null && ! getChildren ( ) . isEmpty ( ) ) 
. append ( getName ( ) ) . append ( ".children)\n" ) ; 
for ( final SimpleTag child : getChildren ( ) ) 
buffer . append ( child . toVelocityTemplate ( ) . toString ( ) ) ; 
buffer . append ( "#end\n" ) ; 
buffer . append ( "</${" ) . append ( getName ( ) ) . append ( ".name}>\n" ) ; 
} public String toXmlString ( ) 
buffer . append ( getName ( ) ) ; 
Optional < String > attr = TagExtensions . attributesToString ( getAttributes ( ) ) ; 
if ( attr . isPresent ( ) ) 
buffer . append ( attr . get ( ) ) ; 
if ( isEndTag ( ) ) 
buffer . append ( ">" ) ; 
buffer . append ( getContent ( ) ) ; 
buffer . append ( child . toXmlString ( ) ) ; 
buffer . append ( "</" ) ; 
buffer . append ( "/>" ) ; 
public static < T > T toObjectWithXMLDecoder ( final String xmlString ) 
XMLDecoder dec = null ; 
T obj = null ; 
final InputStream is = new ByteArrayInputStream ( xmlString . getBytes ( ) ) ; 
dec = new XMLDecoder ( is ) ; 
obj = ( T ) dec . readObject ( ) ; 
if ( dec != null ) 
dec . close ( ) ; 
return obj ; 
} public static < T > T toObjectWithXStream ( final String xmlString , 
final Map < String , Class < ? > > aliases ) 
return toObjectWithXStream ( null , xmlString , aliases ) ; 
} public static < T > T toObjectWithXStream ( final XStream xstream , final String xmlString ) 
return toObjectWithXStream ( xstream , xmlString , null ) ; 
public static < T > T toObjectWithXStream ( XStream xstream , final String xmlString , 
if ( xstream == null ) 
xstream = new XStream ( ) ; 
if ( aliases != null ) 
for ( final Map . Entry < String , Class < ? > > alias : aliases . entrySet ( ) ) 
xstream . alias ( alias . getKey ( ) , alias . getValue ( ) ) ; 
return ( T ) xstream . fromXML ( xmlString ) ; 
} public static String toJson ( final String xmlString , final Map < String , Class < ? > > aliases ) 
final Object object = XmlToObjectExtensions . toObjectWithXStream ( xmlString ) ; 
final XStream xstream = new XStream ( new JettisonMappedXmlDriver ( ) ) ; 
final String json = xstream . toXML ( object ) ; 
} public static < T > T loadObject ( final File xmlFile ) throws IOException 
final InputStream is = FileUtils . openInputStream ( xmlFile ) ; 
return loadObject ( is ) ; 
} private static < T > T loadObject ( final InputStream is ) throws IOException 
final String xmlString = ReadFileExtensions . inputStream2String ( is ) ; 
final T object = XmlToObjectExtensions . toObjectWithXStream ( xmlString ) ; 
} public static < T > T loadObject ( final String xmlFileName ) throws IOException 
final InputStream is = ClassExtensions . getResourceAsStream ( xmlFileName ) ; 
} public static String newTag ( final String tagname , final String value , 
final Map < String , String > attributes ) 
final StringBuilder xmlTag = new StringBuilder ( ) ; 
xmlTag . append ( "<" ) . append ( tagname ) ; 
for ( final Map . Entry < String , String > attributte : attributes . entrySet ( ) ) 
xmlTag . append ( attributte . getKey ( ) ) ; 
xmlTag . append ( "=" ) ; 
xmlTag . append ( "\"" ) . append ( attributte . getValue ( ) ) . append ( "\"" ) ; 
if ( count != attributes . size ( ) ) 
xmlTag . append ( ">" ) ; 
xmlTag . append ( value ) ; 
xmlTag . append ( "</" ) . append ( tagname ) . append ( ">" ) ; 
return xmlTag . toString ( ) ; 
protected void write ( final String s ) throws SAXException 
getWriter ( ) . write ( s ) ; 
getWriter ( ) . flush ( ) ; 
catch ( final IOException e ) 
} public static < T > String toXmlWithXMLEncoder ( final T obj ) 
XMLEncoder enc = null ; 
enc = new XMLEncoder ( baos ) ; 
enc . writeObject ( obj ) ; 
enc . close ( ) ; 
return baos . toString ( ) ; 
} public static < T > String toXmlWithXStream ( final T objectToXML , 
return toXmlWithXStream ( null , objectToXML , aliases ) ; 
} public static < T > String toXmlWithXStream ( final XStream xstream , final T objectToXML ) 
return toXmlWithXStream ( xstream , objectToXML , null ) ; 
} public static < T > String toXmlWithXStream ( XStream xstream , final T objectToXML , 
final String xml = xstream . toXML ( objectToXML ) ; 
} public String toXml ( ) 
final String lqSimpleName = this . getClass ( ) . getSimpleName ( ) . toLowerCase ( ) ; 
final Map < String , Class < ? > > aliases = new HashMap < > ( ) ; 
aliases . put ( lqSimpleName , this . getClass ( ) ) ; 
return ObjectToXmlExtensions . toXmlWithXStream ( this , aliases ) ; 
} public static < T > T toObject ( final String jsonString , final Class < T > clazz ) 
throws JsonParseException , JsonMappingException , IOException 
return toObject ( jsonString , clazz , false ) ; 
} public static < T > T toObject ( final String jsonString , final Class < T > clazz , 
final boolean newMapper ) throws JsonParseException , JsonMappingException , IOException 
final ObjectMapper mapper = ObjectMapperFactory . getObjectMapper ( newMapper ) ; 
final T object = mapper . readValue ( jsonString , clazz ) ; 
final Module ... modules ) throws JsonParseException , JsonMappingException , IOException 
ObjectMapper mapper = ObjectMapperFactory . getObjectMapper ( true ) ; 
mapper = mapper . registerModules ( modules ) ; 
} public static < T > List < T > toObjectList ( final String jsonString , final Class < T > elementClass ) 
return ( List < T > ) toObjectCollection ( jsonString , List . class , elementClass ) ; 
} public static < T > Collection < T > toObjectCollection ( final String jsonString , 
@ SuppressWarnings ( "rawtypes" ) Class < ? extends Collection > collectionClass , 
Class < T > elementClass ) throws JsonParseException , JsonMappingException , IOException 
final ObjectMapper mapper = ObjectMapperFactory . getObjectMapper ( true ) ; 
return mapper . readValue ( jsonString , 
mapper . getTypeFactory ( ) . constructCollectionType ( collectionClass , elementClass ) ) ; 
} public static < T > String toJson ( final List < T > list ) 
throws JsonGenerationException , JsonMappingException , IOException 
final ObjectMapper mapper = new ObjectMapper ( ) ; 
mapper . writeValue ( out , list ) ; 
final byte [ ] bytes = out . toByteArray ( ) ; 
return new String ( bytes ) ; 
} public static < T > String toJson ( final T object , final boolean newMapper ) 
throws JsonProcessingException 
final String json = mapper . writeValueAsString ( object ) ; 
} public static String toXml ( final String jsonString ) throws JSONException 
final JSONObject json = new JSONObject ( jsonString ) ; 
final String xmlString = XML . toString ( json ) ; 
return xmlString ; 
} public static < T > String toXml ( final String jsonString , final Class < T > clazz ) 
final T object = JsonToObjectExtensions . toObject ( jsonString , clazz ) ; 
final String xmlString = ObjectToXmlExtensions . toXmlWithXStream ( object ) ; 
} public String addAttribute ( final String name , final String value ) 
if ( getAttributes ( ) == null ) 
this . attributes = MapFactory . newLinkedHashMap ( ) ; 
return getAttributes ( ) . put ( name , value ) ; 
} public boolean addChild ( final Tag child , final Integer position ) 
this . childTagPositions = ListFactory . newArrayList ( ) ; 
final ChildTagPosition childTagPosition = ChildTagPosition . builder ( ) . child ( child ) 
. position ( position ) . build ( ) ; 
return getChildren ( ) . add ( childTagPosition ) ; 
} public boolean removeChild ( final Tag child ) 
if ( getChildren ( ) != null ) 
ChildTagPosition found = null ; 
for ( final ChildTagPosition childTagPosition : getChildren ( ) ) 
if ( childTagPosition . getChild ( ) . equals ( child ) ) 
found = childTagPosition ; 
if ( found != null ) 
return getChildren ( ) . remove ( found ) ; 
String processingContent = getContent ( ) ; 
Integer lastPosition = 0 ; 
for ( final ChildTagPosition child : getChildren ( ) ) 
final String subContent = getContent ( ) . substring ( lastPosition , 
child . getPosition ( ) ) ; 
lastPosition = child . getPosition ( ) ; 
processingContent = processingContent . substring ( lastPosition , 
processingContent . length ( ) ) ; 
buffer . append ( subContent ) ; 
buffer . append ( child . getChild ( ) . toXmlString ( ) ) ; 
buffer . append ( processingContent ) ; 
public List < String > getFormats ( final String baseName ) 
if ( baseName == null ) 
return Collections . unmodifiableList ( Arrays . asList ( XML ) ) ; 
public void characters ( final char [ ] buf , final int offset , final int len ) throws SAXException 
final String string = new String ( buf , offset , len ) ; 
if ( stringBuilder == null ) 
stringBuilder = new StringBuilder ( string ) ; 
stringBuilder . append ( string ) ; 
public void endDocument ( ) throws SAXException 
insertNewLine ( ) ; 
public void endElement ( final String namespaceURI , final String simpleName , 
final String qualifiedName ) throws SAXException 
writeToBuffer ( ) ; 
String elementName = simpleName ; 
if ( "" . equals ( elementName ) ) 
elementName = qualifiedName ; 
write ( "</" + elementName + ">" ) ; 
} private void insertNewLine ( ) throws SAXException 
writer . write ( System . getProperty ( "line.separator" ) ) ; 
public void startElement ( final String namespaceURI , final String simpleName , 
final String qualifiedName , final Attributes attributes ) throws SAXException 
write ( "<" + elementName ) ; 
if ( attributes != null ) 
for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) 
String attributeName = attributes . getLocalName ( i ) ; 
if ( "" . equals ( attributeName ) ) 
attributeName = attributes . getQName ( i ) ; 
write ( attributeName + "=\"" + attributes . getValue ( i ) + "\"" ) ; 
write ( ">" ) ; 
} private void writeToBuffer ( ) throws SAXException 
final String string = stringBuilder . toString ( ) . trim ( ) ; 
write ( string ) ; 
stringBuilder = null ; 
} public static void xmlToXsd ( final File xmlInputFile , final File xsdOutFile ) 
throws XmlException , IOException 
xmlToXsd ( xmlInputFile , xsdOutFile , new Inst2XsdOptions ( ) ) ; 
} public static void xmlToXsd ( final File xmlInputFile , final File xsdOutFile , 
final Inst2XsdOptions inst2XsdOptions ) throws XmlException , IOException 
xmlToXsd ( xmlInputFile , xsdOutFile , inst2XsdOptions , new XmlOptions ( ) . setSavePrettyPrint ( ) ) ; 
} public static String xmlToXsd ( final File xmlFile , final Inst2XsdOptions inst2XsdOptions ) 
return xmlToXsd ( xmlFile , inst2XsdOptions , new XmlOptions ( ) . setSavePrettyPrint ( ) ) ; 
} public static String xmlToXsd ( final File xmlFile , final Inst2XsdOptions inst2XsdOptions , 
final XmlOptions xmlOptions ) throws XmlException , IOException 
final XmlObject [ ] xmlInstances = new XmlObject [ 1 ] ; 
xmlInstances [ 0 ] = XmlObject . Factory . parse ( xmlFile ) ; 
final SchemaDocument [ ] schemaDocs = Inst2Xsd . inst2xsd ( xmlInstances , inst2XsdOptions ) ; 
final SchemaDocument schema = schemaDocs [ 0 ] ; 
return schema . xmlText ( xmlOptions ) ; 
} public static void xmlToXsd ( final File [ ] xmlFiles , final Inst2XsdOptions inst2XsdOptions , 
File outDir , String outPrefix ) throws IOException 
if ( xmlFiles == null || xmlFiles . length == 0 ) 
if ( outDir == null ) 
outDir = new File ( "." ) ; 
if ( outPrefix == null ) 
outPrefix = "schema" ; 
final XmlObject [ ] xmlInstances = new XmlObject [ xmlFiles . length ] ; 
for ( i = 0 ; i < xmlFiles . length ; i ++ ) 
xmlInstances [ i ] = XmlObject . Factory . parse ( xmlFiles [ i ] ) ; 
catch ( final XmlException e ) 
for ( i = 0 ; i < schemaDocs . length ; i ++ ) 
final SchemaDocument schema = schemaDocs [ i ] ; 
schema . save ( new File ( outDir , outPrefix + i + ".xsd" ) , 
new XmlOptions ( ) . setSavePrettyPrint ( ) ) ; 
} public static < T > String toJsonQuietly ( final T object ) 
return ObjectToJsonExtensions . toJson ( object ) ; 
catch ( final JsonProcessingException e ) 
log . log ( Level . SEVERE , 
+ object . toString ( ) + "\n" , 
} public static NodeList getNodeList ( final String xml , final String xpathExpression ) 
throws XPathExpressionException , ParserConfigurationException , SAXException , IOException 
final DocumentBuilderFactory domFactory = DocumentBuilderFactory . newInstance ( ) ; 
domFactory . setNamespaceAware ( true ) ; 
final DocumentBuilder builder = domFactory . newDocumentBuilder ( ) ; 
final Document doc = builder . parse ( xml ) ; 
final XPath xpath = XPathFactory . newInstance ( ) . newXPath ( ) ; 
final XPathExpression expr = xpath . compile ( xpathExpression ) ; 
final Object result = expr . evaluate ( doc , XPathConstants . NODESET ) ; 
final NodeList nodes = ( NodeList ) result ; 
return nodes ; 
if ( s . startsWith ( "$" ) ) 
final String newValue = data . get ( s . substring ( 1 , s . length ( ) ) ) ; 
getWriter ( ) . append ( newValue ) ; 
getWriter ( ) . append ( s ) ; 
} private void constructFromLongs ( long hi , long lo ) { 
content [ 0 ] = ( byte ) ( hi > > 56 ) ; 
content [ 1 ] = ( byte ) ( hi > > 48 ) ; 
content [ 2 ] = ( byte ) ( hi > > 40 ) ; 
content [ 3 ] = ( byte ) ( hi > > 32 ) ; 
content [ 4 ] = ( byte ) ( hi > > 24 ) ; 
content [ 5 ] = ( byte ) ( hi > > 16 ) ; 
content [ 6 ] = ( byte ) ( hi > > 8 ) ; 
content [ 7 ] = ( byte ) ( hi ) ; 
content [ 8 ] = ( byte ) ( lo > > 56 ) ; 
content [ 9 ] = ( byte ) ( lo > > 48 ) ; 
content [ 10 ] = ( byte ) ( lo > > 40 ) ; 
content [ 11 ] = ( byte ) ( lo > > 32 ) ; 
content [ 12 ] = ( byte ) ( lo > > 24 ) ; 
content [ 13 ] = ( byte ) ( lo > > 16 ) ; 
content [ 14 ] = ( byte ) ( lo > > 8 ) ; 
content [ 15 ] = ( byte ) ( lo ) ; 
} public static boolean isValidUUID ( char [ ] ch ) { 
return ch != null && 
ch . length == 36 && 
validHex ( ch [ 0 ] ) && 
validHex ( ch [ 1 ] ) && 
validHex ( ch [ 2 ] ) && 
validHex ( ch [ 3 ] ) && 
validHex ( ch [ 4 ] ) && 
validHex ( ch [ 5 ] ) && 
validHex ( ch [ 6 ] ) && 
validHex ( ch [ 7 ] ) && 
ch [ 8 ] == '-' && 
validHex ( ch [ 9 ] ) && 
validHex ( ch [ 10 ] ) && 
validHex ( ch [ 11 ] ) && 
validHex ( ch [ 12 ] ) && 
ch [ 13 ] == '-' && 
validHex ( ch [ 14 ] ) && 
validHex ( ch [ 15 ] ) && 
validHex ( ch [ 16 ] ) && 
validHex ( ch [ 17 ] ) && 
ch [ 18 ] == '-' && 
validHex ( ch [ 19 ] ) && 
validHex ( ch [ 20 ] ) && 
validHex ( ch [ 21 ] ) && 
validHex ( ch [ 22 ] ) && 
ch [ 23 ] == '-' && 
validHex ( ch [ 24 ] ) && 
validHex ( ch [ 25 ] ) && 
validHex ( ch [ 26 ] ) && 
validHex ( ch [ 27 ] ) && 
validHex ( ch [ 28 ] ) && 
validHex ( ch [ 29 ] ) && 
validHex ( ch [ 30 ] ) && 
validHex ( ch [ 31 ] ) && 
validHex ( ch [ 32 ] ) && 
validHex ( ch [ 33 ] ) && 
validHex ( ch [ 34 ] ) && 
validHex ( ch [ 35 ] ) ; 
} public static void useSequentialIds ( ) { 
if ( ! sequential ) { 
TimeZone tz = TimeZone . getTimeZone ( "UTC" ) ; 
DateFormat df = new SimpleDateFormat ( "yyyyMMddHHmm" ) ; 
df . setTimeZone ( tz ) ; 
String date = df . format ( new Date ( ) ) . substring ( 0 , 11 ) ; 
byte [ ] digest ; 
MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; 
digest = md . digest ( date . getBytes ( "UTF-8" ) ) ; 
int x ; 
x = ( ( int ) digest [ 0 ] & 0xFF ) ; 
x |= ( ( int ) digest [ 1 ] & 0xFF ) << 8 ; 
x |= ( ( int ) digest [ 2 ] & 0xFF ) << 16 ; 
x |= ( ( int ) digest [ 3 ] & 0xFF ) << 24 ; 
COUNTER . set ( x ) ; 
sequential = true ; 
} private static int intValue ( char x ) { 
if ( x >= '0' && x <= '9' ) 
return x - '0' ; 
if ( x >= 'a' && x <= 'f' ) 
return x - 'a' + 10 ; 
if ( x >= 'A' && x <= 'F' ) 
return x - 'A' + 10 ; 
} private static byte mapToByte ( char a , char b ) { 
int ai = intValue ( a ) ; 
int bi = intValue ( b ) ; 
return ( byte ) ( ( ai << 4 ) | bi ) ; 
} public long getMostSignificantBits ( ) { 
long a ; 
a = ( ( long ) content [ 0 ] & 0xFF ) << 56 ; 
a |= ( ( long ) content [ 1 ] & 0xFF ) << 48 ; 
a |= ( ( long ) content [ 2 ] & 0xFF ) << 40 ; 
a |= ( ( long ) content [ 3 ] & 0xFF ) << 32 ; 
a |= ( ( long ) content [ 4 ] & 0xFF ) << 24 ; 
a |= ( ( long ) content [ 5 ] & 0xFF ) << 16 ; 
a |= ( ( long ) content [ 6 ] & 0xFF ) << 8 ; 
a |= ( ( long ) content [ 7 ] & 0xFF ) ; 
} public long getLeastSignificantBits ( ) { 
b = ( ( long ) content [ 8 ] & 0xFF ) << 56 ; 
b |= ( ( long ) content [ 9 ] & 0xFF ) << 48 ; 
b |= ( ( long ) content [ 10 ] & 0xFF ) << 40 ; 
b |= ( ( long ) content [ 11 ] & 0xFF ) << 32 ; 
b |= ( ( long ) content [ 12 ] & 0xFF ) << 24 ; 
b |= ( ( long ) content [ 13 ] & 0xFF ) << 16 ; 
b |= ( ( long ) content [ 14 ] & 0xFF ) << 8 ; 
b |= ( ( long ) content [ 15 ] & 0xFF ) ; 
} public Date getTimestamp ( ) { 
if ( getVersion ( ) != VERSION ) 
long time ; 
time = ( ( long ) content [ 10 ] & 0xFF ) << 40 ; 
time |= ( ( long ) content [ 11 ] & 0xFF ) << 32 ; 
time |= ( ( long ) content [ 12 ] & 0xFF ) << 24 ; 
time |= ( ( long ) content [ 13 ] & 0xFF ) << 16 ; 
time |= ( ( long ) content [ 14 ] & 0xFF ) << 8 ; 
time |= ( ( long ) content [ 15 ] & 0xFF ) ; 
return new Date ( time ) ; 
} public byte [ ] getMacFragment ( ) { 
if ( getVersion ( ) != 'b' ) 
byte [ ] x = new byte [ 6 ] ; 
x [ 0 ] = 0 ; 
x [ 1 ] = 0 ; 
x [ 2 ] = ( byte ) ( content [ 6 ] & 0xF ) ; 
x [ 3 ] = content [ 7 ] ; 
x [ 4 ] = content [ 8 ] ; 
x [ 5 ] = content [ 9 ] ; 
} private static byte [ ] macAddress ( ) { 
Enumeration < NetworkInterface > interfaces = NetworkInterface . getNetworkInterfaces ( ) ; 
byte [ ] mac = null ; 
while ( interfaces . hasMoreElements ( ) && ( mac == null || mac . length != 6 ) ) { 
NetworkInterface netInterface = interfaces . nextElement ( ) ; 
if ( netInterface . isLoopback ( ) || netInterface . isVirtual ( ) ) 
mac = netInterface . getHardwareAddress ( ) ; 
if ( mac == null ) 
mac = new byte [ ] { 0 , 0 , 0 , 0 , 0 , 0 } ; 
return mac ; 
} private static int processId ( ) { 
final String jvmName = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; 
final int index = jvmName . indexOf ( '@' ) ; 
if ( index < 1 ) 
return Integer . parseInt ( jvmName . substring ( 0 , index ) ) % MAX_PID ; 
} public < T , U > U forStream ( 
String fileName , 
Class < T > clazz , 
Function < ? super Stream < T > , U > handleStream ) { 
String sql = getTemplate ( fileName , EMPTY_ARGS ) ; 
PreparedStatementSetter pss = paramBuilder . byArgs ( new Object [ 0 ] ) ; 
RowMapper < T > mapper = mapperBuilder . mapper ( clazz ) ; 
return queryStreamWithOrdinalParams ( sql , pss , mapper , handleStream ) ; 
Map < String , Object > params , 
String sql = getTemplate ( fileName , params ) ; 
SqlParameterSource sps = paramBuilder . byMap ( params ) ; 
return queryStreamWithNamedParams ( sql , sps , mapper , handleStream ) ; 
Object entity , 
String sql = getTemplate ( fileName , entity ) ; 
SQLExceptionTranslator excTranslator = jdbcTemplate . getExceptionTranslator ( ) ; 
if ( TypeUtils . isSimpleValueType ( entity . getClass ( ) ) ) { 
PreparedStatementSetter pss = paramBuilder . byArgs ( entity ) ; 
SqlParameterSource sps = paramBuilder . byBean ( entity ) ; 
} public < U > U forStream ( 
Function < ? super Stream < Map < String , Object > > , U > handleStream ) { 
RowMapper < Map < String , Object > > mapper = new ColumnMapRowMapper ( ) ; 
} private < T , U > U queryStreamWithOrdinalParams ( 
String sql , 
PreparedStatementSetter pss , 
RowMapper < T > mapper , 
ResultSetExtractor < U > extractor 
= new StreamResultSetExtractor ( sql , mapper , handleStream , excTranslator ) ; 
return jdbcTemplate . query ( sql , pss , extractor ) ; 
} private < T , U > U queryStreamWithNamedParams ( 
SqlParameterSource sps , 
return namedJdbcTemplate . query ( sql , sps , extractor ) ; 
} public static Field [ ] get ( Class < ? > clazz ) { 
Field [ ] fields = CACHED_FIELDS . get ( clazz ) ; 
fields = clazz . getFields ( ) ; 
CACHED_FIELDS . putIfAbsent ( clazz , fields ) ; 
} public static boolean isSimpleValueType ( Class < ? > clazz ) { 
return ClassUtils . isPrimitiveOrWrapper ( clazz ) || clazz . isEnum ( ) || 
CharSequence . class . isAssignableFrom ( clazz ) || 
Number . class . isAssignableFrom ( clazz ) || 
Date . class . isAssignableFrom ( clazz ) || 
Temporal . class . isAssignableFrom ( clazz ) || 
clazz . equals ( URI . class ) || clazz . equals ( URL . class ) || 
clazz . equals ( Locale . class ) || clazz . equals ( Class . class ) ; 
public Object getValue ( String paramName ) { 
Object value = values . get ( paramName ) ; 
return Jsr310JdbcUtils . convertIfNecessary ( value , zoneId ) ; 
} private Optional < T > fetchRow ( ) { 
if ( this . row != null ) { 
return Optional . of ( this . row ) ; 
this . hasReachedEos = hasReachedEos || ! wrapSqlException ( ( ) -> rs . next ( ) ) ; 
if ( this . hasReachedEos ) { 
this . row = wrapSqlException ( ( ) -> mapper . mapRow ( rs , 1 ) ) ; 
return Optional . ofNullable ( this . row ) ; 
} < R > R wrapSqlException ( SqlAction < R > action ) { 
return action . perform ( ) ; 
} catch ( SQLException sqlException ) { 
throw excTranslator . translate ( "StreamResultSetExtractor" , sql , sqlException ) ; 
} protected static LocalDateTime getAsLocalDateTime ( ResultSet rs , int index ) throws SQLException { 
Timestamp timestamp = rs . getTimestamp ( index ) ; 
if ( timestamp != null ) { 
return timestamp . toLocalDateTime ( ) ; 
} protected static LocalDate getAsLocalDate ( ResultSet rs , int index ) throws SQLException { 
Date date = rs . getDate ( index ) ; 
if ( date != null ) { 
return date . toLocalDate ( ) ; 
} protected static LocalTime getAsLocalTime ( ResultSet rs , int index ) throws SQLException { 
Time time = rs . getTime ( index ) ; 
return time . toLocalTime ( ) ; 
} protected static ZonedDateTime getAsZonedDateTime ( ResultSet rs , int index , ZoneId zoneId ) throws SQLException { 
return timestamp . toLocalDateTime ( ) . atZone ( zoneId ) ; 
} protected static OffsetDateTime getAsOffsetDateTime ( ResultSet rs , int index , ZoneId zoneId ) throws SQLException { 
return timestamp . toLocalDateTime ( ) . atZone ( zoneId ) . toOffsetDateTime ( ) ; 
} protected static OffsetTime getAsOffsetTime ( ResultSet rs , int index , ZoneId zoneId ) throws SQLException { 
return time . toLocalTime ( ) . atOffset ( zoneId . getRules ( ) . getOffset ( Instant . now ( ) ) ) ; 
public boolean hasValue ( String paramName ) { 
return privateFields . contains ( paramName ) || publicFeilds . containsKey ( paramName ) ; 
if ( privateFields . contains ( paramName ) ) { 
value = beanWrapper . getPropertyValue ( paramName ) ; 
} else if ( publicFeilds . containsKey ( paramName ) ) { 
Field field = publicFeilds . get ( paramName ) ; 
value = field . get ( entity ) ; 
} private String underscoreName ( String name ) { 
if ( ! StringUtils . hasLength ( name ) ) { 
result . append ( name . substring ( 0 , 1 ) 
. toLowerCase ( ) ) ; 
for ( int i = 1 ; i < name . length ( ) ; i ++ ) { 
String s = name . substring ( i , i + 1 ) ; 
String slc = s . toLowerCase ( ) ; 
if ( ! s . equals ( slc ) ) { 
result . append ( "_" ) 
. append ( slc ) ; 
result . append ( s ) ; 
public T mapRow ( ResultSet rs , int rowNumber ) throws SQLException { 
T mappedObject = BeanUtils . instantiate ( this . mappedClass ) ; 
BeanWrapper bw = PropertyAccessorFactory . forBeanPropertyAccess ( mappedObject ) ; 
ResultSetMetaData metaData = rs . getMetaData ( ) ; 
int columnCount = metaData . getColumnCount ( ) ; 
for ( int index = 1 ; index <= columnCount ; index ++ ) { 
String column = JdbcUtils . lookupColumnName ( metaData , index ) ; 
if ( privateFields . containsKey ( name ) ) { 
PropertyDescriptor pd = privateFields . get ( name ) ; 
value = getColumnValue ( rs , index , pd . getPropertyType ( ) ) ; 
if ( logger . isDebugEnabled ( ) && rowNumber == 0 ) { 
bw . setPropertyValue ( pd . getName ( ) , value ) ; 
} else if ( publicFields . containsKey ( name ) ) { 
Field field = this . publicFields . get ( name ) ; 
value = getColumnValue ( rs , index , field . getType ( ) ) ; 
field . set ( mappedObject , value ) ; 
return mappedObject ; 
} protected Object getColumnValue ( ResultSet rs , int index , Class < ? > requiredType ) throws SQLException { 
return Jsr310JdbcUtils . getResultSetValue ( rs , index , requiredType , zoneId ) ; 
} protected void doSetValue ( PreparedStatement ps , int parameterPosition , Object argValue ) throws SQLException { 
super . doSetValue ( ps , parameterPosition , Jsr310JdbcUtils . convertIfNecessary ( argValue , zoneId ) ) ; 
public U extractData ( ResultSet rs ) { 
Iterable < T > iterable = ( ) -> new ResultSetIterator ( sql , rs , mapper , excTranslator ) ; 
Stream < T > stream = StreamSupport . stream ( iterable . spliterator ( ) , false ) ; 
return handleStream . apply ( stream ) ; 
} public File upload ( int pollingInterval ) throws UploadFailureException { 
RequestHelper requestHelper = client . getRequestHelper ( ) ; 
URI uploadUrl = Urls . uploadFromUrl ( sourceUrl , client . getPublicKey ( ) , store ) ; 
String token = requestHelper . executeQuery ( new HttpGet ( uploadUrl ) , false , UploadFromUrlData . class ) . token ; 
URI statusUrl = Urls . uploadFromUrlStatus ( token ) ; 
sleep ( pollingInterval ) ; 
HttpGet request = new HttpGet ( statusUrl ) ; 
UploadFromUrlStatusData data = requestHelper . executeQuery ( request , false , UploadFromUrlStatusData . class ) ; 
if ( data . status . equals ( "success" ) ) { 
return client . getFile ( data . fileId ) ; 
} else if ( data . status . equals ( "error" ) || data . status . equals ( "failed" ) ) { 
throw new UploadFailureException ( ) ; 
} public CdnPathBuilder crop ( int width , int height ) { 
dimensionsGuard ( width , height ) ; 
sb . append ( "/-/crop/" ) 
. append ( width ) 
. append ( "x" ) 
. append ( height ) ; 
} public CdnPathBuilder cropCenter ( int width , int height ) { 
. append ( height ) 
. append ( "/center" ) ; 
} public CdnPathBuilder cropColor ( int width , int height , Color color ) { 
. append ( "/" ) 
. append ( colorToHex ( color ) ) ; 
} public CdnPathBuilder resizeWidth ( int width ) { 
dimensionGuard ( width ) ; 
sb . append ( "/-/resize/" ) 
. append ( "x" ) ; 
} public CdnPathBuilder resize ( int width , int height ) { 
} public CdnPathBuilder scaleCrop ( int width , int height ) { 
sb . append ( "/-/scale_crop/" ) 
} public CdnPathBuilder scaleCropCenter ( int width , int height ) { 
} public CdnPathBuilder blur ( int strength ) { 
if ( strength < 0 || strength > 5000 ) { 
strength = 10 ; 
sb . append ( "/-/blur/" ) 
. append ( strength ) ; 
} public CdnPathBuilder sharp ( int strength ) { 
if ( strength < 0 || strength > 20 ) { 
strength = 5 ; 
sb . append ( "/-/sharp/" ) 
} public CdnPathBuilder preview ( int width , int height ) { 
sb . append ( "/-/preview/" ) 
} public Project getProject ( ) { 
URI url = Urls . apiProject ( ) ; 
RequestHelper requestHelper = getRequestHelper ( ) ; 
ProjectData projectData = requestHelper . executeQuery ( new HttpGet ( url ) , true , ProjectData . class ) ; 
return new Project ( this , projectData ) ; 
} public File getFile ( String fileId ) { 
URI url = Urls . apiFile ( fileId ) ; 
FileData fileData = requestHelper . executeQuery ( new HttpGet ( url ) , true , FileData . class ) ; 
return new File ( this , fileData ) ; 
} public void deleteFile ( String fileId ) { 
requestHelper . executeCommand ( new HttpDelete ( url ) , true ) ; 
} public void saveFile ( String fileId ) { 
URI url = Urls . apiFileStorage ( fileId ) ; 
requestHelper . executeCommand ( new HttpPost ( url ) , true ) ; 
} public File upload ( ) throws UploadFailureException { 
URI uploadUrl = Urls . uploadBase ( ) ; 
HttpPost request = new HttpPost ( uploadUrl ) ; 
MultipartEntityBuilder entityBuilder = MultipartEntityBuilder . create ( ) ; 
entityBuilder . addTextBody ( "UPLOADCARE_PUB_KEY" , client . getPublicKey ( ) ) ; 
entityBuilder . addTextBody ( "UPLOADCARE_STORE" , store ) ; 
entityBuilder . addPart ( "file" , new FileBody ( file ) ) ; 
entityBuilder . addBinaryBody ( "file" , stream ) ; 
entityBuilder . addPart ( "file" , new ByteArrayBody ( bytes , filename ) ) ; 
request . setEntity ( entityBuilder . build ( ) ) ; 
String fileId = client . getRequestHelper ( ) 
. executeQuery ( request , false , UploadBaseData . class ) . file ; 
return client . getFile ( fileId ) ; 
} public HttpResponse executeCommand ( HttpUriRequest request , boolean apiHeaders ) { 
if ( apiHeaders ) { 
setApiHeaders ( request ) ; 
CloseableHttpResponse response = client . getHttpClient ( ) . execute ( request ) ; 
checkResponseStatus ( response ) ; 
throw new UploadcareNetworkException ( e ) ; 
} private void checkResponseStatus ( HttpResponse response ) throws IOException { 
int statusCode = response . getStatusLine ( ) . getStatusCode ( ) ; 
if ( statusCode >= 200 && statusCode < 300 ) { 
} else if ( statusCode == 401 || statusCode == 403 ) { 
throw new UploadcareAuthenticationException ( 
streamToString ( response . getEntity ( ) . getContent ( ) ) ) ; 
} else if ( statusCode == 400 || statusCode == 404 ) { 
throw new UploadcareInvalidRequestException ( 
throw new UploadcareApiException ( 
response . getEntity ( ) . getContent ( ) ) ) ; 
} private static String streamToString ( InputStream is ) { 
java . util . Scanner s = new java . util . Scanner ( is , "UTF-8" ) . useDelimiter ( "\\A" ) ; 
return s . hasNext ( ) ? s . next ( ) : "" ; 
} public static URI uploadFromUrl ( String sourceUrl , String pubKey , String store ) { 
URIBuilder builder = new URIBuilder ( URI . create ( UPLOAD_BASE ) ) ; 
builder . setPath ( "/from_url/" ) 
. setParameter ( "source_url" , sourceUrl ) 
. setParameter ( "pub_key" , pubKey ) 
. setParameter ( "store" , store ) ; 
return trustedBuild ( builder ) ; 
} public static URI uploadFromUrlStatus ( String token ) { 
builder . setPath ( "/from_url/status/" ) 
. setParameter ( "token" , token ) ; 
} public static Builder newBuilder ( Context context , int themeResId ) { 
if ( Build . VERSION . SDK_INT >= 21 ) { 
return new APi21Builder ( context , themeResId ) ; 
return new Api20Builder ( context , themeResId ) ; 
} private void onCommonClick ( ) { 
AlertDialog . build ( this ) 
. setTitle ( "" ) 
. setMessage ( "" ) 
. setNeutralButton ( "" , ( dialog , which ) -> { 
Toast . makeText ( MainActivity . this , "" , Toast . LENGTH_SHORT ) . show ( ) ; 
. setNegativeButton ( "" , ( dialog , which ) -> { 
Toast . makeText ( MainActivity . this , "" , Toast . LENGTH_SHORT ) . show ( ) ; 
. setPositiveButton ( "" , ( dialog , which ) -> { 
Toast . makeText ( MainActivity . this , "" , Toast . LENGTH_SHORT ) . show ( ) ; 
. show ( ) ; 
} private void onSpecialClick ( ) { 
AlertDialog alertDialog = AlertDialog . build ( this ) 
. setNeutralButton ( "" , null ) 
. setNegativeButton ( "" , null ) 
. setPositiveButton ( "" , null ) 
Button btnNeutral = alertDialog . getButton ( DialogInterface . BUTTON_NEUTRAL ) ; 
btnNeutral . setOnClickListener ( v -> { 
Toast . makeText ( MainActivity . this , "dialog" , 
Toast . LENGTH_SHORT ) . show ( ) ; 
Button btnNegative = alertDialog . getButton ( DialogInterface . BUTTON_NEGATIVE ) ; 
btnNegative . setOnClickListener ( v -> { 
alertDialog . dismiss ( ) ; 
Toast . makeText ( MainActivity . this , "" , 
Button btnPositive = alertDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) ; 
btnPositive . setOnClickListener ( v -> { 
Toast . makeText ( MainActivity . this , "" , 
} protected String [ ] buildArgs ( ) { 
String result [ ] = new String [ 0 ] ; 
List < String > args = new ArrayList < String > ( ) ; 
if ( lang != null && lang . length ( ) > 0 ) { 
args . add ( flagify ( CowsayCli . Opt . LANG . toString ( ) ) ) ; 
args . add ( lang ) ; 
if ( html ) { 
args . add ( flagify ( CowsayCli . Opt . HTML . toString ( ) ) ) ; 
if ( alt != null && alt . length ( ) > 0 ) { 
args . add ( flagify ( CowsayCli . Opt . ALT . toString ( ) ) ) ; 
args . add ( alt ) ; 
if ( wrap != null ) { 
args . add ( flagify ( CowsayCli . Opt . WRAP_AT . toString ( ) ) ) ; 
args . add ( wrap ) ; 
buildFaceArgs ( args ) ; 
args . add ( message ) ; 
return args . toArray ( result ) ; 
} private void buildFaceArgs ( final List < String > args ) { 
if ( mode != null && CowFace . isKnownMode ( mode ) ) { 
args . add ( flagify ( mode ) ) ; 
if ( eyes != null ) { 
args . add ( flagify ( CowsayCli . Opt . EYES . toString ( ) ) ) ; 
args . add ( eyes ) ; 
if ( tongue != null ) { 
args . add ( flagify ( CowsayCli . Opt . TONGUE . toString ( ) ) ) ; 
args . add ( tongue ) ; 
if ( cowfile != null ) { 
args . add ( flagify ( CowsayCli . Opt . COWFILE . toString ( ) ) ) ; 
args . add ( cowfile ) ; 
} public String execute ( ) throws IllegalStateException { 
String [ ] args = buildArgs ( ) ; 
if ( think ) { 
result = Cowsay . think ( args ) ; 
result = Cowsay . say ( args ) ; 
public void execute ( ) throws BuildException { 
String moo = executor . execute ( ) ; 
if ( this . property != null && this . property . length ( ) > 0 ) { 
getProject ( ) . setProperty ( this . property , moo ) ; 
System . out . println ( moo ) ; 
throw new BuildException ( ex . getMessage ( ) , ex ) ; 
} public static void setLanguage ( final String language ) { 
currentLocale = new Locale ( language ) ; 
messages = ResourceBundle . getBundle ( "MessagesBundle" , currentLocale ) ; 
} protected static String getMessage ( final String key ) { 
if ( messages == null ) { 
setLanguage ( DEFAULT_LANG ) ; 
return messages . getString ( key ) ; 
} private static String sayOrThink ( final String [ ] args , final boolean think ) { 
boolean isThought = think ; 
String wordwrap = null ; 
CommandLine commandLine = CowsayCli . parseCmdArgs ( args ) ; 
if ( commandLine != null ) { 
if ( commandLine . hasOption ( CowsayCli . Opt . HELP . toString ( ) ) ) { 
CowsayCli . showCmdLineHelp ( ) ; 
else if ( commandLine . hasOption ( CowsayCli . Opt . LIST_COWS . toString ( ) ) ) { 
String [ ] files = Cowloader . listAllCowfiles ( ) ; 
return StringUtils . join ( files , System . getProperty ( "line.separator" ) ) ; 
String cowfileSpec = null ; 
CowFace cowFace = null ; 
if ( commandLine . hasOption ( CowsayCli . Opt . WRAP_AT . toString ( ) ) ) { 
wordwrap = commandLine . getOptionValue ( CowsayCli . Opt . WRAP_AT . toString ( ) ) ; 
else if ( commandLine . hasOption ( CowsayCli . Opt . NOWRAP . toString ( ) ) ) { 
wordwrap = "0" ; 
cowFace = getCowFaceByMode ( commandLine ) ; 
if ( cowFace == null ) { 
if ( commandLine . hasOption ( CowsayCli . Opt . COWFILE . toString ( ) ) ) { 
cowfileSpec = commandLine . getOptionValue ( CowsayCli . Opt . COWFILE . toString ( ) ) ; 
cowFace = getCowFace ( commandLine ) ; 
if ( commandLine . hasOption ( CowsayCli . Opt . THINK . toString ( ) ) ) { 
isThought = true ; 
if ( cowfileSpec == null ) { 
cowfileSpec = Cowloader . DEFAULT_COW ; 
String cowTemplate = Cowloader . load ( cowfileSpec ) ; 
if ( cowTemplate != null ) { 
String moosages [ ] = commandLine . getArgs ( ) ; 
if ( moosage != null && moosage . length ( ) > 0 ) { 
Message message = new Message ( moosage , isThought ) ; 
if ( wordwrap != null ) { 
message . setWordwrap ( wordwrap ) ; 
String cow = CowFormatter . formatCow ( cowTemplate , cowFace , message ) ; 
cow = formatHtml ( commandLine , cow , moosage , isThought ) ; 
return cow ; 
catch ( CowParseException ex ) { 
Logger . getLogger ( Cowsay . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; 
} private static String formatHtml ( final CommandLine commandLine , final String plainCow , final String moosage , 
final boolean isThought ) { 
String cow = plainCow ; 
if ( commandLine . hasOption ( CowsayCli . Opt . HTML . toString ( ) ) ) { 
cow = StringEscapeUtils . escapeHtml4 ( cow ) ; 
String alt ; 
if ( commandLine . hasOption ( CowsayCli . Opt . ALT . toString ( ) ) ) { 
alt = commandLine . getOptionValue ( CowsayCli . Opt . ALT . toString ( ) ) ; 
alt = isThought ? I18n . getMessage ( "altthink" ) : I18n . getMessage ( "altsay" ) ; 
String escaped = StringEscapeUtils . escapeHtml4 ( moosage ) ; 
cow += String . format ( alt , escaped ) ; 
cow += "</figcaption></figure>" ; 
} private static CowFace getCowFaceByMode ( final CommandLine commandLine ) { 
Set < String > modes = CowFace . COW_MODES . keySet ( ) ; 
for ( String mode : modes ) { 
if ( commandLine . hasOption ( mode ) ) { 
cowFace = CowFace . getByMode ( mode ) ; 
return cowFace ; 
} private static CowFace getCowFace ( final CommandLine commandLine ) { 
CowFace cowFace ; 
cowFace = new CowFace ( ) ; 
if ( commandLine . hasOption ( CowsayCli . Opt . EYES . toString ( ) ) ) { 
cowFace . setEyes ( commandLine . getOptionValue ( CowsayCli . Opt . EYES . toString ( ) ) ) ; 
if ( commandLine . hasOption ( CowsayCli . Opt . TONGUE . toString ( ) ) ) { 
cowFace . setTongue ( commandLine . getOptionValue ( CowsayCli . Opt . TONGUE . toString ( ) ) ) ; 
CowsayCli . addCowthinkOption ( ) ; 
String cowsay = say ( args ) ; 
if ( cowsay != null && cowsay . length ( ) > 0 ) { 
System . out . println ( cowsay ) ; 
} private static String extractCowTemplate ( final String cow ) throws CowParseException { 
Matcher matcher = COWSTART_RE . matcher ( cow ) ; 
if ( matcher . find ( 0 ) ) { 
String result = matcher . replaceFirst ( "" ) ; 
} public static String formatCow ( final String cow , final CowFace face , final Message message ) throws CowParseException { 
String result = extractCowTemplate ( cow ) ; 
String tongue = face . getTongue ( ) ; 
String eyes = face . getEyes ( ) ; 
result = result . replaceAll ( "\\\\\\\\" , "\\\\" ) ; 
result = result . replace ( "\\@" , "@" ) ; 
result = result . replace ( "\\$" , "$" ) ; 
result = result . replace ( "${tongue}" , tongue ) ; 
result = result . replace ( "$tongue" , tongue ) ; 
result = result . replace ( "$thoughts" , message . getThoughts ( ) ) ; 
result = result . replace ( "${eyes}" , eyes ) ; 
result = result . replace ( "$eyes" , eyes ) ; 
result = result . replaceAll ( "EOC\\s*$" , "" ) ; 
result = message . getMessage ( ) + result ; 
} public static String load ( final String cowfileSpec ) { 
String effectiveCowfileSpec = ( cowfileSpec != null ) ? cowfileSpec . trim ( ) : DEFAULT_COW ; 
if ( effectiveCowfileSpec . length ( ) > 0 ) { 
if ( ! effectiveCowfileSpec . endsWith ( COWFILE_EXT ) ) { 
effectiveCowfileSpec += COWFILE_EXT ; 
InputStream cowInputStream ; 
if ( effectiveCowfileSpec . indexOf ( File . separatorChar ) >= 0 ) { 
cowInputStream = getCowFromPath ( effectiveCowfileSpec ) ; 
cowInputStream = getCowFromCowPath ( effectiveCowfileSpec ) ; 
if ( cowInputStream == null ) { 
cowInputStream = getCowFromResources ( DEFAULT_COW + COWFILE_EXT ) ; 
if ( cowInputStream != null ) { 
String cow = cowInputStreamToString ( cowInputStream ) ; 
} private static String cowInputStreamToString ( final InputStream cowInputStream ) { 
BufferedReader reader = new BufferedReader ( new InputStreamReader ( cowInputStream ) ) ; 
String newLine = System . getProperty ( "line.separator" ) ; 
sb . append ( line ) ; 
sb . append ( newLine ) ; 
Logger . getLogger ( Cowloader . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; 
cowInputStream . close ( ) ; 
} private static InputStream getCowFromPath ( final String path ) { 
String cwd = System . getProperty ( "user.dir" ) ; 
if ( cwd != null ) { 
File cowfile = new File ( cwd , path ) ; 
if ( isCowfile ( cowfile ) ) { 
return cowfileToCowInputStream ( cowfile ) ; 
File cowfile = new File ( path ) ; 
} private static InputStream getCowFromCowPath ( final String cowName ) { 
String cowPath = System . getenv ( "COWPATH" ) ; 
if ( cowPath != null ) { 
String [ ] paths = cowPath . split ( File . pathSeparator ) ; 
File cowfile = getCowfile ( path , cowName ) ; 
return getCowFromResources ( cowName ) ; 
} public static String [ ] listAllCowfiles ( ) { 
String [ ] resultAsArray ; 
String [ ] bundled = null ; 
String cowfileExtRe = "\\" + COWFILE_EXT + "$" ; 
InputStream bundleStream = Cowloader . class . getResourceAsStream ( "/cowfile-list.csv" ) ; 
if ( bundleStream != null ) { 
BufferedReader reader = new BufferedReader ( new InputStreamReader ( bundleStream ) ) ; 
String bundleList = sb . toString ( ) ; 
bundled = bundleList . split ( "," ) ; 
Logger . getLogger ( Cowloader . class . getName ( ) ) . log ( Level . WARNING , null , ex ) ; 
bundleStream . close ( ) ; 
if ( bundled != null ) { 
for ( String cowfile : bundled ) { 
if ( cowfile . endsWith ( COWFILE_EXT ) ) { 
result . add ( cowfile . replaceAll ( cowfileExtRe , "" ) ) ; 
File [ ] cowfiles = getCowFiles ( path ) ; 
if ( cowfiles != null ) { 
for ( File cowfile : cowfiles ) { 
result . add ( cowfile . getName ( ) . replaceAll ( cowfileExtRe , "" ) ) ; 
resultAsArray = result . toArray ( new String [ result . size ( ) ] ) ; 
Arrays . sort ( resultAsArray ) ; 
return resultAsArray ; 
} private static boolean isCowfile ( final File cowfile ) { 
if ( cowfile != null && cowfile . exists ( ) ) { 
return cowfile . getName ( ) . endsWith ( COWFILE_EXT ) ; 
} private static InputStream cowfileToCowInputStream ( final File cowfile ) { 
InputStream cowInputStream = null ; 
cowInputStream = new FileInputStream ( cowfile ) ; 
} catch ( FileNotFoundException ex ) { 
return cowInputStream ; 
} private static File getCowfile ( final String folder , final String cowName ) { 
File [ ] cowfiles = getCowFiles ( folder ) ; 
if ( cowfile . getName ( ) . equals ( cowName ) ) { 
return cowfile ; 
} private static File [ ] getCowFiles ( final String folder ) { 
File dir = new File ( folder ) ; 
File [ ] files ; 
files = dir . listFiles ( new FilenameFilter ( ) { 
public boolean accept ( final File dir , final String name ) { 
return name . endsWith ( ".cow" ) ; 
} protected static CowFace getByMode ( final String mode ) { 
return COW_MODES . get ( mode ) ; 
} public final void setEyes ( final String eyes ) { 
if ( eyes != null && eyes . length ( ) > 0 ) { 
if ( eyes . length ( ) > 2 ) { 
this . eyes = eyes . substring ( 0 , 2 ) ; 
this . eyes = eyes ; 
} public final void setTongue ( final String tongue ) { 
if ( tongue != null && tongue . length ( ) > 0 ) { 
if ( tongue . length ( ) > 2 ) { 
this . tongue = tongue . substring ( 0 , 2 ) ; 
this . tongue = tongue ; 
} public static final boolean isKnownMode ( final String mode ) { 
Set < String > modes = COW_MODES . keySet ( ) ; 
return modes . contains ( mode ) ; 
} protected static void addCowthinkOption ( ) { 
if ( ! options . hasOption ( null ) ) { 
options . addOption ( null , Opt . THINK . text , false , "" ) ; 
} public static CommandLine parseCmdArgs ( final String [ ] argv ) { 
final CommandLineParser cmdLineParser = new DefaultParser ( ) ; 
CommandLine parsed = cmdLineParser . parse ( options , argv , true ) ; 
if ( parsed . hasOption ( Opt . LANG . text ) ) { 
String language = parsed . getOptionValue ( Opt . LANG . text ) ; 
I18n . setLanguage ( language ) ; 
catch ( MissingArgumentException ex ) { 
Option option = ex . getOption ( ) ; 
String flag = option . getOpt ( ) ; 
flag = option . getLongOpt ( ) ; 
Logger . getLogger ( CowsayCli . class . getName ( ) ) . log ( Level . INFO , I18n . getMessage ( "missingarg" ) , flag ) ; 
catch ( ParseException ex ) { 
Logger . getLogger ( CowsayCli . class . getName ( ) ) . log ( Level . FINEST , null , ex ) ; 
} private static void updateOptionDescriptions ( ) { 
Collection < Option > allOptions = options . getOptions ( ) ; 
for ( Option option : allOptions ) { 
String key = option . getOpt ( ) ; 
key = option . getLongOpt ( ) ; 
String description = I18n . getMessage ( key ) ; 
if ( description != null ) { 
if ( key . equals ( Opt . COWFILE . text ) ) { 
description = String . format ( description , File . separatorChar ) ; 
option . setDescription ( description ) ; 
} public static void showCmdLineHelp ( ) { 
HelpFormatter formatter = new HelpFormatter ( ) ; 
updateOptionDescriptions ( ) ; 
formatter . printHelp ( I18n . getMessage ( "usage" ) , options ) ; 
} private static String formatBubble ( final BubbleWrap bubble , final String message , final int longestLine ) { 
String [ ] lines = message . split ( newLine ) ; 
sb . append ( bubble . buildTop ( longestLine ) ) ; 
if ( lines . length > 1 ) { 
sb . append ( bubble . formatMultiOpen ( lines [ 0 ] , longestLine ) ) ; 
for ( int i = 1 ; i < ( lines . length - 1 ) ; i ++ ) { 
sb . append ( bubble . formatMultiMid ( lines [ i ] , longestLine ) ) ; 
sb . append ( bubble . formatMultiEnd ( lines [ ( lines . length - 1 ) ] , longestLine ) ) ; 
sb . append ( bubble . formatSingle ( lines [ 0 ] ) ) ; 
sb . append ( bubble . buildBottom ( longestLine ) ) ; 
} private String wrapMessage ( final String message ) { 
int wrap = getWordwrap ( ) ; 
if ( wrap <= 0 ) { 
final List < String > result = new ArrayList < String > ( ) ; 
result . add ( WordUtils . wrap ( line , wrap , null , true ) ) ; 
return StringUtils . join ( result , newLine ) ; 
} private String formatMessage ( final String message ) { 
if ( message != null ) { 
result = wrapMessage ( message ) ; 
int longestLine = getLongestLineLen ( result ) ; 
if ( ! isThought ) { 
result = Bubble . formatSpeech ( result , longestLine ) ; 
result = Bubble . formatThought ( result , longestLine ) ; 
} public void setWordwrap ( final String wordwrap ) { 
int ww = Integer . parseInt ( wordwrap ) ; 
if ( ww >= 0 ) { 
this . wordwrap = ww ; 
} catch ( Throwable ignore ) { 
} private static int getLongestLineLen ( final String message ) { 
int maxLen = 0 ; 
maxLen = Math . max ( maxLen , line . length ( ) ) ; 
return maxLen ; 
} public void setTags ( String ... tags ) { 
for ( String s : tags ) { 
for ( String t : s . split ( "," ) ) { 
t = t . trim ( ) ; 
if ( ! t . isEmpty ( ) ) { 
builder . append ( "," ) ; 
builder . append ( t ) ; 
this . tags = builder . length ( ) > 0 ? builder . toString ( ) : null ; 
} public boolean log ( String message ) { 
if ( message == null ) return false ; 
ok = loggly . log ( token , tags , message ) . isExecuted ( ) ; 
} public void log ( String message , final Callback callback ) { 
if ( message == null ) return ; 
loggly . log ( token , 
tags , 
message , 
new retrofit2 . Callback < LogglyResponse > ( ) { 
public void onResponse ( Call < LogglyResponse > call , Response < LogglyResponse > response ) { 
callback . success ( ) ; 
public void onFailure ( Call < LogglyResponse > call , Throwable throwable ) { 
callback . failure ( throwable . getMessage ( ) ) ; 
} public boolean logBulk ( String ... messages ) { 
if ( messages == null ) return false ; 
return logBulk ( Arrays . asList ( messages ) ) ; 
} public boolean logBulk ( Collection < String > messages ) { 
String parcel = joinStrings ( messages ) ; 
if ( parcel . isEmpty ( ) ) return false ; 
ok = loggly . logBulk ( token , tags , parcel ) . isExecuted ( ) ; 
} public void logBulk ( Collection < String > messages , final Callback callback ) { 
if ( messages == null ) return ; 
if ( parcel . isEmpty ( ) ) return ; 
loggly . logBulk ( token , 
parcel , 
} private String joinStrings ( Collection < String > messages ) { 
for ( String s : messages ) { 
if ( s == null || s . isEmpty ( ) ) { 
b . append ( s . replaceAll ( "[\r\n]" , "\r" ) ) . append ( '\n' ) ; 
} public static void main ( String ... args ) { 
if ( args . length == 0 || args [ 0 ] . trim ( ) . isEmpty ( ) ) { 
final String TOKEN = args [ 0 ] ; 
final ILogglyClient loggly = new LogglyClient ( TOKEN ) ; 
new LogglyClient . Callback ( ) { 
public void success ( ) { 
public void failure ( String error ) { 
loggly . logBulk ( Arrays . asList ( "E1" , "E2" ) , 
System . out . println ( ok ? "ok" : "err" ) ; 
ok = loggly . log ( json ) ; 
loggly . setTags ( "foo" , "bar,baz" ) ; 
} public SortedMap < String , Schema > getSchemas ( ) throws SQLException { 
synchronized ( getSchemasLock ) { 
if ( getSchemasCache == null ) { 
SortedMap < String , Schema > newSchemas = new TreeMap < > ( DatabaseMetaData . getCollator ( ) ) ; 
try ( ResultSet results = metaData . getMetaData ( ) . getSchemas ( ) ) { 
ResultSetMetaData resultsMeta = results . getMetaData ( ) ; 
while ( results . next ( ) ) { 
int colCount = resultsMeta . getColumnCount ( ) ; 
colCount == 1 
|| results . getString ( "TABLE_CATALOG" ) == null 
|| name . equals ( results . getString ( "TABLE_CATALOG" ) ) 
Schema newSchema = new Schema ( this , results . getString ( "TABLE_SCHEM" ) ) ; 
getSchemasCache = AoCollections . optimalUnmodifiableSortedMap ( newSchemas ) ; 
return getSchemasCache ; 
} public Schema getSchema ( String name ) throws NoRowException , SQLException { 
Schema schema = getSchemas ( ) . get ( name ) ; 
if ( schema == null ) throw new NoRowException ( "name=" + name ) ; 
return schema ; 
} public SymmetricGraph < Table , Edge < Table > , SQLException > getForeignKeyGraph ( final Set < String > tableTypes ) { 
return new SymmetricGraph < Table , Edge < Table > , SQLException > ( ) { 
public Set < Table > getVertices ( ) throws SQLException { 
Set < Table > vertices = new LinkedHashSet < > ( ) ; 
for ( Schema schema : getSchemas ( ) . values ( ) ) { 
for ( Table table : schema . getTables ( ) . values ( ) ) { 
if ( tableTypes == null || tableTypes . contains ( table . getTableType ( ) ) ) vertices . add ( table ) ; 
return AoCollections . optimalUnmodifiableSet ( vertices ) ; 
public Set < Edge < Table > > getEdgesFrom ( Table from ) throws SQLException { 
Set < ? extends Table > tos = from . getImportedTables ( ) ; 
Set < Edge < Table > > edges = new LinkedHashSet < > ( tos . size ( ) * 4 / 3 + 1 ) ; 
for ( Table to : tos ) { 
tableTypes == null 
|| tableTypes . contains ( from . getTableType ( ) ) 
|| tableTypes . contains ( to . getTableType ( ) ) 
) edges . add ( new Edge < > ( from , to ) ) ; 
return AoCollections . optimalUnmodifiableSet ( edges ) ; 
public Set < Edge < Table > > getEdgesTo ( Table to ) throws SQLException { 
Set < ? extends Table > froms = to . getExportedTables ( ) ; 
Set < Edge < Table > > edges = new LinkedHashSet < > ( froms . size ( ) * 4 / 3 + 1 ) ; 
for ( Table from : froms ) { 
public void contextInitialized ( ServletContextEvent sce ) { 
ServletContext sc ; 
synchronized ( servletContextLock ) { 
servletContext = sce . getServletContext ( ) ; 
sc = servletContext ; 
String gitToplevelPath = sc . getInitParameter ( GIT_TOPLEVEL_CONTEXT_PARAM ) ; 
File gitToplevelRaw ; 
if ( gitToplevelPath == null || gitToplevelPath . isEmpty ( ) ) { 
String rootRealPath = sc . getRealPath ( "/" ) ; 
gitToplevelRaw = new File ( rootRealPath ) ; 
if ( gitToplevelPath . startsWith ( "~/" ) ) { 
gitToplevelRaw = new File ( System . getProperty ( "user.home" ) , gitToplevelPath . substring ( 2 ) ) ; 
gitToplevelRaw = new File ( gitToplevelPath ) ; 
Path gtl ; 
synchronized ( gitToplevelLock ) { 
gitToplevel = gitToplevelRaw . getCanonicalFile ( ) . toPath ( ) ; 
gtl = gitToplevel ; 
WatchService w ; 
synchronized ( watcherLock ) { 
watcher = gtl . getFileSystem ( ) . newWatchService ( ) ; 
w = watcher ; 
resync ( ) ; 
synchronized ( watcherThreadLock ) { 
watcherThread = new Thread ( watcherRunnable ) ; 
watcherThread . start ( ) ; 
synchronized ( changedThreadLock ) { 
changedThread = new Thread ( changedRunnable ) ; 
changedThread . start ( ) ; 
sc . setAttribute ( APPLICATION_SCOPE_KEY , this ) ; 
throw new WrappedException ( e ) ; 
} private void resync ( ) throws IOException { 
if ( gtl != null && w != null ) { 
synchronized ( registered ) { 
Set < Path > extraKeys = new HashSet < > ( registered . keySet ( ) ) ; 
resync ( w , gtl , extraKeys ) ; 
for ( Path extraKey : extraKeys ) { 
registered . remove ( extraKey ) . cancel ( ) ; 
} private void updateGitStatus ( ) throws IOException , ParseException { 
GitStatus newStatus ; 
if ( gtl == null ) { 
List < UncommittedChange > emptyList = Collections . emptyList ( ) ; 
newStatus = new GitStatus ( now , State . DISABLED , emptyList ) ; 
List < String > modules ; 
ProcessBuilder pb = 
. directory ( gtl . toFile ( ) ) 
Process p = pb . start ( ) ; 
ProcessResult result = ProcessResult . getProcessResult ( p ) ; 
List < String > submodules = StringUtility . splitLines ( result . getStdout ( ) ) ; 
modules = new ArrayList < > ( submodules . size ( ) + 1 ) ; 
modules . addAll ( submodules ) ; 
modules . add ( "" ) ; 
State state = State . SYNCHRONIZED ; 
List < UncommittedChange > uncommittedChanges = new ArrayList < > ( ) ; 
for ( String module : modules ) { 
File workingDir ; 
if ( module . isEmpty ( ) ) { 
workingDir = gtl . toFile ( ) ; 
workingDir = new File ( gtl . toFile ( ) , module ) ; 
new ProcessBuilder ( "git" , "status" , "--porcelain" , "-z" ) 
. directory ( workingDir ) 
List < String > split = new ArrayList < > ( StringUtility . splitString ( result . getStdout ( ) , ( char ) 0 ) ) ; 
if ( ! split . isEmpty ( ) ) { 
String last = split . remove ( split . size ( ) - 1 ) ; 
while ( i < split . size ( ) ) { 
char x ; 
char y ; 
String from ; 
String to ; 
String first = split . get ( i ++ ) ; 
x = first . charAt ( 0 ) ; 
y = first . charAt ( 1 ) ; 
if ( x == 'R' ) { 
to = first . substring ( 3 ) ; 
from = split . get ( i ++ ) ; 
to = null ; 
from = first . substring ( 3 ) ; 
UncommittedChange uncommittedChange = new UncommittedChange ( x , y , module , from , to ) ; 
uncommittedChanges . add ( uncommittedChange ) ; 
State meaningState = uncommittedChange . getMeaning ( ) . getState ( ) ; 
if ( meaningState . compareTo ( state ) > 0 ) state = meaningState ; 
newStatus = new GitStatus ( now , state , Collections . unmodifiableList ( uncommittedChanges ) ) ; 
synchronized ( statusLock ) { 
status = newStatus ; 
public GitStatus getGitStatus ( ) { 
long statusTime = status . getStatusTime ( ) ; 
long millisSince = now - statusTime ; 
millisSince >= TIMEOUT_MILLIS 
|| millisSince <= - TIMEOUT_MILLIS 
return new GitStatus ( statusTime , State . TIMEOUT , emptyList ) ; 
public static AutoGitContextListener getInstance ( ServletContext sc ) { 
return ( AutoGitContextListener ) sc . getAttribute ( APPLICATION_SCOPE_KEY ) ; 
private static final String GIT_STATUS_REQUEST_CACHE_KEY = AutoGitContextListener . class . getName ( ) + ".getGitStatus.cache" ; 
public static GitStatus getGitStatus ( 
ServletRequest request 
GitStatus gitStatus = ( GitStatus ) request . getAttribute ( GIT_STATUS_REQUEST_CACHE_KEY ) ; 
if ( gitStatus == null ) { 
AutoGitContextListener gitContext = AutoGitContextListener . getInstance ( servletContext ) ; 
if ( gitContext == null ) { 
gitStatus = new GitStatus ( System . currentTimeMillis ( ) , State . DISABLED , emptyList ) ; 
gitStatus = gitContext . getGitStatus ( ) ; 
request . setAttribute ( GIT_STATUS_REQUEST_CACHE_KEY , gitStatus ) ; 
return gitStatus ; 
} public SortedMap < String , Table > getTables ( ) throws SQLException { 
synchronized ( getTablesLock ) { 
if ( getTablesCache == null ) { 
SortedMap < String , Table > newTables = new TreeMap < > ( DatabaseMetaData . getCollator ( ) ) ; 
try ( ResultSet results = catalog . getMetaData ( ) . getMetaData ( ) . getTables ( catalog . getName ( ) , name , null , null ) ) { 
Table newTable = new Table ( this , results . getString ( "TABLE_NAME" ) , results . getString ( "TABLE_TYPE" ) ) ; 
getTablesCache = AoCollections . optimalUnmodifiableSortedMap ( newTables ) ; 
return getTablesCache ; 
} public Table getTable ( String name ) throws NoRowException , SQLException { 
Table table = getTables ( ) . get ( name ) ; 
if ( table == null ) throw new NoRowException ( ) ; 
return table ; 
private static String getRow ( ResultSet result ) throws SQLException { 
sb . append ( '(' ) ; 
ResultSetMetaData metaData = result . getMetaData ( ) ; 
int colCount = metaData . getColumnCount ( ) ; 
for ( int c = 1 ; c <= colCount ; c ++ ) { 
int colType = metaData . getColumnType ( c ) ; 
switch ( colType ) { 
case Types . BIGINT : 
case Types . BIT : 
case Types . BOOLEAN : 
case Types . DECIMAL : 
case Types . DOUBLE : 
case Types . FLOAT : 
case Types . INTEGER : 
case Types . NUMERIC : 
case Types . REAL : 
case Types . SMALLINT : 
case Types . TINYINT : 
sb . append ( result . getObject ( c ) ) ; 
case Types . CHAR : 
case Types . DATE : 
case Types . LONGNVARCHAR : 
case Types . LONGVARCHAR : 
case Types . NCHAR : 
case Types . NVARCHAR : 
case Types . TIME : 
case Types . TIMESTAMP : 
case Types . VARCHAR : 
SQLUtility . escapeSQL ( result . getString ( c ) , sb ) ; 
sb . append ( ')' ) ; 
} private void writeToImpl ( Writer out , long writeStart , long writeEnd ) throws IOException { 
RandomAccessFile raf = new RandomAccessFile ( tempFile . getFile ( ) , "r" ) ) { 
byte [ ] bytes = BufferManager . getBytes ( ) ; 
char [ ] chars = BufferManager . getChars ( ) ; 
long index = writeStart ; 
raf . seek ( index << 1 ) ; 
while ( index < writeEnd ) { 
long blockSizeLong = ( writeEnd - index ) << 1 ; 
int blockSize = blockSizeLong > BufferManager . BUFFER_SIZE ? BufferManager . BUFFER_SIZE : ( int ) blockSizeLong ; 
raf . readFully ( bytes , 0 , blockSize ) ; 
int bpos = 0 , cpos = 0 ; 
bpos < blockSize ; 
bpos += 2 , cpos ++ 
chars [ cpos ] = IoUtils . bufferToChar ( bytes , bpos ) ; 
out . write ( chars , 0 , blockSize > > 1 ) ; 
index += blockSize > > 1 ; 
BufferManager . release ( chars , false ) ; 
BufferManager . release ( bytes , false ) ; 
} public SortedMap < String , Catalog > getCatalogs ( ) throws SQLException { 
synchronized ( getCatalogsLock ) { 
if ( getCatalogsCache == null ) { 
SortedMap < String , Catalog > newCatalogs = new TreeMap < > ( englishCollator ) ; 
try ( ResultSet results = metaData . getCatalogs ( ) ) { 
Catalog newCatalog = new Catalog ( this , results . getString ( 1 ) ) ; 
getCatalogsCache = AoCollections . optimalUnmodifiableSortedMap ( newCatalogs ) ; 
return getCatalogsCache ; 
} public Catalog getCatalog ( String name ) throws NoRowException , SQLException { 
Catalog catalog = getCatalogs ( ) . get ( name ) ; 
if ( catalog == null ) throw new NoRowException ( ) ; 
} private char [ ] getBuffer ( int additional ) throws IOException { 
long newLen = ( long ) length + additional ; 
char [ ] buf = this . buffer ; 
int bufLen = buf . length ; 
if ( newLen > bufLen ) { 
int newBufLen = bufLen == 0 ? BufferManager . BUFFER_SIZE : ( bufLen << 1 ) ; 
while ( newBufLen < newLen ) { 
newBufLen <<= 1 ; 
char [ ] newBuf = 
( newBufLen == BufferManager . BUFFER_SIZE ) 
? BufferManager . getChars ( ) 
: new char [ newBufLen ] ; 
System . arraycopy ( buf , 0 , newBuf , 0 , length ) ; 
if ( bufLen == BufferManager . BUFFER_SIZE ) { 
BufferManager . release ( buf , false ) ; 
buf = newBuf ; 
this . buffer = buf ; 
} private void log ( Encoder encoder ) throws IOException { 
if ( encoder == null ) log . write ( "null" ) ; 
String className = encoder . getClass ( ) . getName ( ) ; 
if ( "com.aoindustries.encoding.JavaScriptInXhtmlAttributeEncoder" . equals ( className ) ) { 
log . write ( "javaScriptInXhtmlAttributeEncoder" ) ; 
} else if ( "com.aoindustries.encoding.JavaScriptInXhtmlEncoder" . equals ( className ) ) { 
log . write ( "javaScriptInXhtmlEncoder" ) ; 
} else if ( "com.aoindustries.encoding.TextInXhtmlAttributeEncoder" . equals ( className ) ) { 
log . write ( "textInXhtmlAttributeEncoder" ) ; 
log . write ( className ) ; 
} private void log ( Writer writer ) throws IOException { 
log . write ( "null" ) ; 
} else if ( writer instanceof LoggingWriter ) { 
LoggingWriter loggingWriter = ( LoggingWriter ) writer ; 
log . write ( "writer[" ) ; 
log . write ( Long . toString ( loggingWriter . getId ( ) ) ) ; 
log . write ( ']' ) ; 
} else if ( writer instanceof EncoderWriter ) { 
EncoderWriter encoderWriter = ( EncoderWriter ) writer ; 
log ( encoderWriter . getEncoder ( ) ) ; 
log ( encoderWriter . getOut ( ) ) ; 
log . write ( ')' ) ; 
String classname = writer . getClass ( ) . getName ( ) ; 
if ( classname . equals ( "org.apache.jasper.runtime.BodyContentImpl" ) ) log . write ( "bodyContent" ) ; 
else if ( classname . equals ( "org.apache.jasper.runtime.JspWriterImpl" ) ) log . write ( "jspWriter" ) ; 
else log . write ( classname ) ; 
} public static < F > LexicalPosition < F > zeroWithFile ( 
final F file ) 
return LexicalPosition . of ( 0 , 0 , Optional . of ( file ) ) ; 
} private void append ( int segmentIndex , StringBuilder buffer ) { 
switch ( segmentTypes [ segmentIndex ] ) { 
case SegmentedWriter . TYPE_STRING : 
int off = segmentOffsets [ segmentIndex ] ; 
buffer . append ( 
( String ) segmentValues [ segmentIndex ] , 
off , 
off + segmentLengths [ segmentIndex ] 
case SegmentedWriter . TYPE_CHAR_NEWLINE : 
assert segmentOffsets [ segmentIndex ] == 0 ; 
assert segmentLengths [ segmentIndex ] == 1 ; 
buffer . append ( '\n' ) ; 
case SegmentedWriter . TYPE_CHAR_QUOTE : 
buffer . append ( '"' ) ; 
case SegmentedWriter . TYPE_CHAR_APOS : 
buffer . append ( '\'' ) ; 
case SegmentedWriter . TYPE_CHAR_OTHER : 
buffer . append ( ( ( Character ) segmentValues [ segmentIndex ] ) . charValue ( ) ) ; 
throw new AssertionError ( ) ; 
} private void append ( int segmentIndex , int off , int len , StringBuilder buffer ) { 
off + len 
assert off == 0 ; 
assert len == 1 ; 
} private void writeSegment ( int segmentIndex , Encoder encoder , Writer out ) throws IOException { 
encoder . write ( 
segmentOffsets [ segmentIndex ] , 
segmentLengths [ segmentIndex ] , 
out 
encoder . write ( '\n' , out ) ; 
encoder . write ( '"' , out ) ; 
encoder . write ( '\'' , out ) ; 
encoder . write ( ( Character ) segmentValues [ segmentIndex ] , out ) ; 
} private void writeSegment ( int segmentIndex , int off , int len , Encoder encoder , Writer out ) throws IOException { 
len , 
} private static char charAt ( byte type , Object value , int charIndex ) { 
return ( ( String ) value ) . charAt ( charIndex ) ; 
assert charIndex == 0 ; 
return '\n' ; 
return '"' ; 
return '\'' ; 
return ( Character ) value ; 
} private Map < String , Class < ? > > getSqlDataTypes ( ) throws SQLException { 
if ( sqlDataTypes == null ) { 
Map < String , Class < ? > > newMap = new LinkedHashMap < > ( ) ; 
Iterator < SQLData > iter = ServiceLoader . load ( SQLData . class ) . iterator ( ) ; 
SQLData sqlData = iter . next ( ) ; 
newMap . put ( sqlData . getSQLTypeName ( ) , sqlData . getClass ( ) ) ; 
sqlDataTypes = newMap ; 
return sqlDataTypes ; 
} public void executeTransaction ( final DatabaseRunnable runnable ) throws SQLException { 
executeTransaction ( 
RuntimeException . class , 
new DatabaseCallableE < Void , RuntimeException > ( ) { 
public Void call ( DatabaseConnection db ) throws SQLException { 
runnable . run ( db ) ; 
} public < E extends Exception > void executeTransaction ( 
Class < E > eClass , 
final DatabaseRunnableE < E > runnable 
) throws SQLException , E { 
eClass , 
new DatabaseCallableE < Void , E > ( ) { 
public Void call ( DatabaseConnection db ) throws SQLException , E { 
} public < V > V executeTransaction ( final DatabaseCallable < V > callable ) throws SQLException { 
return executeTransaction ( 
new DatabaseCallableE < V , RuntimeException > ( ) { 
public V call ( DatabaseConnection db ) throws SQLException { 
return callable . call ( db ) ; 
} public < V , E extends Exception > V executeTransaction ( 
DatabaseCallableE < V , E > callable 
DatabaseConnection conn = transactionConnection . get ( ) ; 
return callable . call ( conn ) ; 
} catch ( RuntimeException err ) { 
conn . rollback ( ) ; 
throw err ; 
} catch ( NoRowException err ) { 
} catch ( SQLException err ) { 
conn . rollbackAndClose ( ) ; 
if ( eClass . isInstance ( e ) ) throw eClass . cast ( e ) ; 
throw new SQLException ( e ) ; 
conn = createDatabaseConnection ( ) ; 
transactionConnection . set ( conn ) ; 
V result = callable . call ( conn ) ; 
conn . commit ( ) ; 
transactionConnection . remove ( ) ; 
} catch ( RuntimeException | NoRowException err ) { 
conn . releaseConnection ( ) ; 
} public static Method getValueOfIntMethod ( Class < ? > clazz ) { 
Method existing = valueOfIntMethods . get ( clazz ) ; 
Method newMethod ; 
newMethod = clazz . getMethod ( "valueOf" , Integer . TYPE ) ; 
int mod = newMethod . getModifiers ( ) ; 
if ( ! Modifier . isStatic ( mod ) || ! Modifier . isPublic ( mod ) ) newMethod = notExists ; 
} catch ( NoSuchMethodException err ) { 
newMethod = notExists ; 
existing = valueOfIntMethods . put ( clazz , newMethod ) ; 
if ( existing == null ) existing = newMethod ; 
return existing == notExists ? null : existing ; 
} public static Method getValueOfStringMethod ( Class < ? > clazz ) { 
Method existing = valueOfStringMethods . get ( clazz ) ; 
newMethod = clazz . getMethod ( "valueOf" , String . class ) ; 
existing = valueOfStringMethods . put ( clazz , newMethod ) ; 
public T createObject ( ResultSet result ) throws SQLException { 
int numColumns = metaData . getColumnCount ( ) ; 
int numParams = prefixParams . length + numColumns ; 
Object [ ] params = new Object [ numParams ] ; 
List < String > warnings = null ; 
Constructor < ? > [ ] constructors = clazz . getConstructors ( ) ; 
CONSTRUCTORS : 
for ( Constructor < ? > constructor : constructors ) { 
Class < ? > [ ] paramTypes = constructor . getParameterTypes ( ) ; 
if ( paramTypes . length == numParams ) { 
for ( int i = 0 ; i < prefixParams . length ; i ++ ) { 
Class < ? > paramType = paramTypes [ i ] ; 
if ( ! paramType . isAssignableFrom ( prefixParams [ i ] . getClass ( ) ) ) continue CONSTRUCTORS ; 
params [ i ] = prefixParams [ i ] ; 
for ( int c = 1 ; c <= numColumns ; c ++ ) { 
int i = prefixParams . length + c - 1 ; 
if ( paramType == String . class ) { 
params [ i ] = result . getString ( c ) ; 
} else if ( paramType == Integer . TYPE ) { 
int value = result . getInt ( c ) ; 
params [ i ] = value ; 
} else if ( paramType == Short . TYPE ) { 
short value = result . getShort ( c ) ; 
} else if ( paramType == Boolean . TYPE ) { 
boolean b = result . getBoolean ( c ) ; 
params [ i ] = b ; 
} else if ( paramType == Float . TYPE ) { 
float value = result . getFloat ( c ) ; 
} else if ( paramType == Long . TYPE ) { 
long value = result . getLong ( c ) ; 
} else if ( paramType == Date . class ) { 
params [ i ] = result . getDate ( c ) ; 
} else if ( paramType == Boolean . class ) { 
params [ i ] = result . wasNull ( ) ? null : b ; 
} else if ( paramType == Timestamp . class ) { 
params [ i ] = result . getTimestamp ( c ) ; 
} else if ( paramType == Integer . class ) { 
params [ i ] = result . wasNull ( ) ? null : value ; 
} else if ( paramType == Float . class ) { 
} else if ( paramType == Short . class ) { 
} else if ( paramType == Long . class ) { 
Method valueOfIntMethod = getValueOfIntMethod ( paramType ) ; 
if ( valueOfIntMethod != null ) { 
if ( result . wasNull ( ) ) params [ i ] = null ; 
params [ i ] = valueOfIntMethod . invoke ( null , value ) ; 
Method valueOfStringMethod = getValueOfStringMethod ( paramType ) ; 
if ( valueOfStringMethod != null ) { 
String value = result . getString ( c ) ; 
params [ i ] = result . wasNull ( ) ? null : valueOfStringMethod . invoke ( null , value ) ; 
if ( warnings == null ) warnings = new ArrayList < > ( ) ; 
continue CONSTRUCTORS ; 
Object newInstance = constructor . newInstance ( params ) ; 
return clazz . cast ( newInstance ) ; 
if ( warnings != null ) for ( String warning : warnings ) message . append ( EOL ) . append ( warning ) ; 
throw new SQLException ( message . toString ( ) ) ; 
} catch ( InstantiationException | IllegalAccessException | InvocationTargetException err ) { 
throw new SQLException ( err ) ; 
} public SortedMap < String , Column > getColumnMap ( ) throws SQLException { 
synchronized ( getColumnMapLock ) { 
if ( getColumnMapCache == null ) { 
SortedMap < String , Column > newColumnMap = new TreeMap < > ( DatabaseMetaData . getCollator ( ) ) ; 
try ( ResultSet results = schema . getCatalog ( ) . getMetaData ( ) . getMetaData ( ) . getColumns ( schema . getCatalog ( ) . getName ( ) , schema . getName ( ) , name , null ) ) { 
Column newColumn = new Column ( 
results . getString ( "COLUMN_NAME" ) , 
results . getInt ( "DATA_TYPE" ) , 
results . getString ( "TYPE_NAME" ) , 
getInteger ( results , "COLUMN_SIZE" ) , 
getInteger ( results , "DECIMAL_DIGITS" ) , 
results . getInt ( "NULLABLE" ) , 
results . getString ( "COLUMN_DEF" ) , 
getInteger ( results , "CHAR_OCTET_LENGTH" ) , 
results . getInt ( "ORDINAL_POSITION" ) , 
results . getString ( "IS_NULLABLE" ) , 
results . getString ( "IS_AUTOINCREMENT" ) 
getColumnMapCache = AoCollections . optimalUnmodifiableSortedMap ( newColumnMap ) ; 
return getColumnMapCache ; 
} public Column getColumn ( String name ) throws NoRowException , SQLException { 
Column column = getColumnMap ( ) . get ( name ) ; 
if ( column == null ) throw new NoRowException ( ) ; 
return column ; 
} public List < Column > getColumns ( ) throws SQLException { 
synchronized ( getColumnsLock ) { 
if ( getColumnsCache == null ) { 
SortedMap < String , Column > columnMap = getColumnMap ( ) ; 
List < Column > newColumns = new ArrayList < > ( columnMap . size ( ) ) ; 
for ( int i = 0 ; i < columnMap . size ( ) ; i ++ ) newColumns . add ( null ) ; 
for ( Column column : columnMap . values ( ) ) { 
int ordinalPosition = column . getOrdinalPosition ( ) ; 
for ( int i = 0 ; i < newColumns . size ( ) ; i ++ ) { 
getColumnsCache = AoCollections . optimalUnmodifiableList ( newColumns ) ; 
return getColumnsCache ; 
} public Column getColumn ( int ordinalPosition ) throws NoRowException , SQLException { 
return getColumns ( ) . get ( ordinalPosition - 1 ) ; 
} catch ( IndexOutOfBoundsException exc ) { 
throw new NoRowException ( exc ) ; 
} public Index getPrimaryKey ( ) throws SQLException { 
synchronized ( getPrimaryKeyLock ) { 
if ( ! getPrimaryKeyCached ) { 
String pkName = null ; 
List < Column > columns = new AutoGrowArrayList < > ( ) ; 
try ( ResultSet results = schema . getCatalog ( ) . getMetaData ( ) . getMetaData ( ) . getPrimaryKeys ( schema . getCatalog ( ) . getName ( ) , schema . getName ( ) , name ) ) { 
String columnName = results . getString ( "COLUMN_NAME" ) ; 
int keySeq = results . getInt ( "KEY_SEQ" ) ; 
String newPkName = results . getString ( "PK_NAME" ) ; 
if ( newPkName != null ) { 
if ( pkName == null ) pkName = newPkName ; 
if ( columns . isEmpty ( ) ) { 
getPrimaryKeyCache = null ; 
getPrimaryKeyCached = true ; 
for ( int i = 0 ; i < columns . size ( ) ; i ++ ) { 
getPrimaryKeyCache = new Index ( this , pkName , IndexType . PRIMARY_KEY , columns ) ; 
return getPrimaryKeyCache ; 
} public Set < ? extends Table > getImportedTables ( ) throws SQLException { 
synchronized ( getImportedTablesLock ) { 
if ( getImportedTablesCache == null ) { 
Set < Table > newImportedTables = new LinkedHashSet < > ( ) ; 
Catalog catalog = schema . getCatalog ( ) ; 
DatabaseMetaData metaData = catalog . getMetaData ( ) ; 
try ( ResultSet results = schema . getCatalog ( ) . getMetaData ( ) . getMetaData ( ) . getImportedKeys ( schema . getCatalog ( ) . getName ( ) , schema . getName ( ) , name ) ) { 
String pkCat = results . getString ( "PKTABLE_CAT" ) ; 
Catalog pkCatalog = pkCat == null ? catalog : metaData . getCatalog ( pkCat ) ; 
newImportedTables . add ( 
pkCatalog 
. getSchema ( results . getString ( "PKTABLE_SCHEM" ) ) 
. getTable ( results . getString ( "PKTABLE_NAME" ) ) 
getImportedTablesCache = AoCollections . optimalUnmodifiableSet ( newImportedTables ) ; 
return getImportedTablesCache ; 
} public Set < ? extends Table > getExportedTables ( ) throws SQLException { 
synchronized ( getExportedTablesLock ) { 
if ( getExportedTablesCache == null ) { 
Set < Table > newExportedTables = new LinkedHashSet < > ( ) ; 
try ( ResultSet results = schema . getCatalog ( ) . getMetaData ( ) . getMetaData ( ) . getExportedKeys ( schema . getCatalog ( ) . getName ( ) , schema . getName ( ) , name ) ) { 
String fkCat = results . getString ( "FKTABLE_CAT" ) ; 
Catalog fkCatalog = fkCat == null ? catalog : metaData . getCatalog ( fkCat ) ; 
newExportedTables . add ( 
fkCatalog 
. getSchema ( results . getString ( "FKTABLE_SCHEM" ) ) 
. getTable ( results . getString ( "FKTABLE_NAME" ) ) 
getExportedTablesCache = AoCollections . optimalUnmodifiableSet ( newExportedTables ) ; 
return getExportedTablesCache ; 
} private void addSegment ( byte type , Object value , int off , int len ) { 
assert ! isClosed ; 
final int arraylen = segmentValues . length ; 
if ( segmentCount == arraylen ) { 
if ( arraylen == 0 ) { 
this . segmentTypes = new byte [ START_LEN ] ; 
this . segmentValues = new Object [ START_LEN ] ; 
this . segmentOffsets = new int [ START_LEN ] ; 
this . segmentLengths = new int [ START_LEN ] ; 
int newLen = arraylen << 1 ; 
byte [ ] newTypes = new byte [ newLen ] ; 
System . arraycopy ( segmentTypes , 0 , newTypes , 0 , arraylen ) ; 
this . segmentTypes = newTypes ; 
Object [ ] newValues = new Object [ newLen ] ; 
System . arraycopy ( segmentValues , 0 , newValues , 0 , arraylen ) ; 
this . segmentValues = newValues ; 
int [ ] newOffsets = new int [ newLen ] ; 
System . arraycopy ( segmentOffsets , 0 , newOffsets , 0 , arraylen ) ; 
this . segmentOffsets = newOffsets ; 
int [ ] newLengths = new int [ newLen ] ; 
System . arraycopy ( segmentLengths , 0 , newLengths , 0 , arraylen ) ; 
this . segmentLengths = newLengths ; 
segmentTypes [ segmentCount ] = type ; 
segmentValues [ segmentCount ] = value ; 
segmentOffsets [ segmentCount ] = off ; 
segmentLengths [ segmentCount ++ ] = len ; 
} private void log ( char ch ) throws IOException { 
if ( ch == '\t' ) log . write ( "'\\t'" ) ; 
else if ( ch == '\b' ) log . write ( "'\\b'" ) ; 
else if ( ch == '\n' ) log . write ( "'\\n'" ) ; 
else if ( ch == '\r' ) log . write ( "'\\r'" ) ; 
else if ( ch == '\f' ) log . write ( "'\\f'" ) ; 
else if ( ch == '\'' ) log . write ( "'\\'" ) ; 
else if ( ch == '\\' ) log . write ( "'\\\\'" ) ; 
else if ( ch == '"' ) log . write ( "'\\\"'" ) ; 
log . write ( "'\\u" ) ; 
String hex = Integer . toHexString ( ch ) ; 
for ( int l = hex . length ( ) ; l < 4 ; l ++ ) log . write ( '0' ) ; 
log . write ( hex ) ; 
log . write ( '\'' ) ; 
log . write ( ch ) ; 
} private void log ( String value ) throws IOException { 
log . write ( "(String)null" ) ; 
log . write ( '"' ) ; 
for ( int i = 0 , len = value . length ( ) ; i < len ; i ++ ) { 
char ch = value . charAt ( i ) ; 
if ( ch == '\t' ) log . write ( "\\t" ) ; 
else if ( ch == '\b' ) log . write ( "\\b" ) ; 
else if ( ch == '\n' ) log . write ( "\\n" ) ; 
else if ( ch == '\r' ) log . write ( "\\r" ) ; 
else if ( ch == '\f' ) log . write ( "\\f" ) ; 
else if ( ch == '\\' ) log . write ( "\\\\" ) ; 
else if ( ch == '"' ) log . write ( "\\\"" ) ; 
log . write ( "\\u" ) ; 
} public void diff_cleanupSemantic ( LinkedList < Diff > diffs ) { 
if ( diffs . isEmpty ( ) ) { 
boolean changes = false ; 
Stack < Diff > equalities = new Stack < Diff > ( ) ; 
String lastequality = null ; 
ListIterator < Diff > pointer = diffs . listIterator ( ) ; 
int length_insertions1 = 0 ; 
int length_deletions1 = 0 ; 
int length_insertions2 = 0 ; 
int length_deletions2 = 0 ; 
Diff thisDiff = pointer . next ( ) ; 
while ( thisDiff != null ) { 
if ( thisDiff . operation == Operation . EQUAL ) { 
equalities . push ( thisDiff ) ; 
length_insertions1 = length_insertions2 ; 
length_deletions1 = length_deletions2 ; 
length_insertions2 = 0 ; 
length_deletions2 = 0 ; 
lastequality = thisDiff . text ; 
if ( thisDiff . operation == Operation . INSERT ) { 
length_insertions2 += thisDiff . text . length ( ) ; 
length_deletions2 += thisDiff . text . length ( ) ; 
if ( lastequality != null && ( lastequality . length ( ) 
<= Math . max ( length_insertions1 , length_deletions1 ) ) 
&& ( lastequality . length ( ) 
<= Math . max ( length_insertions2 , length_deletions2 ) ) ) { 
while ( thisDiff != equalities . lastElement ( ) ) { 
thisDiff = pointer . previous ( ) ; 
pointer . next ( ) ; 
pointer . set ( new Diff ( Operation . DELETE , lastequality ) ) ; 
pointer . add ( new Diff ( Operation . INSERT , lastequality ) ) ; 
equalities . pop ( ) ; 
if ( ! equalities . empty ( ) ) { 
if ( equalities . empty ( ) ) { 
while ( pointer . hasPrevious ( ) ) { 
pointer . previous ( ) ; 
thisDiff = equalities . lastElement ( ) ; 
while ( thisDiff != pointer . previous ( ) ) { 
length_insertions1 = 0 ; 
length_deletions1 = 0 ; 
lastequality = null ; 
changes = true ; 
thisDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; 
if ( changes ) { 
diff_cleanupMerge ( diffs ) ; 
diff_cleanupSemanticLossless ( diffs ) ; 
pointer = diffs . listIterator ( ) ; 
Diff prevDiff = null ; 
thisDiff = null ; 
if ( pointer . hasNext ( ) ) { 
prevDiff = pointer . next ( ) ; 
thisDiff = pointer . next ( ) ; 
if ( prevDiff . operation == Operation . DELETE && 
thisDiff . operation == Operation . INSERT ) { 
String deletion = prevDiff . text ; 
String insertion = thisDiff . text ; 
int overlap_length1 = this . diff_commonOverlap ( deletion , insertion ) ; 
int overlap_length2 = this . diff_commonOverlap ( insertion , deletion ) ; 
if ( overlap_length1 >= overlap_length2 ) { 
if ( overlap_length1 >= deletion . length ( ) / 2.0 || 
overlap_length1 >= insertion . length ( ) / 2.0 ) { 
pointer . add ( new Diff ( Operation . EQUAL , 
insertion . substring ( 0 , overlap_length1 ) ) ) ; 
prevDiff . text = 
deletion . substring ( 0 , deletion . length ( ) - overlap_length1 ) ; 
thisDiff . text = insertion . substring ( overlap_length1 ) ; 
if ( overlap_length2 >= deletion . length ( ) / 2.0 || 
overlap_length2 >= insertion . length ( ) / 2.0 ) { 
deletion . substring ( 0 , overlap_length2 ) ) ) ; 
prevDiff . operation = Operation . INSERT ; 
insertion . substring ( 0 , insertion . length ( ) - overlap_length2 ) ; 
thisDiff . operation = Operation . DELETE ; 
thisDiff . text = deletion . substring ( overlap_length2 ) ; 
prevDiff = thisDiff ; 
} public void diff_cleanupSemanticLossless ( LinkedList < Diff > diffs ) { 
String equality1 , edit , equality2 ; 
String commonString ; 
int commonOffset ; 
int score , bestScore ; 
String bestEquality1 , bestEdit , bestEquality2 ; 
Diff prevDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; 
Diff thisDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; 
Diff nextDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; 
while ( nextDiff != null ) { 
if ( prevDiff . operation == Operation . EQUAL && 
nextDiff . operation == Operation . EQUAL ) { 
equality1 = prevDiff . text ; 
edit = thisDiff . text ; 
equality2 = nextDiff . text ; 
commonOffset = diff_commonSuffix ( equality1 , edit ) ; 
if ( commonOffset != 0 ) { 
commonString = edit . substring ( edit . length ( ) - commonOffset ) ; 
equality1 = equality1 . substring ( 0 , equality1 . length ( ) - commonOffset ) ; 
edit = commonString + edit . substring ( 0 , edit . length ( ) - commonOffset ) ; 
equality2 = commonString + equality2 ; 
bestEquality1 = equality1 ; 
bestEdit = edit ; 
bestEquality2 = equality2 ; 
bestScore = diff_cleanupSemanticScore ( equality1 , edit ) 
+ diff_cleanupSemanticScore ( edit , equality2 ) ; 
while ( edit . length ( ) != 0 && equality2 . length ( ) != 0 
&& edit . charAt ( 0 ) == equality2 . charAt ( 0 ) ) { 
equality1 += edit . charAt ( 0 ) ; 
edit = edit . substring ( 1 ) + equality2 . charAt ( 0 ) ; 
equality2 = equality2 . substring ( 1 ) ; 
score = diff_cleanupSemanticScore ( equality1 , edit ) 
if ( score >= bestScore ) { 
bestScore = score ; 
if ( ! prevDiff . text . equals ( bestEquality1 ) ) { 
if ( bestEquality1 . length ( ) != 0 ) { 
prevDiff . text = bestEquality1 ; 
pointer . remove ( ) ; 
thisDiff . text = bestEdit ; 
if ( bestEquality2 . length ( ) != 0 ) { 
nextDiff . text = bestEquality2 ; 
nextDiff = thisDiff ; 
thisDiff = prevDiff ; 
thisDiff = nextDiff ; 
nextDiff = pointer . hasNext ( ) ? pointer . next ( ) : null ; 
} private int diff_cleanupSemanticScore ( String one , String two ) { 
if ( one . length ( ) == 0 || two . length ( ) == 0 ) { 
return 6 ; 
char char1 = one . charAt ( one . length ( ) - 1 ) ; 
char char2 = two . charAt ( 0 ) ; 
boolean nonAlphaNumeric1 = ! Character . isLetterOrDigit ( char1 ) ; 
boolean nonAlphaNumeric2 = ! Character . isLetterOrDigit ( char2 ) ; 
boolean whitespace1 = nonAlphaNumeric1 && Character . isWhitespace ( char1 ) ; 
boolean whitespace2 = nonAlphaNumeric2 && Character . isWhitespace ( char2 ) ; 
boolean lineBreak1 = whitespace1 
&& Character . getType ( char1 ) == Character . CONTROL ; 
boolean lineBreak2 = whitespace2 
&& Character . getType ( char2 ) == Character . CONTROL ; 
boolean blankLine1 = lineBreak1 && BLANKLINEEND . matcher ( one ) . find ( ) ; 
boolean blankLine2 = lineBreak2 && BLANKLINESTART . matcher ( two ) . find ( ) ; 
if ( blankLine1 || blankLine2 ) { 
return 5 ; 
} else if ( lineBreak1 || lineBreak2 ) { 
} else if ( nonAlphaNumeric1 && ! whitespace1 && whitespace2 ) { 
} else if ( whitespace1 || whitespace2 ) { 
} else if ( nonAlphaNumeric1 || nonAlphaNumeric2 ) { 
} public void diff_cleanupEfficiency ( LinkedList < Diff > diffs ) { 
boolean pre_ins = false ; 
boolean pre_del = false ; 
boolean post_ins = false ; 
boolean post_del = false ; 
Diff safeDiff = thisDiff ; 
if ( thisDiff . text . length ( ) < Diff_EditCost && ( post_ins || post_del ) ) { 
pre_ins = post_ins ; 
pre_del = post_del ; 
equalities . clear ( ) ; 
safeDiff = thisDiff ; 
post_ins = post_del = false ; 
if ( thisDiff . operation == Operation . DELETE ) { 
post_del = true ; 
post_ins = true ; 
if ( lastequality != null 
&& ( ( pre_ins && pre_del && post_ins && post_del ) 
|| ( ( lastequality . length ( ) < Diff_EditCost / 2 ) 
&& ( ( pre_ins ? 1 : 0 ) + ( pre_del ? 1 : 0 ) 
+ ( post_ins ? 1 : 0 ) + ( post_del ? 1 : 0 ) ) == 3 ) ) ) { 
pointer . add ( thisDiff = new Diff ( Operation . INSERT , lastequality ) ) ; 
if ( pre_ins && pre_del ) { 
post_ins = post_del = true ; 
thisDiff = safeDiff ; 
} protected int match_bitap ( String text , String pattern , int loc ) { 
assert ( Match_MaxBits == 0 || pattern . length ( ) <= Match_MaxBits ) 
Map < Character , Integer > s = match_alphabet ( pattern ) ; 
double score_threshold = Match_Threshold ; 
int best_loc = text . indexOf ( pattern , loc ) ; 
if ( best_loc != - 1 ) { 
score_threshold = Math . min ( match_bitapScore ( 0 , best_loc , loc , pattern ) , 
score_threshold ) ; 
best_loc = text . lastIndexOf ( pattern , loc + pattern . length ( ) ) ; 
int matchmask = 1 << ( pattern . length ( ) - 1 ) ; 
best_loc = - 1 ; 
int bin_min , bin_mid ; 
int bin_max = pattern . length ( ) + text . length ( ) ; 
int [ ] last_rd = new int [ 0 ] ; 
for ( int d = 0 ; d < pattern . length ( ) ; d ++ ) { 
bin_min = 0 ; 
bin_mid = bin_max ; 
while ( bin_min < bin_mid ) { 
if ( match_bitapScore ( d , loc + bin_mid , loc , pattern ) 
<= score_threshold ) { 
bin_min = bin_mid ; 
bin_max = bin_mid ; 
bin_mid = ( bin_max - bin_min ) / 2 + bin_min ; 
int start = Math . max ( 1 , loc - bin_mid + 1 ) ; 
int finish = Math . min ( loc + bin_mid , text . length ( ) ) + pattern . length ( ) ; 
int [ ] rd = new int [ finish + 2 ] ; 
rd [ finish + 1 ] = ( 1 << d ) - 1 ; 
for ( int j = finish ; j >= start ; j -- ) { 
int charMatch ; 
if ( text . length ( ) <= j - 1 || ! s . containsKey ( text . charAt ( j - 1 ) ) ) { 
charMatch = 0 ; 
charMatch = s . get ( text . charAt ( j - 1 ) ) ; 
if ( d == 0 ) { 
rd [ j ] = ( ( rd [ j + 1 ] << 1 ) | 1 ) & charMatch ; 
rd [ j ] = ( ( ( rd [ j + 1 ] << 1 ) | 1 ) & charMatch ) 
| ( ( ( last_rd [ j + 1 ] | last_rd [ j ] ) << 1 ) | 1 ) | last_rd [ j + 1 ] ; 
if ( ( rd [ j ] & matchmask ) != 0 ) { 
double score = match_bitapScore ( d , j - 1 , loc , pattern ) ; 
if ( score <= score_threshold ) { 
score_threshold = score ; 
best_loc = j - 1 ; 
if ( best_loc > loc ) { 
start = Math . max ( 1 , 2 * loc - best_loc ) ; 
if ( match_bitapScore ( d + 1 , loc , loc , pattern ) > score_threshold ) { 
last_rd = rd ; 
return best_loc ; 
} public LinkedList < Patch > patch_make ( String text1 , LinkedList < Diff > diffs ) { 
if ( text1 == null || diffs == null ) { 
LinkedList < Patch > patches = new LinkedList < Patch > ( ) ; 
return patches ; 
Patch patch = new Patch ( ) ; 
int char_count1 = 0 ; 
int char_count2 = 0 ; 
String prepatch_text = text1 ; 
String postpatch_text = text1 ; 
for ( Diff aDiff : diffs ) { 
if ( patch . diffs . isEmpty ( ) && aDiff . operation != Operation . EQUAL ) { 
patch . start1 = char_count1 ; 
patch . start2 = char_count2 ; 
switch ( aDiff . operation ) { 
case INSERT : 
patch . diffs . add ( aDiff ) ; 
patch . length2 += aDiff . text . length ( ) ; 
postpatch_text = postpatch_text . substring ( 0 , char_count2 ) 
+ aDiff . text + postpatch_text . substring ( char_count2 ) ; 
patch . length1 += aDiff . text . length ( ) ; 
+ postpatch_text . substring ( char_count2 + aDiff . text . length ( ) ) ; 
if ( aDiff . text . length ( ) <= 2 * Patch_Margin 
&& ! patch . diffs . isEmpty ( ) && aDiff != diffs . getLast ( ) ) { 
if ( aDiff . text . length ( ) >= 2 * Patch_Margin ) { 
if ( ! patch . diffs . isEmpty ( ) ) { 
patch_addContext ( patch , prepatch_text ) ; 
patches . add ( patch ) ; 
patch = new Patch ( ) ; 
prepatch_text = postpatch_text ; 
char_count1 = char_count2 ; 
if ( aDiff . operation != Operation . INSERT ) { 
char_count1 += aDiff . text . length ( ) ; 
if ( aDiff . operation != Operation . DELETE ) { 
char_count2 += aDiff . text . length ( ) ; 
} public List < Patch > patch_fromText ( String textline ) 
List < Patch > patches = new LinkedList < Patch > ( ) ; 
if ( textline . length ( ) == 0 ) { 
List < String > textList = Arrays . asList ( textline . split ( "\n" ) ) ; 
LinkedList < String > text = new LinkedList < String > ( textList ) ; 
Patch patch ; 
Pattern patchHeader 
char sign ; 
while ( ! text . isEmpty ( ) ) { 
m = patchHeader . matcher ( text . getFirst ( ) ) ; 
if ( ! m . matches ( ) ) { 
patch . start1 = Integer . parseInt ( m . group ( 1 ) ) ; 
if ( m . group ( 2 ) . length ( ) == 0 ) { 
patch . start1 -- ; 
patch . length1 = 1 ; 
} else if ( m . group ( 2 ) . equals ( "0" ) ) { 
patch . length1 = 0 ; 
patch . length1 = Integer . parseInt ( m . group ( 2 ) ) ; 
patch . start2 = Integer . parseInt ( m . group ( 3 ) ) ; 
if ( m . group ( 4 ) . length ( ) == 0 ) { 
patch . start2 -- ; 
patch . length2 = 1 ; 
} else if ( m . group ( 4 ) . equals ( "0" ) ) { 
patch . length2 = 0 ; 
patch . length2 = Integer . parseInt ( m . group ( 4 ) ) ; 
text . removeFirst ( ) ; 
sign = text . getFirst ( ) . charAt ( 0 ) ; 
line = text . getFirst ( ) . substring ( 1 ) ; 
line = line . replace ( "+" , "%2B" ) ; 
line = URLDecoder . decode ( line , "UTF-8" ) ; 
if ( sign == '-' ) { 
patch . diffs . add ( new Diff ( Operation . DELETE , line ) ) ; 
} else if ( sign == '+' ) { 
patch . diffs . add ( new Diff ( Operation . INSERT , line ) ) ; 
patch . diffs . add ( new Diff ( Operation . EQUAL , line ) ) ; 
} else if ( sign == '@' ) { 
} String convertSoapMessageAsString ( SOAPMessage soapMessage ) { 
if ( soapMessage == null ) { 
return "null" ; 
soapMessage . writeTo ( os ) ; 
return new String ( os . toByteArray ( ) , determineMessageEncoding ( soapMessage ) ) ; 
return "ERROR" ; 
} public boolean shouldBeProcessed ( final ProfileSettings profileSettings ) { 
if ( profileSettings != null ) { 
String propertyName = GetterUtilities . getFullQualifiedFieldName ( baseType , method ) ; 
Boolean shouldBeProcessed = profileSettings . getPropertyValue ( propertyName ) ; 
if ( shouldBeProcessed == null ) { 
propertyName = baseType . getCanonicalName ( ) + "." + method . getName ( ) ; 
shouldBeProcessed = profileSettings . getPropertyValue ( propertyName ) ; 
if ( shouldBeProcessed == null && annotation != null ) { 
shouldBeProcessed = annotation . enabledPerDefault ( ) ; 
if ( shouldBeProcessed != null ) { 
return shouldBeProcessed ; 
} protected boolean hasTraceeContextProviderAnnotation ( final Object instance ) { 
TraceeContextProvider annotation = TraceeContextLogAnnotationUtilities . getAnnotationFromType ( instance ) ; 
return annotation != null ; 
} protected boolean isExtendingTraceeContextProvider ( final Object instance ) { 
return ImplicitContextData . class . isAssignableFrom ( instance . getClass ( ) ) || WrappedContextData . class . isAssignableFrom ( instance . getClass ( ) ) ; 
} public static boolean isListOfType ( Object instance , Class type ) { 
if ( instance == null || type == null ) { 
if ( List . class . isAssignableFrom ( instance . getClass ( ) ) ) { 
List list = ( List ) instance ; 
boolean isEmpty = list . size ( ) == 0 ; 
if ( element != null && ! type . isAssignableFrom ( element . getClass ( ) ) ) { 
} public static < T > List < T > getListOfType ( Object instance , Class < T > elementType ) { 
if ( instance == null || elementType == null || ! isListOfType ( instance , elementType ) ) { 
return ( List < T > ) instance ; 
} protected static synchronized FileObjectWrapper getOrCreateProfileProperties ( final Filer filer , String fileName ) throws IOException { 
FileObjectWrapper fileObject = traceeProfileProperties . get ( fileName ) ; 
if ( fileObject == null ) { 
fileObject = new FileObjectWrapper ( filer . createResource ( StandardLocation . SOURCE_OUTPUT , "" , fileName , null ) ) ; 
traceeProfileProperties . put ( fileName , fileObject ) ; 
return fileObject ; 
} protected boolean isValidMethod ( Element element ) { 
if ( element . getKind ( ) != ElementKind . METHOD ) { 
TraceeContextProviderMethod . class . getSimpleName ( ) ) ; 
if ( ! element . getModifiers ( ) . contains ( Modifier . PUBLIC ) ) { 
if ( element . getModifiers ( ) . contains ( Modifier . ABSTRACT ) ) { 
if ( element . getModifiers ( ) . contains ( Modifier . STATIC ) ) { 
} protected boolean isGetterMethod ( ExecutableElement executableElement ) { 
TypeMirror returnTypeMirror = executableElement . getReturnType ( ) ; 
if ( returnTypeMirror . getKind ( ) . equals ( TypeKind . VOID ) ) { 
List parameters = executableElement . getParameters ( ) ; 
if ( parameters != null && parameters . size ( ) > 0 ) { 
} protected boolean isParentAnnotatedWithTraceeContextProvider ( final Element element ) { 
Element parentElement = element . getEnclosingElement ( ) ; 
if ( parentElement == null || parentElement . getKind ( ) != ElementKind . CLASS 
|| ! isTypeAnnotatedWithTraceeContextProvider ( ( TypeElement ) parentElement ) ) { 
Flatten . class . getSimpleName ( ) , TraceeContextProvider . class . getSimpleName ( ) ) ; 
} public Boolean getPropertyValue ( final String propertyKey ) { 
if ( propertyKey == null ) { 
if ( toTraceeContextStringRepresentationBuilder != null && toTraceeContextStringRepresentationBuilder . getManualContextOverrides ( ) != null ) { 
Boolean manualOverrideCheck = toTraceeContextStringRepresentationBuilder . getManualContextOverrides ( ) . get ( propertyKey ) ; 
if ( manualOverrideCheck != null ) { 
return manualOverrideCheck ; 
if ( profileProperties != null ) { 
String value = profileProperties . getProperty ( propertyKey ) ; 
return Boolean . valueOf ( value ) ; 
} protected boolean checkIfClassHasNoargsConstructor ( TypeElement typeElement ) { 
boolean foundConstructor = false ; 
boolean foundNoargsConstructor = false ; 
for ( Element child : typeElement . getEnclosedElements ( ) ) { 
if ( ElementKind . CONSTRUCTOR . equals ( child . getKind ( ) ) ) { 
foundConstructor = true ; 
ExecutableElement constructor = ( ExecutableElement ) child ; 
if ( constructor . getParameters ( ) . size ( ) == 0 ) { 
foundNoargsConstructor = true ; 
return ! ( foundConstructor && ! foundNoargsConstructor ) ; 
} public static < T extends Annotation > T getAnnotationFromType ( final Object instance , Class < T > annotation ) { 
if ( instance == null || annotation == null ) { 
return instance . getClass ( ) . getAnnotation ( annotation ) ; 
} public static List < MethodAnnotationPair > getAnnotatedMethodsOfInstance ( final Object instance ) { 
List < MethodAnnotationPair > result = new ArrayList < MethodAnnotationPair > ( ) ; 
for ( Method method : instance . getClass ( ) . getDeclaredMethods ( ) ) { 
if ( checkIsPublic ( method ) && checkMethodHasNoParameters ( method ) && checkMethodHasNonVoidReturnType ( method ) ) { 
TraceeContextProviderMethod annotation = method . getAnnotation ( TraceeContextProviderMethod . class ) ; 
result . add ( new MethodAnnotationPair ( instance . getClass ( ) , method , annotation ) ) ; 
} public static boolean checkMethodHasNonVoidReturnType ( final Method method ) { 
return ! ( Void . TYPE == method . getReturnType ( ) ) ; 
} public static Set < Method > getGetterMethodsRecursively ( final Class type ) { 
Set < Method > getterMethods = new HashSet < Method > ( ) ; 
methods = type . getDeclaredMethods ( ) ; 
catch ( SecurityException e ) { 
methods = type . getMethods ( ) ; 
if ( IsGetterMethodPredicate . check ( type , method ) ) { 
getterMethods . add ( method ) ; 
getterMethods . addAll ( getGetterMethodsRecursively ( type . getSuperclass ( ) ) ) ; 
return getterMethods ; 
} public boolean apply ( final StringBuilder stringBuilder , final OutputStyle outputStyle , final OutputElement outputElement ) { 
if ( outputElement != null ) { 
if ( OutputElementType . COLLECTION . equals ( outputElement . getOutputElementType ( ) ) ) { 
result = handleCollectionType ( stringBuilder , outputStyle , outputElement ) ; 
} else if ( OutputElementType . COMPLEX . equals ( outputElement . getOutputElementType ( ) ) ) { 
if ( TraceeContextLogAnnotationUtilities . getAnnotationFromType ( outputElement . getEncapsulatedInstance ( ) ) != null ) { 
result = handleTraceeContextprovider ( stringBuilder , outputStyle , outputElement ) ; 
result = handleComplexType ( stringBuilder , outputStyle , outputElement ) ; 
} public static Set < Class > findWrapperClasses ( ) { 
final List < TypeToWrapper > localTypeToWrapperList = getTypeToWrapper ( ) ; 
Set < Class > resultList = new HashSet < Class > ( ) ; 
if ( localTypeToWrapperList != null ) { 
for ( TypeToWrapper typeToWrapper : localTypeToWrapperList ) { 
resultList . add ( typeToWrapper . getWrapperType ( ) ) ; 
return resultList ; 
} public static Set < ImplicitContextData > getImplicitContextDataProviders ( ) { 
final Set < ImplicitContextData > result = new HashSet < ImplicitContextData > ( ) ; 
for ( Class clazz : ContextProviderServiceLoader . getServiceLocator ( ) . getImplicitContextProvider ( ) ) { 
if ( ImplicitContextData . class . isAssignableFrom ( clazz ) ) { 
ImplicitContextData instance = ( ImplicitContextData ) ( clazz . newInstance ( ) ) ; 
result . add ( instance ) ; 
} public static List < TypeToWrapper > getAvailableWrappers ( ) { 
final List < TypeToWrapper > result = new ArrayList < TypeToWrapper > ( ) ; 
for ( Class clazz : ContextProviderServiceLoader . getServiceLocator ( ) . getContextProvider ( ) ) { 
if ( WrappedContextData . class . isAssignableFrom ( clazz ) ) { 
final WrappedContextData instance = ( WrappedContextData ) clazz . newInstance ( ) ; 
result . add ( new TypeToWrapper ( instance . getWrappedType ( ) , clazz ) ) ; 
} private void initConnectors ( ) { 
Set < String > connectorConfigurationNames = this . getConnectorConfigurationNames ( ) ; 
for ( String connectorConfigurationName : connectorConfigurationNames ) { 
Connector connector = this . createConnector ( connectorConfigurationName ) ; 
if ( connector != null ) { 
this . connectorMap . put ( connectorConfigurationName , connector ) ; 
if ( ! isConnectorConfigured ( LogConnector . class ) ) { 
Connector logConnector = new LogConnector ( ) ; 
this . connectorMap . put ( "LOGGER" , logConnector ) ; 
} final void sendErrorReportToConnectors ( ConnectorOutputProvider connectorOutputProvider ) { 
for ( Connector connector : this . connectorMap . values ( ) ) { 
connector . sendErrorReport ( connectorOutputProvider ) ; 
} final Set < String > getConnectorConfigurationNames ( ) { 
Set < String > connectorNames = new HashSet < String > ( ) ; 
Enumeration < Object > keyEnumeration = getSystemProperties ( ) . keys ( ) ; 
while ( keyEnumeration . hasMoreElements ( ) ) { 
String key = keyEnumeration . nextElement ( ) . toString ( ) ; 
Matcher matcher = KEY_MATCHER_PATTERN . matcher ( key ) ; 
if ( matcher . matches ( ) && matcher . groupCount ( ) > 0 ) { 
connectorNames . add ( matcher . group ( 1 ) ) ; 
return connectorNames ; 
} final Map < String , String > getPropertiesForConnectorConfigurationName ( final String connectorName ) { 
final Map < String , String > propertyMap = new HashMap < String , String > ( ) ; 
final String patternString = String . format ( CONNECTOR_PROPERTY_GRABBER_PATTERN , connectorName ) ; 
final Pattern propertyGrabPattern = Pattern . compile ( patternString ) ; 
final Set < Map . Entry < Object , Object > > entries = getSystemProperties ( ) . entrySet ( ) ; 
final String key = entry . getKey ( ) . toString ( ) ; 
final Object value = entry . getValue ( ) ; 
final Matcher matcher = propertyGrabPattern . matcher ( key ) ; 
if ( value != null && matcher . matches ( ) && matcher . groupCount ( ) > 0 ) { 
final String propertyName = matcher . group ( 1 ) ; 
propertyMap . put ( propertyName , value . toString ( ) ) ; 
return propertyMap ; 
} final Connector createConnector ( final String connectorConfigurationName ) { 
Map < String , String > propertyMap = this . getPropertiesForConnectorConfigurationName ( connectorConfigurationName ) ; 
String type = propertyMap . get ( TraceeContextLoggerConstants . SYSTEM_PROPERTY_CONTEXT_LOGGER_CONNECTOR_TYPE ) ; 
if ( WELL_KNOW_CONNECTOR_MAPPINGS . containsKey ( type ) ) { 
type = WELL_KNOW_CONNECTOR_MAPPINGS . get ( type ) ; 
Connector connector = ( Connector ) Class . forName ( type ) . newInstance ( ) ; 
connector . init ( propertyMap ) ; 
return connector ; 
} private boolean isConnectorConfigured ( Class connectorClass ) { 
if ( connectorClass . isInstance ( connector ) ) { 
} boolean hasGetterPrefixInMethodName ( Method method ) { 
if ( methodName != null ) { 
for ( String prefix : GETTER_PREFIXES ) { 
} boolean isPublicNonStaticMethod ( final Method method ) { 
int modifiers = method . getModifiers ( ) ; 
return ! Modifier . isStatic ( modifiers ) && Modifier . isPublic ( modifiers ) ; 
} boolean hasReturnValue ( final Method method ) { 
return ! Void . TYPE . equals ( returnType ) ; 
} boolean hasCompatibleReturnTypes ( Class type , Method method ) { 
Field correspondingField = getCorrespondingField ( type , method ) ; 
return correspondingField != null && method . getReturnType ( ) . isAssignableFrom ( correspondingField . getType ( ) ) ; 
} Field getCorrespondingField ( Class type , Method method ) { 
return type . getDeclaredField ( GetterUtilities . getFieldName ( method ) ) ; 
catch ( NoSuchFieldException e ) { 
} public static boolean isGetterMethod ( final String methodName ) { 
} public static String getFieldName ( final String methodName ) { 
if ( isGetterMethod ( methodName ) ) { 
return decapitalizeFirstCharOfString ( stripGetterPrefix ( methodName ) ) ; 
} public static String getFieldName ( final Method method ) { 
return getFieldName ( method . getName ( ) ) ; 
} public static String getFullQualifiedFieldName ( final Class type , final Method method ) { 
final String typeName ; 
typeName = type . getCanonicalName ( ) ; 
typeName = method . getDeclaringClass ( ) . getCanonicalName ( ) ; 
final String fieldName ; 
if ( isGetterMethod ( method . getName ( ) ) ) { 
fieldName = getFieldName ( method . getName ( ) ) ; 
fieldName = method . getName ( ) ; 
return typeName + "." + fieldName ; 
} static String capitalizeFirstCharOfString ( final String input ) { 
if ( input == null || input . length ( ) == 0 ) { 
else if ( input . length ( ) == 1 ) { 
return input . toUpperCase ( ) ; 
return input . substring ( 0 , 1 ) . toUpperCase ( ) + input . substring ( 1 ) ; 
} static String decapitalizeFirstCharOfString ( final String input ) { 
return input . toLowerCase ( ) ; 
return input . substring ( 0 , 1 ) . toLowerCase ( ) + input . substring ( 1 ) ; 
} static String stripGetterPrefix ( final String input ) { 
if ( input != null ) { 
if ( input . startsWith ( prefix ) ) { 
return input . substring ( prefix . length ( ) ) ; 
} protected Object invokeGetter ( final Object instance , final Method method ) { 
return method . invoke ( instance ) ; 
} protected Object invokeField ( final Object instance , final Method method ) { 
if ( instance == null || method == null ) { 
Field field = FieldUtilities . getField ( instance . getClass ( ) , GetterUtilities . getFieldName ( method ) ) ; 
return field . get ( instance ) ; 
} void sendErrorReportToConnectors ( ProceedingJoinPoint proceedingJoinPoint , String annotatedId , Throwable e ) { 
ErrorMessage errorMessage = WatchdogUtils . getErrorMessageAnnotation ( proceedingJoinPoint ) ; 
if ( errorMessage == null ) { 
TraceeContextLogger 
. create ( ) 
. enforceOrder ( ) 
. apply ( ) 
. logWithPrefixedMessage ( MessagePrefixProvider . provideLogMessagePrefix ( MessageLogLevel . ERROR , Watchdog . class ) , CoreImplicitContextProviders . COMMON , 
CoreImplicitContextProviders . TRACEE , WatchdogDataWrapper . wrap ( annotatedId , proceedingJoinPoint ) , e ) ; 
. logWithPrefixedMessage ( MessagePrefixProvider . provideLogMessagePrefix ( MessageLogLevel . ERROR , Watchdog . class ) , 
TraceeMessage . wrap ( errorMessage . value ( ) ) , CoreImplicitContextProviders . COMMON , CoreImplicitContextProviders . TRACEE , 
WatchdogDataWrapper . wrap ( annotatedId , proceedingJoinPoint ) , e ) ; 
} public Object apply ( ContextLoggerConfiguration contextLoggerConfiguration , Object instanceToWrap ) { 
if ( IsImplicitContextEnumValuePredicate . getInstance ( ) . apply ( instanceToWrap ) ) { 
return createInstance ( ( Class ) contextLoggerConfiguration . getImplicitContextProviderClass ( ( ImplicitContext ) instanceToWrap ) ) ; 
Class matchingWrapperType = contextLoggerConfiguration . getContextProviderClass ( instanceToWrap . getClass ( ) ) ; 
if ( matchingWrapperType == null ) { 
for ( TypeToWrapper wrapper : contextLoggerConfiguration . getWrapperList ( ) ) { 
if ( wrapper . getWrappedInstanceType ( ) . isAssignableFrom ( instanceToWrap . getClass ( ) ) ) { 
matchingWrapperType = wrapper . getWrapperType ( ) ; 
if ( matchingWrapperType != null ) { 
WrappedContextData wrapperInstance = ( WrappedContextData ) createInstance ( matchingWrapperType ) ; 
wrapperInstance . setContextData ( instanceToWrap ) ; 
return wrapperInstance ; 
return instanceToWrap ; 
} protected Object createInstance ( final Class type ) { 
} protected boolean hasTraceeContextProviderPrimitiveTypeAnnotation ( final Object instance ) { 
TraceeContextProviderPrimitiveType annotation = TraceeContextLogAnnotationUtilities . getAnnotationFromType ( instance , TraceeContextProviderPrimitiveType . class ) ; 
return WrappedPrimitiveTypeContextData . class . isAssignableFrom ( instance . getClass ( ) ) ; 
} public static Profile getCurrentProfile ( ) { 
Profile profile = getProfileFromSystemProperties ( ) ; 
if ( profile == null ) { 
profile = getProfileFromFileInClasspath ( ProfilePropertyNames . PROFILE_SET_BY_FILE_IN_CLASSPATH_FILENAME ) ; 
profile = ProfilePropertyNames . DEFAULT_PROFILE ; 
return profile ; 
} static Profile getProfileFromSystemProperties ( ) { 
Profile result = null ; 
String systemPropertyProfileName = System . getProperty ( ProfilePropertyNames . PROFILE_SET_GLOBALLY_VIA_SYSTEM_PROPERTIES ) ; 
if ( systemPropertyProfileName != null ) { 
result = Profile . valueOf ( systemPropertyProfileName ) ; 
} static Profile getProfileFromFileInClasspath ( final String filename ) { 
Properties properties = openProperties ( filename ) ; 
String profileFromProperties = properties . getProperty ( ProfilePropertyNames . PROFILE_SET_BY_FILE_IN_CLASSPATH_PROPERTY ) ; 
if ( profileFromProperties != null ) { 
result = Profile . valueOf ( profileFromProperties ) ; 
} public static Properties openProperties ( final String propertyFileName ) throws IOException { 
if ( propertyFileName == null ) { 
inputStream = Profile . class . getResourceAsStream ( propertyFileName ) ; 
properties . load ( inputStream ) ; 
} private void fillManualContextOverrideMap ( final String [ ] contexts , final boolean value ) { 
for ( String context : contexts ) { 
if ( ! context . isEmpty ( ) ) { 
this . manualContextOverrides . put ( context , value ) ; 
} private TraceeContextStringRepresentationBuilderImpl createContextStringRepresentationLogBuilder ( ) { 
TraceeContextStringRepresentationBuilderImpl traceeContextStringRepresentationBuilderImpl = new TraceeContextStringRepresentationBuilderImpl ( ) ; 
traceeContextStringRepresentationBuilderImpl . setManualContextOverrides ( this . getManualContextOverrides ( ) ) ; 
traceeContextStringRepresentationBuilderImpl . setProfile ( this . getProfile ( ) ) ; 
traceeContextStringRepresentationBuilderImpl . setEnforceOrder ( this . getEnforceOrder ( ) ) ; 
traceeContextStringRepresentationBuilderImpl . setOutputWriterConfiguration ( this . getOutputWriterConfiguration ( ) ) ; 
return traceeContextStringRepresentationBuilderImpl ; 
} public static Watchdog getWatchdogAnnotation ( final ProceedingJoinPoint proceedingJoinPoint ) { 
MethodSignature methodSignature = ( MethodSignature ) proceedingJoinPoint . getSignature ( ) ; 
Watchdog methodAnnotation = methodSignature . getMethod ( ) . getAnnotation ( Watchdog . class ) ; 
if ( methodAnnotation != null ) { 
return methodAnnotation ; 
return ( Watchdog ) proceedingJoinPoint . getSignature ( ) . getDeclaringType ( ) . getAnnotation ( Watchdog . class ) ; 
} public static ErrorMessage getErrorMessageAnnotation ( final ProceedingJoinPoint proceedingJoinPoint ) { 
ErrorMessage methodAnnotation = methodSignature . getMethod ( ) . getAnnotation ( ErrorMessage . class ) ; 
} public static boolean checkIfMethodThrowsContainsPassedException ( final ProceedingJoinPoint proceedingJoinPoint , Throwable thrownException ) { 
if ( proceedingJoinPoint == null || thrownException == null ) { 
Class [ ] throwsClassesFromMethodSignature = getDefinedThrowsFromMethodSignature ( proceedingJoinPoint ) ; 
return checkClassIsDefinedInThrowsException ( throwsClassesFromMethodSignature , thrownException ) ; 
} public static boolean checkClassIsDefinedInThrowsException ( Class [ ] classes , Throwable thrownException ) { 
if ( classes == null || thrownException == null ) { 
for ( Class clazz : classes ) { 
if ( clazz . isInstance ( thrownException ) ) { 
} public static Class [ ] getDefinedThrowsFromMethodSignature ( final ProceedingJoinPoint proceedingJoinPoint ) { 
if ( proceedingJoinPoint == null ) { 
return new Class [ 0 ] ; 
return methodSignature . getMethod ( ) . getExceptionTypes ( ) ; 
} public static boolean checkProcessWatchdog ( final Watchdog watchdogAnnotation , final ProceedingJoinPoint proceedingJoinPoint , final Throwable throwable ) { 
if ( watchdogAnnotation != null && watchdogAnnotation . isActive ( ) ) { 
boolean throwableIsPartOfThrowsDeclaration = WatchdogUtils . checkIfMethodThrowsContainsPassedException ( proceedingJoinPoint , throwable ) ; 
if ( ! watchdogAnnotation . suppressThrowsExceptions ( ) || ( watchdogAnnotation . suppressThrowsExceptions ( ) && ! throwableIsPartOfThrowsDeclaration ) ) { 
} @ SuppressWarnings ( "PMD" ) 
public void add ( final Statement ... toAdd ) { 
if ( toAdd != null ) { 
Arrays . stream ( toAdd ) 
. forEach ( c -> { 
if ( c instanceof CommonEdgeAttributes ) { 
this . commonEdgeAttributes = ( CommonEdgeAttributes ) c ; 
} else if ( c instanceof CommonGraphAttributes ) { 
this . commonGraphAttributes = ( CommonGraphAttributes ) c ; 
} else if ( c instanceof CommonNodeAttributes ) { 
this . commonNodeAttributes = ( CommonNodeAttributes ) c ; 
} else if ( c instanceof Node ) { 
this . nodes . add ( ( Node ) c ) ; 
} else if ( c instanceof Identifier ) { 
this . identifiers . add ( ( Identifier ) c ) ; 
} else if ( c instanceof Edge ) { 
this . edges . add ( ( Edge ) c ) ; 
} else if ( c instanceof Subgraph ) { 
this . subgraphs . add ( ( Subgraph ) c ) ; 
} public Node findNode ( final String identifier , final boolean recursive ) { 
Optional < Node > toReturn = getNodes ( ) . stream ( ) . filter ( c -> c . getId ( ) . equals ( identifier ) ) . findFirst ( ) ; 
if ( ! toReturn . isPresent ( ) && recursive && getSubgraphs ( ) != null && ! getSubgraphs ( ) . isEmpty ( ) ) { 
toReturn = getSubgraphs ( ) . stream ( ) 
. map ( c -> c . getStatements ( ) . findNode ( identifier , true ) ) 
. filter ( c -> c != null ) 
return toReturn . orElse ( null ) ; 
} public Edge findEdge ( final String fromId , final String toId , final boolean recursive ) { 
Optional < Edge > toReturn = getEdges ( ) . stream ( ) 
. filter ( c -> c . getId ( ) . equals ( fromId ) && c . getRightSideEdge ( ) . getId ( ) . equals ( toId ) ) 
if ( ! toReturn . isPresent ( ) && recursive ) { 
toReturn = subgraphs . stream ( ) . map ( c -> c . getStatements ( ) . findEdge ( fromId , toId , true ) ) . findFirst ( ) ; 
} public Subgraph findSubgraph ( final String identifier , final boolean recursive ) { 
Optional < Subgraph > toReturn = getSubgraphs ( ) . stream ( ) . filter ( c -> c . getId ( ) . equals ( identifier ) ) . findFirst ( ) ; 
. map ( c -> c . getStatements ( ) . findSubgraph ( identifier , true ) ) 
} public Edge addEdge ( final String fromId , final String toId , final Graph parentGraph ) { 
if ( fromId == null || fromId . isEmpty ( ) ) { 
if ( toId == null || toId . isEmpty ( ) ) { 
if ( parentGraph == null ) { 
Edge toReturn = null ; 
final Node fromNode = findNode ( fromId , true ) ; 
final Subgraph fromSubgraph = findSubgraph ( fromId , true ) ; 
if ( fromNode != null || fromSubgraph != null ) { 
final Node toNode = findNode ( toId , true ) ; 
final Subgraph toSubgraph = findSubgraph ( toId , true ) ; 
final NodeID toNodeId = toNode == null ? null : toNode . getNodeID ( ) ; 
if ( toNodeId != null || toSubgraph != null ) { 
final RightSideEdge rightSideEdge = toNodeId == null 
? new RightSideEdge ( toSubgraph ) 
: new RightSideEdge ( toNodeId ) ; 
toReturn = fromNode == null 
? new Edge ( fromSubgraph , rightSideEdge ) 
: new Edge ( fromNode . getNodeID ( ) , rightSideEdge ) ; 
if ( toReturn != null ) { 
add ( toReturn ) ; 
return toReturn ; 
} public void execute ( ) 
throws MojoExecutionException , MojoFailureException { 
if ( skip ) { 
if ( ! skipExec ) { 
if ( checkstyleRules != null ) { 
if ( ! "sun_checks.xml" . equals ( configLocation ) ) { 
if ( checkstyleRules . getChildCount ( ) > 1 ) { 
PlexusConfiguration checkerModule = checkstyleRules . getChild ( 0 ) ; 
FileUtils . forceMkdir ( rulesFiles . getParentFile ( ) ) ; 
FileUtils . fileWrite ( rulesFiles , CHECKSTYLE_FILE_HEADER + checkerModule . toString ( ) ) ; 
throw new MojoExecutionException ( e . getMessage ( ) , e ) ; 
configLocation = rulesFiles . getAbsolutePath ( ) ; 
CheckstyleExecutorRequest request = new CheckstyleExecutorRequest ( ) ; 
request . setConsoleListener ( getConsoleListener ( ) ) . setConsoleOutput ( consoleOutput ) 
. setExcludes ( excludes ) . setFailsOnError ( failsOnError ) . setIncludes ( includes ) 
. setResourceIncludes ( resourceIncludes ) 
. setResourceExcludes ( resourceExcludes ) 
. setIncludeResources ( includeResources ) 
. setIncludeTestResources ( includeTestResources ) 
. setIncludeTestSourceDirectory ( includeTestSourceDirectory ) . setListener ( getListener ( ) ) 
. setProject ( project ) . setSourceDirectories ( getSourceDirectories ( ) ) 
. setResources ( resources ) . setTestResources ( testResources ) 
. setStringOutputStream ( stringOutputStream ) . setSuppressionsLocation ( suppressionsLocation ) 
. setTestSourceDirectories ( getTestSourceDirectories ( ) ) . setConfigLocation ( configLocation ) 
. setConfigurationArtifacts ( collectArtifacts ( "config" ) ) 
. setPropertyExpansion ( propertyExpansion ) 
. setHeaderLocation ( headerLocation ) . setLicenseArtifacts ( collectArtifacts ( "license" ) ) 
. setCacheFile ( cacheFile ) . setSuppressionsFileExpression ( suppressionsFileExpression ) 
. setEncoding ( encoding ) . setPropertiesLocation ( propertiesLocation ) ; 
checkstyleExecutor . executeCheckstyle ( request ) ; 
} catch ( CheckstyleException e ) { 
} catch ( CheckstyleExecutorException e ) { 
if ( ! "xml" . equals ( outputFileFormat ) ) { 
if ( ! outputFile . exists ( ) ) { 
Reader reader = null ; 
reader = new BufferedReader ( ReaderFactory . newXmlReader ( outputFile ) ) ; 
XmlPullParser xpp = new MXParser ( ) ; 
xpp . setInput ( reader ) ; 
int violations = countViolations ( xpp ) ; 
if ( violations > maxAllowedViolations ) { 
if ( failOnViolation ) { 
String msg = 
if ( maxAllowedViolations > 0 ) { 
throw new MojoFailureException ( msg ) ; 
reader = null ; 
} catch ( IOException | XmlPullParserException e ) { 
IOUtil . close ( reader ) ; 
} private boolean isViolation ( String severity ) { 
if ( "error" . equals ( severity ) ) { 
return "error" . equals ( violationSeverity ) || "warning" . equals ( violationSeverity ) 
|| "info" . equals ( violationSeverity ) ; 
} else if ( "warning" . equals ( severity ) ) { 
return "warning" . equals ( violationSeverity ) || "info" . equals ( violationSeverity ) ; 
} else if ( "info" . equals ( severity ) ) { 
return "info" . equals ( violationSeverity ) ; 
} public void iconSeverity ( String level ) { 
sink . figure ( ) ; 
sink . figureGraphics ( "images/icon_" + level + "_sml.gif" ) ; 
sink . figure_ ( ) ; 
} public void iconSeverity ( String level , int textType ) { 
if ( textType > 0 ) { 
sink . nonBreakingSpace ( ) ; 
sink . text ( bundle . getString ( "report.checkstyle." + level + suffix ( textType ) ) ) ; 
} public void executeReport ( final Locale locale ) 
throws MavenReportException { 
locator . addSearchPath ( FileResourceLoader . ID , project . getFile ( ) . getParentFile ( ) . getAbsolutePath ( ) ) ; 
locator . addSearchPath ( "url" , "" ) ; 
locator . setOutputDirectory ( new File ( project . getBuild ( ) . getDirectory ( ) ) ) ; 
CheckstyleExecutorRequest request = createRequest ( ) 
. setLicenseArtifacts ( collectArtifacts ( "license" ) ) 
. setConfigurationArtifacts ( collectArtifacts ( "configuration" ) ) ; 
CheckstyleResults results = checkstyleExecutor . executeCheckstyle ( request ) ; 
ResourceBundle bundle = getBundle ( locale ) ; 
generateReportStatics ( ) ; 
generateMainReport ( results , bundle ) ; 
if ( enableRSS ) { 
CheckstyleRssGeneratorRequest checkstyleRssGeneratorRequest = 
new CheckstyleRssGeneratorRequest ( this . project , this . getCopyright ( ) , outputDirectory , getLog ( ) ) ; 
checkstyleRssGenerator . generateRSS ( results , checkstyleRssGeneratorRequest ) ; 
} public < Concept , S extends Statement > AbstractStatementConverter < Concept , S > get ( 
final Class < Concept > conceptClass ) { 
if ( conceptClass == null ) { 
final AbstractStatementConverter < Concept , S > toReturn = statementConverters . get ( conceptClass ) ; 
if ( toReturn == null && log . isDebugEnabled ( ) ) { 
} public < Concept , S extends Statement > void put ( final Class < Concept > conceptClass , 
final AbstractStatementConverter < Concept , S > converter ) { 
public final Graph convert ( final From toConvert ) { 
if ( toConvert == null && ! acceptsNullValues ( ) ) { 
return doConvert ( toConvert ) ; 
} private String getCheckstyleVersion ( ) { 
Package checkstyleApiPackage = Configuration . class . getPackage ( ) ; 
return ( checkstyleApiPackage == null ) ? null : checkstyleApiPackage . getImplementationVersion ( ) ; 
} private void configureResourceLocator ( final ResourceManager resourceManager , 
final CheckstyleExecutorRequest request , 
final List < Artifact > additionalArtifacts ) { 
final MavenProject project = request . getProject ( ) ; 
resourceManager . setOutputDirectory ( new File ( project . getBuild ( ) . getDirectory ( ) ) ) ; 
MavenProject parent = project ; 
while ( parent != null && parent . getFile ( ) != null ) { 
File dir = parent . getFile ( ) . getParentFile ( ) ; 
resourceManager . addSearchPath ( FileResourceLoader . ID , dir . getAbsolutePath ( ) ) ; 
resourceManager . addSearchPath ( "url" , "" ) ; 
if ( additionalArtifacts != null ) { 
for ( Artifact licenseArtifact : additionalArtifacts ) { 
if ( licenseArtifact != null ) { 
if ( getLogger ( ) . isDebugEnabled ( ) ) { 
+ licenseArtifact . getArtifactId ( ) + ":" + licenseArtifact . getVersion ( ) 
resourceManager . addSearchPath ( "jar" , "jar:" + licenseArtifact . getFile ( ) . toURI ( ) . toURL ( ) ) ; 
public boolean start ( final RootDoc root ) { 
if ( this . dotFacade == null ) { 
final VisualizationWrappedRootDoc rootDoc = new VisualizationWrappedRootDoc ( root ) ; 
htmlDoclet . configuration . root = root ; 
htmlDoclet . configuration . setOptions ( ) ; 
} catch ( Configuration . Fault fault ) { 
fault . printStackTrace ( ) ; 
for ( ClassDoc cDoc : rootDoc . classes ( ) ) { 
log . debug ( getJavaDocAndTagsLog ( cDoc ) ) ; 
for ( PackageDoc pDoc : rootDoc . specifiedPackages ( ) ) { 
log . debug ( getJavaDocAndTagsLog ( pDoc ) ) ; 
return HtmlDoclet . start ( root ) ; 
public boolean validateJavaDocOptions ( final String [ ] [ ] options , final DocErrorReporter errorReporter ) { 
htmlDoclet . sharedInstanceForOptions . setOptions ( options ) ; 
return HtmlDoclet . validOptions ( options , errorReporter ) ; 
public int optionLength ( final String option ) { 
if ( JavaDocOption . HELP . getOption ( ) . equals ( option ) ) { 
final int toReturn = HtmlDoclet . optionLength ( option ) ; 
for ( JavaDocOption current : JavaDocOption . values ( ) ) { 
if ( current != JavaDocOption . HELP ) { 
if ( current . getOption ( ) . equals ( option ) ) { 
return current . getOptionLength ( ) ; 
return HtmlDoclet . optionLength ( option ) ; 
protected String doRender ( final RenderConfiguration config , final Subgraph subgraph ) { 
+ quote ( subgraph . getId ( ) ) 
+ config . getNewline ( ) ; 
final Statements statements = subgraph . getStatements ( ) ; 
final StatementsRenderer statementsRenderer = new StatementsRenderer ( ) ; 
final String renderedStatements = statementsRenderer . render ( config . cloneAndChangeIndentation ( 1 ) , statements ) ; 
return prologue + renderedStatements + config . getNewline ( ) + config . getIndent ( ) + "}" ; 
protected String doRender ( final RenderConfiguration config , final CommonNodeAttributes entity ) { 
return config . getIndent ( ) 
+ entity . getId ( ) 
protected Graph doConvert ( final Set < ClassDoc > toConvert ) { 
final ClassDoc [ ] clDocs = toConvert . toArray ( new ClassDoc [ toConvert . size ( ) ] ) ; 
final SortedMap < PackageDoc , SortedSet < ClassDoc > > clPerPackage = Comparators . sortClassesPerPackage ( clDocs ) ; 
final Map . Entry < PackageDoc , SortedSet < ClassDoc > > packageAndClasses = clPerPackage 
. entrySet ( ) 
. filter ( e -> relevantPackage . getName ( ) . equalsIgnoreCase ( e . getKey ( ) . name ( ) ) ) 
. orElse ( "<none>" ) ) ) ; 
final PackageDoc packageDoc = packageAndClasses . getKey ( ) ; 
final SortedSet < ClassDoc > classDocs = packageAndClasses . getValue ( ) ; 
final Graph toReturn = new Graph ( "Graph_" + packageDoc . name ( ) , true , true ) ; 
final Subgraph packageSubgraph = new Subgraph ( packageDoc . name ( ) ) ; 
final CommonGraphAttributes subgraphAttrs = new CommonGraphAttributes ( ) ; 
packageSubgraph . add ( subgraphAttrs ) ; 
final GraphAttributes subAttrs = subgraphAttrs . getAttributes ( ) ; 
toReturn . add ( renderPackageSubGraph ( classDocs ) ) ; 
public int compareTo ( final NodeID that ) { 
if ( that == this ) { 
} else if ( null == that ) { 
return this . getId ( ) . compareTo ( that . getId ( ) ) ; 
} public static boolean containsVisualizationDocletTag ( final String message ) { 
for ( VisualizationDocletTag current : VisualizationDocletTag . values ( ) ) { 
} public SortedSet < PackageDoc > findPackagesFromClassesInJavaDocRun ( ) { 
final SortedSet < PackageDoc > toReturn = new TreeSet < > ( Comparators . PACKAGE_NAME_COMPARATOR ) ; 
final ClassDoc [ ] currentExecutionClasses = classes ( ) ; 
if ( currentExecutionClasses != null ) { 
Arrays . stream ( currentExecutionClasses ) 
. map ( ProgramElementDoc :: containingPackage ) 
. forEach ( toReturn :: add ) ; 
@ SuppressWarnings ( "PMD.PreserveStackTrace" ) 
protected void performValidation ( final MavenProject project , final EnforcerRuleHelper helper ) 
throws RuleFailureException { 
ProjectType . getProjectType ( project ) ; 
throw new RuleFailureException ( e . getMessage ( ) ) ; 
public final String render ( final RenderConfiguration configuration , final Object entity ) { 
if ( ! accept ( entity ) ) { 
String epilogue = "" ; 
if ( entity instanceof Subgraph ) { 
epilogue = configuration . getNewline ( ) ; 
} else if ( entity instanceof Statement ) { 
final T castEntity = acceptedType . cast ( entity ) ; 
return doRender ( configuration , castEntity ) + epilogue ; 
public boolean accept ( final Object entity ) { 
return entity != null && acceptedType . isAssignableFrom ( entity . getClass ( ) ) ; 
} private String getConfigAttribute ( Configuration config , ChainedItem < Configuration > parentConfiguration , 
String attributeName , String defaultValue ) { 
ret = config . getAttribute ( attributeName ) ; 
if ( parentConfiguration != null ) { 
ret = 
getConfigAttribute ( parentConfiguration . value , parentConfiguration . parent , attributeName , 
defaultValue ) ; 
ret = defaultValue ; 
} private void doRulesSummary ( CheckstyleResults results ) { 
if ( checkstyleConfig == null ) { 
sink . section1 ( ) ; 
sink . sectionTitle1 ( ) ; 
sink . text ( bundle . getString ( "report.checkstyle.rules" ) ) ; 
sink . sectionTitle1_ ( ) ; 
sink . table ( ) ; 
sink . tableRow ( ) ; 
sink . tableHeaderCell ( ) ; 
sink . text ( bundle . getString ( "report.checkstyle.rule.category" ) ) ; 
sink . tableHeaderCell_ ( ) ; 
sink . text ( bundle . getString ( "report.checkstyle.rule" ) ) ; 
sink . text ( bundle . getString ( "report.checkstyle.violations" ) ) ; 
sink . text ( bundle . getString ( "report.checkstyle.column.severity" ) ) ; 
sink . tableRow_ ( ) ; 
if ( "checker" . equalsIgnoreCase ( checkstyleConfig . getName ( ) ) ) { 
String category = null ; 
for ( ConfReference ref : sortConfiguration ( results ) ) { 
doRuleRow ( ref , results , category ) ; 
category = ref . category ; 
sink . tableCell ( ) ; 
sink . text ( bundle . getString ( "report.checkstyle.norule" ) ) ; 
sink . tableCell_ ( ) ; 
sink . table_ ( ) ; 
sink . section1_ ( ) ; 
} private void doRuleRow ( ConfReference ref , CheckstyleResults results , String previousCategory ) { 
Configuration checkerConfig = ref . configuration ; 
ChainedItem < Configuration > parentConfiguration = ref . parentConfiguration ; 
String ruleName = checkerConfig . getName ( ) ; 
String category = ref . category ; 
if ( ! category . equals ( previousCategory ) ) { 
sink . text ( category ) ; 
if ( ! "extension" . equals ( category ) ) { 
sink . link ( "http://checkstyle.sourceforge.net/config_" + category + ".html#" + ruleName ) ; 
sink . text ( ruleName ) ; 
sink . link_ ( ) ; 
List < String > attribnames = new ArrayList < > ( Arrays . asList ( checkerConfig . getAttributeNames ( ) ) ) ; 
attribnames . remove ( "severity" ) ; 
if ( ! attribnames . isEmpty ( ) ) { 
sink . list ( ) ; 
for ( String name : attribnames ) { 
sink . listItem ( ) ; 
sink . text ( name ) ; 
String value = getConfigAttribute ( checkerConfig , null , name , "" ) ; 
if ( "header" . equals ( name ) && ( "Header" . equals ( ruleName ) || "RegexpHeader" . equals ( ruleName ) ) ) { 
String [ ] lines = StringUtils . split ( value , "\\n" ) ; 
int linenum = 1 ; 
sink . lineBreak ( ) ; 
sink . text ( linenum + ":" ) ; 
sink . rawText ( "</span>" ) ; 
sink . monospaced ( ) ; 
sink . text ( line ) ; 
sink . monospaced_ ( ) ; 
linenum ++ ; 
} else if ( "headerFile" . equals ( name ) && "RegexpHeader" . equals ( ruleName ) ) { 
sink . text ( "\"" ) ; 
String path = siteTool . getRelativePath ( value , basedir . getAbsolutePath ( ) ) ; 
sink . text ( path . replace ( '\\' , '/' ) ) ; 
sink . text ( value ) ; 
sink . listItem_ ( ) ; 
sink . list_ ( ) ; 
sink . text ( String . valueOf ( ref . violations ) ) ; 
String severity = getConfigAttribute ( checkerConfig , parentConfiguration , "severity" , "error" ) ; 
iconTool . iconSeverity ( severity , IconTool . TEXT_SIMPLE ) ; 
} public boolean matchRule ( AuditEvent event , String ruleName , String expectedMessage , String expectedSeverity ) { 
if ( ! ruleName . equals ( RuleUtil . getName ( event ) ) ) { 
if ( expectedMessage != null ) { 
String msgWithoutSingleQuote = StringUtils . replace ( expectedMessage , "'" , "" ) ; 
return expectedMessage . equals ( event . getMessage ( ) ) || msgWithoutSingleQuote . equals ( event . getMessage ( ) ) ; 
if ( expectedSeverity != null ) { 
return expectedSeverity . equals ( event . getSeverityLevel ( ) . getName ( ) ) ; 
@ SuppressWarnings ( "PMD" ) 
protected String doRender ( final RenderConfiguration config , final AbstractAttributes entity ) { 
final SortedMap < String , String > dotAttributes = new TreeMap < > ( ) ; 
for ( Class < ? > current = entity . getClass ( ) ; 
current != null && current != Object . class ; 
current = current . getSuperclass ( ) ) { 
for ( Field currentField : current . getDeclaredFields ( ) ) { 
if ( isConfigurationField ( currentField ) ) { 
value = currentField . get ( entity ) ; 
final DotProperty dotPropertyAnnotation = currentField . getAnnotation ( DotProperty . class ) ; 
if ( dotPropertyAnnotation == null ) { 
if ( dotPropertyAnnotation . specialTreatment ( ) ) { 
if ( "labelSize" . equals ( currentField . getName ( ) ) 
&& PointOrRectangle . class . equals ( currentField . getType ( ) ) ) { 
final PointOrRectangle rect = ( PointOrRectangle ) value ; 
dotAttributes . put ( quote ( "lwidth" ) , 
BigDecimal . valueOf ( rect . getxOrWidth ( ) ) . toPlainString ( ) ) ; 
dotAttributes . put ( quote ( "lheight" ) , 
BigDecimal . valueOf ( rect . getyOrHeight ( ) ) . toPlainString ( ) ) ; 
key = dotPropertyAnnotation . name ( ) ; 
if ( key . isEmpty ( ) || "##default" . equalsIgnoreCase ( key ) ) { 
key = currentField . getName ( ) ; 
dotAttributes . put ( key , getDotConfigValueFor ( value ) ) ; 
+ entity . getClass ( ) . getSimpleName ( ) + "]" , e ) ; 
if ( dotAttributes . isEmpty ( ) ) { 
final StringBuilder builder = new StringBuilder ( START_TOKEN ) ; 
for ( Map . Entry < String , String > current : dotAttributes . entrySet ( ) ) { 
builder . append ( current . getKey ( ) + SEPARATOR + "\"" + current . getValue ( ) + "\"" + DELIMITER ) ; 
builder . delete ( builder . length ( ) - DELIMITER . length ( ) , builder . length ( ) ) ; 
builder . append ( END_TOKEN ) ; 
} protected boolean initialize ( final RootDoc rootDoc ) { 
if ( isInitializedOK ) { 
for ( String current : discoveryLog ) { 
rootDoc . printNotice ( current ) ; 
final ProcessBuilder pb = new ProcessBuilder ( getExecutableNameOrPath ( ) , "-V" ) ; 
pb . redirectErrorStream ( true ) ; 
if ( homeDirectory != null ) { 
pb . directory ( homeDirectory ) ; 
Process p ; 
p = pb . start ( ) ; 
rootDoc . printWarning ( e . getMessage ( ) ) ; 
try ( BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; 
OutputStream out = p . getOutputStream ( ) ; ) { 
while ( ( line = in . readLine ( ) ) != null ) { 
if ( line . matches ( GRAPHVIZ_EXECUTABLE_FIRST_LINE_CHECK ) ) { 
isInitializedOK = true ; 
isInitializedOK = false ; 
p . waitFor ( ) ; 
protected String doRender ( final RenderConfiguration config , final Identifier entity ) { 
} public void writePngImageAndImageMap ( final RootDoc rootDoc , 
final String dotDiagram , 
final File outputDirectory , 
final String filename ) throws IOException { 
if ( filename == null || filename . isEmpty ( ) ) { 
if ( rootDoc == null ) { 
if ( ! initialize ( rootDoc ) ) { 
final File pngFile = new File ( outputDirectory , filename + ".png" ) ; 
final File mapFile = new File ( outputDirectory , filename + ".map" ) ; 
pngFile . delete ( ) ; 
mapFile . delete ( ) ; 
final ProcessBuilder pb = new ProcessBuilder ( 
getExecutableNameOrPath ( ) , 
"-Tcmapx" , "-o" , mapFile . getAbsolutePath ( ) , 
"-Tpng" , "-o" , pngFile . getAbsolutePath ( ) ) ; 
if ( getHomeDirectory ( ) != null ) { 
pb . directory ( getHomeDirectory ( ) ) ; 
final Process p = pb . start ( ) ; 
try ( final BufferedReader in = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; 
final Writer out = new OutputStreamWriter ( p . getOutputStream ( ) , AbstractExecutableFacade . UTF8_ENCODING ) ) { 
out . write ( dotDiagram ) ; 
System . err . println ( line ) ; 
int result = p . waitFor ( ) ; 
if ( result != 0 ) { 
protected String doRender ( final RenderConfiguration config , final Port entity ) { 
final String prefix = entity . getId ( ) != null && ! entity . getId ( ) . isEmpty ( ) 
} public static SortedMap < PackageDoc , SortedSet < ClassDoc > > sortClassesPerPackage ( final ClassDoc ... classDocs ) { 
final SortedMap < PackageDoc , SortedSet < ClassDoc > > toReturn = new TreeMap < > ( Comparators . PACKAGE_NAME_COMPARATOR ) ; 
if ( classDocs != null ) { 
Arrays . stream ( classDocs ) . forEach ( current -> { 
final SortedSet < ClassDoc > classDocsForCurrentPackage = toReturn . computeIfAbsent ( 
current . containingPackage ( ) , 
k -> new TreeSet < > ( Comparators . CLASS_NAME_COMPARATOR ) ) ; 
classDocsForCurrentPackage . add ( current ) ; 
public final void execute ( final EnforcerRuleHelper helper ) throws EnforcerRuleException { 
final MavenProject project ; 
project = ( MavenProject ) helper . evaluate ( "${project}" ) ; 
} catch ( final ExpressionEvaluationException e ) { 
+ e . getLocalizedMessage ( ) + ")" ; 
throw new EnforcerRuleException ( msg , e ) ; 
performValidation ( project , helper ) ; 
} catch ( RuleFailureException e ) { 
String message = 
"\n" 
+ "\n#" 
+ project . getArtifactId ( ) + ":" + project . getVersion ( ) + "]" + "\n#" ; 
final Artifact art = e . getOffendingArtifact ( ) ; 
if ( art != null ) { 
+ ":" + art . getVersion ( ) + "]" 
+ "\n#" ; 
message += "\n" ; 
throw new EnforcerRuleException ( message ) ; 
} protected static List < String > splice ( final String toSplice ) { 
final List < String > toReturn = new ArrayList < String > ( ) ; 
final StringTokenizer tok = new StringTokenizer ( toSplice , "," , false ) ; 
while ( tok . hasMoreTokens ( ) ) { 
toReturn . add ( tok . nextToken ( ) ) ; 
} protected static List < Pattern > splice2Pattern ( final String toSplice ) throws PatternSyntaxException { 
final List < Pattern > toReturn = new ArrayList < Pattern > ( ) ; 
for ( final String current : splice ( toSplice ) ) { 
toReturn . add ( Pattern . compile ( current ) ) ; 
} protected static boolean matches ( final String toMatch , final List < Pattern > patternList ) { 
for ( final Pattern current : patternList ) { 
if ( current . matcher ( toMatch ) . matches ( ) ) { 
} protected static boolean containsPrefix ( final List < String > source , final String toCheck ) { 
for ( final String current : source ) { 
if ( toCheck . startsWith ( current ) ) { 
protected String doRender ( final RenderConfiguration config , final Graph graph ) { 
config . setDirectedGraph ( graph . isDigraph ( ) ) ; 
final String prologue = 
+ ( graph . isDigraph ( ) ? "digraph" : "graph" ) 
final String renderedStatements = statementsRenderer . render ( 
config . cloneAndChangeIndentation ( 1 ) , 
graph . getStatements ( ) ) ; 
final String epilogue = config . getIndent ( ) + "}" ; 
return prologue + renderedStatements + epilogue ; 
protected String doRender ( final RenderConfiguration config , final RightSideEdge entity ) { 
final String prefix = RightSideEdge . getEdgeSeparator ( config . isDirectedGraph ( ) ) 
+ ( entity . getNodeID ( ) != null 
? nodeIdRenderer . doRender ( config , entity . getNodeID ( ) ) 
: entity . getSubgraph ( ) . getId ( ) ) ; 
String renderedRightSideOfThisEdge = "" ; 
if ( entity . getRightSideEdge ( ) != null ) { 
return prefix + renderedRightSideOfThisEdge ; 
public final void addErrorMessage ( final String message ) { 
if ( message == null || "" . equals ( message ) ) { 
errorMessages . add ( message ) ; 
public String getMessage ( ) { 
for ( final String current : errorMessages ) { 
builder . append ( current ) . append ( "\n" ) ; 
protected String doRender ( final RenderConfiguration config , final Statements statements ) { 
final StringBuilder builder = new StringBuilder ( config . getIndent ( ) ) ; 
final boolean hasAttributeStatements = statements . getCommonGraphAttributes ( ) != null 
|| statements . getCommonNodeAttributes ( ) != null 
|| statements . getCommonEdgeAttributes ( ) != null ; 
if ( hasAttributeStatements ) { 
builder . append ( commentRenderer . render ( config , statements . getCommonAttributesComment ( ) ) ) ; 
if ( statements . getCommonGraphAttributes ( ) != null ) { 
builder . append ( commonGraphAttributesRenderer . render ( config , statements . getCommonGraphAttributes ( ) ) ) ; 
if ( statements . getCommonNodeAttributes ( ) != null ) { 
builder . append ( commonNodeAttributesRenderer . render ( config , statements . getCommonNodeAttributes ( ) ) ) ; 
if ( statements . getCommonEdgeAttributes ( ) != null ) { 
builder . append ( commonEdgeAttributesRenderer . render ( config , statements . getCommonEdgeAttributes ( ) ) ) ; 
final List < Node > nodes = statements . getNodes ( ) ; 
if ( ! nodes . isEmpty ( ) ) { 
builder . append ( commentRenderer . render ( config , statements . getNodesComment ( ) ) ) ; 
nodes . forEach ( n -> builder . append ( nodeRenderer . render ( config , n ) ) ) ; 
final List < Identifier > identifiers = statements . getIdentifiers ( ) ; 
if ( ! identifiers . isEmpty ( ) ) { 
builder . append ( commentRenderer . render ( config , statements . getIdentifiersComment ( ) ) ) ; 
identifiers . forEach ( i -> builder . append ( identifierRenderer . render ( config , i ) ) ) ; 
final List < Edge > edges = statements . getEdges ( ) ; 
if ( edges != null && ! edges . isEmpty ( ) ) { 
builder . append ( commentRenderer . render ( config , statements . getEdgesComment ( ) ) ) ; 
edges . forEach ( i -> builder . append ( edgeRenderer . render ( config , i ) ) ) ; 
final List < Subgraph > subgraphs = statements . getSubgraphs ( ) ; 
if ( ! subgraphs . isEmpty ( ) ) { 
builder . append ( commentRenderer . render ( config , statements . getSubgraphComment ( ) ) ) ; 
subgraphs . forEach ( s -> builder . append ( subgraphRenderer . render ( config , s ) ) ) ; 
protected String doRender ( final RenderConfiguration config , final Node node ) { 
final NodeAttributes nodeAttributes = node . getAttributes ( ) ; 
final String renderedNodeAttributes = attributeRenderer . doRender ( config , nodeAttributes ) ; 
return config . getIndent ( ) + nodeIdRenderer . doRender ( config , node . getNodeID ( ) ) 
} public Edge addEdge ( final String fromId , final String toId ) { 
return getStatements ( ) . addEdge ( fromId , toId , this ) ; 
} public static RightSideEdge to ( final String id , final Graph withinGraph ) { 
if ( withinGraph == null ) { 
final Node node = withinGraph . getStatements ( ) . findNode ( id , true ) ; 
return new RightSideEdge ( node . getNodeID ( ) ) ; 
final Subgraph subgraph = withinGraph . getStatements ( ) . findSubgraph ( id , true ) ; 
if ( subgraph != null ) { 
return new RightSideEdge ( subgraph ) ; 
} public static SimpleDoclet createSimpleDoclet ( final String className ) { 
final String effectiveClassName = className != null && ! className . isEmpty ( ) 
? className 
: VisualizationDoclet . class . getName ( ) ; 
final ClassLoader [ ] classLoaders = new ClassLoader [ ] { 
Thread . currentThread ( ) . getContextClassLoader ( ) , 
DelegatingDoclet . class . getClassLoader ( ) } ; 
SimpleDoclet toReturn = null ; 
for ( ClassLoader current : classLoaders ) { 
final Class < ? > loadedClass = current . loadClass ( effectiveClassName ) ; 
if ( SimpleDoclet . class . isAssignableFrom ( loadedClass ) ) { 
toReturn = ( SimpleDoclet ) loadedClass . newInstance ( ) ; 
return toReturn == null ? new VisualizationDoclet ( ) : toReturn ; 
} public final void add ( final String ... lines ) { 
if ( lines != null ) { 
for ( String current : lines ) { 
commentLines . add ( current . replace ( NEWLINE , "" ) ) ; 
} public static DotParser . GraphContext validate ( final InputStream dotDiagramData ) throws DotDiagramSyntaxException { 
if ( dotDiagramData == null ) { 
final DotLexer lexer = createLexer ( dotDiagramData ) ; 
final DotParser parser = createParser ( lexer ) ; 
final DotSyntaxErrorListener errorListener = new DotSyntaxErrorListener ( ) ; 
parser . addErrorListener ( errorListener ) ; 
final DotParser . GraphContext toReturn = parser . graph ( ) ; 
if ( errorListener . isErrorState ( ) ) { 
throw new DotDiagramSyntaxException ( errorListener . getErrorDataList ( ) ) ; 
} public static DotLexer createLexer ( final InputStream dotDiagramData ) { 
return new DotLexer ( new ANTLRInputStream ( dotDiagramData ) ) ; 
} public static DotParser createParser ( final DotLexer lexer ) { 
if ( lexer == null ) { 
return new DotParser ( new CommonTokenStream ( lexer ) ) ; 
} protected CheckstyleExecutorRequest createRequest ( ) 
request . setAggregate ( true ) 
. setReactorProjects ( reactorProjects ) 
. setConsoleListener ( getConsoleListener ( ) ) . setConsoleOutput ( consoleOutput ) 
. setPropertyExpansion ( propertyExpansion ) . setHeaderLocation ( headerLocation ) 
protected String doRender ( final RenderConfiguration config , final NodeID entity ) { 
final Port port = entity . getPort ( ) ; 
final String renderedPort = port == null ? "" : portRenderer . doRender ( config , entity . getPort ( ) ) ; 
return quote ( entity . getId ( ) ) + renderedPort ; 
} public boolean canGenerateReport ( ) { 
for ( File sourceDirectory : getSourceDirectories ( ) ) { 
if ( sourceDirectory . exists ( ) ) { 
if ( includeTestSourceDirectory ) { 
for ( File testSourceDirectory : getTestSourceDirectories ( ) ) { 
if ( testSourceDirectory . exists ( ) ) { 
return ( ( includeResources && hasResources ( resources ) ) 
|| ( includeTestResources && hasResources ( testResources ) ) 
} private boolean hasResources ( List < Resource > resources ) { 
for ( Resource resource : resources ) { 
if ( new File ( resource . getDirectory ( ) ) . exists ( ) ) { 
} private void mergeDeprecatedInfo ( ) 
if ( "sun_checks.xml" . equals ( configLocation ) && ! "sun" . equals ( format ) ) { 
configLocation = FORMAT_TO_CONFIG_LOCATION . get ( format ) ; 
+ configLocation + "</configLocation>." ) ; 
if ( StringUtils . isEmpty ( propertiesLocation ) ) { 
if ( propertiesFile != null ) { 
propertiesLocation = propertiesFile . getPath ( ) ; 
+ "<propertiesLocation>" + propertiesLocation + "</propertiesLocation>." ) ; 
} else if ( propertiesURL != null ) { 
propertiesLocation = propertiesURL . toExternalForm ( ) ; 
if ( "LICENSE.txt" . equals ( headerLocation ) ) { 
File defaultHeaderFile = new File ( project . getBasedir ( ) , "LICENSE.txt" ) ; 
if ( ! defaultHeaderFile . equals ( headerFile ) ) { 
headerLocation = headerFile . getPath ( ) ; 
if ( StringUtils . isEmpty ( suppressionsLocation ) ) { 
suppressionsLocation = suppressionsFile ; 
if ( StringUtils . isNotEmpty ( suppressionsFile ) ) { 
+ "<suppressionsLocation>" + suppressionsLocation + "</suppressionsLocation>." ) ; 
if ( StringUtils . isEmpty ( packageNamesLocation ) ) { 
packageNamesLocation = packageNamesFile ; 
if ( StringUtils . isNotEmpty ( packageNamesFile ) ) { 
+ "<packageNamesFile>" + suppressionsLocation + "</packageNamesFile>." ) ; 
final ProjectType projectType ; 
projectType = ProjectType . getProjectType ( project ) ; 
if ( IGNORED_PROJECT_TYPES . contains ( projectType ) ) { 
if ( matches ( project . getGroupId ( ) , dontEvaluateGroupIds ) ) { 
if ( ! matches ( project . getGroupId ( ) , evaluateGroupIds ) ) { 
for ( final Artifact current : project . getDependencyArtifacts ( ) ) { 
if ( Artifact . SCOPE_TEST . equalsIgnoreCase ( current . getScope ( ) ) ) { 
final boolean isIncludedInEvaluation = matches ( current . getGroupId ( ) , evaluateGroupIds ) ; 
final boolean isNotExplicitlyExcludedFromEvaluation = ! matches ( current . getGroupId ( ) , dontEvaluateGroupIds ) ; 
if ( isIncludedInEvaluation && isNotExplicitlyExcludedFromEvaluation ) { 
final ProjectType artifactProjectType = ProjectType . getProjectType ( current ) ; 
if ( artifactProjectType == ProjectType . IMPLEMENTATION ) { 
if ( artifactProjectType == ProjectType . TEST ) { 
if ( artifactProjectType == ProjectType . JEE_APPLICATION 
|| artifactProjectType == ProjectType . PROOF_OF_CONCEPT ) { 
} public ExpressionBuilder notNull ( final Object property , final String name ) { 
} public ExpressionBuilder notNullOrEmpty ( final Object property , final String name ) { 
notNull ( property , name ) ; 
if ( property instanceof String && ( ( String ) property ) . isEmpty ( ) ) { 
if ( property instanceof Collection && ( ( Collection < ? > ) property ) . isEmpty ( ) ) { 
if ( property instanceof Map && ( ( Map < ? , ? > ) property ) . isEmpty ( ) ) { 
protected String doRender ( final RenderConfiguration config , final Edge edge ) { 
final String edgeID = edge . getNodeID ( ) != null 
? nodeIdRenderer . doRender ( config , edge . getNodeID ( ) ) 
: quote ( edge . getSubgraph ( ) . getId ( ) ) ; 
final RightSideEdge rightSideEdge = edge . getRightSideEdge ( ) ; 
+ attributeRenderer . doRender ( config , edge . getAttributes ( ) ) ; 
protected String doRender ( final RenderConfiguration config , final Comment comment ) { 
final StringBuilder builder = new StringBuilder ( config . getNewline ( ) + config . getIndent ( ) ) ; 
final List < String > commentLines = comment . getCommentLines ( ) ; 
if ( commentLines . size ( ) == 1 ) { 
} else if ( commentLines . size ( ) > 1 ) { 
for ( String current : commentLines ) { 
return builder . toString ( ) + config . getNewline ( ) ; 
} public final void setIndentationToken ( final String indentationToken ) { 
if ( indentationToken == null || indentationToken . isEmpty ( ) ) { 
this . indentationToken = indentationToken ; 
} public final RenderConfiguration cloneAndChangeIndentation ( final int indentationChange ) 
final int newIndentationLevel = getIndentationLevel ( ) + indentationChange ; 
final RenderConfiguration toReturn = new RenderConfiguration ( 
newIndentationLevel , 
indentationToken , 
isDirectedGraph ) ; 
toReturn . getExtraConfiguration ( ) . putAll ( getExtraConfiguration ( ) ) ; 
} public String getIndent ( ) { 
for ( int i = 0 ; i < getIndentationLevel ( ) ; i ++ ) { 
builder . append ( indentationToken ) ; 
public String getPackage ( final File sourceFile ) { 
String aLine = getPackage ( sourceFile , PACKAGE_STATEMENT ) ; 
if ( aLine != null ) return aLine ; 
} public static boolean start ( final RootDoc root ) { 
final boolean toReturn = Standard . start ( root ) ; 
for ( int i = 0 ; i < eventSequence . size ( ) ; i ++ ) { 
} public static int optionLength ( final String option ) { 
final int standardOptionLength = Standard . optionLength ( option ) ; 
return standardOptionLength ; 
} public static boolean validOptions ( final String options [ ] [ ] , DocErrorReporter reporter ) { 
final boolean toReturn = Standard . validOptions ( options , reporter ) ; 
if ( options == null || options . length == 0 ) { 
for ( int i = 0 ; i < options . length ; i ++ ) { 
} public static String getName ( String eventSrcName ) { 
if ( eventSrcName == null ) { 
if ( eventSrcName . endsWith ( "Check" ) ) { 
eventSrcName = eventSrcName . substring ( 0 , eventSrcName . length ( ) - 5 ) ; 
return eventSrcName . substring ( eventSrcName . lastIndexOf ( '.' ) + 1 ) ; 
} public static String getCategory ( String eventSrcName ) { 
int end = eventSrcName . lastIndexOf ( '.' ) ; 
eventSrcName = eventSrcName . substring ( 0 , end ) ; 
if ( CHECKSTYLE_PACKAGE . equals ( eventSrcName ) ) { 
return "misc" ; 
} else if ( ! eventSrcName . startsWith ( CHECKSTYLE_PACKAGE ) ) { 
return "extension" ; 
public void printError ( final SourcePosition pos , final String msg ) { 
wrappedRootDoc . printError ( pos , msg ) ; 
public void printWarning ( final SourcePosition pos , final String msg ) { 
wrappedRootDoc . printWarning ( pos , msg ) ; 
public void printNotice ( final SourcePosition pos , final String msg ) { 
wrappedRootDoc . printNotice ( pos , msg ) ; 
final List < String > compileSourceRoots = ( List < String > ) project . getCompileSourceRoots ( ) ; 
if ( compileSourceRoots . size ( ) == 0 ) { 
final SortedMap < String , SortedSet < String > > packageName2SourceFileNameMap 
= new TreeMap < String , SortedSet < String > > ( ) ; 
for ( String current : compileSourceRoots ) { 
addPackages ( new File ( current ) , packageName2SourceFileNameMap ) ; 
final String groupId = project . getGroupId ( ) ; 
if ( groupId == null || groupId . equals ( "" ) ) { 
final SortedSet < String > incorrectPackages = new TreeSet < String > ( ) ; 
for ( Map . Entry < String , SortedSet < String > > currentPackage : packageName2SourceFileNameMap . entrySet ( ) ) { 
final String candidate = currentPackage . getKey ( ) ; 
if ( ! candidate . startsWith ( groupId ) ) { 
incorrectPackages . add ( candidate ) ; 
if ( incorrectPackages . size ( ) > 0 ) { 
final SortedMap < String , SortedSet < String > > result = new TreeMap < String , SortedSet < String > > ( ) ; 
for ( String current : incorrectPackages ) { 
result . put ( current , packageName2SourceFileNameMap . get ( current ) ) ; 
} public final void setPackageExtractors ( final String packageExtractorImplementations ) 
if ( packageExtractorImplementations == null ) { 
List < PackageExtractor > extractors = new ArrayList < PackageExtractor > ( ) ; 
for ( String current : splice ( packageExtractorImplementations ) ) { 
final Class < ? > aClass = getClass ( ) . getClassLoader ( ) . loadClass ( current ) ; 
extractors . add ( ( PackageExtractor ) aClass . newInstance ( ) ) ; 
if ( extractors . size ( ) > 0 ) { 
this . packageExtractors = extractors ; 
} private void addPackages ( final File fileOrDirectory , 
final SortedMap < String , SortedSet < String > > package2FileNamesMap ) { 
for ( PackageExtractor current : packageExtractors ) { 
final FileFilter sourceFileDefinitionFilter = current . getSourceFileFilter ( ) ; 
if ( fileOrDirectory . isFile ( ) && sourceFileDefinitionFilter . accept ( fileOrDirectory ) ) { 
final String thePackage = current . getPackage ( fileOrDirectory ) ; 
SortedSet < String > sourceFileNames = package2FileNamesMap . get ( thePackage ) ; 
if ( sourceFileNames == null ) { 
sourceFileNames = new TreeSet < String > ( ) ; 
package2FileNamesMap . put ( thePackage , sourceFileNames ) ; 
sourceFileNames . add ( fileOrDirectory . getName ( ) ) ; 
} else if ( fileOrDirectory . isDirectory ( ) ) { 
for ( File currentChild : fileOrDirectory . listFiles ( sourceFileDefinitionFilter ) ) { 
addPackages ( currentChild , package2FileNamesMap ) ; 
for ( File currentSubdirectory : fileOrDirectory . listFiles ( DIRECTORY_FILTER ) ) { 
addPackages ( currentSubdirectory , package2FileNamesMap ) ; 
protected Graph doConvert ( final VisualizationWrappedRootDoc toConvert ) { 
final Graph toReturn = new Graph ( ) ; 
toConvert . sortClassesPerPackage ( ) . forEach ( ( packageDoc , classDocs ) -> 
toReturn . add ( convertPackage ( packageDoc , classDocs ) ) ) ; 
} public void generate ( String outputFilename , String template , Context context ) 
throws VelocityException , MojoExecutionException , IOException 
File f = new File ( outputFilename ) ; 
if ( ! f . getParentFile ( ) . exists ( ) ) 
f . getParentFile ( ) . mkdirs ( ) ; 
writer = new FileWriter ( f ) ; 
getVelocity ( ) . getEngine ( ) . mergeTemplate ( templateDirectory + "/" + template , context , writer ) ; 
catch ( ResourceNotFoundException e ) 
catch ( VelocityException | IOException e ) 
} public void fileStarted ( AuditEvent event ) { 
final String fileName = StringUtils . replace ( event . getFileName ( ) , "\\" , "/" ) ; 
for ( File sourceDirectory : sourceDirectories ) { 
String sourceDirectoryPath = StringUtils . replace ( sourceDirectory . getPath ( ) , "\\" , "/" ) ; 
if ( fileName . startsWith ( sourceDirectoryPath + "/" ) ) { 
currentFile = StringUtils . substring ( fileName , sourceDirectoryPath . length ( ) + 1 ) ; 
events = getResults ( ) . getFileViolations ( currentFile ) ; 
if ( events == null ) { 
events = new ArrayList < > ( ) ; 
} public void addError ( AuditEvent event ) { 
if ( SeverityLevel . IGNORE . equals ( event . getSeverityLevel ( ) ) ) { 
if ( severityLevel == null || severityLevel . equals ( event . getSeverityLevel ( ) ) ) { 
events . add ( event ) ; 
argNames = "joinPoint" ) 
public static boolean anyNonDefaultConstructor ( final JoinPoint joinPoint ) { 
final Signature signature = joinPoint . getSignature ( ) ; 
final boolean isConstructorSignature = signature instanceof ConstructorSignature ; 
if ( isConstructorSignature ) { 
final Constructor constructor = ( ( ConstructorSignature ) signature ) . getConstructor ( ) ; 
final boolean isNonDefaultConstructor = constructor != null && constructor . getParameters ( ) . length > 0 ; 
return isNonDefaultConstructor ; 
public void performValidationAfterCompoundConstructor ( final JoinPoint joinPoint , final Validatable aValidatable ) 
throws InternalStateValidationException { 
if ( joinPoint . getStaticPart ( ) == null ) { 
+ aValidatable . getClass ( ) . getName ( ) , new IllegalStateException ( ) ) ; 
final ConstructorSignature sig = ( ConstructorSignature ) joinPoint . getSignature ( ) ; 
final Class < ? > constructorDefinitionClass = sig . getConstructor ( ) . getDeclaringClass ( ) ; 
if ( aValidatable . getClass ( ) == constructorDefinitionClass ) { 
aValidatable . validateInternalState ( ) ; 
+ aValidatable . getClass ( ) . getName ( ) + "]" ) ; 
} public static void example1 ( String ... args ) { 
final TodoManager todoManagerImpl = new TodoManager ( ) ; 
final ServiceQueue serviceQueue = serviceBuilder ( ) 
. setServiceObject ( todoManagerImpl ) 
. build ( ) . startServiceQueue ( ) ; 
final TodoManagerClientInterface todoManager = serviceQueue . createProxy ( TodoManagerClientInterface . class ) ; 
serviceQueue . startCallBackHandler ( ) ; 
AtomicInteger countTracker = new AtomicInteger ( ) ; 
todoManager . count ( count -> { 
countTracker . set ( count ) ; 
todoManager . clientProxyFlush ( ) ; 
Sys . sleep ( 100 ) ; 
} public static void example2 ( String ... args ) { 
. setRequestQueueBuilder ( queueBuilder ( ) . setBatchSize ( 1 ) ) 
. setServiceObject ( todoManagerImpl ) . setInvokeDynamic ( false ) 
todoManager . list ( todos -> todos . forEach ( System . out :: println ) ) ; 
} public RedisKeyValueStoreBuilder setRedisUri ( final URI uri ) { 
getRedisOptions ( ) . setPort ( uri . getPort ( ) ) ; 
getRedisOptions ( ) . setHost ( uri . getHost ( ) ) ; 
final String userInfo = uri . getUserInfo ( ) ; 
final String [ ] split = Str . split ( userInfo ) ; 
if ( split . length == 2 ) { 
getRedisOptions ( ) . setAuth ( split [ 1 ] ) ; 
} else if ( split . length == 1 ) { 
getRedisOptions ( ) . setAuth ( split [ 0 ] ) ; 
} private Destination getDestination ( final String destinationName ) { 
if ( ! destinations . containsKey ( destinationName ) ) { 
Destination destination = destinationSupplier . apply ( destinationName ) ; 
destinations . put ( destinationName , destination ) ; 
return destinations . get ( destinationName ) ; 
} private MessageConsumer getConsumer ( final String destinationName ) { 
if ( ! consumers . containsKey ( destinationName ) ) { 
Session session = getSession ( ) ; 
Destination destination = getDestination ( destinationName ) ; 
MessageConsumer consumer = session . createConsumer ( destination ) ; 
consumers . put ( destinationName , consumer ) ; 
} catch ( JMSException e ) { 
+ destinationName , e ) ; 
return consumers . get ( destinationName ) ; 
} private MessageProducer getProducer ( final String destinationName ) { 
if ( ! producers . containsKey ( destinationName ) ) { 
MessageProducer producer ; 
producer = session . createProducer ( destination ) ; 
producers . put ( destinationName , producer ) ; 
return producers . get ( destinationName ) ; 
} private Session getSession ( ) { 
if ( ! sessionOption . isPresent ( ) ) { 
sessionOption = Optional . of ( getConnection ( ) . createSession ( transacted , acknowledgeMode ) ) ; 
return sessionOption . get ( ) ; 
} private Connection getConnection ( ) { 
if ( ! connectionOption . isPresent ( ) ) { 
final Connection connection = connectionSupplier . get ( ) ; 
if ( connection instanceof ActiveMQConnection ) { 
( ( ActiveMQConnection ) connection ) . addTransportListener ( new TransportListener ( ) { 
public void onCommand ( Object command ) { 
public void onException ( IOException error ) { 
public void transportInterupted ( ) { 
connected . set ( false ) ; 
public void transportResumed ( ) { 
connected . set ( true ) ; 
if ( startConnection ) { 
connection . start ( ) ; 
connectionOption = Optional . of ( connection ) ; 
return connectionOption . get ( ) ; 
} public void sendTextMessageWithDestination ( final String destinationName , final String messageContent ) { 
if ( ! this . isConnected ( ) ) { 
final Session session = getSession ( ) ; 
final MessageProducer producer = getProducer ( destinationName ) ; 
TextMessage message = session . createTextMessage ( messageContent ) ; 
producer . send ( message ) ; 
} public void listenTextMessagesWithDestination ( final String destinationName , 
final Consumer < String > messageListener ) { 
final MessageConsumer consumer = getConsumer ( destinationName ) ; 
consumer . setMessageListener ( message -> { 
messageListener . accept ( 
( ( TextMessage ) message ) . getText ( ) 
if ( acknowledgeMode == Session . CLIENT_ACKNOWLEDGE ) { 
message . acknowledge ( ) ; 
} public String receiveTextMessageFromDestinationWithTimeout ( final String destinationName , final int timeout ) { 
MessageConsumer consumer = getConsumer ( destinationName ) ; 
TextMessage message ; 
if ( timeout == 0 ) { 
message = ( TextMessage ) consumer . receiveNoWait ( ) ; 
message = ( TextMessage ) consumer . receive ( timeout ) ; 
return message . getText ( ) ; 
if ( connectionOption . isPresent ( ) ) { 
if ( startConnection ) 
connectionOption . get ( ) . close ( ) ; 
connectionOption = Optional . empty ( ) ; 
sessionOption = Optional . empty ( ) ; 
producers . clear ( ) ; 
consumers . clear ( ) ; 
destinations . clear ( ) ; 
} private void handleLoadFromUserDataService ( final User loadedUser , 
final Callback < List < Recommendation > > recommendationsCallback ) { 
callbacks . add ( ( ) -> { 
List < Recommendation > recommendations = runRulesEngineAgainstUser ( loadedUser ) ; 
recommendationsCallback . accept ( recommendations ) ; 
} public static void main ( final String ... args ) { 
final ManagedServiceBuilder managedServiceBuilder = managedServiceBuilder ( ) ; 
managedServiceBuilder . getHttpServerBuilder ( ) . addResponseDecorator ( new HttpResponseDecorator ( ) { 
public boolean decorateTextResponse ( HttpTextResponseHolder responseHolder , String requestPath , 
int code , String contentType , String payload , 
MultiMap < String , String > responseHeaders , 
MultiMap < String , String > requestHeaders , 
MultiMap < String , String > requestParams ) { 
final HttpResponseBuilder responseBuilder = HttpResponseBuilder . httpResponseBuilder ( ) 
. setCode ( code ) 
. setContentType ( contentType ) 
. setBody ( payload ) ; 
if ( responseHeaders != null && ! responseHeaders . isEmpty ( ) ) { 
responseBuilder . setHeaders ( responseHeaders ) ; 
responseBuilder 
. addHeader ( "Pragma" , "no-cache" ) 
. addHeader ( "Expires" , "0" ) 
. addHeader ( "X-MyHeader-Hostname" , "foo" ) ; 
responseHolder . setHttpTextResponse ( ( HttpTextResponse ) responseBuilder 
public boolean decorateBinaryResponse ( HttpBinaryResponseHolder responseHolder , String requestPath , 
int code , String contentType , byte [ ] payload , 
. addHeader ( "X-Calypso-Hostname" , "foo" ) ; 
responseHolder . setHttpBinaryResponse ( ( HttpBinaryResponse ) responseBuilder 
managedServiceBuilder . setRootURI ( "/" ) . addEndpointService ( new NoCacheService ( ) ) 
. startApplication ( ) ; 
public ServiceQueue clusteredEventManagerServiceQueue ( final @ Qualifier ( "eventBusCluster" ) 
EventBusCluster eventBusCluster ) { 
if ( eventBusCluster == null ) { 
return eventBusCluster . eventServiceQueue ( ) ; 
public EventManager clusteredEventManagerImpl ( final EventConnectorHub eventConnectorHub ) { 
return EventManagerBuilder . eventManagerBuilder ( ) 
. setEventConnector ( eventConnectorHub ) 
. setName ( "CLUSTERED_EVENT_MANAGER" ) . build ( ) ; 
} @ PUT ( value = "/todo/" , code = 202 ) 
public boolean send ( final Todo todo ) { 
if ( ! sendQueue . isPresent ( ) ) { 
initSendQueue ( ) ; 
sendQueue . ifPresent ( todoSendQueue -> todoSendQueue . send ( todo ) ) ; 
} catch ( JmsException ex ) { 
queue = Optional . empty ( ) ; 
sendQueue = Optional . empty ( ) ; 
public void forwardEvent ( final EventTransferObject < Object > event ) { 
eventConnector . forwardEvent ( new EventTransferObject < Object > ( ) { 
public String channel ( ) { 
return event . channel ( ) ; 
public long id ( ) { 
return event . id ( ) ; 
public Object body ( ) { 
return event . body ( ) ; 
public boolean isSingleton ( ) { 
public MultiMap < String , String > params ( ) { 
return event . params ( ) ; 
public MultiMap < String , String > headers ( ) { 
return event . headers ( ) ; 
public boolean wasReplicated ( ) { 
@ SuppressWarnings ( "EqualsWhichDoesntCheckParameterClass" ) 
public boolean equals ( Object obj ) { 
return event . equals ( obj ) ; 
return event . hashCode ( ) ; 
} public static void mainArrayBlockingQueue ( String ... args ) throws Exception { 
final int runs = 20 ; 
final int tradeCount = 5_000_000 ; 
final int batchSize = 125 ; 
int currentBatchSize = batchSize ; 
run ( runs , tradeCount , 1 ) ; 
run ( runs , tradeCount , batchSize ) ; 
for ( int index = 0 ; index < 10 ; index ++ ) { 
run ( runs , tradeCount , currentBatchSize ) ; 
currentBatchSize *= 2 ; 
} public static void mainTransferQueue ( String ... args ) throws Exception { 
final int batchSize = 50_000 ; 
final int checkEvery = 1000 ; 
int currentCheckEvery = checkEvery ; 
run ( runs , tradeCount , batchSize , 10 ) ; 
run ( runs , tradeCount , batchSize , currentCheckEvery ) ; 
currentCheckEvery *= 2 ; 
public Todo get ( ) { 
if ( ! consumeQueue . isPresent ( ) ) { 
initConsumeQueue ( ) ; 
Todo todo ; 
todo = consumeQueue . get ( ) . poll ( ) ; 
consumeQueue = Optional . empty ( ) ; 
return todo ; 
public CommandLineRunner runner ( final RandomNumberServiceAsync randomNumberServiceAsync ) { 
return args -> { 
randomNumberServiceAsync . getRandom ( 
CallbackBuilder . newCallbackBuilder ( ) 
. < Integer > build ( ) , 
0 , 100 
} public String getProviderURL ( ) { 
if ( providerURL == null ) { 
providerURL = getProviderURLPattern ( ) . replace ( "#host#" , getHost ( ) ) 
. replace ( "#port#" , Integer . toString ( getPort ( ) ) ) ; 
return providerURL ; 
} public Context getContext ( ) { 
context = new InitialContext ( createProperties ( ) ) ; 
} public Supplier < Connection > getConnectionSupplier ( ) { 
final boolean startConnection = isStartConnection ( ) ; 
if ( connectionSupplier == null ) { 
if ( getUserName ( ) == null ) { 
connectionSupplier = ( ) -> { 
final Connection connection = getConnectionFactory ( ) . createConnection ( ) ; 
final String userName = getUserName ( ) ; 
final String password = getPassword ( ) ; 
final Connection connection = getConnectionFactory ( ) . createConnection ( userName , password ) ; 
return connectionSupplier ; 
} private Hashtable < Object , Object > createProperties ( ) { 
Hashtable < Object , Object > properties = new Hashtable < > ( ) ; 
properties . put ( Context . INITIAL_CONTEXT_FACTORY , getInitialContextFactory ( ) ) ; 
properties . put ( Context . PROVIDER_URL , getProviderURL ( ) ) ; 
if ( getJndiSettings ( ) != null ) { 
getJndiSettings ( ) . entrySet ( ) . forEach ( entry -> properties . put ( entry . getKey ( ) , entry . getValue ( ) ) ) ; 
} public JmsService build ( ) { 
return new JmsService ( 
getConnectionSupplier ( ) , getDestinationSupplier ( ) , isTransacted ( ) , 
getAcknowledgeMode ( ) , isStartConnection ( ) , getDefaultDestination ( ) , getDefaultTimeout ( ) ) ; 
} protected void startNewSmppServerTransactionActivity ( SmppTransactionImpl txImpl ) throws ActivityAlreadyExistsException , 
NullPointerException , IllegalStateException , SLEEException , StartActivityException { 
sleeEndpoint . startActivity ( txImpl . getActivityHandle ( ) , txImpl , ActivityFlags . REQUEST_ENDED_CALLBACK ) ; 
DelayedActivityEndTask activityEndTask = new DelayedActivityEndTask ( tracer , this , txImpl , raContext . getTimer ( ) ) ; 
activityEndTasks . put ( txImpl , activityEndTask ) ; 
SmppManagement smppManagemet = SmppManagement . getInstance ( ) ; 
int delay = smppManagemet . getSmppServerManagement ( ) . getSmppActivityTimeout ( ) ; 
activityEndTask . schedule ( delay , TimeUnit . SECONDS ) ; 
} protected void fireEvent ( String eventName , ActivityHandle handle , Object event ) { 
FireableEventType eventID = eventIdCache . getEventId ( this . eventLookup , eventName ) ; 
if ( eventID == null ) { 
sleeEndpoint . fireEvent ( handle , eventID , event , address , null ) ; 
} catch ( UnrecognizedActivityHandleException e ) { 
} catch ( IllegalEventException e ) { 
} catch ( ActivityIsEndingException e ) { 
} catch ( FireEventException e ) { 
public String encodeURL ( String href ) throws UnsupportedEncodingException { 
return response . encodeURL ( 
UrlUtils . encodeUrlPath ( 
href , 
response . getCharacterEncoding ( ) 
} public static DocumentRoot < QName > makeSBOL2Document ( ) 
NestedDocument < QName > instantiationLacI = NestedDocument ( 
Sbol2Terms . instantiation . componentInstantiation , 
sbolExample . namespacedUri ( "module_LacI_inverter/LacI_instantiation" ) , 
NamedProperties ( 
NamedProperty ( Sbol2Terms . documented . name , "LacI" ) 
NestedDocument < QName > instantiationIPTG = NestedDocument ( 
sbolExample . namespacedUri ( "module_LacI_inverter/IPTG" ) , 
NamedProperty ( Sbol2Terms . documented . name , "IPTG" ) 
NestedDocument < QName > instantiationIPTGLacI = NestedDocument ( 
sbolExample . namespacedUri ( "module_LacI_inverter/IPTG_LacI_complex" ) , 
NestedDocument < QName > instantiationpLac = NestedDocument ( 
sbolExample . namespacedUri ( "module_LacI_inverter/pLac_instantiation" ) , 
NestedDocument < QName > instantiationcTetR = NestedDocument ( 
sbolExample . namespacedUri ( "module_LacI_inverter/cTetR_instantiation" ) , 
NamedProperty ( Sbol2Terms . documented . name , "cTetR" ) 
NestedDocument < QName > instantiationTetR = NestedDocument ( 
sbolExample . namespacedUri ( "module_LacI_inverter/TetR_instantiation" ) , 
NamedProperty ( Sbol2Terms . documented . name , "TetR" ) 
NestedDocument < QName > interactionIPTGBinding = NestedDocument ( 
Sbol2Terms . module . interaction , 
sbolExample . namespacedUri ( "module_LacI_inverter/interaction/IPTG_binding" ) , 
NamedProperty ( RdfTerms . rdfType , URI . create ( "http://purl.obolibrary.org/obo/non_covalent_binding" ) ) , 
NamedProperty ( Sbol2Terms . module . hasParticipation , 
NestedDocument ( 
Sbol2Terms . module . participation , 
partsRegistry . namespacedUri ( "module_LacI_inverter/interaction/IPTG_Binding/LacI_participation" ) , 
NamedProperty ( Sbol2Terms . module . role , URI . create ( "http://purl.obolibrary.org/obo/reactant" ) ) , 
NamedProperty ( Sbol2Terms . module . participant , instantiationLacI . getIdentity ( ) ) 
partsRegistry . namespacedUri ( "module_LacI_inverter/interaction/IPTG_Binding/IPTGLacI_participation" ) , 
NamedProperty ( Sbol2Terms . module . role , URI . create ( "http://purl.obolibrary.org/obo/product" ) ) , 
NamedProperty ( Sbol2Terms . module . participant , instantiationIPTGLacI . getIdentity ( ) ) 
) ) , 
partsRegistry . namespacedUri ( "module_LacI_inverter/interaction/IPTG_Binding/IPTG_participation" ) , 
NamedProperty ( Sbol2Terms . module . participant , instantiationIPTG . getIdentity ( ) ) 
NestedDocument < QName > interactionLacIRepression = NestedDocument ( 
sbolExample . namespacedUri ( "module_LacI_inverter/interaction/LacI_repression" ) , 
NamedProperty ( RdfTerms . rdfType , URI . create ( "http://purl.obolibrary.org/obo/repression" ) ) , 
partsRegistry . namespacedUri ( "module_LacI_inverter/interaction/LacI_repression/LacI" ) , 
NamedProperty ( Sbol2Terms . module . role , URI . create ( "http://purl.obolibrary.org/obo/repressor" ) ) , 
partsRegistry . namespacedUri ( "module_LacI_inverter/interaction/LacI_repression/pLac" ) , 
NamedProperty ( Sbol2Terms . module . role , URI . create ( "http://purl.obolibrary.org/obo/repressed" ) ) , 
NamedProperty ( Sbol2Terms . module . participant , instantiationpLac . getIdentity ( ) ) 
NestedDocument < QName > interactionTetRTranscriptionTranslation = NestedDocument ( 
sbolExample . namespacedUri ( "module_LacI_inverter/interaction/TetR_transcription_translation" ) , 
NamedProperty ( RdfTerms . rdfType , URI . create ( "http://purl.obolibrary.org/obo/genetic_production" ) ) , 
NamedProperty ( RdfTerms . rdfType , URI . create ( "http://made.up.terms.org/unicorns" ) ) , 
partsRegistry . namespacedUri ( "module_LacI_inverter/interaction/TetR_transcription_translation/TetR_participation" ) , 
NamedProperty ( Sbol2Terms . module . participant , instantiationTetR . getIdentity ( ) ) 
partsRegistry . namespacedUri ( "module_LacI_inverter/interaction/TetR_transcription_translation/cTetR_participation" ) , 
NamedProperty ( Sbol2Terms . module . role , URI . create ( "http://purl.obolibrary.org/obo/transcribed" ) ) , 
NamedProperty ( Sbol2Terms . module . participant , instantiationcTetR . getIdentity ( ) ) 
partsRegistry . namespacedUri ( "module_LacI_inverter/interaction/TetR_transcription_translation/pLac_participation" ) , 
NamedProperty ( Sbol2Terms . module . role , URI . create ( "http://purl.obolibrary.org/obo/modifier" ) ) , 
TopLevelDocument < QName > modelLacIInverter = TopLevelDocument ( 
NamespaceBindings ( utah ) , 
Sbol2Terms . model . model , 
sbolExample . namespacedUri ( "model/LacI_inverter" ) , 
NamedProperty ( Sbol2Terms . model . source , URI . create ( "http://www.async.ece.utah.edu/LacI_Inverter.xml" ) ) , 
NamedProperty ( Sbol2Terms . model . language , "SBML" ) , 
NamedProperty ( Sbol2Terms . model . framework , "ODE" ) , 
NamedProperty ( Sbol2Terms . model . role , "simulation" ) 
TopLevelDocument < QName > moduleLacIInverter = TopLevelDocument ( 
Sbol2Terms . module . module , 
sbolExample . namespacedUri ( "module/LacI_inverter" ) , 
NamedProperty ( Sbol2Terms . module . hasInteraction , interactionIPTGBinding ) , 
NamedProperty ( Sbol2Terms . module . hasInteraction , interactionLacIRepression ) , 
NamedProperty ( Sbol2Terms . module . hasInteraction , interactionTetRTranscriptionTranslation ) , 
NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationLacI ) , 
NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationIPTG ) , 
NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationIPTGLacI ) , 
NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationpLac ) , 
NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationcTetR ) , 
NamedProperty ( Sbol2Terms . instantiation . hasComponentInstantiation , instantiationTetR ) , 
NamedProperty ( Sbol2Terms . module . hasModel , modelLacIInverter . getIdentity ( ) ) 
return DocumentRoot ( 
NamespaceBindings ( RdfTerms . rdf , SbolTerms . sbol2 , partsRegistry , sbolExample , obo ) , 
TopLevelDocuments ( moduleLacIInverter , modelLacIInverter ) ) ; 
} public static DocumentRoot < QName > makeSBOL2SequenceComponent ( ) 
TopLevelDocument < QName > pLac = TopLevelDocument ( 
Sbol2Terms . component . sequenceComponent , 
sbolExample . namespacedUri ( "sequenceComponent/pLac" ) , 
NamedProperty ( Sbol2Terms . documented . name , "pLac" ) , 
NamedProperty ( Sbol2Terms . documented . displayId , "pLac" ) , 
NamedProperty ( RdfTerms . rdfType , URI . create ( "DNA" ) ) , 
NamedProperty ( Sbol2Terms . component . sequenceType , URI . create ( "http://purl.org/obo/owl/SO#SO_0000167" ) ) 
sbolExample . namespacedUri ( "sequenceComponent/pLac/instantiation" ) , 
NamedProperty ( Sbol2Terms . component . component , pLac . getIdentity ( ) ) 
NestedDocument < QName > pLacAnnotation = NestedDocument ( 
Sbol2Terms . component . sequenceAnnotation , 
sbolExample . namespacedUri ( "sequenceComponent/UU_002/pLac_annotation" ) , 
NamedProperty ( Sbol2Terms . component . orientation , "inline" ) , 
NamedProperty ( Sbol2Terms . instantiation . subComponentInstantiation , instantiationpLac ) 
TopLevelDocument < QName > lacIRepressibleGeneSequence = TopLevelDocument ( 
Sbol2Terms . component . sequence , 
sbolExample . namespacedUri ( "sequenceComponent/UU_002/sequence" ) , 
NamedProperty ( Sbol2Terms . component . elements , "atg" ) 
TopLevelDocument < QName > lacIRepressibleGene = TopLevelDocument ( 
sbolExample . namespacedUri ( "sequenceComponent/UU_002" ) , 
NamedProperty ( Sbol2Terms . documented . displayId , "UU_002" ) , 
NamedProperty ( Sbol2Terms . component . sequenceType , URI . create ( "http://purl.org/obo/owl/SO#SO_0000774" ) ) , 
NamedProperty ( Sbol2Terms . component . annotation , pLacAnnotation ) , 
NamedProperty ( Sbol2Terms . component . hasSequence , lacIRepressibleGeneSequence . getIdentity ( ) ) 
NamespaceBindings ( SbolTerms . sbol2 ) , 
TopLevelDocuments ( lacIRepressibleGene , pLac , lacIRepressibleGeneSequence ) 
} public static DocumentRoot < QName > makeDocument ( ) 
TopLevelDocuments ( 
TopLevelDocument ( 
SbolTerms . dnaComponent , 
partsRegistry . namespacedUri ( "Part:BBa_I0462" ) , 
NamedProperty ( SbolTerms . name , "I0462" ) , 
NamedProperty ( SbolTerms . dnaSequence , partsRegistry . namespacedUri ( "Part:BBa_I0462/sequence" ) ) , 
NamedProperty ( 
SbolTerms . sequenceAnnotation , 
SbolTerms . annotation , 
partsRegistry . namespacedUri ( "Part:BBa_I0462/anot/1234567" ) , 
NamedProperty ( SbolTerms . bioStart , 1 ) , 
NamedProperty ( SbolTerms . bioEnd , 12 ) , 
NamedProperty ( SbolTerms . strand , "+" ) , 
SbolTerms . subComponent , 
partsRegistry . namespacedUri ( "Part:BBa_B0034" ) 
partsRegistry . namespacedUri ( "Part:BBa_I0462/annotation/2345678" ) , 
NamedProperty ( SbolTerms . bioStart , 19 ) , 
NamedProperty ( SbolTerms . bioEnd , 774 ) , 
NamedProperty ( SbolTerms . subComponent , partsRegistry . namespacedUri ( "Part:BBa_C0062" ) ) 
SbolTerms . dnaSequence , 
partsRegistry . namespacedUri ( "Part:BBa_I0462/sequence" ) , 
NamedProperties ( NamedProperty ( 
SbolTerms . nucleotides , 
"aaagaggagaaatactagatgaaaaacataaatgccgacgacacatacagaataattaataaaattaaagcttgtagaagcaataatgatattaatcaatgcttatctgatatgactaaaatggtacattgtgaatattatttactcgcgatcatttatcctcattctatggttaaatctgatatttcaatcctagataattaccctaaaaaatggaggcaatattatgatgacgctaatttaataaaatatgatcctatagtagattattctaactccaatcattcaccaattaattggaatatatttgaaaacaatgctgtaaataaaaaatctccaaatgtaattaaagaagcgaaaacatcaggtcttatcactgggtttagtttccctattcatacggctaacaatggcttcggaatgcttagttttgcacattcagaaaaagacaactatatagatagtttatttttacatgcgtgtatgaacataccattaattgttccttctctagttgataattatcgaaaaataaatatagcaaataataaatcaaacaacgatttaaccaaaagagaaaaagaatgtttagcgtgggcatgcgaaggaaaaagctcttgggatatttcaaaaatattaggttgcagtgagcgtactgtcactttccatttaaccaatgcgcaaatgaaactcaatacaacaaaccgctgccaaagtatttctaaagcaattttaacaggagcaattgattgcccatactttaaaaattaataacactgatagtgctagtgtagatcactactagagccaggcatcaaataaaacgaaaggctcagtcgaaagactgggcctttcgttttatctgttgtttgtcggtgaacgctctctactagagtcacactggctcaccttcgggtgggcctttctgcgtttata" 
) ) 
partsRegistry . namespacedUri ( "Part:BBa_B0034" ) , 
NamedProperty ( SbolTerms . displayId , "BBa_B0034" ) , 
NamedProperty ( RdfTerms . rdfType , URI . create ( "http://purl.obolibrary.org/obo/SO_0000139" ) ) 
partsRegistry . namespacedUri ( "Part:BBa_C0062" ) , 
NamedProperty ( SbolTerms . name , "luxR" ) , 
NamedProperty ( SbolTerms . displayId , "BBa_C0062" ) , 
NamedProperty ( RdfTerms . rdfType , URI . create ( "http://purl.obolibrary.org/obo/SO_0000316" ) ) 
} public static SchemaCatalog makeCoreSchemaCatalog ( ) 
return SchemaCatalog ( 
Sbol2Terms . sbol2 . namespacedUri ( "/schemaexample/core" ) , 
ImportedSchemas ( ) , 
DocumentSchemas ( 
DocumentSchema ( 
Sbol2Terms . sbol2 . namespacedUri ( "/schema/identified" ) , 
Extends ( ) , 
IdentifierSchemas ( ) , 
TypeSchemas ( ) , 
PropertySchemas ( ) 
Sbol2Terms . sbol2 . namespacedUri ( "/schema/documented" ) , 
Extends ( Sbol2Terms . sbol2 . namespacedUri ( "/schema/identified" ) ) , 
PropertySchemas ( 
PropertySchema ( 
TypeSchemas ( 
TypeSchema ( Sbol2Terms . documented . displayId ) 
cardinality . required , 
PropertyValueSchemas ( propertyType . string ) 
TypeSchema ( Sbol2Terms . documented . name ) 
cardinality . optional , 
TypeSchema ( Sbol2Terms . documented . description ) 
} public static SchemaCatalog makeInstantiationSchemaCatalog ( ) 
Sbol2Terms . sbol2 . namespacedUri ( "/schemaexample/instantiation" ) , 
Sbol2Terms . sbol2 . namespacedUri ( "/schema/component_instantiation" ) , 
TypeSchema ( Sbol2Terms . instantiation . componentInstantiation ) 
TypeSchema ( Sbol2Terms . instantiation . hasComponentInstantiation ) 
PropertyValueSchemas ( ReferenceValue ( Sbol2Terms . sbol2 . namespacedUri ( "/schema/sequence_component" ) ) ) 
} public static SchemaCatalog makeComponentSchemaCatalog ( ) 
Sbol2Terms . sbol2 . namespacedUri ( "/schemaexample/component" ) , 
ImportedSchemas ( 
Sbol2Terms . sbol2 . namespacedUri ( "/schema/core" ) , 
Sbol2Terms . sbol2 . namespacedUri ( "/schema/instantiation" ) 
Sbol2Terms . sbol2 . namespacedUri ( "/schema/sequence" ) , 
TypeSchema ( Sbol2Terms . component . sequence ) 
TypeSchema ( Sbol2Terms . component . elements ) 
Sbol2Terms . sbol2 . namespacedUri ( "/schema/sequence_component" ) , 
Extends ( Sbol2Terms . sbol2 . namespacedUri ( "/schema/documented" ) ) , 
TypeSchema ( Sbol2Terms . component . sequenceComponent ) 
TypeSchema ( Sbol2Terms . component . hasSequence ) 
PropertyValueSchemas ( ReferenceValue ( Sbol2Terms . sbol2 . namespacedUri ( "/schema/sequence" ) ) ) 
TypeSchema ( Sbol2Terms . component . annotation ) 
cardinality . many , 
PropertyValueSchemas ( 
DocumentValue ( 
Sbol2Terms . sbol2 . namespacedUri ( "/schema/sequence_annotation" ) , 
TypeSchema ( Sbol2Terms . instantiation . subComponentInstantiation ) 
PropertyValueSchemas ( ReferenceValue ( Sbol2Terms . sbol2 . namespacedUri ( "/schema/component_instantiation" ) ) ) 
TypeSchema ( Sbol2Terms . component . orientation ) 
PropertyValueSchemas ( propertyType . oneOf ( "inline" , "reverse_compliment" ) ) 
TypeSchema ( Sbol2Terms . component . start ) 
PropertyValueSchemas ( propertyType . integer ) 
TypeSchema ( Sbol2Terms . component . end ) 
public static < N > TopLevelDocuments < N > TopLevelDocuments ( TopLevelDocument < N > ... documents ) { 
return TopLevelDocuments ( Arrays . asList ( documents ) ) ; 
} public static < N > TopLevelDocuments < N > TopLevelDocuments ( final List < TopLevelDocument < N > > documents ) { 
return new TopLevelDocuments . Impl < > ( documents ) ; 
public static < N > NamedProperties < N > NamedProperties ( final NamedProperty < N > ... properties ) { 
return NamedProperties ( Arrays . asList ( properties ) ) ; 
} public static < N > NamedProperties < N > NamedProperties ( final List < NamedProperty < N > > properties ) { 
return new NamedProperties . Impl < > ( properties ) ; 
} public static < N > TopLevelDocument < N > TopLevelDocument ( final N type , 
final URI identity , 
final NamedProperties < N > properties ) { 
return TopLevelDocument ( NamespaceBindings ( ) , type , identity , properties ) ; 
} public static < N > TopLevelDocument < N > TopLevelDocument ( final NamespaceBindings bindings , 
final N type , 
final URI identity ) { 
return TopLevelDocument ( bindings , type , identity , Datatree . < N > NamedProperties ( ) ) ; 
return new TopLevelDocument . Impl < > ( 
bindings . getBindings ( ) , 
identity , 
properties . getProperties ( ) ) ; 
} public static < N > NestedDocument < N > NestedDocument ( final N type , 
return NestedDocument ( NamespaceBindings ( ) , type , identity , properties ) ; 
} public static < N > DocumentRoot < N > DocumentRoot ( final TopLevelDocuments < N > documents ) { 
return DocumentRoot ( NamespaceBindings ( ) , documents ) ; 
} public static < N > DocumentRoot < N > DocumentRoot ( 
final NamespaceBindings bindings , 
final TopLevelDocuments < N > documents ) { 
return new DocumentRoot . Impl < > ( bindings . getBindings ( ) , documents . getDocuments ( ) ) ; 
} public static < N > NamedProperty < N > NamedProperty ( final N name , final PropertyValue < N > value ) { 
return new NamedProperty . Impl < > ( name , value ) ; 
} public static < N > NamedProperty < N > NamedProperty ( final N name , final String value ) { 
return NamedProperty ( name , Datatree . < N > Literal ( value ) ) ; 
} public static < N > NamedProperty < N > NamedProperty ( final N name , final NestedDocument < N > value ) { 
} public static < N > Literal . StringLiteral < N > Literal ( final String value ) { 
return new Literal . StringLiteral < > ( value ) ; 
} public static < N > Literal . UriLiteral < N > Literal ( final URI value ) { 
return new Literal . UriLiteral < > ( value ) ; 
} public static < N > Literal . TypedLiteral < N > Literal ( final String value , final QName type ) { 
return new Literal . TypedLiteral < > ( value , type ) ; 
} public static QName QName ( String namespaceURI , String localPart , String prefix ) { 
return new QName ( namespaceURI , localPart , prefix ) ; 
} public static void main ( String [ ] args ) throws Exception 
write ( new OutputStreamWriter ( System . out ) , DataTreeCreator . makeDocument ( ) ) ; 
System . out . println ( "----------------------------------------" ) ; 
write ( new OutputStreamWriter ( System . out ) , DataTreeCreator . makeSBOL2Document ( ) ) ; 
} private static Properties getFilterInitParameters ( final FilterConfig config ) { 
Enumeration en = config . getInitParameterNames ( ) ; 
while ( en . hasMoreElements ( ) ) { 
String key = ( String ) en . nextElement ( ) ; 
String value = config . getInitParameter ( key ) ; 
} public void init ( final FilterConfig filterConfig ) 
Properties props = getFilterInitParameters ( filterConfig ) ; 
config = new CORSConfiguration ( props ) ; 
} catch ( CORSConfigurationException e ) { 
handler = new CORSRequestHandler ( config ) ; 
} private void printMessage ( final HttpServletResponse response , final int sc , final String msg ) 
response . setStatus ( sc ) ; 
response . resetBuffer ( ) ; 
PrintWriter out = response . getWriter ( ) ; 
} private void doFilter ( final HttpServletRequest request , final HttpServletResponse response , final FilterChain chain ) 
handler . tagRequest ( request ) ; 
CORSRequestType type = CORSRequestType . detect ( request ) ; 
if ( type == CORSRequestType . ACTUAL ) { 
handler . handleActualRequest ( request , response ) ; 
else if ( type == CORSRequestType . PREFLIGHT ) { 
handler . handlePreflightRequest ( request , response ) ; 
else if ( config . allowGenericHttpRequests ) { 
request . setAttribute ( "cors.isCorsRequest" , false ) ; 
} catch ( InvalidCORSRequestException e ) { 
printMessage ( response , HttpServletResponse . SC_BAD_REQUEST , e . getMessage ( ) ) ; 
} catch ( CORSOriginDeniedException e ) { 
printMessage ( response , HttpServletResponse . SC_FORBIDDEN , msg ) ; 
} catch ( UnsupportedHTTPMethodException e ) { 
HTTPMethod method = e . getRequestedMethod ( ) ; 
printMessage ( response , HttpServletResponse . SC_METHOD_NOT_ALLOWED , msg ) ; 
} catch ( UnsupportedHTTPHeaderException e ) { 
HeaderFieldName header = e . getRequestHeader ( ) ; 
if ( header != null ) 
public void registerService ( ISemanticLocator packedServiceDescriptor ) throws ServiceExecutionException 
Collection < ISemanticIdentifier > deployedServices = this . deploy ( packedServiceDescriptor , bsdmServiceRegistry ) ; 
for ( ISemanticIdentifier deployedService : deployedServices ) 
this . messageBroker . registerService ( 
this . bsdmServiceRegistry . getService ( deployedService ) . applyConnectorURL ( this . urlContainer ) ) ; 
} catch ( ModelException ex ) 
throw new ServiceExecutionException ( ex . getMessage ( ) , ex ) ; 
} public void close ( int port ) { 
for ( Iterator i = _listeners . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
Object k = i . next ( ) ; 
Object s = _listeners . get ( k ) ; 
if ( s instanceof SocketHandler ) { 
SocketHandler sh = ( SocketHandler ) s ; 
if ( port == - 1 || sh . isPort ( port ) ) { 
sh . interrupt ( ) ; 
sh . close ( ) ; 
_transactions . remove ( s ) ; 
_listeners . remove ( k ) ; 
} protected void receive ( Command c , Map h , String b , Authenticatable y ) { 
long id = ( int ) ( Math . random ( ) * 10000 ) ; 
if ( c == Command . COMMIT ) { 
synchronized ( _transactions ) { 
List trans = ( List ) _transactions . remove ( y ) ; 
trans = new ArrayList ( trans ) ; 
for ( Iterator i = trans . iterator ( ) ; i . hasNext ( ) ; ) { 
Message m = ( Message ) i . next ( ) ; 
receive ( m . command ( ) , m . headers ( ) , m . body ( ) , y ) ; 
} else if ( c == Command . ABORT ) { 
_transactions . remove ( y ) ; 
} else if ( _transactions . get ( y ) != null ) { 
( ( List ) _transactions . get ( y ) ) . add ( new Message ( c , h , b ) ) ; 
if ( h == null ) h = new HashMap ( ) ; 
String destination = ( String ) h . get ( "destination" ) ; 
if ( c == Command . SEND ) { 
if ( y instanceof IntraVMClient || 
_authenticator . authorizeSend ( y . token ( ) , destination ) ) { 
synchronized ( _listeners ) { 
List l = ( List ) _listeners . get ( destination ) ; 
if ( l != null ) { 
l = new ArrayList ( l ) ; 
for ( Iterator i = l . iterator ( ) ; i . hasNext ( ) ; ) { 
Listener sh = ( Listener ) i . next ( ) ; 
sh . message ( h , b ) ; 
Map error_headers = new HashMap ( ) ; 
error_headers . put ( "type:" , "send" ) ; 
error_headers . put ( "channel:" , destination ) ; 
} else if ( c == Command . SUBSCRIBE ) { 
_authenticator . authorizeSubscribe ( y . token ( ) , destination ) ) { 
_listeners . put ( destination , l ) ; 
if ( ! l . contains ( y ) ) l . add ( y ) ; 
error_headers . put ( "type:" , "subscription" ) ; 
} else if ( c == Command . UNSUBSCRIBE ) { 
if ( l != null ) l . remove ( y ) ; 
} else if ( c == Command . BEGIN ) { 
List trans = new ArrayList ( ) ; 
_transactions . put ( y , trans ) ; 
} else if ( c == Command . DISCONNECT ) { 
for ( Iterator i = _listeners . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { 
List l = ( List ) i . next ( ) ; 
l . remove ( y ) ; 
if ( h != null ) { 
String receipt = ( String ) h . get ( "receipt" ) ; 
if ( receipt != null ) { 
HashMap headers = new HashMap ( ) ; 
headers . put ( "receipt-id" , receipt ) ; 
y . receive ( Command . RECEIPT , headers , null ) ; 
} public static final void main ( String [ ] args ) { 
if ( args . length != 1 ) { 
int port = Integer . valueOf ( args [ 0 ] ) . intValue ( ) ; 
System . out . println ( Version . VERSION ) ; 
new Server ( port ) ; 
e . printStackTrace ( System . err ) ; 
} public void commitW ( Map header ) throws InterruptedException { 
String receipt = addReceipt ( header ) ; 
transmit ( Command . COMMIT , header ) ; 
waitOnReceipt ( receipt ) ; 
} public void subscribe ( String name , Listener listener , Map headers ) { 
List list = ( List ) _listeners . get ( name ) ; 
list = new ArrayList ( ) ; 
_listeners . put ( name , list ) ; 
if ( ! list . contains ( listener ) ) list . add ( listener ) ; 
if ( headers == null ) headers = new HashMap ( ) ; 
headers . put ( "destination" , name ) ; 
transmit ( Command . SUBSCRIBE , headers ) ; 
} public void subscribeW ( String name , Listener listener , Map header ) 
subscribe ( name , listener , header ) ; 
} public void subscribeW ( String name , Listener listener ) 
subscribeW ( name , listener , null ) ; 
} public void unsubscribe ( String name , Listener l ) { 
if ( list != null ) { 
list . remove ( l ) ; 
if ( list . size ( ) == 0 ) { 
unsubscribe ( name ) ; 
} public void unsubscribe ( String name , Map header ) { 
if ( header == null ) header = new HashMap ( ) ; 
synchronized ( _listeners ) { _listeners . remove ( name ) ; } 
header . put ( "destination" , name ) ; 
transmit ( Command . UNSUBSCRIBE , header ) ; 
} public void unsubscribeW ( String name , Map header ) throws InterruptedException { 
unsubscribe ( name , ( HashMap ) null ) ; 
} public void sendW ( String dest , String mesg ) 
sendW ( dest , mesg , null ) ; 
} public void sendW ( String dest , String mesg , Map header ) 
send ( dest , mesg , header ) ; 
} public void send ( String dest , String mesg , Map header ) { 
header . put ( "destination" , dest ) ; 
transmit ( Command . SEND , header , mesg ) ; 
} public Message getNext ( String name ) { 
synchronized ( _queue ) { 
for ( int idx = 0 ; idx < _queue . size ( ) ; idx ++ ) { 
Message m = ( Message ) _queue . get ( idx ) ; 
if ( m . headers ( ) . get ( "destination" ) . equals ( name ) ) { 
_queue . remove ( idx ) ; 
} public boolean hasReceipt ( String receipt_id ) { 
synchronized ( _receipts ) { 
for ( Iterator i = _receipts . iterator ( ) ; i . hasNext ( ) ; ) { 
String o = ( String ) i . next ( ) ; 
if ( o . equals ( receipt_id ) ) return true ; 
} public void clearReceipt ( String receipt_id ) { 
if ( o . equals ( receipt_id ) ) i . remove ( ) ; 
} public String getSuffix ( ) { 
String s = host ; 
if ( port != - 1 ) 
s = s + ":" + port ; 
} @ Programmatic 
public Collection < String > calendarNamesFor ( final Object notable ) { 
final Set < String > fallback = Collections . singleton ( DEFAULT_CALENDAR_NAME ) ; 
if ( calendarNameRepository == null ) { 
return fallback ; 
final Collection < String > calendarNames = calendarNameRepository . calendarNamesFor ( notable ) ; 
return calendarNames != null ? calendarNames : fallback ; 
} public synchronized void receiveMessagesSyncronously ( long ms ) throws ServiceGroundingException 
for ( IChannelConsumer chConsumer : this . serviceChannelConsumers ) 
if ( chConsumer instanceof AbstractJMSChannelConsumer ) 
AbstractJMSChannelConsumer achConsumer = ( AbstractJMSChannelConsumer ) chConsumer ; 
achConsumer . receiveOrWait ( ms ) ; 
if ( chConsumer instanceof AbstractStompChannelConsumer ) 
AbstractStompChannelConsumer achConsumer = ( AbstractStompChannelConsumer ) chConsumer ; 
} private static String serialize ( final Set set , final String sep ) { 
Iterator it = set . iterator ( ) ; 
s = s + it . next ( ) . toString ( ) ; 
if ( it . hasNext ( ) ) 
s = s + sep ; 
} private static String [ ] parseMultipleHeaderValues ( final String headerValue ) { 
if ( headerValue == null ) 
String trimmedHeaderValue = headerValue . trim ( ) ; 
if ( trimmedHeaderValue . isEmpty ( ) ) 
return trimmedHeaderValue . split ( "\\s*,\\s*|\\s+" ) ; 
} public void tagRequest ( final HttpServletRequest request ) { 
final CORSRequestType type = CORSRequestType . detect ( request ) ; 
case ACTUAL : 
request . setAttribute ( "cors.isCorsRequest" , true ) ; 
request . setAttribute ( "cors.origin" , request . getHeader ( "Origin" ) ) ; 
request . setAttribute ( "cors.requestType" , "actual" ) ; 
case PREFLIGHT : 
request . setAttribute ( "cors.requestType" , "preflight" ) ; 
request . setAttribute ( "cors.requestHeaders" , request . getHeader ( "Access-Control-Request-Headers" ) ) ; 
case OTHER : 
} public void handleActualRequest ( final HttpServletRequest request , final HttpServletResponse response ) 
throws InvalidCORSRequestException , 
CORSOriginDeniedException , 
UnsupportedHTTPMethodException { 
if ( CORSRequestType . detect ( request ) != CORSRequestType . ACTUAL ) 
Origin requestOrigin = new Origin ( request . getHeader ( "Origin" ) ) ; 
if ( ! config . isAllowedOrigin ( requestOrigin ) ) 
HTTPMethod method = null ; 
method = HTTPMethod . valueOf ( request . getMethod ( ) ) ; 
if ( ! config . isSupportedMethod ( method ) ) 
response . addHeader ( "Access-Control-Allow-Origin" , requestOrigin . toString ( ) ) ; 
if ( config . supportsCredentials ) 
response . addHeader ( "Access-Control-Allow-Credentials" , "true" ) ; 
if ( ! exposedHeaders . isEmpty ( ) ) 
response . addHeader ( "Access-Control-Expose-Headers" , exposedHeaders ) ; 
request . setAttribute ( "cors.origin" , requestOrigin . toString ( ) ) ; 
} public void handlePreflightRequest ( final HttpServletRequest request , final HttpServletResponse response ) 
UnsupportedHTTPMethodException , 
UnsupportedHTTPHeaderException { 
if ( CORSRequestType . detect ( request ) != CORSRequestType . PREFLIGHT ) 
String requestMethodHeader = request . getHeader ( "Access-Control-Request-Method" ) ; 
if ( requestMethodHeader == null ) 
HTTPMethod requestedMethod = null ; 
requestedMethod = HTTPMethod . valueOf ( requestMethodHeader . toUpperCase ( ) ) ; 
final String [ ] requestHeaderValues = parseMultipleHeaderValues ( request . getHeader ( "Access-Control-Request-Headers" ) ) ; 
final HeaderFieldName [ ] requestHeaders = new HeaderFieldName [ requestHeaderValues . length ] ; 
for ( int i = 0 ; i < requestHeaders . length ; i ++ ) { 
requestHeaders [ i ] = new HeaderFieldName ( requestHeaderValues [ i ] ) ; 
if ( ! config . isSupportedMethod ( requestedMethod ) ) 
if ( ! config . supportedHeaders . contains ( requestHeaders [ i ] ) ) 
if ( config . supportsCredentials ) { 
if ( config . allowAnyOrigin ) 
response . addHeader ( "Access-Control-Allow-Origin" , "*" ) ; 
if ( config . maxAge > 0 ) 
response . addHeader ( "Access-Control-Max-Age" , Integer . toString ( config . maxAge ) ) ; 
response . addHeader ( "Access-Control-Allow-Methods" , supportedMethods ) ; 
if ( ! supportedHeaders . isEmpty ( ) ) 
response . addHeader ( "Access-Control-Allow-Headers" , supportedHeaders ) ; 
} protected static String formatCanonical ( final String name ) { 
String nameTrimmed = name . trim ( ) ; 
if ( nameTrimmed . isEmpty ( ) ) 
if ( ! nameTrimmed . matches ( "^[a-zA-Z][\\w-]*$" ) ) 
String [ ] tokens = nameTrimmed . toLowerCase ( ) . split ( "-" ) ; 
String out = "" ; 
char [ ] c = tokens [ i ] . toCharArray ( ) ; 
c [ 0 ] = Character . toUpperCase ( c [ 0 ] ) ; 
if ( i >= 1 ) 
out = out + "-" ; 
out = out + new String ( c ) ; 
} public boolean setOptions ( String [ ] options ) throws Exception { 
ArgumentParser parser ; 
Namespace ns ; 
parser = ArgumentParsers . newArgumentParser ( MinDeps . class . getName ( ) ) ; 
parser . addArgument ( "--java-home" ) 
. type ( Arguments . fileType ( ) . verifyExists ( ) . verifyIsDirectory ( ) ) 
. dest ( "javahome" ) 
. required ( true ) 
parser . addArgument ( "--class-path" ) 
. dest ( "classpath" ) 
parser . addArgument ( "--classes" ) 
. type ( Arguments . fileType ( ) . verifyExists ( ) . verifyIsFile ( ) . verifyCanRead ( ) ) 
. dest ( "classes" ) 
parser . addArgument ( "--additional" ) 
. type ( Arguments . fileType ( ) ) 
. setDefault ( new File ( "." ) ) 
. required ( false ) 
. dest ( "additional" ) 
parser . addArgument ( "--output" ) 
. dest ( "output" ) 
parser . addArgument ( "package" ) 
. dest ( "packages" ) 
. nargs ( "+" ) 
ns = parser . parseArgs ( options ) ; 
catch ( ArgumentParserException e ) { 
parser . handleError ( e ) ; 
setJavaHome ( ns . get ( "javahome" ) ) ; 
setClassPath ( ns . getString ( "classpath" ) ) ; 
setClassesFile ( ns . get ( "classes" ) ) ; 
setAdditionalFile ( ns . get ( "additional" ) ) ; 
setPackages ( ns . getList ( "packages" ) ) ; 
setOutputFile ( ns . get ( "output" ) ) ; 
} protected String readFile ( File file , List < String > lines ) { 
lines . addAll ( Files . readAllLines ( file . toPath ( ) ) ) ; 
while ( i < lines . size ( ) ) { 
if ( lines . get ( i ) . trim ( ) . isEmpty ( ) ) { 
lines . remove ( i ) ; 
if ( lines . get ( i ) . startsWith ( "#" ) ) { 
} protected String check ( ) { 
String error ; 
if ( ! m_JavaHome . exists ( ) ) 
if ( ! m_JavaHome . isDirectory ( ) ) 
if ( System . getProperty ( "os.name" ) . toLowerCase ( ) . contains ( "windows" ) ) 
m_Jdeps = new File ( m_JavaHome . getAbsolutePath ( ) + File . separator + "bin" + File . separator + "jdeps.exe" ) ; 
m_Jdeps = new File ( m_JavaHome . getAbsolutePath ( ) + File . separator + "bin" + File . separator + "jdeps" ) ; 
if ( ! m_Jdeps . exists ( ) ) 
if ( ! m_ClassesFile . exists ( ) ) 
if ( m_ClassesFile . isDirectory ( ) ) 
error = readFile ( m_ClassesFile , m_Classes ) ; 
if ( error != null ) 
if ( ( m_AdditionalFile != null ) && m_AdditionalFile . exists ( ) && ( ! m_AdditionalFile . isDirectory ( ) ) ) { 
error = readFile ( m_AdditionalFile , m_Resources ) ; 
} protected List < String > filter ( List < String > lines , String regexp , boolean invert ) { 
List < String > result ; 
Pattern pattern ; 
result = new ArrayList < > ( ) ; 
pattern = Pattern . compile ( regexp ) ; 
if ( invert ) { 
if ( ! pattern . matcher ( line ) . matches ( ) ) 
result . add ( line ) ; 
if ( pattern . matcher ( line ) . matches ( ) ) 
} protected String packagesRegExp ( ) { 
StringBuilder result ; 
String pkg ; 
result = new StringBuilder ( ) ; 
for ( i = 0 ; i < m_Packages . size ( ) ; i ++ ) { 
result . append ( "|" ) ; 
pkg = m_Packages . get ( i ) ; 
if ( ! pkg . endsWith ( "." ) ) 
pkg = pkg + "." ; 
pkg = pkg . replace ( "." , "\\." ) ; 
result . append ( pkg ) ; 
result . append ( ").*$" ) ; 
} protected String determine ( ) { 
String [ ] cmd ; 
ProcessBuilder builder ; 
CollectingProcessOutput output ; 
List < String > lines ; 
for ( String cls : m_Classes ) { 
System . err . println ( cls ) ; 
cmd = new String [ ] { 
m_Jdeps . getAbsolutePath ( ) , 
"-cp" , 
m_ClassPath , 
"-recursive" , 
"-verbose:class" , 
cls 
builder = new ProcessBuilder ( ) ; 
builder . command ( cmd ) ; 
output = new CollectingProcessOutput ( ) ; 
output . monitor ( builder ) ; 
lines = new ArrayList < > ( Arrays . asList ( output . getStdOut ( ) . replace ( "\r" , "" ) . split ( "\n" ) ) ) ; 
lines = filter ( lines , packagesRegExp ( ) , false ) ; 
lines = filter ( lines , ".*\\$.*" , true ) ; 
lines = filter ( lines , ".*\\.jar\\)" , true ) ; 
for ( i = 0 ; i < lines . size ( ) ; i ++ ) { 
line = lines . get ( i ) ; 
lines . set ( i , line ) ; 
m_DependentClasses . addAll ( lines ) ; 
} public String execute ( ) { 
result = check ( ) ; 
result = determine ( ) ; 
m_Dependencies = new ArrayList < > ( ) ; 
m_Dependencies . addAll ( m_Classes ) ; 
for ( String cls : m_DependentClasses ) { 
if ( ! m_Dependencies . contains ( cls ) ) 
m_Dependencies . add ( cls ) ; 
for ( String cls : m_Resources ) { 
Collections . sort ( m_Dependencies ) ; 
} public void output ( ) { 
if ( ( m_OutputFile == null || m_OutputFile . isDirectory ( ) ) ) { 
for ( String dep : m_Dependencies ) 
System . out . println ( dep ) ; 
Files . write ( m_OutputFile . toPath ( ) , m_Dependencies , StandardOpenOption . CREATE , StandardOpenOption . TRUNCATE_EXISTING ) ; 
} public IoWriter < QName > createIoWriter ( final XMLStreamWriter writer ) 
return new IoWriter < QName > ( ) { 
public void write ( DocumentRoot < QName > document ) throws CoreIoException { 
writeStartElement ( RDF ) ; 
setPrefix ( rdf ) ; 
if ( ! document . getNamespaceBindings ( ) . contains ( rdf ) ) { 
writeNamespace ( rdf ) ; 
for ( NamespaceBinding nb : document . getNamespaceBindings ( ) ) { 
setPrefix ( nb ) ; 
writeNamespace ( nb ) ; 
for ( TopLevelDocument < QName > child : document . getTopLevelDocuments ( ) ) 
write ( child ) ; 
writer . writeEndElement ( ) ; 
catch ( XMLStreamException xse ) 
throw new CoreIoException ( xse ) ; 
private void write ( IdentifiableDocument < QName > doc ) throws XMLStreamException { 
writeStartElement ( doc . getType ( ) ) ; 
writeAttribute ( rdfAbout , doc . getIdentity ( ) . toString ( ) ) ; 
for ( NamedProperty < QName > property : doc . getProperties ( ) ) { 
write ( property ) ; 
private void write ( final NamedProperty < QName > property ) { 
new PropertyValue . Visitor < QName > ( ) { 
public void visit ( NestedDocument < QName > v ) throws XMLStreamException { 
writeStartElement ( property . getName ( ) ) ; 
write ( v ) ; 
public void visit ( Literal < QName > v ) throws XMLStreamException { 
if ( isEmptyElementValue ( v ) ) { 
writeEmptyElement ( property . getName ( ) ) ; 
} . visit ( property . getValue ( ) ) ; 
private boolean isEmptyElementValue ( Literal < QName > literal ) { 
return literal instanceof Literal . UriLiteral ; 
private void write ( Literal < QName > literal ) { 
new Literal . Visitor < QName > ( ) { 
public void visit ( Literal . StringLiteral < QName > l ) throws XMLStreamException { 
writer . writeCharacters ( l . getValue ( ) ) ; 
public void visit ( Literal . UriLiteral < QName > l ) throws XMLStreamException { 
writeAttribute ( rdfResource , l . getValue ( ) . toString ( ) ) ; 
public void visit ( Literal . IntegerLiteral < QName > l ) throws XMLStreamException { 
writer . writeCharacters ( l . getValue ( ) . toString ( ) ) ; 
public void visit ( Literal . DoubleLiteral < QName > l ) throws XMLStreamException { 
public void visit ( Literal . TypedLiteral < QName > l ) throws XMLStreamException { 
writer . writeCharacters ( l . getValue ( ) + "^^" + l . getType ( ) . getPrefix ( ) + ":" + l . getType ( ) . getLocalPart ( ) ) ; 
public void visit ( Literal . BooleanLiteral < QName > l ) throws XMLStreamException { 
} . visit ( literal ) ; 
private void writeEmptyElement ( QName tagName ) throws XMLStreamException { 
writer . writeEmptyElement ( tagName . getPrefix ( ) , tagName . getLocalPart ( ) , tagName . getNamespaceURI ( ) ) ; 
private void writeStartElement ( QName tagName ) throws XMLStreamException { 
writer . writeStartElement ( tagName . getPrefix ( ) , tagName . getLocalPart ( ) , tagName . getNamespaceURI ( ) ) ; 
private void setPrefix ( NamespaceBinding binding ) throws XMLStreamException { 
writer . setPrefix ( binding . getPrefix ( ) , binding . getNamespaceURI ( ) ) ; 
private void writeNamespace ( NamespaceBinding binding ) throws XMLStreamException { 
writer . writeNamespace ( binding . getPrefix ( ) , binding . getNamespaceURI ( ) ) ; 
private void writeAttribute ( QName attrName , String attrValue ) throws XMLStreamException { 
writer . writeAttribute ( 
attrName . getPrefix ( ) , 
attrName . getNamespaceURI ( ) , 
attrName . getLocalPart ( ) , 
attrValue ) ; 
} public IoReader < QName > createIoReader ( final XMLStreamReader xmlReader ) throws XMLStreamException 
return new IoReader < QName > ( ) { 
public DocumentRoot < QName > read ( ) throws CoreIoException 
while ( xmlReader . hasNext ( ) ) 
int eventType = xmlReader . next ( ) ; 
switch ( eventType ) { 
case XMLEvent . START_ELEMENT : 
NamespaceBindings bindings = readBindings ( ) ; 
Datatree . TopLevelDocuments < QName > topLevelDocuments = readTopLevelDocuments ( ) ; 
return Datatree . DocumentRoot ( bindings , topLevelDocuments ) ; 
throw new CoreIoException ( e ) ; 
private Datatree . NamespaceBindings readBindings ( ) throws XMLStreamException { 
NamespaceBinding [ ] bindings = new NamespaceBinding [ xmlReader . getNamespaceCount ( ) ] ; 
for ( int i = 0 ; i < xmlReader . getNamespaceCount ( ) ; i ++ ) { 
bindings [ i ] = Datatree . NamespaceBinding ( xmlReader . getNamespaceURI ( i ) , xmlReader . getNamespacePrefix ( i ) ) ; 
return Datatree . NamespaceBindings ( bindings ) ; 
private Stack < Object > documentStack = new Stack < Object > ( ) ; 
private List < TopLevelDocument < QName > > topLevelDocuments = null ; 
private Datatree . TopLevelDocuments < QName > readTopLevelDocuments ( ) 
throws XMLStreamException { 
StringBuilder currentText = null ; 
topLevelDocuments = new ArrayList < TopLevelDocument < QName > > ( ) ; 
while ( xmlReader . hasNext ( ) ) { 
currentText = new StringBuilder ( 256 ) ; 
QName elementURI = Datatree . QName ( xmlReader . getNamespaceURI ( ) , xmlReader . getLocalName ( ) , xmlReader . getPrefix ( ) ) ; 
addToStack ( elementURI ) ; 
case XMLEvent . END_ELEMENT : 
String literalValue = null ; 
if ( currentText != null ) { 
literalValue = currentText . toString ( ) ; 
currentText = null ; 
updateDocumentInStack ( literalValue ) ; 
case XMLEvent . CHARACTERS : 
String characters = xmlReader . getText ( ) ; 
currentText . append ( characters ) ; 
Datatree . TopLevelDocuments < QName > documents = Datatree 
. TopLevelDocuments ( topLevelDocuments . toArray ( new TopLevelDocument [ topLevelDocuments . size ( ) ] ) ) ; 
return documents ; 
private void addToStack ( QName elementURI ) throws XMLStreamException 
URI identity = null ; 
URI resourceURI = null ; 
int attributes = xmlReader . getAttributeCount ( ) ; 
for ( int i = 0 ; i < attributes ; ++ i ) 
if ( rdfAbout . getLocalPart ( ) . equals ( xmlReader . getAttributeLocalName ( i ) ) && rdfAbout . getNamespaceURI ( ) . equals ( xmlReader . getAttributeNamespace ( i ) ) ) 
identity = URI . create ( xmlReader . getAttributeValue ( i ) ) ; 
if ( rdfResource . getLocalPart ( ) . equals ( xmlReader . getAttributeLocalName ( i ) ) && rdfResource . getNamespaceURI ( ) . equals ( xmlReader . getAttributeNamespace ( i ) ) ) 
resourceURI = URI . create ( xmlReader . getAttributeValue ( i ) ) ; 
if ( identity != null ) 
Datatree . NamespaceBindings bindings = readBindings ( ) ; 
IdentifiableDocument < QName > document = null ; 
if ( documentStack . isEmpty ( ) ) 
document = Datatree . TopLevelDocument ( bindings , elementURI , identity ) ; 
document = Datatree . NestedDocument ( bindings , elementURI , identity ) ; 
documentStack . push ( document ) ; 
NamedProperty < QName > property = null ; 
if ( resourceURI != null ) 
property = Datatree . NamedProperty ( elementURI , resourceURI ) ; 
property = Datatree . NamedProperty ( elementURI , "" ) ; 
documentStack . push ( property ) ; 
private void updateDocumentInStack ( String literalValue ) throws XMLStreamException 
if ( ! documentStack . isEmpty ( ) ) 
Object stackObject = documentStack . pop ( ) ; 
if ( stackObject instanceof NamedProperty ) 
NamedProperty < QName > property = ( NamedProperty < QName > ) stackObject ; 
if ( literalValue != null && literalValue . length ( ) > 0 ) 
property = Datatree . NamedProperty ( property . getName ( ) , literalValue ) ; 
updateDocumentInStackWithProperty ( property ) ; 
else if ( stackObject instanceof NestedDocument ) 
NestedDocument < QName > document = ( NestedDocument < QName > ) stackObject ; 
NamedProperty < QName > property = ( NamedProperty < QName > ) documentStack 
. pop ( ) ; 
property = Datatree . NamedProperty ( property . getName ( ) , document ) ; 
if ( eventType == XMLEvent . END_ELEMENT ) 
String elementURI = xmlReader . getNamespaceURI ( ) + xmlReader . getLocalName ( ) ; 
if ( elementURI . equals ( property . getName ( ) . getNamespaceURI ( ) + property . getName ( ) . getLocalPart ( ) ) ) 
else if ( stackObject instanceof TopLevelDocument ) 
topLevelDocuments . add ( ( TopLevelDocument < QName > ) stackObject ) ; 
private void updateDocumentInStackWithProperty ( NamedProperty < QName > property ) 
IdentifiableDocument < QName > documentInStack = ( IdentifiableDocument < QName > ) documentStack . pop ( ) ; 
documentInStack = addProperty ( documentInStack , property ) ; 
documentStack . push ( documentInStack ) ; 
private IdentifiableDocument < QName > addProperty ( 
IdentifiableDocument < QName > document , NamedProperty < QName > property ) 
List < NamedProperty < QName > > properties = new ArrayList < > ( ) ; 
if ( document . getProperties ( ) == null || document . getProperties ( ) . size ( ) == 0 ) 
properties = Datatree . NamedProperties ( property ) . getProperties ( ) ; 
properties . addAll ( document . getProperties ( ) ) ; 
NamedProperty < QName > [ ] propertyArray = properties . toArray ( new NamedProperty [ properties . size ( ) ] ) ; 
NamedProperties < QName > namedProperties = Datatree . NamedProperties ( propertyArray ) ; 
NamespaceBindings bindings = Datatree . NamespaceBindings ( 
( NamespaceBinding [ ] ) document . getNamespaceBindings ( ) . toArray ( new NamespaceBinding [ document . getNamespaceBindings ( ) . size ( ) ] ) ) ; 
if ( document instanceof TopLevelDocument ) 
document = Datatree . TopLevelDocument ( bindings , 
document . getType ( ) , 
document . getIdentity ( ) , 
namedProperties ) ; 
document = Datatree . NestedDocument ( 
bindings , 
} public final boolean isAllowedOrigin ( final Origin origin ) { 
if ( allowAnyOrigin ) 
if ( allowedOrigins . contains ( origin ) ) 
else if ( allowSubdomains ) 
return isAllowedSubdomainOrigin ( origin ) ; 
} public final boolean isAllowedSubdomainOrigin ( final Origin origin ) { 
ValidatedOrigin validatedOrigin = origin . validate ( ) ; 
String scheme = validatedOrigin . getScheme ( ) ; 
String suffix = validatedOrigin . getSuffix ( ) ; 
for ( ValidatedOrigin allowedOrigin : allowedOrigins ) { 
if ( suffix . endsWith ( "." + allowedOrigin . getSuffix ( ) ) && 
scheme . equalsIgnoreCase ( allowedOrigin . getScheme ( ) ) ) 
} catch ( OriginException e ) { 
} protected static String [ ] parseWords ( final String s ) { 
String s1 = s . trim ( ) ; 
if ( s1 . isEmpty ( ) ) 
return new String [ ] { } ; 
return s1 . split ( "\\s*,\\s*|\\s+" ) ; 
public NotableLink findByNote ( final Note note ) { 
return repositoryService . firstMatch ( 
new QueryDefault < > ( NotableLink . class , 
"findByNote" , 
"note" , note ) ) ; 
public List < NotableLink > findByNotable ( final Object notable ) { 
if ( notable == null ) { 
final Bookmark bookmark = bookmarkService . bookmarkFor ( notable ) ; 
if ( bookmark == null ) { 
final String notableStr = bookmark . toString ( ) ; 
return repositoryService . allMatches ( 
"findByNotable" , 
"notableStr" , notableStr ) ) ; 
public NotableLink findByNotableAndCalendarName ( 
final Object notable , 
final String calendarName ) { 
if ( calendarName == null ) { 
"findByNotableAndCalendarName" , 
"notableStr" , notableStr , 
"calendarName" , calendarName ) ) ; 
public List < NotableLink > findByNotableInDateRange ( 
final LocalDate startDate , 
final LocalDate endDate ) { 
if ( startDate == null ) { 
if ( endDate == null ) { 
"findByNotableInDateRange" , 
"startDate" , startDate , 
"endDate" , endDate ) ) ; 
public NotableLink createLink ( 
final Note note , 
final Object notable ) { 
final Class < ? extends NotableLink > subtype = subtypeClassFor ( notable ) ; 
final NotableLink link = repositoryService . instantiate ( subtype ) ; 
link . setNote ( note ) ; 
link . setNotable ( notable ) ; 
link . setNotableStr ( bookmark . toString ( ) ) ; 
repositoryService . persistAndFlush ( link ) ; 
return link ; 
public void updateLink ( final Note note ) { 
final NotableLink link = findByNote ( note ) ; 
sync ( note , link ) ; 
} void sync ( final Note note , final NotableLink link ) { 
if ( link == null ) { 
link . setDate ( note . getDate ( ) ) ; 
link . setCalendarName ( note . getCalendarName ( ) ) ; 
} public void transmit ( Command c , Map h , String b ) { 
_server . receive ( c , h , b , this ) ; 
public List < Note > findByNotable ( final Object notable ) { 
final List < NotableLink > links = linkRepository . findByNotable ( notable ) ; 
return Lists . newArrayList ( 
Iterables . transform ( links , NotableLink . Functions . note ( ) ) ) ; 
public Note findByNotableAndCalendarName ( 
final NotableLink link = linkRepository 
. findByNotableAndCalendarName ( notable , calendarName ) ; 
return NotableLink . Functions . note ( ) . apply ( link ) ; 
public List < Note > findInDateRange ( 
new QueryDefault < > ( 
Note . class , 
"findInDateRange" , 
public Iterable < Note > findByNotableInDateRange ( 
final List < NotableLink > link = linkRepository 
. findByNotableInDateRange ( notable , startDate , endDate ) ; 
return Iterables . transform ( link , NotableLink . Functions . note ( ) ) ; 
public Note add ( 
final String noteText , 
final LocalDate date , 
final Note note = repositoryService . instantiate ( Note . class ) ; 
note . setDate ( date ) ; 
note . setCalendarName ( calendarName ) ; 
note . setContent ( noteText ) ; 
repositoryService . persistAndFlush ( note ) ; 
final NotableLink link = notableLinkRepository . createLink ( note , notable ) ; 
link . setCalendarName ( calendarName ) ; 
link . setDate ( date ) ; 
public void remove ( Note note ) { 
final NotableLink link = linkRepository . findByNote ( note ) ; 
repositoryService . removeAndFlush ( link ) ; 
repositoryService . removeAndFlush ( note ) ; 
Transmitter . transmit ( c , h , b , _output ) ; 
receive ( Command . ERROR , null , e . getMessage ( ) ) ; 
